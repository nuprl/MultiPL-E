language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpb0vt3glz_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpb0vt3glz_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\"a\": true, \"e\": true,\
    \ \"i\": true, \"o\": true, \"u\": true}\n    var last_vowel string\n    var last_consonant\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        char := string(word[i])\n\
    \        if vowels[char] {\n            last_vowel = char\n        } else {\n\
    \            if last_vowel != \"\" {\n                return last_vowel\n    \
    \        }\n            last_consonant = char\n        }\n    }\n    return \"\
    \"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz1rzg60h_test.go:17:9: last_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var prev_consonant bool\n    var closest_vowel string\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if prev_consonant {\n                closest_vowel = string(word[i])\n\
    \                break\n            }\n        } else {\n            prev_consonant\
    \ = true\n        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpzcrasg1__test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpzcrasg1__test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpzcrasg1__test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpzcrasg1__test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpzcrasg1__test.go:62: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if is_vowel(word[i], vowels) {\n            if i == len(word)\
    \ - 1 {\n                continue\n            }\n            if is_vowel(word[i\
    \ + 1], vowels) {\n                continue\n            }\n            return\
    \ string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4cg7vw9s_test.go:20:12: undefined: is_vowel

    /tmp/tmp4cg7vw9s_test.go:24:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) == 0 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\"\
    : true}\n    consonants := map[string]bool{\"b\": true, \"c\": true, \"d\": true,\
    \ \"f\": true, \"g\": true, \"h\": true, \"j\": true, \"k\": true, \"l\": true,\
    \ \"m\": true, \"n\": true, \"p\": true, \"q\": true, \"r\": true, \"s\": true,\
    \ \"t\": true, \"v\": true, \"w\": true, \"x\": true, \"y\": true, \"z\": true}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := consonants[string(word[i])];\
    \ ok {\n            for j := i - 1; j >= 0; j-- {\n                if _, ok :=\
    \ vowels[string(word[j])]; ok {\n                    return string(word[j])\n\
    \                }\n            }\n            return \"\"\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpswff8atj_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpswff8atj_test.go:58: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpswff8atj_test.go:58: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpswff8atj_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpswff8atj_test.go:58: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant string\n    var last_vowel string\n   \
    \ for _, c := range word {\n        if vowels[string(c)] {\n            last_vowel\
    \ = string(c)\n        } else {\n            last_consonant = string(c)\n    \
    \    }\n        if last_consonant != \"\" && last_vowel != \"\" {\n          \
    \  return last_vowel\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp0fip1vtv_test.go:62: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp0fip1vtv_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmp0fip1vtv_test.go:62: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp0fip1vtv_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmp0fip1vtv_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp0fip1vtv_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp0fip1vtv_test.go:62: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp0fip1vtv_test.go:62:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmp0fip1vtv_test.go:62: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    last_consonant := -1\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i]))\
    \ {\n            if last_consonant == -1 {\n                return \"\"\n    \
    \        }\n            return string(word[i])\n        }\n        last_consonant\
    \ = i\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp74c9w_zy_test.go:18:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i + 1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzohnqsa_test.go:17:12: undefined: is_vowel

    /tmp/tmppzohnqsa_test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var index int\n    var found bool\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        for j := 0; j < len(vowels); j++ {\n \
    \           if word[i] == vowels[j][0] {\n                if found {\n       \
    \             if i > index {\n                        result = \"\"\n        \
    \            } else {\n                        result = string(word[i])\n    \
    \                }\n                } else {\n                    result = string(word[i])\n\
    \                    index = i\n                    found = true\n           \
    \     }\n            }\n        }\n        if found && word[i] != 'a' && word[i]\
    \ != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' {\n           \
    \ break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp2idcpgof_test.go:67: expected '', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp2idcpgof_test.go:67: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp2idcpgof_test.go:67: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp2idcpgof_test.go:67: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp2idcpgof_test.go:67: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp2idcpgof_test.go:67: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp2idcpgof_test.go:67: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp2idcpgof_test.go:67:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp2idcpgof_test.go:67: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var last_consonant_index int\n    var last_vowel_index int\n    var last_vowel\
    \ string\n    for i, c := range word {\n        if is_vowel(c) {\n           \
    \ last_vowel_index = i\n            last_vowel = string(c)\n        } else {\n\
    \            if last_vowel_index > last_consonant_index {\n                return\
    \ last_vowel\n            }\n            last_consonant_index = i\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbcsq8bfg_test.go:15:5: vowels declared but not used

    /tmp/tmpbcsq8bfg_test.go:20:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    var last_vowel string\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n       \
    \     last_vowel = string(word[i])\n            break\n        }\n    }\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n  \
    \          continue\n        }\n        if vowels[string(word[i-1])] {\n     \
    \       return string(word[i-1])\n        }\n    }\n    return last_vowel\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513780, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513780,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel({0x51e394, 0x2})\n\t/tmp/tmpm15x05ou_test.go:27\
    \ +0x2bd\ncommand-line-arguments_test.TestGet_Closest_Vowel(0x0?)\n\t/tmp/tmpm15x05ou_test.go:49\
    \ +0x19e\ntesting.tRunner(0xc0000cc1a0, 0x5290e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp35crwejn_test.go:17:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var last_vowel_index = -1\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        for _, v := range vowels {\n            if word[i:i+1] == v {\n     \
    \           last_vowel_index = i\n                break\n            }\n     \
    \   }\n        if last_vowel_index != -1 {\n            break\n        }\n   \
    \ }\n    if last_vowel_index == -1 {\n        return \"\"\n    }\n    for i :=\
    \ last_vowel_index - 1; i >= 0; i-- {\n        for _, v := range vowels {\n  \
    \          if word[i:i+1] == v {\n                return \"\"\n            }\n\
    \        }\n        if word[i:i+1] != \" \" {\n            return word[last_vowel_index:last_vowel_index+1]\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp7tdtq61j_test.go:69: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp7tdtq61j_test.go:69: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmp7tdtq61j_test.go:69: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmp7tdtq61j_test.go:69: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant string\n    var last_vowel string\n   \
    \ for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            last_vowel = string(word[i])\n            if last_consonant\
    \ != \"\" {\n                return last_vowel\n            }\n        } else\
    \ {\n            last_consonant = string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpwh86o3hv_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpwh86o3hv_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpwh86o3hv_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpwh86o3hv_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpwh86o3hv_test.go:62: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var last_consonant_index int\n\
    \    var last_vowel_index int\n    for i := len(word) - 1; i >= 0; i-- {\n   \
    \     if strings.Contains(vowels, string(word[i])) {\n            last_vowel_index\
    \ = i\n            if last_consonant_index > 0 {\n                return string(word[last_vowel_index])\n\
    \            }\n        } else {\n            last_consonant_index = i\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe3dktw34_test.go:19:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\"\
    : true}\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i + 1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpbyncjjil_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpbyncjjil_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpbyncjjil_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpbyncjjil_test.go:57: expected 'i', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpbyncjjil_test.go:57:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var is_vowel bool\n    var\
    \ is_consonant bool\n    var is_first_consonant bool\n    var is_second_consonant\
    \ bool\n    var is_first_vowel bool\n    var is_second_vowel bool\n    var is_first_letter\
    \ bool\n    var is_second_letter bool\n    var is_third_letter bool\n    var is_fourth_letter\
    \ bool\n    var is_fifth_letter bool\n    var is_sixth_letter bool\n    var is_seventh_letter\
    \ bool\n    var is_eighth_letter bool\n    var is_ninth_letter bool\n    var is_tenth_letter\
    \ bool\n    var is_eleventh_letter bool\n    var is_twelfth_letter bool\n    var\
    \ is_thirteenth_letter bool\n    var is_fourteenth_letter bool\n    var is_fifteenth_letter\
    \ bool\n    var is_sixteenth_letter bool\n    var is_seventeenth_letter bool\n\
    \    var is_eighteenth_letter bool\n    var is_nineteenth_letter bool\n    var\
    \ is_twentieth_letter bool\n    var is_twenty_first_letter bool\n    var is_twenty_second_letter\
    \ bool\n    var is_twenty_third_letter bool\n    var is_twenty_fourth_letter bool\n\
    \    var is_twenty_fifth_letter bool\n    var is_twenty_sixth_letter bool\n  \
    \  var is_twenty_seventh_letter bool\n    var is_twenty_eighth_letter bool\n \
    \   var is_twenty_ninth_letter bool\n    var is_thirtieth_letter bool\n    var\
    \ is_thirty_first_letter bool\n    var is_thirty_second_letter bool\n    var is_th\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd1f6kgad_test.go:56:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                continue\n         \
    \   }\n            if is_vowel(word[i + 1], vowels) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu1l0rpv2_test.go:17:12: undefined: is_vowel

    /tmp/tmpu1l0rpv2_test.go:21:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"\
    o\":1, \"u\":1}\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok :=\
    \ vowels[string(word[i])]; ok {\n            if i == len(word) - 1 {\n       \
    \         return \"\"\n            }\n            if _, ok := vowels[string(word[i+1])];\
    \ !ok {\n                return string(word[i])\n            }\n        }\n  \
    \  }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpi79s6qly_test.go:54: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpi79s6qly_test.go:54: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpi79s6qly_test.go:54: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpi79s6qly_test.go:54: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpi79s6qly_test.go:54:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpi79s6qly_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_vowel rune\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[rune(word[i])] {\n            last_vowel =\
    \ rune(word[i])\n            break\n        }\n    }\n    for i := len(word) -\
    \ 1; i >= 0; i-- {\n        if !vowels[rune(word[i])] {\n            if i == len(word)\
    \ - 1 {\n                return string(last_vowel)\n            }\n          \
    \  if vowels[rune(word[i+1])] {\n                return string(rune(word[i+1]))\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpnh5ntbo6_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpnh5ntbo6_test.go:61: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpnh5ntbo6_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpnh5ntbo6_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpnh5ntbo6_test.go:61: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpnh5ntbo6_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpnh5ntbo6_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpnh5ntbo6_test.go:61:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpnh5ntbo6_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var result string\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i]))\
    \ {\n            result = string(word[i])\n            break\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplepf2phe_test.go:18:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            if i == len(word) - 1 {\n                continue\n         \
    \   }\n            if i == 0 {\n                continue\n            }\n    \
    \        if contains(vowels, string(word[i+1])) {\n                continue\n\
    \            }\n            if contains(vowels, string(word[i-1])) {\n       \
    \         continue\n            }\n            return string(word[i])\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvn4rmxu8_test.go:17:12: undefined: contains

    /tmp/tmpvn4rmxu8_test.go:24:16: undefined: contains

    /tmp/tmpvn4rmxu8_test.go:27:16: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074508
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var last_consonant_index int\n    var last_vowel_index\
    \ int\n    var last_vowel string\n    for i, c := range word {\n        if vowels[string(c)]\
    \ {\n            last_vowel_index = i\n            last_vowel = string(c)\n  \
    \      } else {\n            if last_vowel_index > last_consonant_index {\n  \
    \              return last_vowel\n            }\n            last_consonant_index\
    \ = i\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp7ryem9kr_test.go:64: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp7ryem9kr_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp7ryem9kr_test.go:64: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    var closest_vowel_index int\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            closest_vowel = string(word[i])\n            closest_vowel_index\
    \ = i\n            break\n        }\n    }\n    if closest_vowel_index == 0 {\n\
    \        return \"\"\n    }\n    for i := closest_vowel_index - 1; i >= 0; i--\
    \ {\n        if !vowels[string(word[i])] {\n            return closest_vowel\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpb6wfyw21_test.go:67: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpb6wfyw21_test.go:67: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpb6wfyw21_test.go:67: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpb6wfyw21_test.go:67: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpb6wfyw21_test.go:67:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpb6wfyw21_test.go:67: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    var last_consonant string\n    var last_vowel\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            last_vowel = string(word[i])\n        } else {\n            if\
    \ last_vowel != \"\" {\n                return last_vowel\n            }\n   \
    \         last_consonant = string(word[i])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe5xcvekb_test.go:16:9: last_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074509
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var distance int\n    var found bool\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n      \
    \      if word[i] == v[0] {\n                if !found {\n                   \
    \ result = v\n                    distance = len(word) - i\n                 \
    \   found = true\n                } else {\n                    if len(word) -\
    \ i < distance {\n                        result = v\n                       \
    \ distance = len(word) - i\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmprbnfqxvq_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmprbnfqxvq_test.go:63: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmprbnfqxvq_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmprbnfqxvq_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmprbnfqxvq_test.go:63: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmprbnfqxvq_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmprbnfqxvq_test.go:63: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmprbnfqxvq_test.go:63:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmprbnfqxvq_test.go:63: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i + 1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzohnqsa_test.go:17:12: undefined: is_vowel

    /tmp/tmppzohnqsa_test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var last_consonant_index int = -1\n    var last_vowel_index\
    \ int = -1\n    for i, c := range word {\n        if vowels[string(c)] {\n   \
    \         last_vowel_index = i\n        } else {\n            if last_vowel_index\
    \ > last_consonant_index {\n                return string(word[last_vowel_index])\n\
    \            }\n            last_consonant_index = i\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmps5psfobr_test.go:62: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmps5psfobr_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmps5psfobr_test.go:62: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmps5psfobr_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmps5psfobr_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmps5psfobr_test.go:62: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmps5psfobr_test.go:62: expected 'i', got 'a'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var min_distance = len(word)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i]\
    \ == v[0] {\n                var distance = len(word) - i\n                if\
    \ distance < min_distance {\n                    min_distance = distance\n   \
    \                 result = v\n                }\n            }\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpj0e9cewd_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpj0e9cewd_test.go:57: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpj0e9cewd_test.go:57: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpj0e9cewd_test.go:57: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpj0e9cewd_test.go:57:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpj0e9cewd_test.go:57: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpj0e9cewd_test.go:57: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var result string\n    var last_vowel_index int\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            last_vowel_index = i\n            break\n        }\n    }\n\
    \    for i := last_vowel_index - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ !ok {\n            result = string(word[last_vowel_index])\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp06v6d0kb_test.go:64: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp06v6d0kb_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp06v6d0kb_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp06v6d0kb_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp06v6d0kb_test.go:64:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp06v6d0kb_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    for\
    \ i := len(word) - 1; i >= 2; i-- {\n        if is_vowel(word[i]) {\n        \
    \    if !is_vowel(word[i-1]) && !is_vowel(word[i-2]) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw_hsyzlz_test.go:19:12: undefined: is_vowel

    /tmp/tmpw_hsyzlz_test.go:20:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074509
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var distance int\n    var vowels_found int\n   \
    \ var last_consonant_index int\n    var last_vowel_index int\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i]\
    \ == v[0] {\n                if vowels_found == 0 {\n                    vowels_found++\n\
    \                    last_vowel_index = i\n                    distance = last_consonant_index\
    \ - last_vowel_index\n                    result = string(word[i])\n         \
    \       } else {\n                    if last_consonant_index - i < distance {\n\
    \                        distance = last_consonant_index - i\n               \
    \         result = string(word[i])\n                    }\n                }\n\
    \            }\n        }\n        if vowels_found > 0 {\n            if word[i]\
    \ != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u'\
    \ {\n                last_consonant_index = i\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp1wosf3e4_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp1wosf3e4_test.go:71: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp1wosf3e4_test.go:71: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp1wosf3e4_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp1wosf3e4_test.go:71: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp1wosf3e4_test.go:71: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp1wosf3e4_test.go:71: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp1wosf3e4_test.go:71:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1wosf3e4_test.go:71: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpb0vt3glz_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpb0vt3glz_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var prev_is_vowel = false\n    var result string\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n  \
    \          if !prev_is_vowel {\n                result = string(word[i])\n   \
    \             break\n            }\n            prev_is_vowel = true\n       \
    \ } else {\n            prev_is_vowel = false\n        }\n    }\n    return result\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpoxsca88u_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpoxsca88u_test.go:63: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpoxsca88u_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpoxsca88u_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpoxsca88u_test.go:63: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpoxsca88u_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpoxsca88u_test.go:63: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpoxsca88u_test.go:63:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpoxsca88u_test.go:63: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i+1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp1uiorm4o_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1uiorm4o_test.go:60:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1uiorm4o_test.go:60: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var prev_vowel rune\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[rune(word[i])] {\n            prev_vowel =\
    \ rune(word[i])\n            break\n        }\n    }\n    for i := len(word) -\
    \ 1; i >= 0; i-- {\n        if !vowels[rune(word[i])] {\n            if vowels[prev_vowel]\
    \ {\n                return string(prev_vowel)\n            }\n        } else\
    \ {\n            prev_vowel = rune(word[i])\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmprxhc88gw_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmprxhc88gw_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmprxhc88gw_test.go:60: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmprxhc88gw_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmprxhc88gw_test.go:60: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmprxhc88gw_test.go:60: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmprxhc88gw_test.go:60: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmprxhc88gw_test.go:60:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmprxhc88gw_test.go:60: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var last_vowel string\n    var last_consonant string\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            last_vowel = string(word[i])\n            if last_consonant !=\
    \ \"\" {\n                result = last_vowel\n                break\n       \
    \     }\n        } else {\n            last_consonant = string(word[i])\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprvipn_2l_test.go:20:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074509
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n         \
    \   if i == len(word) - 1 {\n                return \"\"\n            } else if\
    \ i == 0 {\n                return \"\"\n            } else if strings.Contains(vowels,\
    \ string(word[i + 1])) {\n                return \"\"\n            } else {\n\
    \                return string(word[i])\n            }\n        }\n    }\n   \
    \ return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkxhpsjw1_test.go:17:12: undefined: strings

    /tmp/tmpkxhpsjw1_test.go:22:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074509
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_consonant rune\n    var last_vowel rune\n\
    \    for _, c := range word {\n        if vowels[c] {\n            last_vowel\
    \ = c\n        } else {\n            last_consonant = c\n        }\n        if\
    \ last_consonant != 0 && last_vowel != 0 {\n            return string(last_vowel)\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpty9at7r7_test.go:56: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpty9at7r7_test.go:56: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpty9at7r7_test.go:56: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpty9at7r7_test.go:56: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpty9at7r7_test.go:56:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpty9at7r7_test.go:56: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpvrl3deo6_test.go:55: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpvrl3deo6_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpvrl3deo6_test.go:55: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpvrl3deo6_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpvrl3deo6_test.go:55:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvrl3deo6_test.go:55: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    last_vowel := \"\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            last_vowel\
    \ = string(word[i])\n            break\n        }\n    }\n    if last_vowel ==\
    \ \"\" {\n        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            continue\n        }\n \
    \       if i > 0 && vowels[string(word[i-1])] {\n            return string(word[i-1])\n\
    \        }\n    }\n    return last_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp0irrzex3_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp0irrzex3_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp0irrzex3_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp0irrzex3_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp0irrzex3_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp0irrzex3_test.go:62: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmp0irrzex3_test.go:62: expected '', got 'a'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var prev_char, curr_char string\n    for i := len(word) -\
    \ 1; i >= 0; i-- {\n        curr_char = string(word[i])\n        if vowels[curr_char]\
    \ {\n            if prev_char != \"\" && !vowels[prev_char] {\n              \
    \  return curr_char\n            }\n        }\n        prev_char = curr_char\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpi7kusac9_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpi7kusac9_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpi7kusac9_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpi7kusac9_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpi7kusac9_test.go:60: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    last_vowel := \"\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            last_vowel\
    \ = string(word[i])\n            break\n        }\n    }\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if !vowels[string(word[i])] {\n            if i\
    \ == len(word) - 1 {\n                return \"\"\n            }\n           \
    \ if vowels[string(word[i + 1])] {\n                return string(word[i + 1])\n\
    \            }\n        }\n    }\n    return last_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpv4eqswpu_test.go:61: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpv4eqswpu_test.go:61: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpv4eqswpu_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpv4eqswpu_test.go:61: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpv4eqswpu_test.go:61: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpv4eqswpu_test.go:61: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpv4eqswpu_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpv4eqswpu_test.go:61:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpv4eqswpu_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var prev_char string\n    var prev_prev_char string\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           if !is_vowel(prev_char) {\n                result = string(word[i])\n\
    \                break\n            }\n        } else {\n            if is_vowel(prev_char)\
    \ && !is_vowel(prev_prev_char) {\n                result = string(prev_char)\n\
    \                break\n            }\n        }\n        prev_prev_char = prev_char\n\
    \        prev_char = string(word[i])\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdagh6k7o_test.go:15:9: vowels declared but not used

    /tmp/tmpdagh6k7o_test.go:20:12: undefined: is_vowel

    /tmp/tmpdagh6k7o_test.go:21:17: undefined: is_vowel

    /tmp/tmpdagh6k7o_test.go:26:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074509
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i > 0 && !vowels[string(word[i-1])]\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpj5waedf6_test.go:51: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpj5waedf6_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpj5waedf6_test.go:51: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpj5waedf6_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpj5waedf6_test.go:51:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpj5waedf6_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n         \
    \   if i > 0 && !strings.Contains(vowels, string(word[i-1])) {\n             \
    \   return string(word[i])\n            }\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9j95n7da_test.go:17:12: undefined: strings

    /tmp/tmp9j95n7da_test.go:18:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074509
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if is_vowel(word[i], vowels) {\n            if i > 0\
    \ && !is_vowel(word[i-1], vowels) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpriy6yph8_test.go:20:12: undefined: is_vowel

    /tmp/tmpriy6yph8_test.go:21:26: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i+1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfjz15r__test.go:17:12: undefined: is_vowel

    /tmp/tmptfjz15r__test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074511
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i+1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfjz15r__test.go:17:12: undefined: is_vowel

    /tmp/tmptfjz15r__test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074511
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var last_consonant_index = -1\n    var last_vowel_index\
    \ = -1\n    for i, c := range word {\n        if vowels[string(c)] {\n       \
    \     last_vowel_index = i\n        } else {\n            if last_vowel_index\
    \ > last_consonant_index {\n                return string(word[last_vowel_index])\n\
    \            }\n            last_consonant_index = i\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmph1mrlf_a_test.go:62: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmph1mrlf_a_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmph1mrlf_a_test.go:62: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmph1mrlf_a_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmph1mrlf_a_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmph1mrlf_a_test.go:62: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmph1mrlf_a_test.go:62: expected 'i', got 'a'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i+1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfjz15r__test.go:17:12: undefined: is_vowel

    /tmp/tmptfjz15r__test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074511
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result = \"\"\n    var found = false\n    var last_vowel = \"\"\n \
    \   for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i:i+1] == v {\n                last_vowel = word[i:i+1]\n\
    \                found = true\n                break\n            }\n        }\n\
    \        if found {\n            break\n        }\n    }\n    if found {\n   \
    \     for i := len(word) - 1; i >= 0; i-- {\n            if word[i:i+1] == last_vowel\
    \ {\n                result = word[i:i+1]\n                break\n           \
    \ }\n            for _, v := range vowels {\n                if word[i:i+1] ==\
    \ v {\n                    result = word[i:i+1]\n                    break\n \
    \               }\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpjc3pnwnk_test.go:73: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpjc3pnwnk_test.go:73: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpjc3pnwnk_test.go:73: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpjc3pnwnk_test.go:73: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpjc3pnwnk_test.go:73: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpjc3pnwnk_test.go:73: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpjc3pnwnk_test.go:73: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpjc3pnwnk_test.go:73:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpjc3pnwnk_test.go:73: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074512
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpb0vt3glz_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpb0vt3glz_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var last_vowel string\n    var last_consonant string\n    var last_vowel_index\
    \ int\n    var last_consonant_index int\n    for i, c := range word {\n      \
    \  if is_vowel(string(c)) {\n            last_vowel = string(c)\n            last_vowel_index\
    \ = i\n        } else {\n            last_consonant = string(c)\n            last_consonant_index\
    \ = i\n        }\n        if last_vowel != \"\" && last_consonant != \"\" {\n\
    \            break\n        }\n    }\n    if last_vowel == \"\" || last_consonant\
    \ == \"\" {\n        return \"\"\n    }\n    for i := len(word) - 1; i > 0; i--\
    \ {\n        if is_vowel(string(word[i])) {\n            if last_vowel_index <\
    \ i && i < last_consonant_index {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjcp08x52_test.go:15:9: vowels declared but not used

    /tmp/tmpjcp08x52_test.go:21:12: undefined: is_vowel

    /tmp/tmpjcp08x52_test.go:36:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var distance int\n    for i := len(word) - 1; i\
    \ >= 0; i-- {\n        for _, v := range vowels {\n            if word[i] == v[0]\
    \ {\n                if distance == 0 {\n                    result = v\n    \
    \                distance = len(word) - i\n                } else if len(word)\
    \ - i < distance {\n                    result = v\n                    distance\
    \ = len(word) - i\n                }\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmprupa7a7j_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmprupa7a7j_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmprupa7a7j_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmprupa7a7j_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmprupa7a7j_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmprupa7a7j_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmprupa7a7j_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmprupa7a7j_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmprupa7a7j_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i > 0 && !is_vowel(word[i-1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqbhug8y1_test.go:17:12: undefined: is_vowel

    /tmp/tmpqbhug8y1_test.go:18:26: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if is_vowel(word[i+1], vowels) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzf0edqps_test.go:17:12: undefined: is_vowel

    /tmp/tmpzf0edqps_test.go:21:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var last_vowel_index int = -1\n\
    \    var last_consonant_index int = -1\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[strings.Index(vowels, string(word[i]))] != 0 {\n      \
    \      last_vowel_index = i\n            if last_consonant_index > 0 {\n     \
    \           return string(word[last_vowel_index])\n            }\n        } else\
    \ {\n            last_consonant_index = i\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwymx4lyr_test.go:19:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var prev_consonant rune\n    var prev_vowel rune\n\
    \    for _, c := range word {\n        if vowels[c] {\n            prev_vowel\
    \ = c\n        } else {\n            if prev_vowel != 0 {\n                return\
    \ string(prev_vowel)\n            }\n            prev_consonant = c\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkiv_8pzj_test.go:16:9: prev_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    last_vowel := \"\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            last_vowel\
    \ = string(word[i])\n            break\n        }\n    }\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            if last_vowel\
    \ != string(word[i]) {\n                return string(word[i])\n            }\n\
    \        } else {\n            last_vowel = \"\"\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp7g1qdjh9_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp7g1qdjh9_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp7g1qdjh9_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp7g1qdjh9_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp7g1qdjh9_test.go:60: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n    \
    \    tmp7g1qdjh9_test.go:60: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i + 1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzohnqsa_test.go:17:12: undefined: is_vowel

    /tmp/tmppzohnqsa_test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) == 0 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\"\
    : true}\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i + 1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpvqa0cgf6_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpvqa0cgf6_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpvqa0cgf6_test.go:57: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpvqa0cgf6_test.go:57: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvqa0cgf6_test.go:57:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvqa0cgf6_test.go:57: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] != -1 {\n\
    \            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9433h371_test.go:17:19: undefined: strings

    /tmp/tmp9433h371_test.go:17:62: -1 (untyped int constant) overflows byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[rune]bool{\n        'a': true,\n    \
    \    'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n\
    \    }\n    var prev_consonant bool\n    var closest_vowel string\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if vowels[rune(word[i])] {\n         \
    \   if prev_consonant {\n                closest_vowel = string(word[i])\n   \
    \             break\n            }\n        } else {\n            prev_consonant\
    \ = true\n        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpj1300vsd_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpj1300vsd_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpj1300vsd_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpj1300vsd_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpj1300vsd_test.go:62: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074513
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\n        \"a\": 1,\n       \
    \ \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n    }\n\
    \    var closest_vowel string\n    var closest_vowel_index int\n    var closest_vowel_distance\
    \ int\n    var prev_char_is_vowel bool\n    var next_char_is_vowel bool\n    var\
    \ prev_char_is_consonant bool\n    var next_char_is_consonant bool\n    for i,\
    \ char := range word {\n        if _, ok := vowels[string(char)]; ok {\n     \
    \       prev_char_is_vowel = true\n            next_char_is_vowel = true\n   \
    \         if i > 0 {\n                if _, ok := vowels[string(word[i-1])]; !ok\
    \ {\n                    prev_char_is_consonant = true\n                }\n  \
    \          }\n            if i < len(word) - 1 {\n                if _, ok :=\
    \ vowels[string(word[i+1])]; !ok {\n                    next_char_is_consonant\
    \ = true\n                }\n            }\n            if prev_char_is_consonant\
    \ && next_char_is_consonant {\n                if closest_vowel_distance == 0\
    \ {\n                    closest_vowel_distance = i\n                    closest_vowel_index\
    \ = i\n                    closest_vowel = string(char)\n                } else\
    \ {\n                    if i < closest_vowel_distance {\n                   \
    \     closest_vowel_distance = i\n                        closest_vowel_index\
    \ = i\n                        closest_vowel = string(char)\n                \
    \    }\n                }\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpftktbny3_test.go:23:9: closest_vowel_index declared but not used

    /tmp/tmpftktbny3_test.go:25:9: prev_char_is_vowel declared but not used

    /tmp/tmpftktbny3_test.go:26:9: next_char_is_vowel declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var found bool\n    var last_consonant_index int\n\
    \    var last_vowel_index int\n    var vowel_index int\n    var vowel_distance\
    \ int\n    var min_vowel_distance int\n    var min_vowel_index int\n    var min_vowel_index_found\
    \ bool\n    for i := len(word) - 1; i >= 0; i-- {\n        for j := 0; j < len(vowels);\
    \ j++ {\n            if word[i] == vowels[j][0] {\n                if found {\n\
    \                    vowel_index = i\n                    vowel_distance = last_consonant_index\
    \ - vowel_index\n                    if min_vowel_index_found {\n            \
    \            if vowel_distance < min_vowel_distance {\n                      \
    \      min_vowel_distance = vowel_distance\n                            min_vowel_index\
    \ = vowel_index\n                        }\n                    } else {\n   \
    \                     min_vowel_distance = vowel_distance\n                  \
    \      min_vowel_index = vowel_index\n                        min_vowel_index_found\
    \ = true\n                    }\n                } else {\n                  \
    \  last_vowel_index = i\n                }\n            }\n        }\n       \
    \ if !found {\n            if last_vowel_index != i {\n                found =\
    \ true\n                last_consonant_index = i\n            }\n        }\n \
    \   }\n    if min_vowel_index_found {\n        result = string(word[min_vowel_index])\n\
    \    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp2w8mme3i_test.go:84: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp2w8mme3i_test.go:84: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp2w8mme3i_test.go:84: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp2w8mme3i_test.go:84: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp2w8mme3i_test.go:84: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074513
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var prev_char, curr_char, next_char string\n    var prev_char_is_vowel,\
    \ next_char_is_vowel bool\n    var curr_char_index int\n    var closest_vowel\
    \ string\n    var closest_vowel_index int\n    var closest_vowel_distance int\n\
    \    var curr_vowel_distance int\n\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        curr_char = string(word[i])\n        if i == 0 {\n            prev_char\
    \ = \"\"\n        } else {\n            prev_char = string(word[i-1])\n      \
    \  }\n        if i == len(word) - 1 {\n            next_char = \"\"\n        }\
    \ else {\n            next_char = string(word[i+1])\n        }\n\n        prev_char_is_vowel\
    \ = false\n        next_char_is_vowel = false\n        for _, v := range vowels\
    \ {\n            if prev_char == v {\n                prev_char_is_vowel = true\n\
    \            }\n            if next_char == v {\n                next_char_is_vowel\
    \ = true\n            }\n        }\n\n        if !prev_char_is_vowel && !next_char_is_vowel\
    \ {\n            for j, v := range vowels {\n                if curr_char == v\
    \ {\n                    curr_char_index = j\n                    break\n    \
    \            }\n            }\n            curr_vowel_distance = len(vowels) -\
    \ curr_char_index\n            if closest_vowel_distance == 0 || curr_vowel_distance\
    \ < closest_vowel_distance {\n                closest_vowel_distance = curr_vowel_distance\n\
    \                closest_vowel = curr_char\n                closest_vowel_index\
    \ = i\n            }\n        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpubuz6b5a_test.go:20:9: closest_vowel_index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i > 0 && !is_vowel(word[i-1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqbhug8y1_test.go:17:12: undefined: is_vowel

    /tmp/tmpqbhug8y1_test.go:18:26: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if is_consonant(word[i]) {\n            for j := i -\
    \ 1; j >= 0; j-- {\n                if is_vowel(word[j]) {\n                 \
    \   return string(word[j])\n                }\n            }\n            return\
    \ \"\"\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpst55f2c5_test.go:18:5: vowels declared but not used

    /tmp/tmpst55f2c5_test.go:20:12: undefined: is_consonant

    /tmp/tmpst55f2c5_test.go:22:20: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i+1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfjz15r__test.go:17:12: undefined: is_vowel

    /tmp/tmptfjz15r__test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074511
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    last_vowel := -1\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[rune(word[i])] {\n            last_vowel = i\n \
    \           break\n        }\n    }\n    if last_vowel == -1 {\n        return\
    \ \"\"\n    }\n    for i := last_vowel - 1; i >= 0; i-- {\n        if !vowels[rune(word[i])]\
    \ {\n            return string(word[last_vowel])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpui1agv2a_test.go:59: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpui1agv2a_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpui1agv2a_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpui1agv2a_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpui1agv2a_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpui1agv2a_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074513
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i + 1 < len(word) &&\
    \ !vowels[string(word[i + 1])] {\n                return string(word[i])\n   \
    \         }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpjrm58av5_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpjrm58av5_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpjrm58av5_test.go:51: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpjrm58av5_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpjrm58av5_test.go:51: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074513
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var distance int\n    var prev_is_vowel bool\n \
    \   var curr_is_vowel bool\n    var curr_distance int\n    var curr_vowel string\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        curr_is_vowel = false\n  \
    \      for _, v := range vowels {\n            if word[i] == v[0] {\n        \
    \        curr_is_vowel = true\n                curr_vowel = v\n              \
    \  break\n            }\n        }\n        if curr_is_vowel {\n            if\
    \ !prev_is_vowel {\n                curr_distance = len(word) - i\n          \
    \      if distance == 0 || curr_distance < distance {\n                    distance\
    \ = curr_distance\n                    result = curr_vowel\n                }\n\
    \            }\n        }\n        prev_is_vowel = curr_is_vowel\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpez14_hus_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpez14_hus_test.go:70: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpez14_hus_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpez14_hus_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpez14_hus_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpez14_hus_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpez14_hus_test.go:70: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpez14_hus_test.go:70:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpez14_hus_test.go:70: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074513
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var last_consonant_index int\n    var last_vowel_index\
    \ int\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            last_vowel_index = i\n        } else {\n            if last_vowel_index\
    \ > last_consonant_index {\n                return string(word[last_vowel_index])\n\
    \            }\n            last_consonant_index = i\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvt_qit___test.go:62: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvt_qit___test.go:62: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpvt_qit___test.go:62: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpvt_qit___test.go:62: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpvt_qit___test.go:62: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpvt_qit___test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpvt_qit___test.go:62: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpvt_qit___test.go:62:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvt_qit___test.go:62: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074513
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var result string\n    var last_vowel_index int\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n  \
    \          last_vowel_index = i\n            break\n        }\n    }\n    for\
    \ i := last_vowel_index - 1; i >= 0; i-- {\n        if !vowels[string(word[i])]\
    \ {\n            result = string(word[last_vowel_index])\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpa0bo6rlf_test.go:64: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpa0bo6rlf_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpa0bo6rlf_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpa0bo6rlf_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpa0bo6rlf_test.go:64:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpa0bo6rlf_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074513
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpb0vt3glz_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpb0vt3glz_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i < len(word) - 1 && !is_vowel(word[i + 1], vowels) {\n  \
    \              return string(word[i])\n            }\n        } else {\n     \
    \       if i < len(word) - 1 && is_vowel(word[i + 1], vowels) {\n            \
    \    return string(word[i + 1])\n            }\n        }\n    }\n    return \"\
    \"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa0knke5m_test.go:17:12: undefined: is_vowel

    /tmp/tmpa0knke5m_test.go:18:38: undefined: is_vowel

    /tmp/tmpa0knke5m_test.go:22:37: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var last_vowel_index int\n    var last_consonant_index\
    \ int\n    var last_vowel_distance int\n    var last_consonant_distance int\n\
    \    var found_vowel bool\n    var found_consonant bool\n    for i, char := range\
    \ word {\n        if contains(vowels, string(char)) {\n            if !found_vowel\
    \ {\n                last_vowel_index = i\n                found_vowel = true\n\
    \            } else {\n                last_vowel_distance = i - last_vowel_index\n\
    \                last_vowel_index = i\n            }\n        } else {\n     \
    \       if !found_consonant {\n                last_consonant_index = i\n    \
    \            found_consonant = true\n            } else {\n                last_consonant_distance\
    \ = i - last_consonant_index\n                last_consonant_index = i\n     \
    \       }\n        }\n        if found_vowel && found_consonant {\n          \
    \  if last_vowel_distance < last_consonant_distance {\n                result\
    \ = string(word[last_vowel_index])\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp78hqa4n1_test.go:24:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074514
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if !vowels[string(word[i\
    \ + 1])] {\n                return string(word[i])\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpslosobpm_test.go:54: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpslosobpm_test.go:54: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpslosobpm_test.go:54: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpslosobpm_test.go:54: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpslosobpm_test.go:54:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpslosobpm_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074514
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]int{\n        \"a\": 1,\n    \
    \    \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n    }\n\
    \    var last_vowel string\n    for i := len(word) - 1; i >= 0; i-- {\n      \
    \  if _, ok := vowels[string(word[i])]; ok {\n            last_vowel = string(word[i])\n\
    \            break\n        }\n    }\n    if last_vowel == \"\" {\n        return\
    \ \"\"\n    }\n    var closest_vowel string\n    var closest_vowel_distance int\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if closest_vowel_distance == 0 {\n                closest_vowel\
    \ = string(word[i])\n                closest_vowel_distance = len(word) - i\n\
    \            } else {\n                if len(word) - i < closest_vowel_distance\
    \ {\n                    closest_vowel = string(word[i])\n                   \
    \ closest_vowel_distance = len(word) - i\n                }\n            }\n \
    \       }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpr3du1tl1_test.go:75: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpr3du1tl1_test.go:75: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpr3du1tl1_test.go:75: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpr3du1tl1_test.go:75: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpr3du1tl1_test.go:75: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpr3du1tl1_test.go:75: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpr3du1tl1_test.go:75: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpr3du1tl1_test.go:75:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpr3du1tl1_test.go:75: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074514
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_consonant rune\n    var last_vowel rune\n\
    \    for _, c := range word {\n        if vowels[c] {\n            last_vowel\
    \ = c\n        } else {\n            last_consonant = c\n        }\n        if\
    \ last_consonant != 0 && last_vowel != 0 {\n            return string(last_vowel)\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpty9at7r7_test.go:56: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpty9at7r7_test.go:56: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpty9at7r7_test.go:56: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpty9at7r7_test.go:56: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpty9at7r7_test.go:56:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpty9at7r7_test.go:56: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if !vowels[string(word[i\
    \ + 1])] {\n                return string(word[i])\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpslosobpm_test.go:54: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpslosobpm_test.go:54: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpslosobpm_test.go:54: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpslosobpm_test.go:54: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpslosobpm_test.go:54:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpslosobpm_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074514
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) == 0 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"\
    i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            if i ==\
    \ len(word) - 1 {\n                return \"\"\n            }\n            if\
    \ !vowels[string(word[i+1])] {\n                return string(word[i])\n     \
    \       }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp59fmwhkc_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp59fmwhkc_test.go:63: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp59fmwhkc_test.go:63: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp59fmwhkc_test.go:63: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp59fmwhkc_test.go:63:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp59fmwhkc_test.go:63: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant string\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[string(word[i])] {\n            if last_consonant\
    \ != \"\" {\n                return string(word[i])\n            }\n        }\
    \ else {\n            last_consonant = string(word[i])\n        }\n    }\n   \
    \ return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp8ornzlvo_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp8ornzlvo_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp8ornzlvo_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp8ornzlvo_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp8ornzlvo_test.go:60: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n        \
    \    if i == len(word) - 1 {\n                return \"\"\n            }\n   \
    \         if is_vowel(word[i+1]) {\n                continue\n            }\n\
    \            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo04gq188_test.go:19:12: undefined: is_vowel

    /tmp/tmpo04gq188_test.go:23:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074514
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                continue\n         \
    \   }\n            if !is_vowel(word[i + 1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9pt170gi_test.go:17:12: undefined: is_vowel

    /tmp/tmp9pt170gi_test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074514
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i+1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp1uiorm4o_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1uiorm4o_test.go:60:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1uiorm4o_test.go:60: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1,\
    \ \"o\": 1, \"u\": 1}\n    for i := len(word) - 1; i >= 0; i-- {\n        if _,\
    \ ok := vowels[string(word[i])]; ok {\n            if i > 0 && i < len(word) -\
    \ 1 {\n                if _, ok := vowels[string(word[i-1])]; !ok && _, ok :=\
    \ vowels[string(word[i+1])]; !ok {\n                    return string(word[i])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoeftaf0__test.go:19:56: expected identifier on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074514
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i > 0 && !is_vowel(word[i-1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqbhug8y1_test.go:17:12: undefined: is_vowel

    /tmp/tmpqbhug8y1_test.go:18:26: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074512
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var last_consonant_index int = -1\n    var last_vowel_index\
    \ int = -1\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            last_vowel_index = i\n        } else {\n            if last_vowel_index\
    \ != -1 {\n                last_consonant_index = i\n                break\n \
    \           }\n        }\n    }\n    if last_consonant_index == -1 {\n       \
    \ return \"\"\n    }\n    return string(word[last_vowel_index])\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmph84j4i9x_test.go:65: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmph84j4i9x_test.go:65: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmph84j4i9x_test.go:65: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmph84j4i9x_test.go:65: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmph84j4i9x_test.go:65:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmph84j4i9x_test.go:65: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var closest_vowel string\n    var closest_index int\n    for\
    \ i, c := range word {\n        if vowels[string(c)] {\n            closest_vowel\
    \ = string(c)\n            closest_index = i\n            break\n        }\n \
    \   }\n    for i, c := range word {\n        if vowels[string(c)] {\n        \
    \    if i > closest_index {\n                closest_vowel = string(c)\n     \
    \           closest_index = i\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp37md_oog_test.go:67: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp37md_oog_test.go:67: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp37md_oog_test.go:67: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp37md_oog_test.go:67: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp37md_oog_test.go:67: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp37md_oog_test.go:67: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp37md_oog_test.go:67: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp37md_oog_test.go:67:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp37md_oog_test.go:67: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 2; i-- {\n        if !is_vowel(word[i], vowels) && is_vowel(word[i-1],\
    \ vowels) && !is_vowel(word[i-2], vowels) {\n            return string(word[i-1])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpby9kdc5__test.go:20:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074514
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var found bool\n    var last_consonant int\n   \
    \ var last_vowel int\n    var last_vowel_index int\n    var last_consonant_index\
    \ int\n    var last_vowel_distance int\n    var last_consonant_distance int\n\
    \    for i, c := range word {\n        if c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' {\n            last_vowel = i\n            last_vowel_index\
    \ = i\n            last_vowel_distance = i - last_consonant\n            if last_vowel_distance\
    \ < last_consonant_distance {\n                found = true\n                result\
    \ = vowels[last_vowel_index]\n            }\n        } else {\n            last_consonant\
    \ = i\n            last_consonant_index = i\n            last_consonant_distance\
    \ = i - last_vowel\n            if last_consonant_distance < last_vowel_distance\
    \ {\n                found = true\n                result = vowels[last_vowel_index]\n\
    \            }\n        }\n    }\n    if found {\n        return result\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpprjg016l_test.go:21:9: last_consonant_index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074514
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpb0vt3glz_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpb0vt3glz_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpb0vt3glz_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpb0vt3glz_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpb0vt3glz_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpt2kpkqrw_test.go:49: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpt2kpkqrw_test.go:49: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpt2kpkqrw_test.go:49: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpt2kpkqrw_test.go:49: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpt2kpkqrw_test.go:49: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpt2kpkqrw_test.go:49: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpt2kpkqrw_test.go:49: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpt2kpkqrw_test.go:49:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpt2kpkqrw_test.go:49: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var last_vowel_index int\n    var last_consonant_index\
    \ int\n    var found_vowel bool\n    var found_consonant bool\n    var found_vowel_after_consonant\
    \ bool\n    var found_consonant_after_vowel bool\n    var found_vowel_after_consonant_index\
    \ int\n    var found_consonant_after_vowel_index int\n    for i := len(word) -\
    \ 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i:i+1]\
    \ == v {\n                last_vowel_index = i\n                found_vowel =\
    \ true\n                if found_consonant_after_vowel {\n                   \
    \ found_vowel_after_consonant = true\n                    found_vowel_after_consonant_index\
    \ = i\n                }\n                break\n            }\n        }\n  \
    \      if !found_vowel {\n            last_consonant_index = i\n            found_consonant\
    \ = true\n            if found_vowel_after_consonant {\n                found_consonant_after_vowel\
    \ = true\n                found_consonant_after_vowel_index = i\n            }\n\
    \        }\n        if found_vowel_after_consonant && found_consonant_after_vowel\
    \ {\n            break\n        }\n    }\n    if found_vowel_after_consonant &&\
    \ found_consonant_after_vowel {\n        if found_vowel_after_consonant_index\
    \ - last_consonant_index < last_vowel_index - found_consonant_after_vowel_index\
    \ {\n            result = word[found_vowel_after_consonant_index:found_vowel_after_consonant_index+1]\n\
    \        } else {\n            result = word[last_vowel_index:last_vowel_index+1\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk4fwcour_test.go:53:62: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074514
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\"\
    : true}\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if i == len(word) - 1 {\n                return \"\"\n   \
    \         }\n            if _, ok := vowels[string(word[i + 1])]; !ok {\n    \
    \            return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpe12xa18g_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpe12xa18g_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpe12xa18g_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpe12xa18g_test.go:57: expected 'i', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpe12xa18g_test.go:57:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    consonants := map[string]bool{\"b\"\
    : true, \"c\": true, \"d\": true, \"f\": true, \"g\": true, \"h\": true, \"j\"\
    : true, \"k\": true, \"l\": true, \"m\": true, \"n\": true, \"p\": true, \"q\"\
    : true, \"r\": true, \"s\": true, \"t\": true, \"v\": true, \"w\": true, \"x\"\
    : true, \"y\": true, \"z\": true}\n    var result string\n    var last_consonant\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if last_consonant != \"\" {\n                result = string(word[i])\n\
    \                break\n            }\n        } else if _, ok := consonants[string(word[i])];\
    \ ok {\n            last_consonant = string(word[i])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpas6ndk58_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpas6ndk58_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpas6ndk58_test.go:57: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpas6ndk58_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpas6ndk58_test.go:57: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i + 1 < len(word) &&\
    \ !vowels[string(word[i + 1])] {\n                return string(word[i])\n   \
    \         }\n        } else {\n            if i + 1 < len(word) && vowels[string(word[i\
    \ + 1])] {\n                return string(word[i + 1])\n            }\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp4nalmgog_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp4nalmgog_test.go:55: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp4nalmgog_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp4nalmgog_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp4nalmgog_test.go:55: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp4nalmgog_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp4nalmgog_test.go:55: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp4nalmgog_test.go:55:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp4nalmgog_test.go:55: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    last_vowel := \"\"\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            last_vowel = string(word[i])\n\
    \            break\n        }\n    }\n    if last_vowel == \"\" {\n        return\
    \ \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            continue\n        }\n        if vowels[string(word[i-1])] {\n\
    \            return string(word[i-1])\n        }\n    }\n    return last_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513780, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513780,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel({0x51e394, 0x2})\n\t/tmp/tmpat9pzzc5_test.go:36\
    \ +0x2d0\ncommand-line-arguments_test.TestGet_Closest_Vowel(0x0?)\n\t/tmp/tmpat9pzzc5_test.go:58\
    \ +0x19e\ntesting.tRunner(0xc0000cc1a0, 0x5290e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var vowel_index int\n    var vowel_distance int\n\
    \    var word_length = len(word)\n    for i := word_length - 1; i > 0; i-- {\n\
    \        for j := 0; j < len(vowels); j++ {\n            if word[i] == vowels[j][0]\
    \ {\n                if vowel_distance == 0 {\n                    vowel_distance\
    \ = word_length - i\n                    vowel_index = i\n                } else\
    \ if word_length - i < vowel_distance {\n                    vowel_distance =\
    \ word_length - i\n                    vowel_index = i\n                }\n  \
    \          }\n        }\n    }\n    if vowel_index > 0 {\n        result = string(word[vowel_index])\n\
    \    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpiyfqrppg_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpiyfqrppg_test.go:64: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpiyfqrppg_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpiyfqrppg_test.go:64: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpiyfqrppg_test.go:64:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpiyfqrppg_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpiyfqrppg_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpvrl3deo6_test.go:55: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpvrl3deo6_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpvrl3deo6_test.go:55: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpvrl3deo6_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpvrl3deo6_test.go:55:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvrl3deo6_test.go:55: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      } else {\n                if is_vowel(word[i+1], vowels) {\n          \
    \          continue\n                } else {\n                    return string(word[i])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1fgcxfa2_test.go:17:12: undefined: is_vowel

    /tmp/tmp1fgcxfa2_test.go:21:20: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074515
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            if i == len(word) - 1 {\n                continue\n         \
    \   }\n            if !contains(vowels, string(word[i + 1])) {\n             \
    \   return string(word[i])\n            }\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu0lxt7d__test.go:17:12: undefined: contains

    /tmp/tmpu0lxt7d__test.go:21:17: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var result string\n    var last_vowel string\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n       \
    \     last_vowel = string(word[i])\n            break\n        }\n    }\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n  \
    \          result = string(word[i])\n            break\n        }\n    }\n   \
    \ if result == \"\" {\n        return result\n    }\n    for i := len(word) -\
    \ 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n            continue\n\
    \        }\n        if vowels[string(word[i-1])] {\n            result = string(word[i-1])\n\
    \            break\n        }\n    }\n    if result == \"\" {\n        return\
    \ last_vowel\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513780, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513780,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel({0x51e394, 0x2})\n\t/tmp/tmp86uko8e4_test.go:43\
    \ +0x3c5\ncommand-line-arguments_test.TestGet_Closest_Vowel(0x0?)\n\t/tmp/tmp86uko8e4_test.go:69\
    \ +0x19e\ntesting.tRunner(0xc0000cc340, 0x5290e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074515
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i+1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfjz15r__test.go:17:12: undefined: is_vowel

    /tmp/tmptfjz15r__test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074511
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpvrl3deo6_test.go:55: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpvrl3deo6_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpvrl3deo6_test.go:55: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpvrl3deo6_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpvrl3deo6_test.go:55: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpvrl3deo6_test.go:55:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvrl3deo6_test.go:55: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if is_vowel(word[i + 1], vowels) {\n                continue\n\
    \            }\n            return string(word[i])\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn8kh1td7_test.go:17:12: undefined: is_vowel

    /tmp/tmpn8kh1td7_test.go:21:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074515
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var min int = len(word)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i]\
    \ == v[0] {\n                if i < min {\n                    min = i\n     \
    \               result = v\n                }\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpikouy34a_test.go:56: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpikouy34a_test.go:56: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpikouy34a_test.go:56: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpikouy34a_test.go:56: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpikouy34a_test.go:56: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpikouy34a_test.go:56: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpikouy34a_test.go:56: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpikouy34a_test.go:56:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpikouy34a_test.go:56: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074516
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    var prev_is_vowel bool\n    var prev_vowel\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if prev_is_vowel {\n                return prev_vowel\n     \
    \       }\n            prev_is_vowel = true\n            prev_vowel = string(word[i])\n\
    \        } else {\n            if prev_is_vowel {\n                return string(word[i])\n\
    \            }\n            prev_is_vowel = false\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpsdoinvp5_test.go:60: expected 'u', got 'g'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpsdoinvp5_test.go:60: expected\
    \ 'u', got 'f'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n    \
    \    tmpsdoinvp5_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpsdoinvp5_test.go:60: expected '', got 'l'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpsdoinvp5_test.go:60: expected\
    \ 'a', got 'b'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n    \
    \    tmpsdoinvp5_test.go:60: expected 'o', got 'm'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8\
    \ (0.00s)\n        tmpsdoinvp5_test.go:60: expected '', got 'b'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpsdoinvp5_test.go:60: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmpsdoinvp5_test.go:60: expected 'i', got 'm'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpsdoinvp5_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpsdoinvp5_test.go:60:\
    \ expected 'o', got 'v'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074516
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) == 0 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i] ==\
    \ v[0] {\n                return v\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpdthywbzs_test.go:54: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpdthywbzs_test.go:54: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpdthywbzs_test.go:54: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpdthywbzs_test.go:54: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpdthywbzs_test.go:54: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpdthywbzs_test.go:54: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpdthywbzs_test.go:54: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpdthywbzs_test.go:54:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpdthywbzs_test.go:54: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074516
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if is_vowel(word[i], vowels) {\n            if i == len(word)\
    \ - 1 {\n                return \"\"\n            }\n            if !is_vowel(word[i\
    \ + 1], vowels) {\n                return string(word[i])\n            }\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu9hcn95r_test.go:20:12: undefined: is_vowel

    /tmp/tmpu9hcn95r_test.go:24:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074516
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_vowel string\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if vowels[string(word[i])] {\n            last_vowel = string(word[i])\n\
    \            break\n        }\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if !vowels[string(word[i])] {\n            if i > 0 && vowels[string(word[i-1])]\
    \ {\n                return string(word[i-1])\n            }\n        }\n    }\n\
    \    return last_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpjua9ww_z_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpjua9ww_z_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpjua9ww_z_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpjua9ww_z_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpjua9ww_z_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpjua9ww_z_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpjua9ww_z_test.go:64: expected '', got 'a'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074517
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var index int\n    var found bool\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        for j := 0; j < len(vowels); j++ {\n \
    \           if word[i] == vowels[j][0] {\n                if found {\n       \
    \             if i > index {\n                        result = string(word[i])\n\
    \                        index = i\n                    }\n                } else\
    \ {\n                    result = string(word[i])\n                    index =\
    \ i\n                    found = true\n                }\n            }\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpk5q5tzo3_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpk5q5tzo3_test.go:63: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpk5q5tzo3_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpk5q5tzo3_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpk5q5tzo3_test.go:63: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpk5q5tzo3_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpk5q5tzo3_test.go:63: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpk5q5tzo3_test.go:63:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpk5q5tzo3_test.go:63: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074517
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) == 0 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if is_vowel(word[i], vowels) {\n            if i == len(word)\
    \ - 1 {\n                return \"\"\n            }\n            if !is_vowel(word[i\
    \ + 1], vowels) {\n                return string(word[i])\n            }\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmdpyw_yf_test.go:20:12: undefined: is_vowel

    /tmp/tmpmdpyw_yf_test.go:24:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074516
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{\n        'a': true,\n       \
    \ 'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n   \
    \ }\n    var last_consonant rune\n    var last_vowel rune\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[rune(word[i])] {\n            last_vowel\
    \ = rune(word[i])\n            if last_consonant != 0 {\n                return\
    \ string(last_vowel)\n            }\n        } else {\n            last_consonant\
    \ = rune(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpbgeg34y2_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpbgeg34y2_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpbgeg34y2_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpbgeg34y2_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpbgeg34y2_test.go:62: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074517
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !contains(vowels, string(word[i + 1])) {\n          \
    \      return string(word[i])\n            }\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpysgl_2gp_test.go:17:12: undefined: contains

    /tmp/tmpysgl_2gp_test.go:21:17: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074516
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_vowel rune\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[rune(word[i])] {\n            last_vowel =\
    \ rune(word[i])\n            break\n        }\n    }\n    if last_vowel == 0 {\n\
    \        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   if !vowels[rune(word[i])] {\n            if i == len(word) - 1 {\n       \
    \         return string(last_vowel)\n            }\n            if vowels[rune(word[i+1])]\
    \ {\n                return string(last_vowel)\n            }\n        }\n   \
    \ }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp32h227hs_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp32h227hs_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp32h227hs_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp32h227hs_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp32h227hs_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp32h227hs_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp32h227hs_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp32h227hs_test.go:64:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp32h227hs_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074517
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[vowels[i]] {\n            if i > 0 && !vowels[word[i-1]]\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpywazgr1j_test.go:17:12: non-boolean condition in if statement

    /tmp/tmpywazgr1j_test.go:18:26: invalid operation: operator ! not defined on vowels[word[i
    - 1]] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074517
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var distance int\n    var\
    \ min_distance int\n    var is_vowel bool\n    var is_consonant bool\n    var\
    \ is_first_vowel bool\n    var is_first_consonant bool\n    var is_last_vowel\
    \ bool\n    var is_last_consonant bool\n    var is_first_char bool\n    var is_last_char\
    \ bool\n    var is_first_char_vowel bool\n    var is_last_char_vowel bool\n  \
    \  var is_first_char_consonant bool\n    var is_last_char_consonant bool\n   \
    \ var is_first_char_vowel_or_consonant bool\n    var is_last_char_vowel_or_consonant\
    \ bool\n    var is_first_char_vowel_or_consonant_or_empty bool\n    var is_last_char_vowel_or_consonant_or_empty\
    \ bool\n    var is_first_char_vowel_or_consonant_or_empty_or_space bool\n    var\
    \ is_last_char_vowel_or_consonant_or_empty_or_space bool\n    var is_first_char_vowel_or_consonant_or_empty_or_space_or_number\
    \ bool\n    var is_last_char_vowel_or_consonant_or_empty_or_space_or_number bool\n\
    \    var is_first_char_vowel_or_consonant_or_empty_or_space_or_number_or_symbol\
    \ bool\n    var is_last_char_vowel_or_consonant_or_empty_or_space_or_number_or_\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplw2jo2tk_test.go:41:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074516
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n        \
    \    if i == len(word) - 1 {\n                return \"\"\n            }\n   \
    \         if is_vowel(word[i-1]) {\n                continue\n            }\n\
    \            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwvbbry43_test.go:19:12: undefined: is_vowel

    /tmp/tmpwvbbry43_test.go:23:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074517
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var prev_char string\n    var prev_prev_char string\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n  \
    \          if prev_char != \"\" && !vowels[prev_char] {\n                return\
    \ string(word[i])\n            }\n        } else {\n            if prev_char !=\
    \ \"\" && vowels[prev_char] {\n                return prev_char\n            }\n\
    \        }\n        prev_prev_char = prev_char\n        prev_char = string(word[i])\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpghf_dbvo_test.go:23:9: prev_prev_char declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074517
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var prev_vowel string\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if vowels[string(word[i])] {\n            prev_vowel = string(word[i])\n\
    \            break\n        }\n    }\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if prev_vowel != string(word[i])\
    \ {\n                return string(word[i])\n            }\n        } else {\n\
    \            prev_vowel = \"\"\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpd8g63v2t_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpd8g63v2t_test.go:66: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpd8g63v2t_test.go:66: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpd8g63v2t_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpd8g63v2t_test.go:66: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n    \
    \    tmpd8g63v2t_test.go:66: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074518
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant_index int\n    var last_vowel_index int\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            last_vowel_index = i\n        } else {\n            if last_vowel_index\
    \ > last_consonant_index {\n                return string(word[last_vowel_index])\n\
    \            }\n            last_consonant_index = i\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpylu50bqt_test.go:62: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpylu50bqt_test.go:62: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpylu50bqt_test.go:62: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpylu50bqt_test.go:62: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpylu50bqt_test.go:62: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpylu50bqt_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpylu50bqt_test.go:62: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpylu50bqt_test.go:62:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpylu50bqt_test.go:62: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074518
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n \
    \           if i == len(word) - 1 {\n                return \"\"\n           \
    \ }\n            if !is_vowel(word[i + 1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppee8g29q_test.go:15:5: vowels declared but not used

    /tmp/tmppee8g29q_test.go:17:12: undefined: is_vowel

    /tmp/tmppee8g29q_test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074517
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var distance int\n    var min_distance int = len(word)\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                if i == len(word) - 1 {\n \
    \                   return \"\"\n                }\n                if i == 0\
    \ {\n                    return \"\"\n                }\n                for j\
    \ := i - 1; j >= 0; j-- {\n                    for _, v := range vowels {\n  \
    \                      if word[j] == v[0] {\n                            return\
    \ \"\"\n                        }\n                    }\n                   \
    \ distance = i - j\n                    if distance < min_distance {\n       \
    \                 min_distance = distance\n                        result = string(word[i])\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp1rvt07n__test.go:71: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1rvt07n__test.go:71:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1rvt07n__test.go:71: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074518
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var result string\n    var last_consonant_index\
    \ int\n    var last_vowel_index int\n    for i, c := range word {\n        if\
    \ contains(vowels, string(c)) {\n            last_vowel_index = i\n        }\n\
    \        if contains(consonants, string(c)) {\n            last_consonant_index\
    \ = i\n        }\n        if last_consonant_index > last_vowel_index {\n     \
    \       result = string(c)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo7me18gx_test.go:21:12: undefined: contains

    /tmp/tmpo7me18gx_test.go:24:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074517
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var result string\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            result = string(word[i])\n\
    \            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpt3crotuo_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpt3crotuo_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpt3crotuo_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpt3crotuo_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpt3crotuo_test.go:57: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpt3crotuo_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpt3crotuo_test.go:57: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpt3crotuo_test.go:57:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpt3crotuo_test.go:57: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074518
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i+1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp1uiorm4o_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1uiorm4o_test.go:60:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1uiorm4o_test.go:60: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !contains(vowels, string(word[i+1])) {\n            \
    \    return string(word[i])\n            }\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_f4r2rce_test.go:17:12: undefined: contains

    /tmp/tmp_f4r2rce_test.go:21:17: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074517
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\"a\": true, \"e\": true,\
    \ \"i\": true, \"o\": true, \"u\": true}\n    var last_vowel string\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n    \
    \        last_vowel = string(word[i])\n            break\n        }\n    }\n \
    \   for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if last_vowel != string(word[i]) {\n                return string(word[i])\n\
    \            }\n        } else {\n            last_vowel = \"\"\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpwc2eyat2_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpwc2eyat2_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpwc2eyat2_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpwc2eyat2_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpwc2eyat2_test.go:60: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n    \
    \    tmpwc2eyat2_test.go:60: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074518
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i+1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp1uiorm4o_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1uiorm4o_test.go:60:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1uiorm4o_test.go:60: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"\
    o\":1, \"u\":1}\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ == 1 {\n            if i == len(word) - 1 {\n                return \"\"\n \
    \           }\n            if vowels[string(word[i+1])] != 1 {\n             \
    \   return string(word[i])\n            }\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp6ly4xriv_test.go:54: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp6ly4xriv_test.go:54: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp6ly4xriv_test.go:54: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp6ly4xriv_test.go:54: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp6ly4xriv_test.go:54:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp6ly4xriv_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074518
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))] != -1 {\n\
    \            if i == len(word) - 1 {\n                return \"\"\n          \
    \  }\n            if vowels[strings.Index(vowels, string(word[i+1]))] == -1 {\n\
    \                return string(word[i])\n            }\n        }\n    }\n   \
    \ return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_07avzdg_test.go:17:19: undefined: strings

    /tmp/tmp_07avzdg_test.go:17:62: -1 (untyped int constant) overflows byte

    /tmp/tmp_07avzdg_test.go:21:23: undefined: strings

    /tmp/tmp_07avzdg_test.go:21:68: -1 (untyped int constant) overflows byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074518
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant_index int\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if _, ok := vowels[string(word[i])]; !ok {\n        \
    \    last_consonant_index = i\n            break\n        }\n    }\n    for i\
    \ := last_consonant_index - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            return string(word[i])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpftrxh4ys_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpftrxh4ys_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpftrxh4ys_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpftrxh4ys_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpftrxh4ys_test.go:62: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074519
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            if i ==\
    \ len(word) - 1 {\n                return \"\"\n            }\n            if\
    \ word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1]\
    \ != 'o' && word[i + 1] != 'u' {\n                return string(word[i])\n   \
    \         }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp_rndmx7y_test.go:56: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp_rndmx7y_test.go:56: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp_rndmx7y_test.go:56: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp_rndmx7y_test.go:56: expected 'i', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmp_rndmx7y_test.go:56:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074519
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) == 0 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\"\
    : true}\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if i == len(word) - 1 {\n                return \"\"\n   \
    \         }\n            if _, ok := vowels[string(word[i+1])]; !ok {\n      \
    \          return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp_8bm_p67_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp_8bm_p67_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp_8bm_p67_test.go:57: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp_8bm_p67_test.go:57: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp_8bm_p67_test.go:57:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp_8bm_p67_test.go:57: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074519
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if contains(vowels, string(word[i]))\
    \ {\n            if i == len(word) - 1 {\n                continue\n         \
    \   } else if i == 0 {\n                continue\n            } else if contains(vowels,\
    \ string(word[i-1])) {\n                continue\n            } else if contains(vowels,\
    \ string(word[i+1])) {\n                continue\n            } else {\n     \
    \           return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprvv58ion_test.go:17:12: undefined: contains

    /tmp/tmprvv58ion_test.go:22:23: undefined: contains

    /tmp/tmprvv58ion_test.go:24:23: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074519
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]int{\n        \"a\": 1,\n        \"e\": 1,\n        \"i\": 1,\n\
    \        \"o\": 1,\n        \"u\": 1,\n    }\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if _, ok := vowels[string(word[i])]; ok {\n            if\
    \ i == len(word) - 1 {\n                return \"\"\n            }\n         \
    \   if _, ok := vowels[string(word[i+1])]; !ok {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpkj00oqa4_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpkj00oqa4_test.go:63: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpkj00oqa4_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpkj00oqa4_test.go:63: expected 'i', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpkj00oqa4_test.go:63:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074519
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return string(word[i])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpsr3gcce4_test.go:51: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpsr3gcce4_test.go:51: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpsr3gcce4_test.go:51: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpsr3gcce4_test.go:51:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpsr3gcce4_test.go:51: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[rune]bool{\n        'a': true,\n    \
    \    'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n\
    \    }\n    var last_consonant rune\n    var last_vowel rune\n    for _, c :=\
    \ range word {\n        if vowels[c] {\n            last_vowel = c\n        }\
    \ else {\n            last_consonant = c\n        }\n        if last_consonant\
    \ != 0 && last_vowel != 0 {\n            return string(last_vowel)\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpqjdfdaut_test.go:62: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpqjdfdaut_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpqjdfdaut_test.go:62: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpqjdfdaut_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpqjdfdaut_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpqjdfdaut_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpqjdfdaut_test.go:62: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpqjdfdaut_test.go:62:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpqjdfdaut_test.go:62: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074519
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i < len(word) - 1 &&\
    \ !vowels[string(word[i + 1])] {\n                return string(word[i])\n   \
    \         }\n        } else {\n            if i < len(word) - 1 && vowels[string(word[i\
    \ + 1])] {\n                return string(word[i + 1])\n            }\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp8islx6h9_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp8islx6h9_test.go:55: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp8islx6h9_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp8islx6h9_test.go:55: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp8islx6h9_test.go:55: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp8islx6h9_test.go:55: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp8islx6h9_test.go:55: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp8islx6h9_test.go:55:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp8islx6h9_test.go:55: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074519
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    var last_consonant string\n    var last_vowel\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            last_vowel = string(word[i])\n        } else {\n            if\
    \ last_vowel != \"\" {\n                return last_vowel\n            }\n   \
    \         last_consonant = string(word[i])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe5xcvekb_test.go:16:9: last_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074509
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var result string\n    var last_consonant_index int\n \
    \   for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if last_consonant_index > 0 {\n                result = string(word[i])\n\
    \                break\n            }\n        } else {\n            last_consonant_index\
    \ = i\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp11h00a0k_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp11h00a0k_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp11h00a0k_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp11h00a0k_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp11h00a0k_test.go:62: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074519
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var distance int\n    var found bool\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n          \
    \  if found {\n                if i + 1 < len(word) && !is_vowel(word[i + 1])\
    \ {\n                    if distance > len(word) - i - 1 {\n                 \
    \       result = string(word[i])\n                        distance = len(word)\
    \ - i - 1\n                    }\n                }\n            } else {\n  \
    \              if i + 1 < len(word) && !is_vowel(word[i + 1]) {\n            \
    \        result = string(word[i])\n                    distance = len(word) -\
    \ i - 1\n                    found = true\n                }\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjji65oq2_test.go:15:9: vowels declared but not used

    /tmp/tmpjji65oq2_test.go:20:12: undefined: is_vowel

    /tmp/tmpjji65oq2_test.go:22:42: undefined: is_vowel

    /tmp/tmpjji65oq2_test.go:29:42: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074519
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result = \"\"\n    var last_vowel = \"\"\n    var last_consonant =\
    \ \"\"\n    for _, char := range word {\n        if contains(vowels, string(char))\
    \ {\n            last_vowel = string(char)\n        } else {\n            last_consonant\
    \ = string(char)\n        }\n        if last_vowel != \"\" && last_consonant !=\
    \ \"\" {\n            result = last_vowel\n            break\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcv_zroh8_test.go:20:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074519
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var last_consonant_index = -1\n    var last_vowel_index = -1\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels) {\n  \
    \          last_vowel_index = i\n            if last_consonant_index != -1 {\n\
    \                return string(word[last_vowel_index])\n            }\n      \
    \  } else {\n            last_consonant_index = i\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyrk2ybvk_test.go:19:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074519
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if vowels[string(word[i])] {\n            if i == len(word) - 1 {\n\
    \                return \"\"\n            }\n            if !vowels[string(word[i\
    \ + 1])] {\n                return string(word[i])\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpslosobpm_test.go:54: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpslosobpm_test.go:54: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpslosobpm_test.go:54: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpslosobpm_test.go:54: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpslosobpm_test.go:54:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpslosobpm_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074514
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]bool{\"a\": true, \"e\": true,\
    \ \"i\": true, \"o\": true, \"u\": true}\n    var consonants = map[string]bool{\"\
    b\": true, \"c\": true, \"d\": true, \"f\": true, \"g\": true, \"h\": true, \"\
    j\": true, \"k\": true, \"l\": true, \"m\": true, \"n\": true, \"p\": true, \"\
    q\": true, \"r\": true, \"s\": true, \"t\": true, \"v\": true, \"w\": true, \"\
    x\": true, \"y\": true, \"z\": true}\n    var result string\n    var found_vowel\
    \ bool\n    var found_consonant bool\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if _, ok := vowels[string(word[i])]; ok {\n            if found_consonant\
    \ {\n                result = string(word[i])\n                found_vowel = true\n\
    \                break\n            }\n        } else if _, ok := consonants[string(word[i])];\
    \ ok {\n            if found_vowel {\n                break\n            }\n \
    \           found_consonant = true\n        }\n    }\n    return result\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpmw4ghvwz_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpmw4ghvwz_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpmw4ghvwz_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpmw4ghvwz_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpmw4ghvwz_test.go:62: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074519
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n         \
    \   if i == len(word) - 1 {\n                return \"\"\n            }\n    \
    \        if !strings.Contains(vowels, string(word[i + 1])) {\n               \
    \ return string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmwilq52h_test.go:17:12: undefined: strings

    /tmp/tmpmwilq52h_test.go:21:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074519
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var result string\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i]))\
    \ {\n            if i == len(word) - 1 {\n                continue\n         \
    \   }\n            if i == 0 {\n                continue\n            }\n    \
    \        if strings.Contains(vowels, string(word[i+1])) {\n                continue\n\
    \            }\n            if strings.Contains(vowels, string(word[i-1])) {\n\
    \                continue\n            }\n            result = string(word[i])\n\
    \            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdl9f8_nn_test.go:18:12: undefined: strings

    /tmp/tmpdl9f8_nn_test.go:25:16: undefined: strings

    /tmp/tmpdl9f8_nn_test.go:28:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1,\
    \ \"o\": 1, \"u\": 1}\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ == 1 {\n            return string(word[i])\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpi5f4ehdq_test.go:49: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpi5f4ehdq_test.go:49: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpi5f4ehdq_test.go:49: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpi5f4ehdq_test.go:49: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpi5f4ehdq_test.go:49: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpi5f4ehdq_test.go:49: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpi5f4ehdq_test.go:49: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpi5f4ehdq_test.go:49:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpi5f4ehdq_test.go:49: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !is_vowel(word[i + 1], vowels) {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppzohnqsa_test.go:17:12: undefined: is_vowel

    /tmp/tmppzohnqsa_test.go:21:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i], vowels)\
    \ {\n            if i + 1 < len(word) && !is_vowel(word[i + 1], vowels) {\n  \
    \              return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6t76q046_test.go:17:12: undefined: is_vowel

    /tmp/tmp6t76q046_test.go:18:38: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var last_consonant rune\n    var last_vowel rune\n\
    \    for _, c := range word {\n        if vowels[c] {\n            last_vowel\
    \ = c\n        } else {\n            last_consonant = c\n        }\n        if\
    \ last_consonant != 0 && last_vowel != 0 {\n            return string(last_vowel)\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpty9at7r7_test.go:56: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpty9at7r7_test.go:56: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpty9at7r7_test.go:56: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpty9at7r7_test.go:56: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpty9at7r7_test.go:56: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpty9at7r7_test.go:56:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpty9at7r7_test.go:56: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant string\n    var closest_vowel string\n\
    \    var closest_vowel_distance int\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if vowels[string(word[i])] {\n            if last_consonant != \"\" {\n\
    \                if closest_vowel_distance == 0 || closest_vowel_distance > i\
    \ - len(last_consonant) {\n                    closest_vowel = string(word[i])\n\
    \                    closest_vowel_distance = i - len(last_consonant)\n      \
    \          }\n            }\n            last_consonant = \"\"\n        } else\
    \ {\n            last_consonant = string(word[i])\n        }\n    }\n    return\
    \ closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpysd_1dfg_test.go:66: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpysd_1dfg_test.go:66: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpysd_1dfg_test.go:66: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpysd_1dfg_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpysd_1dfg_test.go:66: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpysd_1dfg_test.go:66: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpysd_1dfg_test.go:66: expected 'i', got 'a'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant_index int\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if vowels[string(word[i])] {\n            if last_consonant_index\
    \ == 0 {\n                return \"\"\n            }\n            return string(word[last_consonant_index\
    \ + 1])\n        }\n        last_consonant_index = i\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out\
    \ of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out of\
    \ range [3] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514780,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514780, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel(...)\n\t/tmp/tmplg47tpph_test.go:28\n\
    command-line-arguments_test.TestGet_Closest_Vowel(0xc0000cc340?)\n\t/tmp/tmplg47tpph_test.go:47\
    \ +0x1c2f\ntesting.tRunner(0xc0000cc340, 0x52a0e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var last_vowel_index int = -1\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels,\
    \ string(word[i])) {\n            last_vowel_index = i\n            break\n  \
    \      }\n    }\n    if last_vowel_index == -1 {\n        return \"\"\n    }\n\
    \    for i := last_vowel_index - 1; i >= 0; i-- {\n        if !strings.Contains(vowels,\
    \ string(word[i])) {\n            return string(word[last_vowel_index])\n    \
    \    }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv34yhqz__test.go:18:12: undefined: strings

    /tmp/tmpv34yhqz__test.go:27:13: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpedaqo4b0_test.go:44: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpedaqo4b0_test.go:44: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpedaqo4b0_test.go:44: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpedaqo4b0_test.go:44:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpedaqo4b0_test.go:44: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var last_vowel string\n    var last_consonant string\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n            last_vowel =\
    \ string(word[i])\n            if last_consonant != \"\" {\n                return\
    \ last_vowel\n            }\n        } else {\n            last_consonant = string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr8ix30lu_test.go:15:9: vowels declared but not used

    /tmp/tmpr8ix30lu_test.go:19:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var distance int\n    for i := len(word) - 1; i\
    \ >= 0; i-- {\n        for _, v := range vowels {\n            if word[i] == v[0]\
    \ {\n                if distance == 0 {\n                    result = v\n    \
    \                distance = len(word) - i\n                } else if len(word)\
    \ - i < distance {\n                    result = v\n                    distance\
    \ = len(word) - i\n                }\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmprupa7a7j_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmprupa7a7j_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmprupa7a7j_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmprupa7a7j_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmprupa7a7j_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmprupa7a7j_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmprupa7a7j_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmprupa7a7j_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmprupa7a7j_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074512
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var last_consonant string\n    var last_vowel string\n   \
    \ for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])] {\n\
    \            last_vowel = string(word[i])\n        } else {\n            last_consonant\
    \ = string(word[i])\n            break\n        }\n    }\n    if last_consonant\
    \ == \"\" || last_vowel == \"\" {\n        return \"\"\n    }\n    return last_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmptnn6q4p9_test.go:63: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmptnn6q4p9_test.go:63: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmptnn6q4p9_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmptnn6q4p9_test.go:63: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmptnn6q4p9_test.go:63: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmptnn6q4p9_test.go:63: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmptnn6q4p9_test.go:63: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmptnn6q4p9_test.go:63:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmptnn6q4p9_test.go:63: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.010s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result string\n    var found bool\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        for _, v := range vowels {\n            if word[i] == v[0]\
    \ {\n                result = string(word[i])\n                found = true\n\
    \                break\n            }\n        }\n        if found {\n       \
    \     break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmppqhdgx4t_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmppqhdgx4t_test.go:58: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmppqhdgx4t_test.go:58: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmppqhdgx4t_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmppqhdgx4t_test.go:58: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmppqhdgx4t_test.go:58: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmppqhdgx4t_test.go:58: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmppqhdgx4t_test.go:58:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppqhdgx4t_test.go:58: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) == 0 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if is_vowel(word[i], vowels) {\n            if i == len(word)\
    \ - 1 {\n                return \"\"\n            }\n            if !is_vowel(word[i\
    \ + 1], vowels) {\n                return string(word[i])\n            }\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmdpyw_yf_test.go:20:12: undefined: is_vowel

    /tmp/tmpmdpyw_yf_test.go:24:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074516
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if is_vowel(word[i], vowels) {\n            if i == len(word)\
    \ - 1 {\n                return \"\"\n            }\n            if is_vowel(word[i\
    \ + 1], vowels) {\n                continue\n            }\n            return\
    \ string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptdejd0n3_test.go:20:12: undefined: is_vowel

    /tmp/tmptdejd0n3_test.go:24:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074520
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var last_vowel string\n    var last_consonant string\n    for _, char :=\
    \ range word {\n        if is_vowel(char) {\n            last_vowel = string(char)\n\
    \        } else {\n            last_consonant = string(char)\n        }\n    \
    \    if last_vowel != \"\" && last_consonant != \"\" {\n            return last_vowel\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvs82a950_test.go:15:5: vowels declared but not used

    /tmp/tmpvs82a950_test.go:19:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\"\
    : true}\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i + 1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpbyncjjil_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpbyncjjil_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpbyncjjil_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpbyncjjil_test.go:57: expected 'i', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpbyncjjil_test.go:57:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    cons := []string{\"b\",\
    \ \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        if is_cons(word[i], cons) {\n        \
    \    for j := i - 1; j >= 0; j-- {\n                if is_cons(word[j], cons)\
    \ {\n                    return word[j+1:i]\n                }\n            }\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc_aecpp9_test.go:18:5: vowels declared but not used

    /tmp/tmpc_aecpp9_test.go:21:12: undefined: is_cons

    /tmp/tmpc_aecpp9_test.go:23:20: undefined: is_cons

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    last_consonant := -1\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if vowels[string(word[i])] {\n            if last_consonant ==\
    \ -1 {\n                return \"\"\n            }\n            return string(word[i])\n\
    \        }\n        last_consonant = i\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpilk3zcgr_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpilk3zcgr_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpilk3zcgr_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpilk3zcgr_test.go:60: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpilk3zcgr_test.go:60:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpilk3zcgr_test.go:60: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\"\
    : true}\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i+1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp5kcvaxnu_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp5kcvaxnu_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp5kcvaxnu_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp5kcvaxnu_test.go:57: expected 'i', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmp5kcvaxnu_test.go:57:\
    \ expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var last_vowel string\n    for i := len(word) - 1; i >= 0; i-- {\n    \
    \    for _, v := range vowels {\n            if word[i] == v[0] {\n          \
    \      last_vowel = string(word[i])\n                break\n            }\n  \
    \      }\n        if last_vowel != \"\" {\n            break\n        }\n    }\n\
    \    if last_vowel == \"\" {\n        return \"\"\n    }\n    var closest_vowel\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == last_vowel[0]\
    \ {\n            closest_vowel = string(word[i])\n            break\n        }\n\
    \    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp2as68thz_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp2as68thz_test.go:66: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp2as68thz_test.go:66: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp2as68thz_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp2as68thz_test.go:66: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp2as68thz_test.go:66: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp2as68thz_test.go:66: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp2as68thz_test.go:66:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp2as68thz_test.go:66: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if string_in_slice(word[i:i+1],\
    \ vowels) {\n            return word[i:i+1]\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_9wtovsj_test.go:17:12: undefined: string_in_slice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            if i == len(word) - 1 {\n                return \"\"\n      \
    \      }\n            if !vowels[string(word[i+1])] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp1uiorm4o_test.go:60: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp1uiorm4o_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp1uiorm4o_test.go:60: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1uiorm4o_test.go:60:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1uiorm4o_test.go:60: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074510
