language: go_test.go
name: HumanEval_158_find_max
results:
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_unique := 0\n    for _, word := range words {\n\
    \        unique := 0\n        for i := 0; i < len(word); i++ {\n            for\
    \ j := i + 1; j < len(word); j++ {\n                if word[i] == word[j] {\n\
    \                    break\n                }\n                if j == len(word)\
    \ - 1 {\n                    unique++\n                }\n            }\n    \
    \    }\n        if unique > max_unique {\n            max_unique = unique\n  \
    \          max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpwihxn803_test.go:57: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpwihxn803_test.go:57: expected\
    \ 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpwihxn803_test.go:57:\
    \ expected 'footbott', got 'play'\n    --- FAIL: TestFind_Max/test_num__8 (0.00s)\n\
    \        tmpwihxn803_test.go:57: expected 'b', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix6wxscs_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp751q886o_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp751q886o_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := count_unique(word)\n        if count > max_count {\n       \
    \     max_count = count\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvnkf20mx_test.go:16:18: undefined: count_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  for j := i + 1; j < len(word); j++ {\n                if word[i] == word[j]\
    \ {\n                    break\n                }\n                if j == len(word)\
    \ - 1 {\n                    count++\n                }\n            }\n     \
    \   }\n        if count > max_count {\n            max_count = count\n       \
    \     max_word = word\n        } else if count == max_count {\n            if\
    \ word < max_word {\n                max_word = word\n            }\n        }\n\
    \    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__2\
    \ (0.00s)\n        tmp9mi6_ghq_test.go:61: expected 'aaaaaaa', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__8 (0.00s)\n        tmp9mi6_ghq_test.go:61: expected\
    \ 'b', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix6wxscs_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_len := 0\n    for _, word := range words {\n    \
    \    if len(word) > max_len {\n            max_word = word\n            max_len\
    \ = len(word)\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpp2j9bytz_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            for j\
    \ := i + 1; j < len(word); j++ {\n                if word[i] == word[j] {\n  \
    \                  break\n                }\n            }\n            if j ==\
    \ len(word) {\n                count++\n            }\n        }\n        if count\
    \ > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_9dh0cbt_test.go:23:16: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnjn__rz2_test.go:17:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      if len(word) > max_count {\n            max_count = len(word)\n       \
    \     max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpp1mb7zke_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max := 0\n    max_word := \"\"\n    for _, word := range words {\n        if\
    \ len(unique_chars(word)) > max {\n            max = len(unique_chars(word))\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4o_m_po0_test.go:16:16: undefined: unique_chars

    /tmp/tmp4o_m_po0_test.go:17:23: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := make(map[rune]int)\n        for _, c := range word {\n \
    \           count[c]++\n        }\n        if len(count) > max_count {\n     \
    \       max_count = len(count)\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpu6_z3wuy_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpu6_z3wuy_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_unique_chars int\n\n    for _, word := range\
    \ words {\n        unique_chars := make(map[rune]bool)\n        for _, char :=\
    \ range word {\n            unique_chars[char] = true\n        }\n        if len(unique_chars)\
    \ > max_unique_chars {\n            max_unique_chars = len(unique_chars)\n   \
    \         max_word = word\n        }\n    }\n\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpbgyryey9_test.go:52: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpbgyryey9_test.go:52: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max := 0\n    max_word := \"\"\n    for _, word := range words {\n        unique\
    \ := make(map[rune]bool)\n        for _, c := range word {\n            unique[c]\
    \ = true\n        }\n        if len(unique) > max {\n            max = len(unique)\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpkvwsz_y__test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpkvwsz_y__test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        if len(word) > max_count {\n            max_count = len(word)\n \
    \           max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpbfucta7d_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp092jroh3_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                count++\n            } else {\n                if\
    \ word[i] != word[i-1] {\n                    count++\n                }\n   \
    \         }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if strings.Count(word,\
    \ string(c)) == 1 {\n                count++\n            }\n        }\n     \
    \   if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgbkh0ufz_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if strings.Count(word,\
    \ string(c)) == 1 {\n                count++\n            }\n        }\n     \
    \   if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgbkh0ufz_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      unique_count := 0\n        for _, char := range word {\n            if\
    \ !strings.Contains(max_word, string(char)) {\n                unique_count++\n\
    \            }\n        }\n        if unique_count > max_count {\n           \
    \ max_count = unique_count\n            max_word = word\n        }\n    }\n  \
    \  return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy3bool9e_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := make(map[rune]bool)\n        for _, c := range word {\n\
    \            count[c] = true\n        }\n        if len(count) > max_count {\n\
    \            max_count = len(count)\n            max_word = word\n        }\n\
    \    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpxfrau2md_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpxfrau2md_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                count++\n            } else {\n                if\
    \ word[i] != word[i-1] {\n                    count++\n                }\n   \
    \         }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_unique := 0\n    for _, word := range words {\n \
    \       unique := 0\n        for _, char := range word {\n            if strings.Count(word,\
    \ string(char)) == 1 {\n                unique += 1\n            }\n        }\n\
    \        if unique > max_unique {\n            max_unique = unique\n         \
    \   max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptgwed5bs_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.ContainsRune(max_word,\
    \ char) {\n                count++\n            }\n        }\n        if count\
    \ > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpydo6uhoa_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                count++\n            } else {\n                if\
    \ word[i] != word[i-1] {\n                    count++\n                }\n   \
    \         }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        seen := make(map[rune]bool)\n        for _, c := range\
    \ word {\n            if !seen[c] {\n                count++\n               \
    \ seen[c] = true\n            }\n        }\n        if count > max_count {\n \
    \           max_count = count\n            max_word = word\n        } else if\
    \ count == max_count && word < max_word {\n            max_word = word\n     \
    \   }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp436e2lz__test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp092jroh3_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      if len(word) > max_count {\n            max_count = len(word)\n       \
    \     max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpp1mb7zke_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := count_unique(word)\n        if count > max_count {\n       \
    \     max_count = count\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvnkf20mx_test.go:16:18: undefined: count_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max := 0\n    max_word := \"\"\n    for _, word := range words {\n        unique\
    \ := make(map[rune]bool)\n        for _, c := range word {\n            unique[c]\
    \ = true\n        }\n        if len(unique) > max {\n            max = len(unique)\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpkvwsz_y__test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpkvwsz_y__test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.ContainsRune(max_word,\
    \ char) {\n                count++\n            }\n        }\n        if count\
    \ > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpydo6uhoa_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix6wxscs_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      unique_count := 0\n        for i := 0; i < len(word); i++ {\n         \
    \   if i == 0 {\n                unique_count++\n            } else {\n      \
    \          if word[i] != word[i-1] {\n                    unique_count++\n   \
    \             }\n            }\n        }\n        if unique_count > max_count\
    \ {\n            max_count = unique_count\n            max_word = word\n     \
    \   } else if unique_count == max_count {\n            if word < max_word {\n\
    \                max_word = word\n            }\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074324
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max := 0\n    max_word := \"\"\n    for _, word := range words {\n        unique\
    \ := make(map[rune]bool)\n        for _, c := range word {\n            unique[c]\
    \ = true\n        }\n        if len(unique) > max {\n            max = len(unique)\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpkvwsz_y__test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpkvwsz_y__test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            for j\
    \ := i + 1; j < len(word); j++ {\n                if word[i] == word[j] {\n  \
    \                  break\n                }\n            }\n            if j ==\
    \ len(word) {\n                count++\n            }\n        }\n        if count\
    \ > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_9dh0cbt_test.go:23:16: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, c := range word {\n            if strings.Count(word,\
    \ string(c)) == 1 {\n                count += 1\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb350w7rm_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, c := range word {\n            if c >=\
    \ 'a' && c <= 'z' {\n                count++\n            }\n        }\n     \
    \   if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp3cs2yn2o_test.go:52: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074324
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                count++\n            } else {\n                if\
    \ word[i] != word[i-1] {\n                    count++\n                }\n   \
    \         }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      unique_count := 0\n        for _, char := range word {\n            if\
    \ strings.Count(word, string(char)) == 1 {\n                unique_count++\n \
    \           }\n        }\n        if unique_count > max_count {\n            max_count\
    \ = unique_count\n            max_word = word\n        }\n    }\n    return max_word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5vz0_8m7_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      if len(word) > max_count {\n            max_count = len(word)\n       \
    \     max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpp1mb7zke_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_unique := 0\n    for _, word := range words {\n\
    \        unique := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                unique++\n            } else {\n                found\
    \ := false\n                for j := 0; j < i; j++ {\n                    if word[i]\
    \ == word[j] {\n                        found = true\n                       \
    \ break\n                    }\n                }\n                if !found {\n\
    \                    unique++\n                }\n            }\n        }\n \
    \       if unique > max_unique {\n            max_unique = unique\n          \
    \  max_word = word\n        } else if unique == max_unique {\n            if word\
    \ < max_word {\n                max_word = word\n            }\n        }\n  \
    \  }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := make(map[rune]int)\n        for _, char := range word {\n  \
    \          count[char]++\n        }\n        if len(count) > max_count {\n   \
    \         max_count = len(count)\n            max_word = word\n        }\n   \
    \ }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp4wq1w3vq_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp4wq1w3vq_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.Contains(max_word,\
    \ string(c)) {\n                count++\n            }\n        }\n        if\
    \ count > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdirnmbtw_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix6wxscs_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_count := 0\n    max_word := \"\"\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074325
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  for j := i + 1; j < len(word); j++ {\n                if word[i] == word[j]\
    \ {\n                    break\n                }\n                if j == len(word)\
    \ - 1 {\n                    count++\n                }\n            }\n     \
    \   }\n        if count > max_count {\n            max_count = count\n       \
    \     max_word = word\n        } else if count == max_count {\n            if\
    \ word < max_word {\n                max_word = word\n            }\n        }\n\
    \    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__2\
    \ (0.00s)\n        tmp9mi6_ghq_test.go:61: expected 'aaaaaaa', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__8 (0.00s)\n        tmp9mi6_ghq_test.go:61: expected\
    \ 'b', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := count_unique(word)\n        if count > max_count {\n       \
    \     max_count = count\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvnkf20mx_test.go:16:18: undefined: count_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max := 0\n    max_word := \"\"\n    for _, word := range words {\n        if\
    \ len(word) > max {\n            max = len(word)\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp7t1lck6l_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_unique_chars int\n    for _, word := range\
    \ words {\n        unique_chars := make(map[rune]bool)\n        for _, char :=\
    \ range word {\n            unique_chars[char] = true\n        }\n        if len(unique_chars)\
    \ > max_unique_chars {\n            max_unique_chars = len(unique_chars)\n   \
    \         max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmppw8y6k9i_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmppw8y6k9i_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            found\
    \ := false\n            for j := 0; j < i; j++ {\n                if word[i] ==\
    \ word[j] {\n                    found = true\n                    break\n   \
    \             }\n            }\n            if !found {\n                count++\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        }\n    }\n    return max_word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpb5ll41p2_test.go:59: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpb5ll41p2_test.go:59: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      unique_count := 0\n        for _, char := range word {\n            if\
    \ !strings.Contains(max_word, string(char)) {\n                unique_count +=\
    \ 1\n            }\n        }\n        if unique_count > max_count {\n       \
    \     max_count = unique_count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps4t90_jg_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      if len(word) > len(max_word) {\n            max_word = word\n         \
    \   max_count = len(unique_chars(word))\n        } else if len(word) == len(max_word)\
    \ {\n            if len(unique_chars(word)) > max_count {\n                max_word\
    \ = word\n                max_count = len(unique_chars(word))\n            }\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8h368qa__test.go:18:29: undefined: unique_chars

    /tmp/tmp8h368qa__test.go:20:20: undefined: unique_chars

    /tmp/tmp8h368qa__test.go:22:33: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_unique := 0\n    for _, word := range words {\n \
    \       unique := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                unique++\n            } else {\n                found\
    \ := false\n                for j := 0; j < i; j++ {\n                    if word[i]\
    \ == word[j] {\n                        found = true\n                       \
    \ break\n                    }\n                }\n                if !found {\n\
    \                    unique++\n                }\n            }\n        }\n \
    \       if unique > max_unique {\n            max_unique = unique\n          \
    \  max_word = word\n        } else if unique == max_unique {\n            if word\
    \ < max_word {\n                max_word = word\n            }\n        }\n  \
    \  }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074325
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := count_unique(word)\n        if count > max_count {\n         \
    \   max_count = count\n            max_word = word\n        } else if count ==\
    \ max_count && word < max_word {\n            max_word = word\n        }\n   \
    \ }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdqv4cmcy_test.go:16:18: undefined: count_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  if len(words) == 0 {\n        return \"\"\n    }\n\n    max_word := words[0]\n\
    \    max_count := count_unique_chars(max_word)\n\n    for _, word := range words[1:]\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_word = word\n            max_count = count\n        } else if\
    \ count == max_count && word < max_word {\n            max_word = word\n     \
    \   }\n    }\n\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbnp0hmk0_test.go:18:18: undefined: count_unique_chars

    /tmp/tmpbnp0hmk0_test.go:21:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                count++\n            } else {\n                found\
    \ := false\n                for j := 0; j < i; j++ {\n                    if word[i]\
    \ == word[j] {\n                        found = true\n                       \
    \ break\n                    }\n                }\n                if !found {\n\
    \                    count++\n                }\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        } else if count == max_count {\n            if word < max_word\
    \ {\n                max_word = word\n            }\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max string\n    var max_count int\n    for _, word := range words {\n \
    \       count := count_unique(word)\n        if count > max_count {\n        \
    \    max = word\n            max_count = count\n        }\n    }\n    return max\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj2rwqipo_test.go:16:18: undefined: count_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_len int\n    for _, word := range words {\n\
    \        if len(word) > max_len {\n            max_word = word\n            max_len\
    \ = len(word)\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpr7iz8hky_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, char := range word {\n            if !strings.ContainsRune(max_word,\
    \ char) {\n                count++\n            }\n        }\n        if count\
    \ > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkgw9i4z4_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        unique_chars := make(map[rune]bool)\n        for _, char := range\
    \ word {\n            unique_chars[char] = true\n        }\n        if len(unique_chars)\
    \ > max_count {\n            max_count = len(unique_chars)\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpdfm9zilb_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpdfm9zilb_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                found\
    \ := false\n                for j := 0; j < i; j++ {\n                    if word[i]\
    \ == word[j] {\n                        found = true\n                       \
    \ break\n                    }\n                }\n                if !found {\n\
    \                    count++\n                }\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        } else if count == max_count {\n            if word < max_word\
    \ {\n                max_word = word\n            }\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := make(map[rune]int)\n        for _, c := range word {\n \
    \           count[c]++\n        }\n        if len(count) > max_count {\n     \
    \       max_count = len(count)\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpu6_z3wuy_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpu6_z3wuy_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        seen := make(map[rune]bool)\n        for _, r := range\
    \ word {\n            if !seen[r] {\n                count++\n               \
    \ seen[r] = true\n            }\n        }\n        if count > max_count {\n \
    \           max_count = count\n            max_word = word\n        } else if\
    \ count == max_count && word < max_word {\n            max_word = word\n     \
    \   }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  if len(words) == 0 {\n        return \"\"\n    }\n\n    max_word := words[0]\n\
    \    max_count := 0\n    for _, word := range words {\n        count := 0\n  \
    \      for i := 0; i < len(word); i++ {\n            if i == 0 {\n           \
    \     count++\n            } else {\n                if word[i] != word[i-1] {\n\
    \                    count++\n                }\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpcrby7vpo_test.go:60: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, char := range word {\n            if !strings.ContainsRune(max_word,\
    \ char) {\n                count++\n            }\n        }\n        if count\
    \ > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkgw9i4z4_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  found := false\n                for j := 0; j < i; j++ {\n                \
    \    if word[i] == word[j] {\n                        found = true\n         \
    \               break\n                    }\n                }\n            \
    \    if !found {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max := 0\n    max_word := \"\"\n    for _, word := range words {\n        if\
    \ len(unique_chars(word)) > max {\n            max = len(unique_chars(word))\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4o_m_po0_test.go:16:16: undefined: unique_chars

    /tmp/tmp4o_m_po0_test.go:17:23: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_count := 0\n    max_word := \"\"\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.ContainsRune(max_word,\
    \ char) {\n                count++\n            }\n        }\n        if count\
    \ > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7q11hpn2_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, char := range word {\n            if !strings.ContainsRune(max_word,\
    \ char) {\n                count++\n            }\n        }\n        if count\
    \ > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkgw9i4z4_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := count_unique(word)\n        if count > max_count {\n       \
    \     max_count = count\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvnkf20mx_test.go:16:18: undefined: count_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix6wxscs_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix6wxscs_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := count_unique(word)\n        if count > max_count {\n         \
    \   max_count = count\n            max_word = word\n        } else if count ==\
    \ max_count && word < max_word {\n            max_word = word\n        }\n   \
    \ }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdqv4cmcy_test.go:16:18: undefined: count_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, c := range word {\n            if strings.Count(word,\
    \ string(c)) == 1 {\n                count += 1\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb350w7rm_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix6wxscs_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.Contains(max_word,\
    \ string(c)) {\n                count++\n            }\n        }\n        if\
    \ count > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdirnmbtw_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        if len(word) > max_count {\n            max_count = len(word)\n     \
    \       max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpl0p5t6tc_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        if len(word) > max_count {\n            max_count = len(word)\n     \
    \       max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpl0p5t6tc_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := make(map[rune]int)\n        for _, c := range word {\n \
    \           count[c]++\n        }\n        if len(count) > max_count {\n     \
    \       max_count = len(count)\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpu6_z3wuy_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpu6_z3wuy_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.Contains(max_word,\
    \ string(c)) {\n                count++\n            }\n        }\n        if\
    \ count > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdirnmbtw_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            count += 1\n\
    \        }\n        if count > max_count {\n            max_count = count\n  \
    \          max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprgmlj4yg_test.go:17:16: c declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  if len(words) == 0 {\n        return \"\"\n    }\n\n    max_word := words[0]\n\
    \    max_count := 0\n    for _, word := range words {\n        count := 0\n  \
    \      for _, c := range word {\n            if !strings.Contains(max_word, string(c))\
    \ {\n                count++\n            }\n        }\n        if count > max_count\
    \ {\n            max_count = count\n            max_word = word\n        }\n \
    \   }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0zfw1hak_test.go:22:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                count++\n            } else {\n                if\
    \ word[i] != word[i-1] {\n                    count++\n                }\n   \
    \         }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        unique_chars := make(map[rune]bool)\n        for _, char := range\
    \ word {\n            unique_chars[char] = true\n        }\n        if len(unique_chars)\
    \ > max_count {\n            max_count = len(unique_chars)\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpdfm9zilb_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpdfm9zilb_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  if len(words) == 0 {\n        return \"\"\n    }\n\n    max_word := words[0]\n\
    \    max_count := 0\n    for _, word := range words {\n        count := 0\n  \
    \      for i := 0; i < len(word); i++ {\n            if i == 0 {\n           \
    \     count++\n            } else {\n                if word[i] != word[i-1] {\n\
    \                    count++\n                }\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpcrby7vpo_test.go:60: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count += 1\n            }\n        }\n    \
    \    if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk5pu7f0e_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    var max_index int\n    for\
    \ i, word := range words {\n        count := len(unique_chars(word))\n       \
    \ if count > max_count {\n            max_word = word\n            max_count =\
    \ count\n            max_index = i\n        } else if count == max_count {\n \
    \           if word < max_word {\n                max_word = word\n          \
    \      max_index = i\n            }\n        }\n    }\n    return words[max_index]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpra_1sv5__test.go:17:22: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      if len(word) > max_count {\n            max_count = len(word)\n       \
    \     max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpp1mb7zke_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        chars := make(map[rune]bool)\n        for _,\
    \ char := range word {\n            if _, ok := chars[char]; !ok {\n         \
    \       chars[char] = true\n                count++\n            }\n        }\n\
    \        if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        } else if count == max_count && word < max_word {\n        \
    \    max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.Contains(max_word,\
    \ string(c)) {\n                count++\n            }\n        }\n        if\
    \ count > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdirnmbtw_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := make(map[rune]int)\n        for _, c := range word {\n     \
    \       count[c]++\n        }\n        if len(count) > max_count {\n         \
    \   max_count = len(count)\n            max_word = word\n        }\n    }\n  \
    \  return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpnboqupve_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpnboqupve_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            for\
    \ j := i + 1; j < len(word); j++ {\n                if word[i] == word[j] {\n\
    \                    break\n                }\n            }\n            if j\
    \ == len(word) {\n                count++\n            }\n        }\n        if\
    \ count > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcovd57rb_test.go:23:16: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        unique_count := 0\n        for _, char := range word {\n        \
    \    if !strings.Contains(max_word, string(char)) {\n                unique_count++\n\
    \            }\n        }\n        if unique_count > max_count {\n           \
    \ max_count = unique_count\n            max_word = word\n        }\n    }\n  \
    \  return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv_ktbw54_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_unique := 0\n    for _, word := range words {\n \
    \       unique := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                unique++\n            } else {\n                if\
    \ word[i] != word[i-1] {\n                    unique++\n                }\n  \
    \          }\n        }\n        if unique > max_unique {\n            max_unique\
    \ = unique\n            max_word = word\n        } else if unique == max_unique\
    \ {\n            if word < max_word {\n                max_word = word\n     \
    \       }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                count++\n            } else {\n                if\
    \ word[i] != word[i-1] {\n                    count++\n                }\n   \
    \         }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := make(map[rune]bool)\n        for _, c := range word {\n\
    \            count[c] = true\n        }\n        if len(count) > max_count {\n\
    \            max_count = len(count)\n            max_word = word\n        }\n\
    \    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpxfrau2md_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpxfrau2md_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp092jroh3_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if strings.Count(word,\
    \ string(c)) == 1 {\n                count++\n            }\n        }\n     \
    \   if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgbkh0ufz_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp436e2lz__test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max := 0\n    max_word := \"\"\n    for _, word := range words {\n        unique\
    \ := make(map[rune]int)\n        for _, c := range word {\n            unique[c]\
    \ = 1\n        }\n        if len(unique) > max {\n            max = len(unique)\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp9fuhzaxc_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp9fuhzaxc_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, char := range word {\n            if strings.Count(word,\
    \ string(char)) == 1 {\n                count++\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgdjfsfvf_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp751q886o_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := 0\n        for i := 0; i < len(word); i++ {\n            if\
    \ i == 0 {\n                count++\n            } else {\n                if\
    \ word[i] != word[i-1] {\n                    count++\n                }\n   \
    \         }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := make(map[rune]int)\n        for _, c := range word {\n \
    \           count[c]++\n        }\n        if len(count) > max_count {\n     \
    \       max_count = len(count)\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpu6_z3wuy_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpu6_z3wuy_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if strings.Count(word,\
    \ string(c)) == 1 {\n                count++\n            }\n        }\n     \
    \   if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgbkh0ufz_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for _, c := range word {\n            if !strings.ContainsRune(max_word,\
    \ c) {\n                count++\n            }\n        }\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp751q886o_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      if len(word) > max_count {\n            max_count = len(word)\n       \
    \     max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpp1mb7zke_test.go:46: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := count_unique(word)\n        if count > max_count {\n         \
    \   max_count = count\n            max_word = word\n        } else if count ==\
    \ max_count && word < max_word {\n            max_word = word\n        }\n   \
    \ }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdqv4cmcy_test.go:16:18: undefined: count_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    max_count := 0\n    for _, word := range words {\n\
    \        count := len(unique_chars(word))\n        if count > max_count {\n  \
    \          max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpol7qc93p_test.go:16:22: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := make(map[rune]bool)\n        for _, c := range word {\n\
    \            count[c] = true\n        }\n        if len(count) > max_count {\n\
    \            max_count = len(count)\n            max_word = word\n        }\n\
    \    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpxfrau2md_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpxfrau2md_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if !strings.Contains(max_word,\
    \ string(c)) {\n                count++\n            }\n        }\n        if\
    \ count > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdirnmbtw_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := count_unique_chars(word)\n        if count > max_count {\n\
    \            max_count = count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaotk43jl_test.go:16:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  var max_word string\n    var max_count int\n    for _, word := range words\
    \ {\n        count := 0\n        for i := 0; i < len(word); i++ {\n          \
    \  if i == 0 {\n                count++\n            } else {\n              \
    \  if word[i] != word[i-1] {\n                    count++\n                }\n\
    \            }\n        }\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count {\n\
    \            if word < max_word {\n                max_word = word\n         \
    \   }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      unique_chars := make(map[rune]bool)\n        for _, char := range word\
    \ {\n            unique_chars[char] = true\n        }\n        if len(unique_chars)\
    \ > max_count {\n            max_count = len(unique_chars)\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp_m0w2_mw_test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp_m0w2_mw_test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if strings.Count(word,\
    \ string(char)) == 1 {\n                count++\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1gjpu_m_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                count++\n            }\n        }\n       \
    \ if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbqvgeiwn_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max := 0\n    max_word := \"\"\n    for _, word := range words {\n        unique\
    \ := make(map[rune]bool)\n        for _, c := range word {\n            unique[c]\
    \ = true\n        }\n        if len(unique) > max {\n            max = len(unique)\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpkvwsz_y__test.go:50: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpkvwsz_y__test.go:50: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for i := 0; i < len(word); i++ {\n            if i\
    \ == 0 {\n                count++\n            } else {\n                if word[i]\
    \ != word[i-1] {\n                    count++\n                }\n           \
    \ }\n        }\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        } else if count == max_count {\n       \
    \     if word < max_word {\n                max_word = word\n            }\n \
    \       }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_unique := 0\n    for _, word := range words {\n \
    \       unique := 0\n        for _, char := range word {\n            if !strings.Contains(max_word,\
    \ string(char)) {\n                unique++\n            }\n        }\n      \
    \  if unique > max_unique {\n            max_unique = unique\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp918szemx_test.go:18:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if strings.Count(word,\
    \ string(c)) == 1 {\n                count += 1\n            }\n        }\n  \
    \      if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmi6l7v6_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\nfunc find_max(words []string) string {\n  \
    \  max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n  \
    \      count := 0\n        for _, c := range word {\n            if strings.Index(max_word,\
    \ string(c)) == -1 {\n                count++\n            }\n        }\n    \
    \    if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwixzt51f_test.go:18:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
