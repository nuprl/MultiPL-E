language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    var result []interface{}\n    if p1 < p2 {\n   \
    \     for i := p1 + 1; i < p2; i++ {\n            result = append(result, planets[i])\n\
    \        }\n    } else {\n        for i := p2 + 1; i < p1; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    }\n    return result\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmphpv3aukh_test.go:64: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmphpv3aukh_test.go:64: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6iyo4lie_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var p1, p2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            p1 = i\n        }\n\
    \        if p == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return res\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpec3zj1k1_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpec3zj1k1_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2haz3970_test.go:35:19: cannot use planets[p1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpyib8f1ll_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpyib8f1ll_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var p1, p2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            p1 = i\n        }\n\
    \        if p == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return res\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp1zsboi30_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp1zsboi30_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, p := range\
    \ planets {\n        if p == planet1 {\n            planet1Index = i\n       \
    \ }\n        if p == planet2 {\n            planet2Index = i\n        }\n    }\n\
    \    if planet1Index == 0 || planet2Index == 0 {\n        return []interface{}{}\n\
    \    }\n    if planet1Index > planet2Index {\n        planet1Index, planet2Index\
    \ = planet2Index, planet1Index\n    }\n    return planets[planet1Index:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnllvbrgi_test.go:35:19: cannot use planets[planet1Index:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptb3h6pkj_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var i1, i2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ 0 || i2 == 0 {\n        return res\n    }\n    if i1 > i2 {\n        i1, i2\
    \ = i2, i1\n    }\n    for i := i1 + 1; i < i2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0nbmt55g_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0nbmt55g_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwshb5pqq_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwshb5pqq_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    var res []interface{}\n    if p1 > p2\
    \ {\n        for i := p2; i <= p1; i++ {\n            res = append(res, planets[i])\n\
    \        }\n    } else {\n        for i := p1; i <= p2; i++ {\n            res\
    \ = append(res, planets[i])\n        }\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpb_d0zmhp_test.go:61: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpb_d0zmhp_test.go:61:\
    \ expected '[Venus]', got '[Mercury Venus Earth]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpb_d0zmhp_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL:\
    \ TestBf/test_num__3 (0.00s)\n        tmpb_d0zmhp_test.go:61: expected '[Earth\
    \ Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter Saturn Uranus Neptune]'\n\
    \    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpb_d0zmhp_test.go:61: expected\
    \ '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpb_d0zmhp_test.go:61:\
    \ expected '[]', got '[Earth Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmpb_d0zmhp_test.go:61: expected '[]', got '[Mercury Venus Earth Mars\
    \ Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjzqef6q2_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return res\n    }\n    if\
    \ start > end {\n        start, end = end, start\n    }\n    for i := start +\
    \ 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp1u7o4tei_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp1u7o4tei_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjzqef6q2_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmptpkhbaz6_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmptpkhbaz6_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var i1, i2 int\n    for i, p\
    \ := range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 >\
    \ i2 {\n        i1, i2 = i2, i1\n    }\n    for i := i1 + 1; i < i2; i++ {\n \
    \       result = append(result, planets[i])\n    }\n    return result\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpig973awv_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnddsp127_test.go:35:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprlh4_teh_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprlh4_teh_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpyib8f1ll_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpyib8f1ll_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return res\n    }\n    if\
    \ start > end {\n        start, end = end, start\n    }\n    for i := start +\
    \ 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp1u7o4tei_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp1u7o4tei_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    if planet1 == planet2 {\n     \
    \   return res\n    }\n    if planet1 == \"\" || planet2 == \"\" {\n        return\
    \ res\n    }\n    var start, end int\n    for i, v := range planets {\n      \
    \  if v == planet1 {\n            start = i\n        }\n        if v == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 && end == 0 {\n\
    \        return res\n    }\n    if start > end {\n        start, end = end, start\n\
    \    }\n    for i := start + 1; i < end; i++ {\n        res = append(res, planets[i])\n\
    \    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpob_yilxn_test.go:67: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            for j := i+1; j < len(planets); j++ {\n\
    \                if planets[j] == planet2 {\n                    result = append(result,\
    \ planets[i+1:j]...)\n                    return result\n                }\n \
    \           }\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqrk04zyq_test.go:25:52: cannot use planets[i + 1:j] (value of type []string)
    as type []interface{} in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp3_2n_57k_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp3_2n_57k_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 && end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpq_nw4epl_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            index1 = i\n        }\n        if p ==\
    \ planet2 {\n            index2 = i\n        }\n    }\n    if index1 == 0 || index2\
    \ == 0 {\n        return []interface{}{}\n    }\n    if index1 > index2 {\n  \
    \      index1, index2 = index2, index1\n    }\n    return planets[index1+1:index2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdq20w99y_test.go:35:19: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprlh4_teh_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpyib8f1ll_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpyib8f1ll_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var i1, i2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ 0 || i2 == 0 {\n        return res\n    }\n    if i1 > i2 {\n        i1, i2\
    \ = i2, i1\n    }\n    for i := i1 + 1; i < i2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0nbmt55g_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0nbmt55g_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 && end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpq_nw4epl_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp6te71sym_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjzqef6q2_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprlh4_teh_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    var result []interface{}\n    for i, v\
    \ := range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return result\n    }\n    if p1 > p2 {\n        p1,\
    \ p2 = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmplia38fvz_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmplia38fvz_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var p1, p2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            p1 = i\n        }\n\
    \        if p == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return res\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    for i := p1; i <= p2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpsi7an3s2_test.go:61: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpsi7an3s2_test.go:61:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpsi7an3s2_test.go:61: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpsi7an3s2_test.go:61:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter\
    \ Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpsi7an3s2_test.go:61:\
    \ expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n   \
    \     tmpsi7an3s2_test.go:61: expected '[]', got '[Earth Mars]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6iyo4lie_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 && end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpr49ousqj_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 && end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpr49ousqj_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjzqef6q2_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var ret []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return ret\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        ret = append(ret, planets[i])\n    }\n    return ret\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp4zh54fkw_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp4zh54fkw_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6iyo4lie_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpcrnnm2po_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6iyo4lie_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planets_map = make(map[string]int)\n    for i, p := range\
    \ planets {\n        planets_map[p] = i\n    }\n    var p1 = planets_map[planet1]\n\
    \    var p2 = planets_map[planet2]\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    var result []interface{}\n    if p1 > p2 {\n   \
    \     for i := p2; i <= p1; i++ {\n            result = append(result, planets[i])\n\
    \        }\n    } else {\n        for i := p1; i <= p2; i++ {\n            result\
    \ = append(result, planets[i])\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpy7bg_64u_test.go:61: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpy7bg_64u_test.go:61:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpy7bg_64u_test.go:61: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpy7bg_64u_test.go:61:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter\
    \ Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpy7bg_64u_test.go:61:\
    \ expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n   \
    \     tmpy7bg_64u_test.go:61: expected '[]', got '[Earth Mars]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmptpkhbaz6_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var p1, p2 int\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            p1 = i\n   \
    \     }\n        if planet == planet2 {\n            p2 = i\n        }\n    }\n\
    \    if p1 == 0 || p2 == 0 {\n        return res\n    }\n    if p1 > p2 {\n  \
    \      p1, p2 = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        res\
    \ = append(res, planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpcvbe8m74_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpcvbe8m74_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 && end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpq_nw4epl_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmg03047x_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprlh4_teh_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var i1, i2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ 0 || i2 == 0 {\n        return res\n    }\n    if i1 < i2 {\n        for i :=\
    \ i1 + 1; i < i2; i++ {\n            res = append(res, planets[i])\n        }\n\
    \    } else {\n        for i := i2 + 1; i < i1; i++ {\n            res = append(res,\
    \ planets[i])\n        }\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpxa_kattd_test.go:64: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpxa_kattd_test.go:64: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    for i, p := range planets {\n \
    \       if p == planet1 {\n            for j := i + 1; j < len(planets); j++ {\n\
    \                if planets[j] == planet2 {\n                    res = append(res,\
    \ planets[i+1:j]...)\n                    return res\n                }\n    \
    \        }\n        }\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7w780sy6_test.go:25:46: cannot use planets[i + 1:j] (value of type []string)
    as type []interface{} in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    var result []interface{}\n   \
    \ for i, v := range planets {\n        if v == planet1 {\n            index1 =\
    \ i\n        }\n        if v == planet2 {\n            index2 = i\n        }\n\
    \    }\n    if index1 == 0 || index2 == 0 {\n        return result\n    }\n  \
    \  if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n    for\
    \ i := index1 + 1; i < index2; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppdkdbmtl_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppdkdbmtl_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = map[string]int{\n\
    \        \"Mercury\": 0,\n        \"Venus\": 1,\n        \"Earth\": 2,\n     \
    \   \"Mars\": 3,\n        \"Jupiter\": 4,\n        \"Saturn\": 5,\n        \"\
    Uranus\": 6,\n        \"Neptune\": 7,\n    }\n    var result []interface{}\n \
    \   if _, ok := planets[planet1]; !ok {\n        return result\n    }\n    if\
    \ _, ok := planets[planet2]; !ok {\n        return result\n    }\n    var start,\
    \ end int\n    if planets[planet1] < planets[planet2] {\n        start = planets[planet1]\n\
    \        end = planets[planet2]\n    } else {\n        start = planets[planet2]\n\
    \        end = planets[planet1]\n    }\n    for i := start + 1; i < end; i++ {\n\
    \        for k, v := range planets {\n            if v == i {\n              \
    \  result = append(result, k)\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return res\n    }\n    if\
    \ start > end {\n        start, end = end, start\n    }\n    for i := start +\
    \ 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp1u7o4tei_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp1u7o4tei_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprlh4_teh_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpegdnmaz7_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpegdnmaz7_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var i1, i2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ 0 || i2 == 0 {\n        return res\n    }\n    if i1 > i2 {\n        i1, i2\
    \ = i2, i1\n    }\n    for i := i1 + 1; i < i2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0nbmt55g_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0nbmt55g_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var p1, p2 int\n    for i, v :=\
    \ range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return res\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmph8hhemh5_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmph8hhemh5_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets []string\
    \ = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n    var result []interface{}\n    var i1, i2 int\n\
    \    for i, p := range planets {\n        if p == planet1 {\n            i1 =\
    \ i\n        }\n        if p == planet2 {\n            i2 = i\n        }\n   \
    \ }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n    }\n    for i := i1 + 1; i\
    \ < i2; i++ {\n        result = append(result, planets[i])\n    }\n    return\
    \ result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmtb10xjb_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    var\
    \ found bool\n    for i, planet := range planets {\n        if planet == planet1\
    \ {\n            start = i\n            found = true\n        }\n        if planet\
    \ == planet2 {\n            end = i\n            found = true\n        }\n   \
    \ }\n    if !found {\n        return result\n    }\n    if start > end {\n   \
    \     start, end = end, start\n    }\n    for i := start + 1; i < end; i++ {\n\
    \        result = append(result, planets[i])\n    }\n    return result\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpsvkozugc_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmptpkhbaz6_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 && end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpr49ousqj_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmptpkhbaz6_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp3_2n_57k_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp3_2n_57k_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index > planet2Index {\n\
    \        planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    for\
    \ i := planet1Index + 1; i < planet2Index; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp3fm_5h1w_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp3fm_5h1w_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmptpkhbaz6_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var i1, i2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ 0 || i2 == 0 {\n        return res\n    }\n    if i1 > i2 {\n        i1, i2\
    \ = i2, i1\n    }\n    for i := i1 + 1; i < i2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0nbmt55g_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0nbmt55g_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpegdnmaz7_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpegdnmaz7_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var i1, i2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ 0 || i2 == 0 {\n        return res\n    }\n    if i1 > i2 {\n        i1, i2\
    \ = i2, i1\n    }\n    for i := i1 + 1; i < i2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0nbmt55g_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0nbmt55g_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 && end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpd2e3d4zz_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      start = i\n        }\n        if planet == planet2 {\n            end =\
    \ i\n        }\n    }\n    if start == 0 && end == 0 {\n        return result\n\
    \    }\n    if start > end {\n        start, end = end, start\n    }\n    for\
    \ i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpe56g0zxc_test.go:62: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpdc9yk4il_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index > planet2Index {\n\
    \        planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    for\
    \ i := planet1Index + 1; i < planet2Index; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp3fm_5h1w_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp3fm_5h1w_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return res\n    }\n    if\
    \ start > end {\n        start, end = end, start\n    }\n    for i := start +\
    \ 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp1u7o4tei_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp1u7o4tei_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp3_2n_57k_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp3_2n_57k_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    var res []interface{}\n    for i, v :=\
    \ range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return res\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgp8pplr_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgp8pplr_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            index1 = i\n        }\n     \
    \   if planet == planet2 {\n            index2 = i\n        }\n    }\n    if index1\
    \ == 0 || index2 == 0 {\n        return []interface{}{}\n    }\n    var result\
    \ []interface{}\n    if index1 < index2 {\n        for i := index1 + 1; i < index2;\
    \ i++ {\n            result = append(result, planets[i])\n        }\n    } else\
    \ {\n        for i := index2 + 1; i < index1; i++ {\n            result = append(result,\
    \ planets[i])\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpt0jmrcoy_test.go:64: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpt0jmrcoy_test.go:64: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    for i, p := range planets {\n \
    \       if p == planet1 {\n            for j := i + 1; j < len(planets); j++ {\n\
    \                if planets[j] == planet2 {\n                    return planets[i+1:j]\n\
    \                }\n            }\n        }\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4zs4amqr_test.go:25:35: cannot use planets[i + 1:j] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    var res []interface{}\n    if p1 < p2 {\n      \
    \  for i := p1 + 1; i < p2; i++ {\n            res = append(res, planets[i])\n\
    \        }\n    } else {\n        for i := p2 + 1; i < p1; i++ {\n           \
    \ res = append(res, planets[i])\n        }\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpoqi3bh4m_test.go:64: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpoqi3bh4m_test.go:64: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, v := range planets {\n        if v == planet1 {\n            start\
    \ = i\n        }\n        if v == planet2 {\n            end = i\n        }\n\
    \    }\n    if start == 0 && end == 0 {\n        return result\n    }\n    if\
    \ start > end {\n        start, end = end, start\n    }\n    for i := start +\
    \ 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n    return\
    \ result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp4e8tk42y_test.go:62: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    for i, v := range planets {\n \
    \       if v == planet1 {\n            for j, v := range planets {\n         \
    \       if v == planet2 {\n                    if i < j {\n                  \
    \      res = planets[i+1:j]\n                    } else {\n                  \
    \      res = planets[j+1:i]\n                    }\n                    break\n\
    \                }\n            }\n            break\n        }\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp19urv9aa_test.go:26:38: cannot use planets[i + 1:j] (value of type []string)
    as type []interface{} in assignment

    /tmp/tmp19urv9aa_test.go:28:38: cannot use planets[j + 1:i] (value of type []string)
    as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      start = i\n        }\n        if planet == planet2 {\n            end =\
    \ i\n        }\n    }\n    if start == 0 && end == 0 {\n        return result\n\
    \    }\n    if start > end {\n        start, end = end, start\n    }\n    for\
    \ i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpe56g0zxc_test.go:62: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprlh4_teh_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpyib8f1ll_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpyib8f1ll_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjzqef6q2_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpegdnmaz7_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpegdnmaz7_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6iyo4lie_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpegdnmaz7_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpegdnmaz7_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpmg03047x_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpegdnmaz7_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpegdnmaz7_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start < end {\n        for i := start + 1; i < end; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    } else {\n        for i\
    \ := end + 1; i < start; i++ {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpc4d6rhlc_test.go:64: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpc4d6rhlc_test.go:64: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var i1, i2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            i1 = i\n        }\n\
    \        if p == planet2 {\n            i2 = i\n        }\n    }\n    if i1 ==\
    \ 0 || i2 == 0 {\n        return res\n    }\n    if i1 > i2 {\n        i1, i2\
    \ = i2, i1\n    }\n    for i := i1 + 1; i < i2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp0nbmt55g_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0nbmt55g_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    var result []interface{}\n   \
    \ for i, planet := range planets {\n        if planet == planet1 {\n         \
    \   index1 = i\n        }\n        if planet == planet2 {\n            index2\
    \ = i\n        }\n    }\n    if index1 == 0 && index2 == 0 {\n        return result\n\
    \    }\n    if index1 > index2 {\n        index1, index2 = index2, index1\n  \
    \  }\n    for i := index1 + 1; i < index2; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpbtr4s9x7_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpyib8f1ll_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpyib8f1ll_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpyib8f1ll_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpyib8f1ll_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start+1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpor0qzpgn_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpor0qzpgn_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpdc9yk4il_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpcrnnm2po_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpyib8f1ll_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpyib8f1ll_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjzqef6q2_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, v := range planets {\n        if v == planet1 {\n            start\
    \ = i\n        }\n        if v == planet2 {\n            end = i\n        }\n\
    \    }\n    if start > end {\n        start, end = end, start\n    }\n    for\
    \ i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp7pwoecia_test.go:59: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpdc9yk4il_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n_h7h9w_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwgel9cex_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwgel9cex_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return res\n    }\n    if\
    \ start > end {\n        start, end = end, start\n    }\n    for i := start +\
    \ 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp1u7o4tei_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp1u7o4tei_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpegdnmaz7_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpegdnmaz7_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 && end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpq_nw4epl_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpegdnmaz7_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpegdnmaz7_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 || end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmppw_bmuuy_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmppw_bmuuy_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, v := range planets {\n\
    \        if v == planet1 {\n            p1 = i\n        }\n        if v == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpam4o96ie_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptb3h6pkj_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ v := range planets {\n        if v == planet1 {\n            start = i\n   \
    \     }\n        if v == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start == 0 && end == 0 {\n        return res\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpvm_cjwbk_test.go:61: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpcrnnm2po_test.go:58: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n \
    \   }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54dcz99n_test.go:35:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074269
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpibuiq2np_test.go:36:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074271
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start >\
    \ end {\n        start, end = end, start\n    }\n    for i := start + 1; i < end;\
    \ i++ {\n        result = append(result, planets[i])\n    }\n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpegdnmaz7_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpegdnmaz7_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var p1, p2 int\n    for i, v :=\
    \ range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return res\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpwq6gybhj_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpwq6gybhj_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpn5v_wcas_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpn5v_wcas_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074269
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a tuple containing all planets whose orbits\
    \ are \n// located between the orbit of planet1 and the orbit of planet2, sorted\
    \ by \n// the proximity to the sun. \n// The function should return an empty tuple\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\nfunc\
    \ bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var p1, p2 int\n    for i, v :=\
    \ range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return res\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n        res = append(res,\
    \ planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmph8hhemh5_test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmph8hhemh5_test.go:61: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074272
