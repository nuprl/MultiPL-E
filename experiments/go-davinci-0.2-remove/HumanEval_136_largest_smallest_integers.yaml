name: HumanEval_136_largest_smallest_integers
language: go_test.go
prompt: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n   \
  \ \"fmt\"\n)\n\n// Create a function that returns a tuple (a, b), where 'a' is\n\
  // the largest of negative integers, and 'b' is the smallest\n// of positive integers\
  \ in a list.\n// If there is no negative or positive integers, return them as None.\n\
  // Examples:\nfunc largest_smallest_integers(lst []int) []interface{} {\n"
tests: "func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected:\
  \ []interface{}{None, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}),\
  \ expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1, 3, 2, 4,\
  \ 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
  \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
  \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
  \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}), expected:\
  \ []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3, -5, -6}),\
  \ expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1, -3, -5,\
  \ -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
  \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
  \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
  \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    var a, b int\n    a = 0\n    b = 0\n    for _, v := range lst {\n\
    \        if v < 0 {\n            if v > a {\n                a = v\n         \
    \   }\n        } else {\n            if v < b || b == 0 {\n                b =\
    \ v\n            }\n        }\n    }\n    if a == 0 {\n        a = nil\n    }\n\
    \    if b == 0 {\n        b = nil\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largestNegative int\n    var smallestPositive int\n    var largestNegativeSet\
    \ bool\n    var smallestPositiveSet bool\n    for _, v := range lst {\n      \
    \  if v < 0 {\n            if !largestNegativeSet {\n                largestNegative\
    \ = v\n                largestNegativeSet = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveSet {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            } else if v < smallestPositive\
    \ {\n                smallestPositive = v\n            }\n        }\n    }\n \
    \   if largestNegativeSet && smallestPositiveSet {\n        return []interface{}{largestNegative,\
    \ smallestPositive}\n    } else if largestNegativeSet {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if smallestPositiveSet {\n        return []interface{}{nil,\
    \ smallestPositive}\n    } else {\n        return []interface{}{nil, nil}\n  \
    \  }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeFound bool\n    var smallestPositiveFound bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if !largestNegativeFound {\n\
    \                largestNegative = v\n                largestNegativeFound = true\n\
    \            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, i := range lst {\n        if i < 0 {\n\
    \            if !largestNegativeFound {\n                largestNegative = i\n\
    \                largestNegativeFound = true\n            } else if i > largestNegative\
    \ {\n                largestNegative = i\n            }\n        } else if i >\
    \ 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = i\n                smallestPositiveFound = true\n            } else if i <\
    \ smallestPositive {\n                smallestPositive = i\n            }\n  \
    \      }\n    }\n    if largestNegativeFound && smallestPositiveFound {\n    \
    \    return []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeFound\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveFound\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative int\n\
    \    var smallest_positive int\n    var largest_negative_found bool\n    var smallest_positive_found\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largest_negative_found\
    \ {\n                largest_negative = v\n                largest_negative_found\
    \ = true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_found\
    \ {\n                smallest_positive = v\n                smallest_positive_found\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_found && smallest_positive_found\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_found {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_found {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeFound,\
    \ smallestPositiveFound bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeFound {\n                largestNegative = v\n\
    \                largestNegativeFound = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = v\n                smallestPositiveFound = true\n            } else if v <\
    \ smallestPositive {\n                smallestPositive = v\n            }\n  \
    \      }\n    }\n    if !largestNegativeFound {\n        largestNegative = 0\n\
    \    }\n    if !smallestPositiveFound {\n        smallestPositive = 0\n    }\n\
    \    return []interface{}{largestNegative, smallestPositive}\n}\n", "    var a,\
    \ b int\n    var a_set, b_set bool\n    for _, v := range lst {\n        if v\
    \ < 0 {\n            if !a_set {\n                a = v\n                a_set\
    \ = true\n            } else if v > a {\n                a = v\n            }\n\
    \        } else if v > 0 {\n            if !b_set {\n                b = v\n \
    \               b_set = true\n            } else if v < b {\n                b\
    \ = v\n            }\n        }\n    }\n    if !a_set {\n        a = 0\n    }\n\
    \    if !b_set {\n        b = 0\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largestNegative int\n    var smallestPositive int\n    var largestNegativeSet\
    \ bool\n    var smallestPositiveSet bool\n    for _, num := range lst {\n    \
    \    if num < 0 {\n            if !largestNegativeSet {\n                largestNegative\
    \ = num\n                largestNegativeSet = true\n            } else if num\
    \ > largestNegative {\n                largestNegative = num\n            }\n\
    \        } else if num > 0 {\n            if !smallestPositiveSet {\n        \
    \        smallestPositive = num\n                smallestPositiveSet = true\n\
    \            } else if num < smallestPositive {\n                smallestPositive\
    \ = num\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeExists bool\n    var\
    \ smallestPositiveExists bool\n    for _, element := range lst {\n        if element\
    \ < 0 {\n            if largestNegativeExists {\n                if element >\
    \ largestNegative {\n                    largestNegative = element\n         \
    \       }\n            } else {\n                largestNegative = element\n \
    \               largestNegativeExists = true\n            }\n        } else {\n\
    \            if smallestPositiveExists {\n                if element < smallestPositive\
    \ {\n                    smallestPositive = element\n                }\n     \
    \       } else {\n                smallestPositive = element\n               \
    \ smallestPositiveExists = true\n            }\n        }\n    }\n    if largestNegativeExists\
    \ && smallestPositiveExists {\n        return []interface{}{largestNegative, smallestPositive}\n\
    \    } else if largestNegativeExists {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if smallestPositiveExists {\n        return []interface{}{nil,\
    \ smallestPositive}\n    } else {\n        return []interface{}{nil, nil}\n  \
    \  }\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet || v > largestNegative {\n               \
    \ largestNegative = v\n                largestNegativeSet = true\n           \
    \ }\n        } else {\n            if !smallestPositiveSet || v < smallestPositive\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet {\n     \
    \   if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeFound {\n                largestNegative = v\n\
    \                largestNegativeFound = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = v\n                smallestPositiveFound = true\n            } else if v <\
    \ smallestPositive {\n                smallestPositive = v\n            }\n  \
    \      }\n    }\n    if largestNegativeFound && smallestPositiveFound {\n    \
    \    return []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeFound\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveFound\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative int\n\
    \    var smallestPositive int\n    var largestNegativeExists bool\n    var smallestPositiveExists\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if largestNegativeExists\
    \ {\n                if v > largestNegative {\n                    largestNegative\
    \ = v\n                }\n            } else {\n                largestNegative\
    \ = v\n                largestNegativeExists = true\n            }\n        }\
    \ else {\n            if smallestPositiveExists {\n                if v < smallestPositive\
    \ {\n                    smallestPositive = v\n                }\n           \
    \ } else {\n                smallestPositive = v\n                smallestPositiveExists\
    \ = true\n            }\n        }\n    }\n    if largestNegativeExists && smallestPositiveExists\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeExists {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveExists {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n    var\
    \ smallestPositive int\n    var largestNegativeSet bool\n    var smallestPositiveSet\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveSet\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var largestNegative int\n    var smallestPositive\
    \ int\n    var largestNegativeFound bool\n    var smallestPositiveFound bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if !largestNegativeFound {\n     \
    \   largestNegative = 0\n    }\n    if !smallestPositiveFound {\n        smallestPositive\
    \ = 0\n    }\n    return []interface{}{largestNegative, smallestPositive}\n}\n",
  "    var largestNegative int\n    var smallestPositive int\n    var largestNegativeFound\
    \ bool\n    var smallestPositiveFound bool\n    for _, v := range lst {\n    \
    \    if v < 0 {\n            if !largestNegativeFound {\n                largestNegative\
    \ = v\n                largestNegativeFound = true\n            } else if v >\
    \ largestNegative {\n                largestNegative = v\n            }\n    \
    \    } else if v > 0 {\n            if !smallestPositiveFound {\n            \
    \    smallestPositive = v\n                smallestPositiveFound = true\n    \
    \        } else if v < smallestPositive {\n                smallestPositive =\
    \ v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b int\n    var a_set, b_set bool\n    for _, v := range lst {\n        if v\
    \ < 0 {\n            if !a_set {\n                a = v\n                a_set\
    \ = true\n            } else if v > a {\n                a = v\n            }\n\
    \        } else if v > 0 {\n            if !b_set {\n                b = v\n \
    \               b_set = true\n            } else if v < b {\n                b\
    \ = v\n            }\n        }\n    }\n    if !a_set {\n        a = 0\n    }\n\
    \    if !b_set {\n        b = 0\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largestNegative int\n    var smallestPositive int\n    var largestNegativeSet\
    \ bool\n    var smallestPositiveSet bool\n    for _, v := range lst {\n      \
    \  if v < 0 {\n            if !largestNegativeSet {\n                largestNegative\
    \ = v\n                largestNegativeSet = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveSet {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            } else if v < smallestPositive\
    \ {\n                smallestPositive = v\n            }\n        }\n    }\n \
    \   if largestNegativeSet && smallestPositiveSet {\n        return []interface{}{largestNegative,\
    \ smallestPositive}\n    } else if largestNegativeSet {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if smallestPositiveSet {\n        return []interface{}{nil,\
    \ smallestPositive}\n    } else {\n        return []interface{}{nil, nil}\n  \
    \  }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeSet bool\n    var smallestPositiveSet bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeSet {\n          \
    \      largestNegative = v\n                largestNegativeSet = true\n      \
    \      } else if v > largestNegative {\n                largestNegative = v\n\
    \            }\n        } else if v > 0 {\n            if !smallestPositiveSet\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n    var\
    \ smallestPositive int\n    var largestNegativeFound bool\n    var smallestPositiveFound\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largestNegativeFound == false {\n                largestNegative\
    \ = v\n                largestNegativeFound = true\n            } else if v >\
    \ largestNegative {\n                largestNegative = v\n            }\n    \
    \    } else if v > 0 {\n            if smallestPositiveFound == false {\n    \
    \            smallestPositive = v\n                smallestPositiveFound = true\n\
    \            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound == false {\n\
    \        largestNegative = nil\n    }\n    if smallestPositiveFound == false {\n\
    \        smallestPositive = nil\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var largestNegative, smallestPositive int\n  \
    \  var largestNegativeSet, smallestPositiveSet bool\n\n    for _, n := range lst\
    \ {\n        if n < 0 {\n            if !largestNegativeSet || n > largestNegative\
    \ {\n                largestNegative = n\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ n < smallestPositive {\n                smallestPositive = n\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n\n    if largestNegativeSet\
    \ && smallestPositiveSet {\n        return []interface{}{largestNegative, smallestPositive}\n\
    \    } else if largestNegativeSet {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if smallestPositiveSet {\n        return []interface{}{nil,\
    \ smallestPositive}\n    } else {\n        return []interface{}{nil, nil}\n  \
    \  }\n}\n", "    var a, b interface{}\n    a = nil\n    b = nil\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if a == nil {\n            \
    \    a = v\n            } else if v > a.(int) {\n                a = v\n     \
    \       }\n        } else if v > 0 {\n            if b == nil {\n            \
    \    b = v\n            } else if v < b.(int) {\n                b = v\n     \
    \       }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeSet bool\n    var\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largestNegativeSet {\n                if v > largestNegative {\n\
    \                    largestNegative = v\n                }\n            } else\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if smallestPositiveSet {\n\
    \                if v < smallestPositive {\n                    smallestPositive\
    \ = v\n                }\n            } else {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet && smallestPositiveSet {\n        return []interface{}{largestNegative,\
    \ smallestPositive}\n    } else if largestNegativeSet {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if smallestPositiveSet {\n        return []interface{}{nil,\
    \ smallestPositive}\n    } else {\n        return []interface{}{nil, nil}\n  \
    \  }\n}\n", "    var a, b interface{}\n    for _, v := range lst {\n        if\
    \ v < 0 {\n            if a == nil {\n                a = v\n            } else\
    \ if v > a.(int) {\n                a = v\n            }\n        } else if v\
    \ > 0 {\n            if b == nil {\n                b = v\n            } else\
    \ if v < b.(int) {\n                b = v\n            }\n        }\n    }\n \
    \   return []interface{}{a, b}\n}\n", "    var a, b interface{}\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if a == nil {\n            \
    \    a = v\n            } else if v > a.(int) {\n                a = v\n     \
    \       }\n        } else if v > 0 {\n            if b == nil {\n            \
    \    b = v\n            } else if v < b.(int) {\n                b = v\n     \
    \       }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeExists bool\n    var\
    \ smallestPositiveExists bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largestNegativeExists == false {\n                largestNegative\
    \ = v\n                largestNegativeExists = true\n            } else if v >\
    \ largestNegative {\n                largestNegative = v\n            }\n    \
    \    } else if v > 0 {\n            if smallestPositiveExists == false {\n   \
    \             smallestPositive = v\n                smallestPositiveExists = true\n\
    \            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeExists == false\
    \ {\n        largestNegative = nil\n    }\n    if smallestPositiveExists == false\
    \ {\n        smallestPositive = nil\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var largest_negative, smallest_positive int\n\
    \    var largest_negative_set, smallest_positive_set bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largest_negative_set {\n        \
    \        largest_negative = v\n                largest_negative_set = true\n \
    \           } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeSet bool\n    var smallestPositiveSet bool\n    for _, num :=\
    \ range lst {\n        if num < 0 {\n            if largestNegativeSet {\n   \
    \             if num > largestNegative {\n                    largestNegative\
    \ = num\n                }\n            } else {\n                largestNegative\
    \ = num\n                largestNegativeSet = true\n            }\n        } else\
    \ {\n            if smallestPositiveSet {\n                if num < smallestPositive\
    \ {\n                    smallestPositive = num\n                }\n         \
    \   } else {\n                smallestPositive = num\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var a, b interface{}\n    a =\
    \ nil\n    b = nil\n    for _, v := range lst {\n        if v < 0 {\n        \
    \    if a == nil {\n                a = v\n            } else if v > a.(int) {\n\
    \                a = v\n            }\n        } else if v > 0 {\n           \
    \ if b == nil {\n                b = v\n            } else if v < b.(int) {\n\
    \                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeFound bool\n    var smallestPositiveFound bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if largestNegativeFound == false\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if smallestPositiveFound\
    \ == false {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound == false {\n\
    \        largestNegative = 0\n    }\n    if smallestPositiveFound == false {\n\
    \        smallestPositive = 0\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var largestNegative, smallestPositive int\n  \
    \  var largestNegativeSet, smallestPositiveSet bool\n    for _, i := range lst\
    \ {\n        if i < 0 {\n            if !largestNegativeSet || i > largestNegative\
    \ {\n                largestNegative = i\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ i < smallestPositive {\n                smallestPositive = i\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var a, b interface{}\n\
    \    a = nil\n    b = nil\n    for _, v := range lst {\n        if v < 0 {\n \
    \           if a == nil {\n                a = v\n            } else if v > a.(int)\
    \ {\n                a = v\n            }\n        } else if v > 0 {\n       \
    \     if b == nil {\n                b = v\n            } else if v < b.(int)\
    \ {\n                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeFound bool\n    var smallestPositiveFound bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if !largestNegativeFound {\n\
    \                largestNegative = v\n                largestNegativeFound = true\n\
    \            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative,\
    \ smallest_positive int\n    var largest_negative_set, smallest_positive_set bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largest_negative_set\
    \ {\n                largest_negative = v\n                largest_negative_set\
    \ = true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largest_negative, smallest_positive int\n    var largest_negative_set,\
    \ smallest_positive_set bool\n    for _, i := range lst {\n        if i < 0 {\n\
    \            if !largest_negative_set {\n                largest_negative = i\n\
    \                largest_negative_set = true\n            } else if i > largest_negative\
    \ {\n                largest_negative = i\n            }\n        } else if i\
    \ > 0 {\n            if !smallest_positive_set {\n                smallest_positive\
    \ = i\n                smallest_positive_set = true\n            } else if i <\
    \ smallest_positive {\n                smallest_positive = i\n            }\n\
    \        }\n    }\n    if largest_negative_set && smallest_positive_set {\n  \
    \      return []interface{}{largest_negative, smallest_positive}\n    } else if\
    \ largest_negative_set {\n        return []interface{}{largest_negative, nil}\n\
    \    } else if smallest_positive_set {\n        return []interface{}{nil, smallest_positive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeFound, smallestPositiveFound bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if !largestNegativeFound {\n     \
    \   largestNegative = 0\n    }\n    if !smallestPositiveFound {\n        smallestPositive\
    \ = 0\n    }\n    return []interface{}{largestNegative, smallestPositive}\n}\n",
  "    var a, b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n\
    \        if v < 0 {\n            if a == nil {\n                a = v\n      \
    \      } else if v > a.(int) {\n                a = v\n            }\n       \
    \ } else if v > 0 {\n            if b == nil {\n                b = v\n      \
    \      } else if v < b.(int) {\n                b = v\n            }\n       \
    \ }\n    }\n    return []interface{}{a, b}\n}\n", "    var largest_negative, smallest_positive\
    \ int\n    var largest_negative_set, smallest_positive_set bool\n\n    for _,\
    \ v := range lst {\n        if v < 0 {\n            if !largest_negative_set {\n\
    \                largest_negative = v\n                largest_negative_set =\
    \ true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet || v > largestNegative {\n               \
    \ largestNegative = v\n                largestNegativeSet = true\n           \
    \ }\n        } else {\n            if !smallestPositiveSet || v < smallestPositive\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet {\n     \
    \   if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var a, b int\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if v > a {\n   \
    \             a = v\n            }\n        } else {\n            if v < b {\n\
    \                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var a, b interface{}\n    for _, v := range lst {\n        if\
    \ v < 0 {\n            if a == nil {\n                a = v\n            } else\
    \ if v > a.(int) {\n                a = v\n            }\n        } else if v\
    \ > 0 {\n            if b == nil {\n                b = v\n            } else\
    \ if v < b.(int) {\n                b = v\n            }\n        }\n    }\n \
    \   return []interface{}{a, b}\n}\n", "    var a, b int\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if v > a {\n                a = v\n \
    \           }\n        } else {\n            if v < b {\n                b = v\n\
    \            }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    var\
    \ largestNegative, smallestPositive int\n    var largestNegativeFound, smallestPositiveFound\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if !largestNegativeFound {\n     \
    \   largestNegative = nil\n    }\n    if !smallestPositiveFound {\n        smallestPositive\
    \ = nil\n    }\n    return []interface{}{largestNegative, smallestPositive}\n\
    }\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet || v > largestNegative {\n               \
    \ largestNegative = v\n                largestNegativeSet = true\n           \
    \ }\n        } else {\n            if !smallestPositiveSet || v < smallestPositive\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet {\n     \
    \   if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeExists bool\n    var\
    \ smallestPositiveExists bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largestNegativeExists {\n                if v > largestNegative\
    \ {\n                    largestNegative = v\n                }\n            }\
    \ else {\n                largestNegative = v\n                largestNegativeExists\
    \ = true\n            }\n        } else {\n            if smallestPositiveExists\
    \ {\n                if v < smallestPositive {\n                    smallestPositive\
    \ = v\n                }\n            } else {\n                smallestPositive\
    \ = v\n                smallestPositiveExists = true\n            }\n        }\n\
    \    }\n    if largestNegativeExists && smallestPositiveExists {\n        return\
    \ []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeExists\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveExists\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var smallest, largest int\n\
    \    var smallest_set, largest_set bool\n    for _, v := range lst {\n       \
    \ if v < 0 {\n            if !largest_set {\n                largest = v\n   \
    \             largest_set = true\n            } else if v > largest {\n      \
    \          largest = v\n            }\n        } else {\n            if !smallest_set\
    \ {\n                smallest = v\n                smallest_set = true\n     \
    \       } else if v < smallest {\n                smallest = v\n            }\n\
    \        }\n    }\n    if largest_set && smallest_set {\n        return []interface{}{largest,\
    \ smallest}\n    } else if largest_set {\n        return []interface{}{largest,\
    \ nil}\n    } else if smallest_set {\n        return []interface{}{nil, smallest}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largest_negative int\n   \
    \ var smallest_positive int\n    var largest_negative_set bool\n    var smallest_positive_set\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largest_negative_set\
    \ {\n                largest_negative = v\n                largest_negative_set\
    \ = true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeSet bool\n    var smallestPositiveSet bool\n    for _, num :=\
    \ range lst {\n        if num < 0 {\n            if !largestNegativeSet {\n  \
    \              largestNegative = num\n                largestNegativeSet = true\n\
    \            } else if num > largestNegative {\n                largestNegative\
    \ = num\n            }\n        } else if num > 0 {\n            if !smallestPositiveSet\
    \ {\n                smallestPositive = num\n                smallestPositiveSet\
    \ = true\n            } else if num < smallestPositive {\n                smallestPositive\
    \ = num\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative\
    \ int\n    var smallest_positive int\n    var largest_negative_set bool\n    var\
    \ smallest_positive_set bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largest_negative_set {\n                if v > largest_negative\
    \ {\n                    largest_negative = v\n                }\n           \
    \ } else {\n                largest_negative = v\n                largest_negative_set\
    \ = true\n            }\n        } else {\n            if smallest_positive_set\
    \ {\n                if v < smallest_positive {\n                    smallest_positive\
    \ = v\n                }\n            } else {\n                smallest_positive\
    \ = v\n                smallest_positive_set = true\n            }\n        }\n\
    \    }\n    if largest_negative_set && smallest_positive_set {\n        return\
    \ []interface{}{largest_negative, smallest_positive}\n    } else if largest_negative_set\
    \ {\n        return []interface{}{largest_negative, nil}\n    } else if smallest_positive_set\
    \ {\n        return []interface{}{nil, smallest_positive}\n    } else {\n    \
    \    return []interface{}{nil, nil}\n    }\n}\n", "    var a, b interface{}\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if a == nil {\n\
    \                a = v\n            } else if v > a.(int) {\n                a\
    \ = v\n            }\n        } else if v > 0 {\n            if b == nil {\n \
    \               b = v\n            } else if v < b.(int) {\n                b\
    \ = v\n            }\n        }\n    }\n    return []interface{}{a, b}\n}\n",
  "    var a, b int\n    a = 0\n    b = 0\n    for _, v := range lst {\n        if\
    \ v < 0 {\n            if v > a {\n                a = v\n            }\n    \
    \    } else {\n            if v < b || b == 0 {\n                b = v\n     \
    \       }\n        }\n    }\n    if a == 0 && b == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    return []interface{}{a, b}\n}\n", "    var a, b interface{}\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if a == nil {\n\
    \                a = v\n            } else if v > a.(int) {\n                a\
    \ = v\n            }\n        } else if v > 0 {\n            if b == nil {\n \
    \               b = v\n            } else if v < b.(int) {\n                b\
    \ = v\n            }\n        }\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largest_negative_int, smallest_positive_int int\n    var largest_negative_int_exists,\
    \ smallest_positive_int_exists bool\n    for _, i := range lst {\n        if i\
    \ < 0 {\n            if !largest_negative_int_exists {\n                largest_negative_int\
    \ = i\n                largest_negative_int_exists = true\n            } else\
    \ if i > largest_negative_int {\n                largest_negative_int = i\n  \
    \          }\n        } else if i > 0 {\n            if !smallest_positive_int_exists\
    \ {\n                smallest_positive_int = i\n                smallest_positive_int_exists\
    \ = true\n            } else if i < smallest_positive_int {\n                smallest_positive_int\
    \ = i\n            }\n        }\n    }\n    if largest_negative_int_exists &&\
    \ smallest_positive_int_exists {\n        return []interface{}{largest_negative_int,\
    \ smallest_positive_int}\n    } else if largest_negative_int_exists {\n      \
    \  return []interface{}{largest_negative_int, nil}\n    } else if smallest_positive_int_exists\
    \ {\n        return []interface{}{nil, smallest_positive_int}\n    } else {\n\
    \        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var largestNegative, smallestPositive int\n    var\
    \ largestNegativeSet, smallestPositiveSet bool\n\n    for _, v := range lst {\n\
    \        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n\n    if largestNegativeSet\
    \ && smallestPositiveSet {\n        return []interface{}{largestNegative, smallestPositive}\n\
    \    } else if largestNegativeSet {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if smallestPositiveSet {\n        return []interface{}{nil,\
    \ smallestPositive}\n    } else {\n        return []interface{}{nil, nil}\n  \
    \  }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeFound bool\n    var smallestPositiveFound bool\n    for _, value\
    \ := range lst {\n        if value < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = value\n                largestNegativeFound\
    \ = true\n            } else if value > largestNegative {\n                largestNegative\
    \ = value\n            }\n        } else if value > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = value\n                smallestPositiveFound\
    \ = true\n            } else if value < smallestPositive {\n                smallestPositive\
    \ = value\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, num := range lst {\n        if num <\
    \ 0 {\n            if !largestNegativeFound {\n                largestNegative\
    \ = num\n                largestNegativeFound = true\n            } else if num\
    \ > largestNegative {\n                largestNegative = num\n            }\n\
    \        } else if num > 0 {\n            if !smallestPositiveFound {\n      \
    \          smallestPositive = num\n                smallestPositiveFound = true\n\
    \            } else if num < smallestPositive {\n                smallestPositive\
    \ = num\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largestNegative, smallestPositive\
    \ int\n    var largestNegativeSet, smallestPositiveSet bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var largest_negative, smallest_positive int\n  \
    \  var largest_negative_set, smallest_positive_set bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largest_negative_set {\n        \
    \        largest_negative = v\n                largest_negative_set = true\n \
    \           } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var a, b interface{}\n    for _, v := range lst {\n        if\
    \ v < 0 {\n            if a == nil {\n                a = v\n            } else\
    \ if v > a.(int) {\n                a = v\n            }\n        } else if v\
    \ > 0 {\n            if b == nil {\n                b = v\n            } else\
    \ if v < b.(int) {\n                b = v\n            }\n        }\n    }\n \
    \   return []interface{}{a, b}\n}\n", "    var a, b int\n    a = 0\n    b = 0\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if v > a {\n   \
    \             a = v\n            }\n        } else {\n            if v < b ||\
    \ b == 0 {\n                b = v\n            }\n        }\n    }\n    if a ==\
    \ 0 && b == 0 {\n        return []interface{}{nil, nil}\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeFound bool\n    var smallestPositiveFound bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if !largestNegativeFound {\n\
    \                largestNegative = v\n                largestNegativeFound = true\n\
    \            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int = 0\n    var smallestPositive int = 0\n    var largestNegativeFound bool\
    \ = false\n    var smallestPositiveFound bool = false\n    for _, num := range\
    \ lst {\n        if num < 0 {\n            if largestNegativeFound {\n       \
    \         if num > largestNegative {\n                    largestNegative = num\n\
    \                }\n            } else {\n                largestNegative = num\n\
    \                largestNegativeFound = true\n            }\n        } else if\
    \ num > 0 {\n            if smallestPositiveFound {\n                if num <\
    \ smallestPositive {\n                    smallestPositive = num\n           \
    \     }\n            } else {\n                smallestPositive = num\n      \
    \          smallestPositiveFound = true\n            }\n        }\n    }\n   \
    \ if largestNegativeFound {\n        if smallestPositiveFound {\n            return\
    \ []interface{}{largestNegative, smallestPositive}\n        } else {\n       \
    \     return []interface{}{largestNegative, nil}\n        }\n    } else {\n  \
    \      if smallestPositiveFound {\n            return []interface{}{nil, smallestPositive}\n\
    \        } else {\n            return []interface{}{nil, nil}\n        }\n   \
    \ }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeFound bool\n    var smallestPositiveFound bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if !largestNegativeFound {\n\
    \                largestNegative = v\n                largestNegativeFound = true\n\
    \            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largestNegative, smallestPositive\
    \ int\n    var largestNegativeSet, smallestPositiveSet bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largest_negative,\
    \ smallest_positive int\n    var largest_negative_set, smallest_positive_set bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largest_negative_set\
    \ {\n                largest_negative = v\n                largest_negative_set\
    \ = true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largest_negative, smallest_positive int\n    var largest_negative_set,\
    \ smallest_positive_set bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largest_negative_set {\n                largest_negative = v\n\
    \                largest_negative_set = true\n            } else if v > largest_negative\
    \ {\n                largest_negative = v\n            }\n        } else if v\
    \ > 0 {\n            if !smallest_positive_set {\n                smallest_positive\
    \ = v\n                smallest_positive_set = true\n            } else if v <\
    \ smallest_positive {\n                smallest_positive = v\n            }\n\
    \        }\n    }\n    if largest_negative_set && smallest_positive_set {\n  \
    \      return []interface{}{largest_negative, smallest_positive}\n    } else if\
    \ largest_negative_set {\n        return []interface{}{largest_negative, nil}\n\
    \    } else if smallest_positive_set {\n        return []interface{}{nil, smallest_positive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative\
    \ int\n    var smallest_positive int\n    var largest_negative_found bool\n  \
    \  var smallest_positive_found bool\n    for _, v := range lst {\n        if v\
    \ < 0 {\n            if !largest_negative_found {\n                largest_negative\
    \ = v\n                largest_negative_found = true\n            } else if v\
    \ > largest_negative {\n                largest_negative = v\n            }\n\
    \        } else if v > 0 {\n            if !smallest_positive_found {\n      \
    \          smallest_positive = v\n                smallest_positive_found = true\n\
    \            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_found && smallest_positive_found\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_found {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_found {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largest_negative, smallest_positive int\n    var largest_negative_set,\
    \ smallest_positive_set bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largest_negative_set {\n                largest_negative = v\n\
    \                largest_negative_set = true\n            } else if v > largest_negative\
    \ {\n                largest_negative = v\n            }\n        } else if v\
    \ > 0 {\n            if !smallest_positive_set {\n                smallest_positive\
    \ = v\n                smallest_positive_set = true\n            } else if v <\
    \ smallest_positive {\n                smallest_positive = v\n            }\n\
    \        }\n    }\n    if largest_negative_set && smallest_positive_set {\n  \
    \      return []interface{}{largest_negative, smallest_positive}\n    } else if\
    \ largest_negative_set {\n        return []interface{}{largest_negative, nil}\n\
    \    } else if smallest_positive_set {\n        return []interface{}{nil, smallest_positive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeSet bool\n    var\
    \ smallestPositiveSet bool\n    for _, num := range lst {\n        if num < 0\
    \ {\n            if !largestNegativeSet {\n                largestNegative = num\n\
    \                largestNegativeSet = true\n            } else if num > largestNegative\
    \ {\n                largestNegative = num\n            }\n        } else if num\
    \ > 0 {\n            if !smallestPositiveSet {\n                smallestPositive\
    \ = num\n                smallestPositiveSet = true\n            } else if num\
    \ < smallestPositive {\n                smallestPositive = num\n            }\n\
    \        }\n    }\n    if largestNegativeSet && smallestPositiveSet {\n      \
    \  return []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeSet\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveSet\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative int\n\
    \    var smallestPositive int\n    var largestNegativeSet bool\n    var smallestPositiveSet\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if largestNegativeSet\
    \ {\n                if v > largestNegative {\n                    largestNegative\
    \ = v\n                }\n            } else {\n                largestNegative\
    \ = v\n                largestNegativeSet = true\n            }\n        } else\
    \ {\n            if smallestPositiveSet {\n                if v < smallestPositive\
    \ {\n                    smallestPositive = v\n                }\n           \
    \ } else {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b int\n    for _, v := range lst {\n        if v < 0 {\n            if v > a\
    \ {\n                a = v\n            }\n        } else {\n            if v\
    \ < b {\n                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet || v > largestNegative {\n               \
    \ largestNegative = v\n                largestNegativeSet = true\n           \
    \ }\n        } else {\n            if !smallestPositiveSet || v < smallestPositive\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet {\n     \
    \   if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var hasNegative, hasPositive bool\n    for _, v :=\
    \ range lst {\n        if v < 0 {\n            if !hasNegative || v > largestNegative\
    \ {\n                largestNegative = v\n            }\n            hasNegative\
    \ = true\n        } else {\n            if !hasPositive || v < smallestPositive\
    \ {\n                smallestPositive = v\n            }\n            hasPositive\
    \ = true\n        }\n    }\n    if !hasNegative {\n        largestNegative = 0\n\
    \    }\n    if !hasPositive {\n        smallestPositive = 0\n    }\n    return\
    \ []interface{}{largestNegative, smallestPositive}\n}\n", "    var a, b interface{}\n\
    \    a = nil\n    b = nil\n    for _, v := range lst {\n        if v < 0 {\n \
    \           if a == nil {\n                a = v\n            } else if v > a.(int)\
    \ {\n                a = v\n            }\n        } else if v > 0 {\n       \
    \     if b == nil {\n                b = v\n            } else if v < b.(int)\
    \ {\n                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeFound bool\n    var smallestPositiveFound bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if largestNegativeFound == false\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if smallestPositiveFound\
    \ == false {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound == false {\n\
    \        largestNegative = nil\n    }\n    if smallestPositiveFound == false {\n\
    \        smallestPositive = nil\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var a, b int\n    for _, v := range lst {\n  \
    \      if v < 0 {\n            if v > a {\n                a = v\n           \
    \ }\n        } else {\n            if v < b {\n                b = v\n       \
    \     }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeFound {\n                largestNegative = v\n\
    \                largestNegativeFound = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = v\n                smallestPositiveFound = true\n            } else if v <\
    \ smallestPositive {\n                smallestPositive = v\n            }\n  \
    \      }\n    }\n    if largestNegativeFound && smallestPositiveFound {\n    \
    \    return []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeFound\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveFound\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var a, b int\n    for _,\
    \ v := range lst {\n        if v < 0 {\n            if v > a {\n             \
    \   a = v\n            }\n        } else {\n            if v < b {\n         \
    \       b = v\n            }\n        }\n    }\n    return []interface{}{a, b}\n\
    }\n", "    var largestNegative int\n    var smallestPositive int\n    var hasNegative\
    \ bool\n    var hasPositive bool\n    for _, v := range lst {\n        if v <\
    \ 0 {\n            if !hasNegative {\n                largestNegative = v\n  \
    \              hasNegative = true\n            } else if v > largestNegative {\n\
    \                largestNegative = v\n            }\n        } else if v > 0 {\n\
    \            if !hasPositive {\n                smallestPositive = v\n       \
    \         hasPositive = true\n            } else if v < smallestPositive {\n \
    \               smallestPositive = v\n            }\n        }\n    }\n    if\
    \ hasNegative && hasPositive {\n        return []interface{}{largestNegative,\
    \ smallestPositive}\n    } else if hasNegative {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if hasPositive {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative,\
    \ smallest_positive int\n    var largest_negative_set, smallest_positive_set bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largest_negative_set\
    \ {\n                largest_negative = v\n                largest_negative_set\
    \ = true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n\n    for _, num := range lst {\n        if num <\
    \ 0 && !largestNegativeSet {\n            largestNegative = num\n            largestNegativeSet\
    \ = true\n        } else if num < 0 && num > largestNegative {\n            largestNegative\
    \ = num\n        }\n\n        if num > 0 && !smallestPositiveSet {\n         \
    \   smallestPositive = num\n            smallestPositiveSet = true\n        }\
    \ else if num > 0 && num < smallestPositive {\n            smallestPositive =\
    \ num\n        }\n    }\n\n    if largestNegativeSet && smallestPositiveSet {\n\
    \        return []interface{}{largestNegative, smallestPositive}\n    } else if\
    \ largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n \
    \   } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n    var\
    \ smallestPositive int\n    var largestNegativeFound bool\n    var smallestPositiveFound\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var pos,\
    \ neg int\n    var pos_set, neg_set bool\n    for _, v := range lst {\n      \
    \  if v > 0 {\n            if !pos_set {\n                pos = v\n          \
    \      pos_set = true\n            } else if v < pos {\n                pos =\
    \ v\n            }\n        } else if v < 0 {\n            if !neg_set {\n   \
    \             neg = v\n                neg_set = true\n            } else if v\
    \ > neg {\n                neg = v\n            }\n        }\n    }\n    if !pos_set\
    \ {\n        pos = 0\n    }\n    if !neg_set {\n        neg = 0\n    }\n    return\
    \ []interface{}{neg, pos}\n}\n", "    var largestNegative, smallestPositive int\n\
    \    var largestNegativeSet, smallestPositiveSet bool\n\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeExists bool\n    var\
    \ smallestPositiveExists bool\n    for _, i := range lst {\n        if i < 0 {\n\
    \            if !largestNegativeExists {\n                largestNegative = i\n\
    \                largestNegativeExists = true\n            } else if i > largestNegative\
    \ {\n                largestNegative = i\n            }\n        } else if i >\
    \ 0 {\n            if !smallestPositiveExists {\n                smallestPositive\
    \ = i\n                smallestPositiveExists = true\n            } else if i\
    \ < smallestPositive {\n                smallestPositive = i\n            }\n\
    \        }\n    }\n    if largestNegativeExists && smallestPositiveExists {\n\
    \        return []interface{}{largestNegative, smallestPositive}\n    } else if\
    \ largestNegativeExists {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveExists {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b int\n    var a_set, b_set bool\n    for _, v := range lst {\n        if v\
    \ < 0 {\n            if !a_set {\n                a = v\n                a_set\
    \ = true\n            } else if v > a {\n                a = v\n            }\n\
    \        } else if v > 0 {\n            if !b_set {\n                b = v\n \
    \               b_set = true\n            } else if v < b {\n                b\
    \ = v\n            }\n        }\n    }\n    if !a_set {\n        a = 0\n    }\n\
    \    if !b_set {\n        b = 0\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largestNegative int\n    var smallestPositive int\n    var largestNegativeExists\
    \ bool\n    var smallestPositiveExists bool\n    for _, v := range lst {\n   \
    \     if v < 0 {\n            if !largestNegativeExists {\n                largestNegative\
    \ = v\n                largestNegativeExists = true\n            } else if v >\
    \ largestNegative {\n                largestNegative = v\n            }\n    \
    \    } else if v > 0 {\n            if !smallestPositiveExists {\n           \
    \     smallestPositive = v\n                smallestPositiveExists = true\n  \
    \          } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeExists && smallestPositiveExists\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeExists {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveExists {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeSet bool\n    var\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet {\n                largestNegative = v\n \
    \               largestNegativeSet = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveSet {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            } else if v < smallestPositive\
    \ {\n                smallestPositive = v\n            }\n        }\n    }\n \
    \   if largestNegativeSet && smallestPositiveSet {\n        return []interface{}{largestNegative,\
    \ smallestPositive}\n    } else if largestNegativeSet {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if smallestPositiveSet {\n        return []interface{}{nil,\
    \ smallestPositive}\n    } else {\n        return []interface{}{nil, nil}\n  \
    \  }\n}\n", "    var a, b interface{}\n    a = nil\n    b = nil\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if a == nil {\n            \
    \    a = v\n            } else if v > a.(int) {\n                a = v\n     \
    \       }\n        } else if v > 0 {\n            if b == nil {\n            \
    \    b = v\n            } else if v < b.(int) {\n                b = v\n     \
    \       }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    var largest,\
    \ smallest int\n    var largest_set, smallest_set bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largest_set {\n                largest\
    \ = v\n                largest_set = true\n            } else if v > largest {\n\
    \                largest = v\n            }\n        } else if v > 0 {\n     \
    \       if !smallest_set {\n                smallest = v\n                smallest_set\
    \ = true\n            } else if v < smallest {\n                smallest = v\n\
    \            }\n        }\n    }\n    if !largest_set {\n        largest = 0\n\
    \    }\n    if !smallest_set {\n        smallest = 0\n    }\n    return []interface{}{largest,\
    \ smallest}\n}\n", "    var largestNegative int\n    var smallestPositive int\n\
    \    var largestNegativeSet bool\n    var smallestPositiveSet bool\n    for _,\
    \ v := range lst {\n        if v < 0 {\n            if !largestNegativeSet {\n\
    \                largestNegative = v\n                largestNegativeSet = true\n\
    \            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveSet\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative,\
    \ smallest_positive int\n    var largest_negative_set, smallest_positive_set bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largest_negative_set\
    \ {\n                largest_negative = v\n                largest_negative_set\
    \ = true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var a, b int\n    a = 0\n    b = 0\n    for _, v := range lst\
    \ {\n        if v < 0 {\n            if v > a {\n                a = v\n     \
    \       }\n        } else {\n            if v < b || b == 0 {\n              \
    \  b = v\n            }\n        }\n    }\n    if a == 0 && b == 0 {\n       \
    \ return []interface{}{nil, nil}\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largestNegative, smallestPositive int\n    var largestNegativeSet, smallestPositiveSet\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var largestNegative, smallestPositive int\n    var\
    \ largestNegativeSet, smallestPositiveSet bool\n    for _, v := range lst {\n\
    \        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largestNegativeFound == false {\n                largestNegative\
    \ = v\n                largestNegativeFound = true\n            } else if v >\
    \ largestNegative {\n                largestNegative = v\n            }\n    \
    \    } else if v > 0 {\n            if smallestPositiveFound == false {\n    \
    \            smallestPositive = v\n                smallestPositiveFound = true\n\
    \            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound == false {\n\
    \        largestNegative = nil\n    }\n    if smallestPositiveFound == false {\n\
    \        smallestPositive = nil\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var largestNegative int\n    var smallestPositive\
    \ int\n    var largestNegativeFound bool\n    var smallestPositiveFound bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if largestNegativeFound\
    \ {\n                if v > largestNegative {\n                    largestNegative\
    \ = v\n                }\n            } else {\n                largestNegative\
    \ = v\n                largestNegativeFound = true\n            }\n        } else\
    \ {\n            if smallestPositiveFound {\n                if v < smallestPositive\
    \ {\n                    smallestPositive = v\n                }\n           \
    \ } else {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative,\
    \ smallest_positive int\n    var largest_negative_exists, smallest_positive_exists\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largest_negative_exists\
    \ {\n                largest_negative = v\n                largest_negative_exists\
    \ = true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_exists\
    \ {\n                smallest_positive = v\n                smallest_positive_exists\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_exists && smallest_positive_exists\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_exists {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_exists {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largest_negative, smallest_positive int\n    var largest_negative_set,\
    \ smallest_positive_set bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largest_negative_set {\n                largest_negative = v\n\
    \                largest_negative_set = true\n            } else if v > largest_negative\
    \ {\n                largest_negative = v\n            }\n        } else if v\
    \ > 0 {\n            if !smallest_positive_set {\n                smallest_positive\
    \ = v\n                smallest_positive_set = true\n            } else if v <\
    \ smallest_positive {\n                smallest_positive = v\n            }\n\
    \        }\n    }\n    if largest_negative_set && smallest_positive_set {\n  \
    \      return []interface{}{largest_negative, smallest_positive}\n    } else if\
    \ largest_negative_set {\n        return []interface{}{largest_negative, nil}\n\
    \    } else if smallest_positive_set {\n        return []interface{}{nil, smallest_positive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeSet bool\n    var\
    \ smallestPositiveSet bool\n    for _, num := range lst {\n        if num < 0\
    \ {\n            if !largestNegativeSet {\n                largestNegative = num\n\
    \                largestNegativeSet = true\n            } else if num > largestNegative\
    \ {\n                largestNegative = num\n            }\n        } else if num\
    \ > 0 {\n            if !smallestPositiveSet {\n                smallestPositive\
    \ = num\n                smallestPositiveSet = true\n            } else if num\
    \ < smallestPositive {\n                smallestPositive = num\n            }\n\
    \        }\n    }\n    if largestNegativeSet && smallestPositiveSet {\n      \
    \  return []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeSet\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveSet\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative, smallestPositive\
    \ int\n    var largestNegativeSet, smallestPositiveSet bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var a, b int\n\
    \    var a_set, b_set bool\n    for _, i := range lst {\n        if i < 0 {\n\
    \            if !a_set {\n                a = i\n                a_set = true\n\
    \            } else if i > a {\n                a = i\n            }\n       \
    \ } else if i > 0 {\n            if !b_set {\n                b = i\n        \
    \        b_set = true\n            } else if i < b {\n                b = i\n\
    \            }\n        }\n    }\n    if a_set && b_set {\n        return []interface{}{a,\
    \ b}\n    } else if a_set {\n        return []interface{}{a, nil}\n    } else\
    \ if b_set {\n        return []interface{}{nil, b}\n    } else {\n        return\
    \ []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative int\n    var\
    \ smallestPositive int\n    var largestNegativeFound bool\n    var smallestPositiveFound\
    \ bool\n    for _, i := range lst {\n        if i < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = i\n                largestNegativeFound\
    \ = true\n            } else if i > largestNegative {\n                largestNegative\
    \ = i\n            }\n        } else if i > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = i\n                smallestPositiveFound\
    \ = true\n            } else if i < smallestPositive {\n                smallestPositive\
    \ = i\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b int\n    var a_set, b_set bool\n    for _, v := range lst {\n        if v\
    \ < 0 {\n            if !a_set {\n                a = v\n                a_set\
    \ = true\n            } else if v > a {\n                a = v\n            }\n\
    \        } else if v > 0 {\n            if !b_set {\n                b = v\n \
    \               b_set = true\n            } else if v < b {\n                b\
    \ = v\n            }\n        }\n    }\n    if !a_set {\n        a = 0\n    }\n\
    \    if !b_set {\n        b = 0\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largestNegative int\n    var smallestPositive int\n    var largestNegativeFound\
    \ bool\n    var smallestPositiveFound bool\n    for _, v := range lst {\n    \
    \    if v < 0 {\n            if !largestNegativeFound {\n                largestNegative\
    \ = v\n                largestNegativeFound = true\n            } else if v >\
    \ largestNegative {\n                largestNegative = v\n            }\n    \
    \    } else if v > 0 {\n            if !smallestPositiveFound {\n            \
    \    smallestPositive = v\n                smallestPositiveFound = true\n    \
    \        } else if v < smallestPositive {\n                smallestPositive =\
    \ v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative,\
    \ smallest_positive int\n    var largest_negative_set, smallest_positive_set bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largest_negative_set\
    \ {\n                largest_negative = v\n                largest_negative_set\
    \ = true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeExists bool\n    var smallestPositiveExists bool\n    for _,\
    \ v := range lst {\n        if v < 0 {\n            if largestNegativeExists {\n\
    \                if v > largestNegative {\n                    largestNegative\
    \ = v\n                }\n            } else {\n                largestNegative\
    \ = v\n                largestNegativeExists = true\n            }\n        }\
    \ else {\n            if smallestPositiveExists {\n                if v < smallestPositive\
    \ {\n                    smallestPositive = v\n                }\n           \
    \ } else {\n                smallestPositive = v\n                smallestPositiveExists\
    \ = true\n            }\n        }\n    }\n    if largestNegativeExists && smallestPositiveExists\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeExists {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveExists {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largest_negative, smallest_positive\
    \ int\n    var largest_negative_set, smallest_positive_set bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if !largest_negative_set {\n\
    \                largest_negative = v\n                largest_negative_set =\
    \ true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var a, b int\n    for _, v := range lst {\n        if v < 0\
    \ {\n            if v > a {\n                a = v\n            }\n        } else\
    \ {\n            if v < b {\n                b = v\n            }\n        }\n\
    \    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n \
    \   var smallestPositive int\n    var largestNegativeFound bool\n    var smallestPositiveFound\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeExists bool\n    var\
    \ smallestPositiveExists bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largestNegativeExists {\n                if v > largestNegative\
    \ {\n                    largestNegative = v\n                }\n            }\
    \ else {\n                largestNegative = v\n                largestNegativeExists\
    \ = true\n            }\n        } else {\n            if smallestPositiveExists\
    \ {\n                if v < smallestPositive {\n                    smallestPositive\
    \ = v\n                }\n            } else {\n                smallestPositive\
    \ = v\n                smallestPositiveExists = true\n            }\n        }\n\
    \    }\n    if largestNegativeExists && smallestPositiveExists {\n        return\
    \ []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeExists\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveExists\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var a, b interface{}\n \
    \   a = nil\n    b = nil\n    for _, v := range lst {\n        if v < 0 {\n  \
    \          if a == nil {\n                a = v\n            } else if v > a.(int)\
    \ {\n                a = v\n            }\n        } else if v > 0 {\n       \
    \     if b == nil {\n                b = v\n            } else if v < b.(int)\
    \ {\n                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var a, b int\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if v > a {\n                a = v\n            }\n        } else\
    \ {\n            if v < b {\n                b = v\n            }\n        }\n\
    \    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n \
    \   var smallestPositive int\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largestNegative == 0 {\n                largestNegative = v\n\
    \            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if smallestPositive\
    \ == 0 {\n                smallestPositive = v\n            } else if v < smallestPositive\
    \ {\n                smallestPositive = v\n            }\n        }\n    }\n \
    \   return []interface{}{largestNegative, smallestPositive}\n}\n", "    var a,\
    \ b interface{}\n    for _, v := range lst {\n        if v < 0 {\n           \
    \ if a == nil {\n                a = v\n            } else if v > a.(int) {\n\
    \                a = v\n            }\n        } else if v > 0 {\n           \
    \ if b == nil {\n                b = v\n            } else if v < b.(int) {\n\
    \                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largest_negative int\n    var smallest_positive int\n   \
    \ var largest_negative_set bool\n    var smallest_positive_set bool\n    for _,\
    \ v := range lst {\n        if v < 0 {\n            if !largest_negative_set {\n\
    \                largest_negative = v\n                largest_negative_set =\
    \ true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var a, b int\n    for _, v := range lst {\n        if v < 0\
    \ {\n            if v > a {\n                a = v\n            }\n        } else\
    \ {\n            if v < b {\n                b = v\n            }\n        }\n\
    \    }\n    if a == 0 && b == 0 {\n        return []interface{}{nil, nil}\n  \
    \  }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n   \
    \ var smallestPositive int\n    var largestNegativeFound bool\n    var smallestPositiveFound\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, n := range lst {\n        if n < 0 {\n            if !largestNegativeSet\
    \ || n > largestNegative {\n                largestNegative = n\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || n < smallestPositive {\n                smallestPositive\
    \ = n\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet && smallestPositiveSet {\n        return []interface{}{largestNegative,\
    \ smallestPositive}\n    } else if largestNegativeSet {\n        return []interface{}{largestNegative,\
    \ nil}\n    } else if smallestPositiveSet {\n        return []interface{}{nil,\
    \ smallestPositive}\n    } else {\n        return []interface{}{nil, nil}\n  \
    \  }\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet || v > largestNegative {\n               \
    \ largestNegative = v\n                largestNegativeSet = true\n           \
    \ }\n        } else {\n            if !smallestPositiveSet || v < smallestPositive\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet {\n     \
    \   if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, num := range lst {\n        if num < 0 {\n            if !largestNegativeSet\
    \ || num > largestNegative {\n                largestNegative = num\n        \
    \        largestNegativeSet = true\n            }\n        } else {\n        \
    \    if !smallestPositiveSet || num < smallestPositive {\n                smallestPositive\
    \ = num\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    return []interface{}{largestNegative, smallestPositive}\n}\n", " \
    \   var largest_negative, smallest_positive int\n    var largest_negative_set,\
    \ smallest_positive_set bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largest_negative_set {\n                largest_negative = v\n\
    \                largest_negative_set = true\n            } else if v > largest_negative\
    \ {\n                largest_negative = v\n            }\n        } else if v\
    \ > 0 {\n            if !smallest_positive_set {\n                smallest_positive\
    \ = v\n                smallest_positive_set = true\n            } else if v <\
    \ smallest_positive {\n                smallest_positive = v\n            }\n\
    \        }\n    }\n    if largest_negative_set && smallest_positive_set {\n  \
    \      return []interface{}{largest_negative, smallest_positive}\n    } else if\
    \ largest_negative_set {\n        return []interface{}{largest_negative, nil}\n\
    \    } else if smallest_positive_set {\n        return []interface{}{nil, smallest_positive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b int\n    for _, v := range lst {\n        if v < 0 {\n            if v > a\
    \ {\n                a = v\n            }\n        } else {\n            if v\
    \ < b {\n                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet || v > largestNegative {\n               \
    \ largestNegative = v\n                largestNegativeSet = true\n           \
    \ }\n        } else {\n            if !smallestPositiveSet || v < smallestPositive\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet {\n     \
    \   if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largest_negative\
    \ int = 0\n    var smallest_positive int = 0\n    var is_largest_negative bool\
    \ = false\n    var is_smallest_positive bool = false\n    for _, v := range lst\
    \ {\n        if v < 0 {\n            if is_largest_negative == false {\n     \
    \           largest_negative = v\n                is_largest_negative = true\n\
    \            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if is_smallest_positive\
    \ == false {\n                smallest_positive = v\n                is_smallest_positive\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if is_largest_negative == false {\n\
    \        largest_negative = 0\n    }\n    if is_smallest_positive == false {\n\
    \        smallest_positive = 0\n    }\n    return []interface{}{largest_negative,\
    \ smallest_positive}\n}\n", "    var a, b interface{}\n    a = nil\n    b = nil\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if a == nil {\n\
    \                a = v\n            } else if v > a.(int) {\n                a\
    \ = v\n            }\n        } else if v > 0 {\n            if b == nil {\n \
    \               b = v\n            } else if v < b.(int) {\n                b\
    \ = v\n            }\n        }\n    }\n    return []interface{}{a, b}\n}\n",
  "    var a, b int\n    for _, v := range lst {\n        if v < 0 {\n           \
    \ if v > a {\n                a = v\n            }\n        } else {\n       \
    \     if v < b {\n                b = v\n            }\n        }\n    }\n   \
    \ return []interface{}{a, b}\n}\n", "    var largestNegative, smallestPositive\
    \ int\n    var largestNegativeSet, smallestPositiveSet bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeFound {\n                largestNegative = v\n\
    \                largestNegativeFound = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = v\n                smallestPositiveFound = true\n            } else if v <\
    \ smallestPositive {\n                smallestPositive = v\n            }\n  \
    \      }\n    }\n    if largestNegativeFound && smallestPositiveFound {\n    \
    \    return []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeFound\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveFound\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative int\n\
    \    var smallestPositive int\n    var largestNegativeFound bool\n    var smallestPositiveFound\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if largestNegativeSet\
    \ == false {\n                largestNegative = v\n                largestNegativeSet\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if smallestPositiveSet\
    \ == false {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeSet == false {\n\
    \        largestNegative = 0\n    }\n    if smallestPositiveSet == false {\n \
    \       smallestPositive = 0\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var a, b int\n    for _, v := range lst {\n  \
    \      if v < 0 {\n            if v > a {\n                a = v\n           \
    \ }\n        } else {\n            if v < b {\n                b = v\n       \
    \     }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    var lst_neg\
    \ []int\n    var lst_pos []int\n    var lst_out []interface{}\n    for _, v :=\
    \ range lst {\n        if v < 0 {\n            lst_neg = append(lst_neg, v)\n\
    \        } else {\n            lst_pos = append(lst_pos, v)\n        }\n    }\n\
    \    if len(lst_neg) > 0 {\n        lst_out = append(lst_out, max(lst_neg))\n\
    \    } else {\n        lst_out = append(lst_out, nil)\n    }\n    if len(lst_pos)\
    \ > 0 {\n        lst_out = append(lst_out, min(lst_pos))\n    } else {\n     \
    \   lst_out = append(lst_out, nil)\n    }\n    return lst_out\n}\n", "    var\
    \ a, b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n  \
    \      if v < 0 {\n            if a == nil {\n                a = v\n        \
    \    } else if v > a.(int) {\n                a = v\n            }\n        }\
    \ else if v > 0 {\n            if b == nil {\n                b = v\n        \
    \    } else if v < b.(int) {\n                b = v\n            }\n        }\n\
    \    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n \
    \   var smallestPositive int\n    var largestNegativeSet bool\n    var smallestPositiveSet\
    \ bool\n    for _, val := range lst {\n        if val < 0 {\n            if !largestNegativeSet\
    \ {\n                largestNegative = val\n                largestNegativeSet\
    \ = true\n            } else if val > largestNegative {\n                largestNegative\
    \ = val\n            }\n        } else if val > 0 {\n            if !smallestPositiveSet\
    \ {\n                smallestPositive = val\n                smallestPositiveSet\
    \ = true\n            } else if val < smallestPositive {\n                smallestPositive\
    \ = val\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largest_negative, smallest_positive\
    \ int\n    var largest_negative_set, smallest_positive_set bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if !largest_negative_set {\n\
    \                largest_negative = v\n                largest_negative_set =\
    \ true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var a, b int\n    for _, v := range lst {\n        if v < 0\
    \ {\n            if v > a {\n                a = v\n            }\n        } else\
    \ {\n            if v < b {\n                b = v\n            }\n        }\n\
    \    }\n    return []interface{}{a, b}\n}\n", "    var a, b int\n    var a_set,\
    \ b_set bool\n    for _, x := range lst {\n        if x < 0 {\n            if\
    \ !a_set {\n                a = x\n                a_set = true\n            }\
    \ else if x > a {\n                a = x\n            }\n        } else if x >\
    \ 0 {\n            if !b_set {\n                b = x\n                b_set =\
    \ true\n            } else if x < b {\n                b = x\n            }\n\
    \        }\n    }\n    if a_set && b_set {\n        return []interface{}{a, b}\n\
    \    } else if a_set {\n        return []interface{}{a, nil}\n    } else if b_set\
    \ {\n        return []interface{}{nil, b}\n    } else {\n        return []interface{}{nil,\
    \ nil}\n    }\n}\n", "    var largest_negative, smallest_positive int\n    var\
    \ largest_negative_set, smallest_positive_set bool\n    for _, v := range lst\
    \ {\n        if v < 0 {\n            if !largest_negative_set {\n            \
    \    largest_negative = v\n                largest_negative_set = true\n     \
    \       } else if v > largest_negative {\n                largest_negative = v\n\
    \            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet || v > largestNegative {\n               \
    \ largestNegative = v\n                largestNegativeSet = true\n           \
    \ }\n        } else {\n            if !smallestPositiveSet || v < smallestPositive\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet {\n     \
    \   if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var a, b interface{}\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if a == nil {\n\
    \                a = v\n            } else if v > a.(int) {\n                a\
    \ = v\n            }\n        } else if v > 0 {\n            if b == nil {\n \
    \               b = v\n            } else if v < b.(int) {\n                b\
    \ = v\n            }\n        }\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largest_negative, smallest_positive int\n    var largest_negative_set,\
    \ smallest_positive_set bool\n\n    for _, i := range lst {\n        if i < 0\
    \ {\n            if !largest_negative_set {\n                largest_negative\
    \ = i\n                largest_negative_set = true\n            } else if i >\
    \ largest_negative {\n                largest_negative = i\n            }\n  \
    \      } else if i > 0 {\n            if !smallest_positive_set {\n          \
    \      smallest_positive = i\n                smallest_positive_set = true\n \
    \           } else if i < smallest_positive {\n                smallest_positive\
    \ = i\n            }\n        }\n    }\n\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largest_negative, smallest_positive int\n    var largest_negative_set,\
    \ smallest_positive_set bool\n    for _, i := range lst {\n        if i < 0 {\n\
    \            if !largest_negative_set {\n                largest_negative = i\n\
    \                largest_negative_set = true\n            } else if i > largest_negative\
    \ {\n                largest_negative = i\n            }\n        } else if i\
    \ > 0 {\n            if !smallest_positive_set {\n                smallest_positive\
    \ = i\n                smallest_positive_set = true\n            } else if i <\
    \ smallest_positive {\n                smallest_positive = i\n            }\n\
    \        }\n    }\n    if largest_negative_set && smallest_positive_set {\n  \
    \      return []interface{}{largest_negative, smallest_positive}\n    } else if\
    \ largest_negative_set {\n        return []interface{}{largest_negative, nil}\n\
    \    } else if smallest_positive_set {\n        return []interface{}{nil, smallest_positive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeExists bool\n    var\
    \ smallestPositiveExists bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largestNegativeExists {\n                if v > largestNegative\
    \ {\n                    largestNegative = v\n                }\n            }\
    \ else {\n                largestNegative = v\n                largestNegativeExists\
    \ = true\n            }\n        } else {\n            if smallestPositiveExists\
    \ {\n                if v < smallestPositive {\n                    smallestPositive\
    \ = v\n                }\n            } else {\n                smallestPositive\
    \ = v\n                smallestPositiveExists = true\n            }\n        }\n\
    \    }\n    if largestNegativeExists && smallestPositiveExists {\n        return\
    \ []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeExists\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveExists\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative, smallestPositive\
    \ int\n    var largestNegativeSet, smallestPositiveSet bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var a, b int\n\
    \    var a_set, b_set bool\n    for _, n := range lst {\n        if n < 0 {\n\
    \            if !a_set {\n                a = n\n                a_set = true\n\
    \            } else if n > a {\n                a = n\n            }\n       \
    \ } else if n > 0 {\n            if !b_set {\n                b = n\n        \
    \        b_set = true\n            } else if n < b {\n                b = n\n\
    \            }\n        }\n    }\n    if !a_set {\n        a = 0\n    }\n    if\
    \ !b_set {\n        b = 0\n    }\n    return []interface{}{a, b}\n}\n", "    var\
    \ largestNegative, smallestPositive int\n    var largestNegativeFound, smallestPositiveFound\
    \ bool\n\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n\n    if !largestNegativeFound {\n   \
    \     largestNegative = 0\n    }\n    if !smallestPositiveFound {\n        smallestPositive\
    \ = 0\n    }\n\n    return []interface{}{largestNegative, smallestPositive}\n\
    }\n", "    var largestNegative, smallestPositive int\n    var largestNegativeFound,\
    \ smallestPositiveFound bool\n\n    for _, v := range lst {\n        if v < 0\
    \ {\n            if !largestNegativeFound {\n                largestNegative =\
    \ v\n                largestNegativeFound = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = v\n                smallestPositiveFound = true\n            } else if v <\
    \ smallestPositive {\n                smallestPositive = v\n            }\n  \
    \      }\n    }\n\n    if !largestNegativeFound {\n        largestNegative = nil\n\
    \    }\n    if !smallestPositiveFound {\n        smallestPositive = nil\n    }\n\
    \n    return []interface{}{largestNegative, smallestPositive}\n}\n", "    var\
    \ a, b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n  \
    \      if v < 0 {\n            if a == nil {\n                a = v\n        \
    \    } else if v > a.(int) {\n                a = v\n            }\n        }\
    \ else if v > 0 {\n            if b == nil {\n                b = v\n        \
    \    } else if v < b.(int) {\n                b = v\n            }\n        }\n\
    \    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative, smallestPositive\
    \ int\n    var largestNegativeSet, smallestPositiveSet bool\n    for _, i := range\
    \ lst {\n        if i < 0 {\n            if !largestNegativeSet || i > largestNegative\
    \ {\n                largestNegative = i\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ i < smallestPositive {\n                smallestPositive = i\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var a, b int\n\
    \    var a_set, b_set bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !a_set {\n                a = v\n                a_set = true\n\
    \            } else if v > a {\n                a = v\n            }\n       \
    \ } else if v > 0 {\n            if !b_set {\n                b = v\n        \
    \        b_set = true\n            } else if v < b {\n                b = v\n\
    \            }\n        }\n    }\n    if !a_set {\n        a = 0\n    }\n    if\
    \ !b_set {\n        b = 0\n    }\n    return []interface{}{a, b}\n}\n", "    var\
    \ largestNegative int\n    var smallestPositive int\n    var largestNegativeFound\
    \ bool\n    var smallestPositiveFound bool\n    for _, value := range lst {\n\
    \        if value < 0 {\n            if !largestNegativeFound {\n            \
    \    largestNegative = value\n                largestNegativeFound = true\n  \
    \          } else if value > largestNegative {\n                largestNegative\
    \ = value\n            }\n        } else if value > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = value\n                smallestPositiveFound\
    \ = true\n            } else if value < smallestPositive {\n                smallestPositive\
    \ = value\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var a, b interface{}\n    a =\
    \ nil\n    b = nil\n    for _, v := range lst {\n        if v < 0 {\n        \
    \    if a == nil {\n                a = v\n            } else if v > a.(int) {\n\
    \                a = v\n            }\n        } else if v > 0 {\n           \
    \ if b == nil {\n                b = v\n            } else if v < b.(int) {\n\
    \                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ isNegative bool\n    var isPositive bool\n    for _, v := range lst {\n    \
    \    if v < 0 {\n            if !isNegative {\n                largestNegative\
    \ = v\n                isNegative = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !isPositive {\n                smallestPositive = v\n  \
    \              isPositive = true\n            } else if v < smallestPositive {\n\
    \                smallestPositive = v\n            }\n        }\n    }\n    if\
    \ isNegative && isPositive {\n        return []interface{}{largestNegative, smallestPositive}\n\
    \    } else if isNegative {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if isPositive {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative\
    \ int\n    var smallest_positive int\n    var largest_negative_exists bool\n \
    \   var smallest_positive_exists bool\n    for _, v := range lst {\n        if\
    \ v < 0 {\n            if largest_negative_exists == false {\n               \
    \ largest_negative = v\n                largest_negative_exists = true\n     \
    \       } else if v > largest_negative {\n                largest_negative = v\n\
    \            }\n        } else if v > 0 {\n            if smallest_positive_exists\
    \ == false {\n                smallest_positive = v\n                smallest_positive_exists\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_exists == false\
    \ {\n        largest_negative = nil\n    }\n    if smallest_positive_exists ==\
    \ false {\n        smallest_positive = nil\n    }\n    return []interface{}{largest_negative,\
    \ smallest_positive}\n}\n", "    var largestNegative int\n    var smallestPositive\
    \ int\n    var largestNegativeFound bool\n    var smallestPositiveFound bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeFound\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative\
    \ int\n    var smallest_positive int\n    var largest_negative_set bool\n    var\
    \ smallest_positive_set bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largest_negative_set {\n                largest_negative = v\n\
    \                largest_negative_set = true\n            } else if v > largest_negative\
    \ {\n                largest_negative = v\n            }\n        } else if v\
    \ > 0 {\n            if !smallest_positive_set {\n                smallest_positive\
    \ = v\n                smallest_positive_set = true\n            } else if v <\
    \ smallest_positive {\n                smallest_positive = v\n            }\n\
    \        }\n    }\n    if largest_negative_set && smallest_positive_set {\n  \
    \      return []interface{}{largest_negative, smallest_positive}\n    } else if\
    \ largest_negative_set {\n        return []interface{}{largest_negative, nil}\n\
    \    } else if smallest_positive_set {\n        return []interface{}{nil, smallest_positive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeFound {\n                largestNegative = v\n\
    \                largestNegativeFound = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = v\n                smallestPositiveFound = true\n            } else if v <\
    \ smallestPositive {\n                smallestPositive = v\n            }\n  \
    \      }\n    }\n    if largestNegativeFound {\n        if smallestPositiveFound\
    \ {\n            return []interface{}{largestNegative, smallestPositive}\n   \
    \     } else {\n            return []interface{}{largestNegative, nil}\n     \
    \   }\n    } else {\n        if smallestPositiveFound {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var a, b interface{}\n    a = nil\n    b = nil\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if a == nil {\n\
    \                a = v\n            } else if v > a.(int) {\n                a\
    \ = v\n            }\n        } else if v > 0 {\n            if b == nil {\n \
    \               b = v\n            } else if v < b.(int) {\n                b\
    \ = v\n            }\n        }\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largest_negative_int int\n    var smallest_positive_int int\n    var largest_negative_int_found\
    \ bool\n    var smallest_positive_int_found bool\n    for _, v := range lst {\n\
    \        if v < 0 {\n            if !largest_negative_int_found {\n          \
    \      largest_negative_int = v\n                largest_negative_int_found =\
    \ true\n            } else if v > largest_negative_int {\n                largest_negative_int\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_int_found\
    \ {\n                smallest_positive_int = v\n                smallest_positive_int_found\
    \ = true\n            } else if v < smallest_positive_int {\n                smallest_positive_int\
    \ = v\n            }\n        }\n    }\n    if largest_negative_int_found && smallest_positive_int_found\
    \ {\n        return []interface{}{largest_negative_int, smallest_positive_int}\n\
    \    } else if largest_negative_int_found {\n        return []interface{}{largest_negative_int,\
    \ nil}\n    } else if smallest_positive_int_found {\n        return []interface{}{nil,\
    \ smallest_positive_int}\n    } else {\n        return []interface{}{nil, nil}\n\
    \    }\n}\n", "    var largest_negative int = 0\n    var smallest_positive int\
    \ = 0\n    var found_negative bool = false\n    var found_positive bool = false\n\
    \    for _, x := range lst {\n        if x < 0 {\n            if x > largest_negative\
    \ {\n                largest_negative = x\n            }\n            found_negative\
    \ = true\n        } else if x > 0 {\n            if smallest_positive == 0 {\n\
    \                smallest_positive = x\n            } else if x < smallest_positive\
    \ {\n                smallest_positive = x\n            }\n            found_positive\
    \ = true\n        }\n    }\n    if !found_negative {\n        largest_negative\
    \ = -1\n    }\n    if !found_positive {\n        smallest_positive = -1\n    }\n\
    \    return []interface{}{largest_negative, smallest_positive}\n}\n", "    var\
    \ largestNegative, smallestPositive int\n    var largestNegativeSet, smallestPositiveSet\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var largestNegative, smallestPositive int\n    var\
    \ largestNegativeFound, smallestPositiveFound bool\n    for _, v := range lst\
    \ {\n        if v < 0 {\n            if largestNegativeFound {\n             \
    \   if v > largestNegative {\n                    largestNegative = v\n      \
    \          }\n            } else {\n                largestNegative = v\n    \
    \            largestNegativeFound = true\n            }\n        } else {\n  \
    \          if smallestPositiveFound {\n                if v < smallestPositive\
    \ {\n                    smallestPositive = v\n                }\n           \
    \ } else {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b int\n    var a_set, b_set bool\n    for _, v := range lst {\n        if v\
    \ < 0 {\n            if !a_set {\n                a = v\n                a_set\
    \ = true\n            } else if v > a {\n                a = v\n            }\n\
    \        } else if v > 0 {\n            if !b_set {\n                b = v\n \
    \               b_set = true\n            } else if v < b {\n                b\
    \ = v\n            }\n        }\n    }\n    if !a_set {\n        a = 0\n    }\n\
    \    if !b_set {\n        b = 0\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largestNegative, smallestPositive int\n    var largestNegativeSet, smallestPositiveSet\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var largestNegative int\n    var smallestPositive\
    \ int\n    var largestNegativeSet bool\n    var smallestPositiveSet bool\n   \
    \ for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveSet\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    // the\
    \ largest of negative integers\n    var largest_neg int\n    // the smallest of\
    \ positive integers\n    var smallest_pos int\n    // the number of negative integers\n\
    \    var neg_count int\n    // the number of positive integers\n    var pos_count\
    \ int\n    // the number of zeros\n    var zero_count int\n    // the number of\
    \ non-integers\n    var non_int_count int\n    // the number of integers\n   \
    \ var int_count int\n    // the number of items in the list\n    var item_count\
    \ int\n    // the number of items in the list\n    item_count = len(lst)\n   \
    \ // loop through the list\n    for _, item := range lst {\n        // increment\
    \ the number of items\n        item_count++\n        // check if the item is an\
    \ integer\n        if item == int(item) {\n            // increment the number\
    \ of integers\n            int_count++\n            // check if the item is negative\n\
    \            if item < 0 {\n                // increment the number of negative\
    \ integers\n                neg_count++\n                // check if the item\
    \ is the largest negative\n                if item > largest_neg {\n         \
    \           // set the largest negative\n                    largest_neg = item\n\
    \                }\n            } else if item > 0 {\n                // increment\
    \ the number of positive integers\n                pos_count++\n             \
    \   // check if the item is the smallest positive\n                if item < smallest_pos\
    \ {\n                    // set the smallest positive\n                    smallest_pos\
    \ = item\n                }\n            } else {\n                // increment\
    \ the number of zeros\n                zero_count++\n            }\n        }\
    \ else {\n            // increment the number of non-integers\n            non_int_count++\n\
    \        }\n    }\n    // check if there are no integers\n    if int_count ==\
    \ 0 {\n        // return None\n        return []interface{}{nil, nil}\n    }\n\
    \    // check if there are no negative integers\n    if neg_count == 0 {\n   \
    \     // return None\n        largest_neg = nil\n    }\n    // check if there\
    \ are no positive integers\n    if pos_count == 0 {\n        // return None\n\
    \        smallest_pos = nil\n    }\n    // return the largest of negative integers\
    \ and the smallest of", "    var a, b interface{}\n    a = nil\n    b = nil\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if a == nil {\n\
    \                a = v\n            } else if v > a.(int) {\n                a\
    \ = v\n            }\n        } else if v > 0 {\n            if b == nil {\n \
    \               b = v\n            } else if v < b.(int) {\n                b\
    \ = v\n            }\n        }\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largest_negative, smallest_positive int\n    var largest_negative_set,\
    \ smallest_positive_set bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largest_negative_set {\n                largest_negative = v\n\
    \                largest_negative_set = true\n            } else if v > largest_negative\
    \ {\n                largest_negative = v\n            }\n        } else if v\
    \ > 0 {\n            if !smallest_positive_set {\n                smallest_positive\
    \ = v\n                smallest_positive_set = true\n            } else if v <\
    \ smallest_positive {\n                smallest_positive = v\n            }\n\
    \        }\n    }\n    if largest_negative_set && smallest_positive_set {\n  \
    \      return []interface{}{largest_negative, smallest_positive}\n    } else if\
    \ largest_negative_set {\n        return []interface{}{largest_negative, nil}\n\
    \    } else if smallest_positive_set {\n        return []interface{}{nil, smallest_positive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative\
    \ int\n    var smallest_positive int\n    var largest_negative_set bool\n    var\
    \ smallest_positive_set bool\n    for _, value := range lst {\n        if value\
    \ < 0 {\n            if !largest_negative_set {\n                largest_negative\
    \ = value\n                largest_negative_set = true\n            } else if\
    \ value > largest_negative {\n                largest_negative = value\n     \
    \       }\n        } else if value > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = value\n                smallest_positive_set\
    \ = true\n            } else if value < smallest_positive {\n                smallest_positive\
    \ = value\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var a, b interface{}\n    a = nil\n    b = nil\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if a == nil {\n            \
    \    a = v\n            } else if v > a.(int) {\n                a = v\n     \
    \       }\n        } else if v > 0 {\n            if b == nil {\n            \
    \    b = v\n            } else if v < b.(int) {\n                b = v\n     \
    \       }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var a, b int\n    for _, v := range lst {\n    \
    \    if v < 0 {\n            if v > a {\n                a = v\n            }\n\
    \        } else {\n            if v < b {\n                b = v\n           \
    \ }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var largestNegative, smallestPositive int\n    var\
    \ largestNegativeSet, smallestPositiveSet bool\n    for _, v := range lst {\n\
    \        if v < 0 {\n            if !largestNegativeSet || v > largestNegative\
    \ {\n                largestNegative = v\n                largestNegativeSet =\
    \ true\n            }\n        } else {\n            if !smallestPositiveSet ||\
    \ v < smallestPositive {\n                smallestPositive = v\n             \
    \   smallestPositiveSet = true\n            }\n        }\n    }\n    if largestNegativeSet\
    \ {\n        if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var a, b interface{}\n\
    \    a = nil\n    b = nil\n    for _, v := range lst {\n        if v < 0 {\n \
    \           if a == nil {\n                a = v\n            } else if v > a.(int)\
    \ {\n                a = v\n            }\n        } else if v > 0 {\n       \
    \     if b == nil {\n                b = v\n            } else if v < b.(int)\
    \ {\n                b = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var a, b int\n    var a_set, b_set bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !a_set {\n                a = v\n\
    \                a_set = true\n            } else if v > a {\n               \
    \ a = v\n            }\n        } else if v > 0 {\n            if !b_set {\n \
    \               b = v\n                b_set = true\n            } else if v <\
    \ b {\n                b = v\n            }\n        }\n    }\n    if !a_set {\n\
    \        a = 0\n    }\n    if !b_set {\n        b = 0\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeSet,\
    \ smallestPositiveSet bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeSet || v > largestNegative {\n               \
    \ largestNegative = v\n                largestNegativeSet = true\n           \
    \ }\n        } else {\n            if !smallestPositiveSet || v < smallestPositive\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            }\n        }\n    }\n    if largestNegativeSet {\n     \
    \   if smallestPositiveSet {\n            return []interface{}{largestNegative,\
    \ smallestPositive}\n        } else {\n            return []interface{}{largestNegative,\
    \ nil}\n        }\n    } else {\n        if smallestPositiveSet {\n          \
    \  return []interface{}{nil, smallestPositive}\n        } else {\n           \
    \ return []interface{}{nil, nil}\n        }\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeSet bool\n    var\
    \ smallestPositiveSet bool\n    for _, num := range lst {\n        if num < 0\
    \ {\n            if !largestNegativeSet {\n                largestNegative = num\n\
    \                largestNegativeSet = true\n            } else if num > largestNegative\
    \ {\n                largestNegative = num\n            }\n        } else if num\
    \ > 0 {\n            if !smallestPositiveSet {\n                smallestPositive\
    \ = num\n                smallestPositiveSet = true\n            } else if num\
    \ < smallestPositive {\n                smallestPositive = num\n            }\n\
    \        }\n    }\n    if largestNegativeSet && smallestPositiveSet {\n      \
    \  return []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeSet\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveSet\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative int\n\
    \    var smallestPositive int\n    var largestNegativeFound bool\n    var smallestPositiveFound\
    \ bool\n    for _, number := range lst {\n        if number < 0 {\n          \
    \  if !largestNegativeFound {\n                largestNegative = number\n    \
    \            largestNegativeFound = true\n            } else if number > largestNegative\
    \ {\n                largestNegative = number\n            }\n        } else if\
    \ number > 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = number\n                smallestPositiveFound = true\n            } else if\
    \ number < smallestPositive {\n                smallestPositive = number\n   \
    \         }\n        }\n    }\n    if largestNegativeFound && smallestPositiveFound\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeFound {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveFound {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var a,\
    \ b interface{}\n    a = nil\n    b = nil\n    for _, v := range lst {\n     \
    \   if v < 0 {\n            if a == nil {\n                a = v\n           \
    \ } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n    var\
    \ smallestPositive int\n    var largestNegativeFound bool\n    var smallestPositiveFound\
    \ bool\n    for _, v := range lst {\n        if v < 0 {\n            if largestNegativeFound\
    \ {\n                if v > largestNegative {\n                    largestNegative\
    \ = v\n                }\n            } else {\n                largestNegative\
    \ = v\n                largestNegativeFound = true\n            }\n        } else\
    \ {\n            if smallestPositiveFound {\n                if v < smallestPositive\
    \ {\n                    smallestPositive = v\n                }\n           \
    \ } else {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            }\n        }\n    }\n    var result []interface{}\n    if\
    \ largestNegativeFound {\n        result = append(result, largestNegative)\n \
    \   } else {\n        result = append(result, nil)\n    }\n    if smallestPositiveFound\
    \ {\n        result = append(result, smallestPositive)\n    } else {\n       \
    \ result = append(result, nil)\n    }\n    return result\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if !largestNegativeFound {\n                largestNegative = v\n\
    \                largestNegativeFound = true\n            } else if v > largestNegative\
    \ {\n                largestNegative = v\n            }\n        } else if v >\
    \ 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = v\n                smallestPositiveFound = true\n            } else if v <\
    \ smallestPositive {\n                smallestPositive = v\n            }\n  \
    \      }\n    }\n    if largestNegativeFound && smallestPositiveFound {\n    \
    \    return []interface{}{largestNegative, smallestPositive}\n    } else if largestNegativeFound\
    \ {\n        return []interface{}{largestNegative, nil}\n    } else if smallestPositiveFound\
    \ {\n        return []interface{}{nil, smallestPositive}\n    } else {\n     \
    \   return []interface{}{nil, nil}\n    }\n}\n", "    var largest_negative, smallest_positive\
    \ int\n    var largest_negative_set, smallest_positive_set bool\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if !largest_negative_set {\n\
    \                largest_negative = v\n                largest_negative_set =\
    \ true\n            } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallest_positive_set\
    \ {\n                smallest_positive = v\n                smallest_positive_set\
    \ = true\n            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        }\n    }\n    if largest_negative_set && smallest_positive_set\
    \ {\n        return []interface{}{largest_negative, smallest_positive}\n    }\
    \ else if largest_negative_set {\n        return []interface{}{largest_negative,\
    \ nil}\n    } else if smallest_positive_set {\n        return []interface{}{nil,\
    \ smallest_positive}\n    } else {\n        return []interface{}{nil, nil}\n \
    \   }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeSet bool\n    var smallestPositiveSet bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeSet {\n          \
    \      largestNegative = v\n                largestNegativeSet = true\n      \
    \      } else if v > largestNegative {\n                largestNegative = v\n\
    \            }\n        } else if v > 0 {\n            if !smallestPositiveSet\
    \ {\n                smallestPositive = v\n                smallestPositiveSet\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    if largestNegativeSet && smallestPositiveSet\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeSet {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveSet {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var largestNegative\
    \ int\n    var smallestPositive int\n    var largestNegativeFound bool\n    var\
    \ smallestPositiveFound bool\n    var result []interface{}\n\n    for _, v :=\
    \ range lst {\n        if v < 0 {\n            if largestNegativeFound == false\
    \ {\n                largestNegative = v\n                largestNegativeFound\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if smallestPositiveFound\
    \ == false {\n                smallestPositive = v\n                smallestPositiveFound\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n\n    if largestNegativeFound == false\
    \ {\n        result = append(result, nil)\n    } else {\n        result = append(result,\
    \ largestNegative)\n    }\n\n    if smallestPositiveFound == false {\n       \
    \ result = append(result, nil)\n    } else {\n        result = append(result,\
    \ smallestPositive)\n    }\n\n    return result\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    var largestNegativeSet, smallestPositiveSet bool\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if !largestNegativeSet\
    \ || v > largestNegative {\n                largestNegative = v\n            \
    \    largestNegativeSet = true\n            }\n        } else {\n            if\
    \ !smallestPositiveSet || v < smallestPositive {\n                smallestPositive\
    \ = v\n                smallestPositiveSet = true\n            }\n        }\n\
    \    }\n    if largestNegativeSet {\n        if smallestPositiveSet {\n      \
    \      return []interface{}{largestNegative, smallestPositive}\n        } else\
    \ {\n            return []interface{}{largestNegative, nil}\n        }\n    }\
    \ else {\n        if smallestPositiveSet {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
