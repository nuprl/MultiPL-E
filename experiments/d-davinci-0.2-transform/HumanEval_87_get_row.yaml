name: HumanEval_87_get_row
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a 2 dimensional\
  \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
  \    each row may contain a different number of columns.\n    Given lst, and integer\
  \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
  \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
  \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
  \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L,\
  \ 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
  \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
  \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
  \ lst, long x) \n"
tests: "unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
  \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
  \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
  \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
  \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
  \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
  \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
  \ 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L,\
  \ 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L,\
  \ 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L,\
  \ 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L),\
  \ tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]],\
  \ 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L,\
  \ 2L)]);\n}\nvoid main(){}"
completions: ["{\n    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n   \
    \ {\n        foreach(j, col; row)\n        {\n            if(col == x)\n     \
    \       {\n                result ~= tuple(i, j);\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    auto result = new Tuple!(long, long)[];\n\
    \    foreach(i, row; lst)\n    {\n        foreach(j, item; row)\n        {\n \
    \           if(item == x)\n            {\n                result ~= tuple(i, j);\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, col; row)\n\
    \        {\n            if(col == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, col; row)\n\
    \        {\n            if(col == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    Tuple!(long, long)[] result;\n    foreach(i,\
    \ row; lst)\n    {\n        foreach(j, col; row)\n        {\n            if(col\
    \ == x)\n            {\n                result ~= tuple(i, j);\n            }\n\
    \        }\n    }\n    return result;\n}", "{\n    auto result = new Tuple!(long,\
    \ long)[];\n    foreach(i, row; lst)\n    {\n        foreach(j, col; row)\n  \
    \      {\n            if(col == x)\n            {\n                result ~= tuple(i,\
    \ j);\n            }\n        }\n    }\n    return result;\n}", "{\n    Tuple!(long,\
    \ long)[] res;\n    foreach(i, row; lst)\n    {\n        foreach(j, col; row)\n\
    \        {\n            if(col == x)\n            {\n                res ~= tuple(i,\
    \ j);\n            }\n        }\n    }\n    return res.sort!((a, b) => a[0] <\
    \ b[0] || (a[0] == b[0] && a[1] > b[1]));\n}", "{\n    Tuple!(long, long)[] result;\n\
    \    foreach(i, row; lst)\n    {\n        foreach(j, col; row)\n        {\n  \
    \          if(col == x)\n            {\n                result ~= tuple(i, j);\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, val; row)\n\
    \        {\n            if(val == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ col; row)\n        {\n            if(col == x)\n            {\n            \
    \    result ~= tuple(i, j);\n            }\n        }\n    }\n    return result.sort!((a,\
    \ b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, col; row)\n\
    \        {\n            if(col == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    Tuple!(long, long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j,\
    \ item; row)\n        {\n            if(item == x)\n            {\n          \
    \      result ~= tuple(i, j);\n            }\n        }\n    }\n    return result.sort!((a,\
    \ b) => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, col; row)\n\
    \        {\n            if(col == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, col; row)\n\
    \        {\n            if(col == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, item; row)\n\
    \        {\n            if(item == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result.sort!((a, b)\
    \ => a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\n}", "{\n    Tuple!(long,\
    \ long)[] result;\n    foreach(i, row; lst)\n    {\n        foreach(j, elem; row)\n\
    \        {\n            if(elem == x)\n            {\n                result ~=\
    \ tuple(i, j);\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    auto result = new Tuple!(long, long)[];\n    foreach(i, row; lst)\n    {\n\
    \        foreach(j, col; row)\n        {\n            if(col == x)\n         \
    \   {\n                result ~= tuple(i, j);\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    Tuple!(long, long)[] result;\n    foreach(i,\
    \ row; lst)\n    {\n        foreach(j, elem; row)\n        {\n            if(elem\
    \ == x)\n            {\n                result ~= tuple(i, j);\n            }\n\
    \        }\n    }\n    return result.sort!((a, b) => a[0] < b[0] || (a[0] == b[0]\
    \ && a[1] > b[1]));\n}", "{\n    Tuple!(long, long)[] result;\n    foreach(i,\
    \ row; lst)\n    {\n        foreach(j, col; row)\n        {\n            if(col\
    \ == x)\n            {\n                result ~= tuple(i, j);\n            }\n\
    \        }\n    }\n    return result.sort!((a, b) => a[0] < b[0] || (a[0] == b[0]\
    \ && a[1] > b[1]));\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
