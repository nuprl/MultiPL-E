name: HumanEval_43_pairs_sum_to_zero
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    pairs_sum_to_zero takes\
  \ a list of integers as an input.\n    it returns True if there are two distinct\
  \ elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1L,\
  \ 3L, 5L, 0L])\n    false\n    >>> pairs_sum_to_zero([1L, 3L, -2L, 1L])\n    false\n\
  \    >>> pairs_sum_to_zero([1L, 2L, 3L, 7L])\n    false\n    >>> pairs_sum_to_zero([2L,\
  \ 4L, -5L, 3L, 5L, 7L])\n    true\n    >>> pairs_sum_to_zero([1L])\n    false\n\
  \    \n*/\nbool pairs_sum_to_zero(long[] l) \n"
tests: "unittest\n{\n    alias candidate = pairs_sum_to_zero;\n\n    assert(candidate([1L,\
  \ 3L, 5L, 0L]) == false);\n    assert(candidate([1L, 3L, -2L, 1L]) == false);\n\
  \    assert(candidate([1L, 2L, 3L, 7L]) == false);\n    assert(candidate([2L, 4L,\
  \ -5L, 3L, 5L, 7L]) == true);\n    assert(candidate([1L]) == false);\n    assert(candidate([-3L,\
  \ 9L, -1L, 3L, 2L, 30L]) == true);\n    assert(candidate([-3L, 9L, -1L, 3L, 2L,\
  \ 31L]) == true);\n    assert(candidate([-3L, 9L, -1L, 4L, 2L, 30L]) == false);\n\
  \    assert(candidate([-3L, 9L, -1L, 4L, 2L, 31L]) == false);\n}\nvoid main(){}"
completions: ["{\n    bool result = false;\n    foreach(long i; l)\n    {\n      \
    \  foreach(long j; l)\n        {\n            if(i + j == 0 && i != j)\n     \
    \       {\n                result = true;\n            }\n        }\n    }\n \
    \   return result;\n}\n/*", "{\n    bool result = false;\n    foreach(i; 0 ..\
    \ l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n         \
    \   if(l[i] + l[j] == 0)\n            {\n                result = true;\n    \
    \        }\n        }\n    }\n    return result;\n}", "{\n    if (l.length < 2)\
    \ \n    {\n        return false;\n    }\n    else \n    {\n        long[] sorted_l\
    \ = l.sort();\n        long[] negative_l = sorted_l.filter!(x => x < 0)();\n \
    \       long[] positive_l = sorted_l.filter!(x => x > 0)();\n        if (negative_l.length\
    \ == 0 || positive_l.length == 0) \n        {\n            return false;\n   \
    \     }\n        else \n        {\n            long[] negative_sums = negative_l.map!(x\
    \ => -x)();\n            long[] positive_sums = positive_l.map!(x => -x)();\n\
    \            return negative_sums.any!(x => positive_l.canFind(x)) || positive_sums.any!(x\
    \ => negative_l.canFind(x));\n        }\n    }\n}\n/*", "{\n    if (l.length <\
    \ 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] l_sorted\
    \ = l.dup.sort;\n        long[] l_sorted_neg = l_sorted.map!(a => -a);\n     \
    \   long[] l_sorted_neg_pos = l_sorted_neg.dup.sort;\n        bool result = false;\n\
    \        for (int i = 0; i < l_sorted.length; i++)\n        {\n            if\
    \ (l_sorted[i] == l_sorted_neg_pos[i])\n            {\n                result\
    \ = true;\n                break;\n            }\n        }\n        return result;\n\
    \    }\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    long i = 0;\n    while\
    \ (i < l2.length) \n    {\n        long j = i + 1;\n        while (j < l2.length)\
    \ \n        {\n            if (l2[i] + l2[j] == 0) \n            {\n         \
    \       return true;\n            }\n            j += 1;\n        }\n        i\
    \ += 1;\n    }\n    return false;\n}\n/*", "{\n    if (l.length < 2) \n    {\n\
    \        return false;\n    }\n    else \n    {\n        long[] l1 = l[0..$-1];\n\
    \        long[] l2 = l[1..$];\n        return pairs_sum_to_zero(l1) || pairs_sum_to_zero(l2)\
    \ ||\n            l1.any!(x => l2.any!(y => x + y == 0L));\n    }\n}\n/*", "{\n\
    \    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ 0 .. l.length)\n        {\n            if(i != j)\n            {\n         \
    \       if(l[i] + l[j] == 0)\n                {\n                    result =\
    \ true;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted_l = l.sort();\n        long[] positive_l = sorted_l.filter!(x\
    \ => x > 0)();\n        long[] negative_l = sorted_l.filter!(x => x < 0)();\n\
    \        long[] zero_l = sorted_l.filter!(x => x == 0)();\n        if (zero_l.length\
    \ > 1) \n        {\n            return true;\n        }\n        else \n     \
    \   {\n            foreach (long positive_num; positive_l) \n            {\n \
    \               foreach (long negative_num; negative_l) \n                {\n\
    \                    if (positive_num + negative_num == 0) \n                \
    \    {\n                        return true;\n                    }\n        \
    \        }\n            }\n            return false;\n        }\n    }\n}\n/*",
  "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i != j && i + j == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] l_sorted = l.dup.sort;\n        long[] l_sorted_neg\
    \ = l_sorted.map!(a => -a);\n        foreach (i; 0 .. l_sorted.length) \n    \
    \    {\n            if (l_sorted[i] == 0) \n            {\n                if\
    \ (l_sorted.count(0) > 1) \n                {\n                    return true;\n\
    \                }\n            }\n            else \n            {\n        \
    \        if (l_sorted_neg.count(l_sorted[i]) > 0) \n                {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \     return false;\n    }\n}\n/*", "{\n    if (l.length < 2)\n    {\n       \
    \ return false;\n    }\n    else\n    {\n        long[] l_sorted = l.sort();\n\
    \        long[] l_sorted_unique = l_sorted.unique;\n        long[] l_sorted_unique_neg\
    \ = l_sorted_unique.map!(a => -a)();\n        long[] l_sorted_unique_neg_sorted\
    \ = l_sorted_unique_neg.sort();\n        long[] l_sorted_unique_neg_sorted_unique\
    \ = l_sorted_unique_neg_sorted.unique;\n        return l_sorted_unique_neg_sorted_unique.length\
    \ < l_sorted_unique.length;\n    }\n}\n/*", "{\n    bool result = false;\n   \
    \ foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n    \
    \    {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}", "{\n    bool\
    \ result = false;\n    for (int i = 0; i < l.length; i++)\n    {\n        for\
    \ (int j = i + 1; j < l.length; j++)\n        {\n            if (l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    bool found = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                found = true;\n\
    \            }\n        }\n    }\n    return found;\n}\n/*", "{\n    bool result\
    \ = false;\n    for (int i = 0; i < l.length; i++)\n    {\n        for (int j\
    \ = i + 1; j < l.length; j++)\n        {\n            if (l[i] + l[j] == 0)\n\
    \            {\n                result = true;\n            }\n        }\n   \
    \ }\n    return result;\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        long[] sorted_l = l.sort();\n     \
    \   long[] distinct_l = sorted_l.dup.removeDuplicates();\n        long[] negative_l\
    \ = distinct_l.filter!(x => x < 0)();\n        long[] positive_l = distinct_l.filter!(x\
    \ => x > 0)();\n        if (negative_l.length == 0 || positive_l.length == 0)\
    \ \n        {\n            return false;\n        }\n        else \n        {\n\
    \            long[] negative_sums = negative_l.map!(x => -x)();\n            long[]\
    \ positive_sums = positive_l.map!(x => -x)();\n            return negative_sums.any!(x\
    \ => positive_l.canFind(x))() || positive_sums.any!(x => negative_l.canFind(x))();\n\
    \        }\n    }\n}\n/*", "{\n    long[] sorted_l = l.dup.sort;\n    long[] negative_sorted_l\
    \ = l.dup.sort.map!(x => -x);\n    long[] negative_sorted_l_without_zeros = negative_sorted_l.filter!(x\
    \ => x != 0);\n    long[] sorted_l_without_zeros = sorted_l.filter!(x => x !=\
    \ 0);\n    return sorted_l_without_zeros.canFind(x => negative_sorted_l_without_zeros.canFind(y\
    \ => x == y));\n}", "{\n    bool result = false;\n    for (int i = 0; i < l.length;\
    \ i++)\n    {\n        for (int j = i + 1; j < l.length; j++)\n        {\n   \
    \         if (l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    auto n =\
    \ l.length;\n    if (n < 2) return false;\n    auto l1 = l[0..$-1];\n    auto\
    \ l2 = l[1..$];\n    return (l1.sumof == -l2.sumof) || pairs_sum_to_zero(l1) ||\
    \ pairs_sum_to_zero(l2);\n}", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        long[] sorted = l.sort();\n       \
    \ long[] neg = sorted.filter!(x => x < 0);\n        long[] pos = sorted.filter!(x\
    \ => x > 0);\n        if (neg.length == 0 || pos.length == 0) \n        {\n  \
    \          return false;\n        }\n        else \n        {\n            long[]\
    \ neg_squared = neg.map!(x => x * x);\n            long[] pos_squared = pos.map!(x\
    \ => x * x);\n            long[] neg_squared_sorted = neg_squared.sort();\n  \
    \          long[] pos_squared_sorted = pos_squared.sort();\n            long[]\
    \ neg_squared_sorted_reversed = neg_squared_sorted.reverse();\n            long[]\
    \ pos_squared_sorted_reversed = pos_squared_sorted.reverse();\n            bool\
    \ neg_pos_sum_to_zero = neg_squared_sorted_reversed.zip(pos_squared_sorted).any!(x\
    \ => x[0] + x[1] == 0);\n            bool pos_neg_sum_to_zero = pos_squared_sorted_reversed.zip(neg_squared_sorted).any!(x\
    \ => x[0] + x[1] == 0);\n            return neg_pos_sum_to_zero || pos_neg_sum_to_zero;\n\
    \        }\n    }\n}\n/*"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
