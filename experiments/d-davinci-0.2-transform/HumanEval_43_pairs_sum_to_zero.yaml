name: HumanEval_43_pairs_sum_to_zero
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    pairs_sum_to_zero takes\
  \ a list of integers as an input.\n    it returns True if there are two distinct\
  \ elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1L,\
  \ 3L, 5L, 0L])\n    false\n    >>> pairs_sum_to_zero([1L, 3L, -2L, 1L])\n    false\n\
  \    >>> pairs_sum_to_zero([1L, 2L, 3L, 7L])\n    false\n    >>> pairs_sum_to_zero([2L,\
  \ 4L, -5L, 3L, 5L, 7L])\n    true\n    >>> pairs_sum_to_zero([1L])\n    false\n\
  \    \n*/\nbool pairs_sum_to_zero(long[] l) \n"
tests: "unittest\n{\n    alias candidate = pairs_sum_to_zero;\n\n    assert(candidate([1L,\
  \ 3L, 5L, 0L]) == false);\n    assert(candidate([1L, 3L, -2L, 1L]) == false);\n\
  \    assert(candidate([1L, 2L, 3L, 7L]) == false);\n    assert(candidate([2L, 4L,\
  \ -5L, 3L, 5L, 7L]) == true);\n    assert(candidate([1L]) == false);\n    assert(candidate([-3L,\
  \ 9L, -1L, 3L, 2L, 30L]) == true);\n    assert(candidate([-3L, 9L, -1L, 3L, 2L,\
  \ 31L]) == true);\n    assert(candidate([-3L, 9L, -1L, 4L, 2L, 30L]) == false);\n\
  \    assert(candidate([-3L, 9L, -1L, 4L, 2L, 31L]) == false);\n}\nvoid main(){}"
completions: ["{\n    bool result = false;\n    foreach(long i; l)\n    {\n      \
    \  foreach(long j; l)\n        {\n            if(i + j == 0 && i != j)\n     \
    \       {\n                result = true;\n            }\n        }\n    }\n \
    \   return result;\n}\n/*", "{\n    bool result = false;\n    foreach(i; 0 ..\
    \ l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n         \
    \   if(l[i] + l[j] == 0)\n            {\n                result = true;\n    \
    \        }\n        }\n    }\n    return result;\n}", "{\n    if (l.length < 2)\
    \ \n    {\n        return false;\n    }\n    else \n    {\n        long[] sorted_l\
    \ = l.sort();\n        long[] negative_l = sorted_l.filter!(x => x < 0)();\n \
    \       long[] positive_l = sorted_l.filter!(x => x > 0)();\n        if (negative_l.length\
    \ == 0 || positive_l.length == 0) \n        {\n            return false;\n   \
    \     }\n        else \n        {\n            long[] negative_sums = negative_l.map!(x\
    \ => -x)();\n            long[] positive_sums = positive_l.map!(x => -x)();\n\
    \            return negative_sums.any!(x => positive_l.canFind(x)) || positive_sums.any!(x\
    \ => negative_l.canFind(x));\n        }\n    }\n}\n/*", "{\n    if (l.length <\
    \ 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] l_sorted\
    \ = l.dup.sort;\n        long[] l_sorted_neg = l_sorted.map!(a => -a);\n     \
    \   long[] l_sorted_neg_pos = l_sorted_neg.dup.sort;\n        bool result = false;\n\
    \        for (int i = 0; i < l_sorted.length; i++)\n        {\n            if\
    \ (l_sorted[i] == l_sorted_neg_pos[i])\n            {\n                result\
    \ = true;\n                break;\n            }\n        }\n        return result;\n\
    \    }\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    long i = 0;\n    while\
    \ (i < l2.length) \n    {\n        long j = i + 1;\n        while (j < l2.length)\
    \ \n        {\n            if (l2[i] + l2[j] == 0) \n            {\n         \
    \       return true;\n            }\n            j += 1;\n        }\n        i\
    \ += 1;\n    }\n    return false;\n}\n/*", "{\n    if (l.length < 2) \n    {\n\
    \        return false;\n    }\n    else \n    {\n        long[] l1 = l[0..$-1];\n\
    \        long[] l2 = l[1..$];\n        return pairs_sum_to_zero(l1) || pairs_sum_to_zero(l2)\
    \ ||\n            l1.any!(x => l2.any!(y => x + y == 0L));\n    }\n}\n/*", "{\n\
    \    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ 0 .. l.length)\n        {\n            if(i != j)\n            {\n         \
    \       if(l[i] + l[j] == 0)\n                {\n                    result =\
    \ true;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted_l = l.sort();\n        long[] positive_l = sorted_l.filter!(x\
    \ => x > 0)();\n        long[] negative_l = sorted_l.filter!(x => x < 0)();\n\
    \        long[] zero_l = sorted_l.filter!(x => x == 0)();\n        if (zero_l.length\
    \ > 1) \n        {\n            return true;\n        }\n        else \n     \
    \   {\n            foreach (long positive_num; positive_l) \n            {\n \
    \               foreach (long negative_num; negative_l) \n                {\n\
    \                    if (positive_num + negative_num == 0) \n                \
    \    {\n                        return true;\n                    }\n        \
    \        }\n            }\n            return false;\n        }\n    }\n}\n/*",
  "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i != j && i + j == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] l_sorted = l.dup.sort;\n        long[] l_sorted_neg\
    \ = l_sorted.map!(a => -a);\n        foreach (i; 0 .. l_sorted.length) \n    \
    \    {\n            if (l_sorted[i] == 0) \n            {\n                if\
    \ (l_sorted.count(0) > 1) \n                {\n                    return true;\n\
    \                }\n            }\n            else \n            {\n        \
    \        if (l_sorted_neg.count(l_sorted[i]) > 0) \n                {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \     return false;\n    }\n}\n/*", "{\n    if (l.length < 2)\n    {\n       \
    \ return false;\n    }\n    else\n    {\n        long[] l_sorted = l.sort();\n\
    \        long[] l_sorted_unique = l_sorted.unique;\n        long[] l_sorted_unique_neg\
    \ = l_sorted_unique.map!(a => -a)();\n        long[] l_sorted_unique_neg_sorted\
    \ = l_sorted_unique_neg.sort();\n        long[] l_sorted_unique_neg_sorted_unique\
    \ = l_sorted_unique_neg_sorted.unique;\n        return l_sorted_unique_neg_sorted_unique.length\
    \ < l_sorted_unique.length;\n    }\n}\n/*", "{\n    bool result = false;\n   \
    \ foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n    \
    \    {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}", "{\n    bool\
    \ result = false;\n    for (int i = 0; i < l.length; i++)\n    {\n        for\
    \ (int j = i + 1; j < l.length; j++)\n        {\n            if (l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    bool found = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                found = true;\n\
    \            }\n        }\n    }\n    return found;\n}\n/*", "{\n    bool result\
    \ = false;\n    for (int i = 0; i < l.length; i++)\n    {\n        for (int j\
    \ = i + 1; j < l.length; j++)\n        {\n            if (l[i] + l[j] == 0)\n\
    \            {\n                result = true;\n            }\n        }\n   \
    \ }\n    return result;\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        long[] sorted_l = l.sort();\n     \
    \   long[] distinct_l = sorted_l.dup.removeDuplicates();\n        long[] negative_l\
    \ = distinct_l.filter!(x => x < 0)();\n        long[] positive_l = distinct_l.filter!(x\
    \ => x > 0)();\n        if (negative_l.length == 0 || positive_l.length == 0)\
    \ \n        {\n            return false;\n        }\n        else \n        {\n\
    \            long[] negative_sums = negative_l.map!(x => -x)();\n            long[]\
    \ positive_sums = positive_l.map!(x => -x)();\n            return negative_sums.any!(x\
    \ => positive_l.canFind(x))() || positive_sums.any!(x => negative_l.canFind(x))();\n\
    \        }\n    }\n}\n/*", "{\n    long[] sorted_l = l.dup.sort;\n    long[] negative_sorted_l\
    \ = l.dup.sort.map!(x => -x);\n    long[] negative_sorted_l_without_zeros = negative_sorted_l.filter!(x\
    \ => x != 0);\n    long[] sorted_l_without_zeros = sorted_l.filter!(x => x !=\
    \ 0);\n    return sorted_l_without_zeros.canFind(x => negative_sorted_l_without_zeros.canFind(y\
    \ => x == y));\n}", "{\n    bool result = false;\n    for (int i = 0; i < l.length;\
    \ i++)\n    {\n        for (int j = i + 1; j < l.length; j++)\n        {\n   \
    \         if (l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    auto n =\
    \ l.length;\n    if (n < 2) return false;\n    auto l1 = l[0..$-1];\n    auto\
    \ l2 = l[1..$];\n    return (l1.sumof == -l2.sumof) || pairs_sum_to_zero(l1) ||\
    \ pairs_sum_to_zero(l2);\n}", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        long[] sorted = l.sort();\n       \
    \ long[] neg = sorted.filter!(x => x < 0);\n        long[] pos = sorted.filter!(x\
    \ => x > 0);\n        if (neg.length == 0 || pos.length == 0) \n        {\n  \
    \          return false;\n        }\n        else \n        {\n            long[]\
    \ neg_squared = neg.map!(x => x * x);\n            long[] pos_squared = pos.map!(x\
    \ => x * x);\n            long[] neg_squared_sorted = neg_squared.sort();\n  \
    \          long[] pos_squared_sorted = pos_squared.sort();\n            long[]\
    \ neg_squared_sorted_reversed = neg_squared_sorted.reverse();\n            long[]\
    \ pos_squared_sorted_reversed = pos_squared_sorted.reverse();\n            bool\
    \ neg_pos_sum_to_zero = neg_squared_sorted_reversed.zip(pos_squared_sorted).any!(x\
    \ => x[0] + x[1] == 0);\n            bool pos_neg_sum_to_zero = pos_squared_sorted_reversed.zip(neg_squared_sorted).any!(x\
    \ => x[0] + x[1] == 0);\n            return neg_pos_sum_to_zero || pos_neg_sum_to_zero;\n\
    \        }\n    }\n}\n/*", "{\n    long[] sorted_l = l.dup.sort;\n    int i =\
    \ 0;\n    int j = sorted_l.length - 1;\n    while (i < j) {\n        long sum\
    \ = sorted_l[i] + sorted_l[j];\n        if (sum == 0) {\n            return true;\n\
    \        } else if (sum < 0) {\n            i += 1;\n        } else {\n      \
    \      j -= 1;\n        }\n    }\n    return false;\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] l2\
    \ = l[1..$];\n        foreach (i; l2)\n        {\n            if (l[0] + i ==\
    \ 0)\n            {\n                return true;\n            }\n        }\n\
    \        return pairs_sum_to_zero(l2);\n    }\n}", "{\n    if (l.length < 2)\n\
    \    {\n        return false;\n    }\n    else\n    {\n        foreach (i; l)\n\
    \        {\n            foreach (j; l)\n            {\n                if (i +\
    \ j == 0 && i != j)\n                {\n                    return true;\n   \
    \             }\n            }\n        }\n        return false;\n    }\n}", "{\n\
    \    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] l2 = l[1..$];\n        foreach (long i; l2)\n        {\n     \
    \       if (l.find(i * -1) != -1)\n            {\n                return true;\n\
    \            }\n        }\n        return false;\n    }\n}\n/*", "{\n    return\
    \ l.length > 1 && l.length < 4;\n}", "{\n    if (l.length < 2)\n    {\n      \
    \  return false;\n    }\n    else\n    {\n        foreach (i; 0 .. l.length)\n\
    \        {\n            foreach (j; i + 1 .. l.length)\n            {\n      \
    \          if (l[i] + l[j] == 0)\n                {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;\n\
    \    }\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n\
    \    else\n    {\n        long[] l2 = l[1..$];\n        foreach (long x; l2)\n\
    \        {\n            if (l.find(-x) != -1)\n            {\n               \
    \ return true;\n            }\n        }\n        return false;\n    }\n}\n/*",
  "{\n    bool result = false;\n    for (int i = 0; i < l.length; i++)\n    {\n  \
    \      for (int j = i + 1; j < l.length; j++)\n        {\n            if (l[i]\
    \ + l[j] == 0)\n            {\n                result = true;\n            }\n\
    \        }\n    }\n    return result;\n}\n/*", "{\n    long[] sorted = l.dup.sort;\n\
    \    long[] distinct = sorted.dup.uniq;\n    foreach(i; 0..distinct.length)\n\
    \    {\n        if(distinct[i] == 0)\n        {\n            if(sorted.count(0)\
    \ >= 2)\n            {\n                return true;\n            }\n        }\n\
    \        else\n        {\n            if(sorted.count(distinct[i]) >= 1 && sorted.count(-distinct[i])\
    \ >= 1)\n            {\n                return true;\n            }\n        }\n\
    \    }\n    return false;\n}\n/*", "{\n    bool[] seen = new bool[l.length];\n\
    \    foreach(long i; l) \n    {\n        if (seen[abs(i)]) \n        {\n     \
    \       return true;\n        }\n        seen[abs(i)] = true;\n    }\n    return\
    \ false;\n}", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n\
    \    else \n    {\n        long[] sorted = l.sort();\n        long[] negs = sorted.filter!(x\
    \ => x < 0).array;\n        long[] poss = sorted.filter!(x => x > 0).array;\n\
    \        if (negs.length == 0 || poss.length == 0) \n        {\n            return\
    \ false;\n        }\n        else \n        {\n            long[] negs_rev = negs.reverse();\n\
    \            long[] poss_rev = poss.reverse();\n            long[] negs_rev_cumsum\
    \ = negs_rev.scan!((a, b) => a + b)(0L).array;\n            long[] poss_rev_cumsum\
    \ = poss_rev.scan!((a, b) => a + b)(0L).array;\n            long[] negs_rev_cumsum_rev\
    \ = negs_rev_cumsum.reverse();\n            long[] poss_rev_cumsum_rev = poss_rev_cumsum.reverse();\n\
    \            long[] negs_rev_cumsum_rev_poss = negs_rev_cumsum_rev.zip(poss_rev_cumsum_rev).map!(x\
    \ => x[0] * x[1]).array;\n            long[] poss_rev_cumsum_rev_negs = poss_rev_cumsum_rev.zip(negs_rev_cumsum_rev).map!(x\
    \ => x[0] * x[1]).array;\n            long[] negs_rev_cumsum_rev_poss_rev = negs_rev_cumsum_rev_poss.reverse();\n\
    \            long[] poss_rev_cumsum_rev_negs_rev = poss_rev_cumsum_rev_negs.reverse();\n\
    \            long[] negs_rev_cumsum_rev_poss_rev_negs_rev = negs_rev_cumsum_rev_poss_rev.zip(poss_rev_cumsum_rev_negs_rev).map!(x\
    \ => x[0]", "{\n    bool result = false;\n    for (int i = 0; i < l.length; i++)\n\
    \    {\n        for (int j = i + 1; j < l.length; j++)\n        {\n          \
    \  if (l[i] + l[j] == 0)\n            {\n                result = true;\n    \
    \        }\n        }\n    }\n    return result;\n}", "{\n    bool result = false;\n\
    \    foreach(i; 0..l.length)\n    {\n        foreach(j; i+1..l.length)\n     \
    \   {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}", "{\n    bool\
    \ result = false;\n    foreach(i; 0..l.length)\n    {\n        foreach(j; i+1..l.length)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}", "{\n    bool\
    \ ret = false;\n    foreach(long i; l)\n    {\n        foreach(long j; l)\n  \
    \      {\n            if(i + j == 0 && i != j)\n            {\n              \
    \  ret = true;\n            }\n        }\n    }\n    return ret;\n}", "{\n   \
    \ bool result = false;\n    long[] l_sorted = l.dup.sort;\n    long[] l_sorted_neg\
    \ = l_sorted.map!(a => -a);\n    foreach(i, e; l_sorted)\n    {\n        if(l_sorted_neg.canFind(e))\n\
    \        {\n            result = true;\n            break;\n        }\n    }\n\
    \    return result;\n}", "{\n    bool result = false;\n    foreach(i; 0..l.length)\n\
    \    {\n        foreach(j; i+1..l.length)\n        {\n            if(l[i] + l[j]\
    \ == 0)\n            {\n                result = true;\n            }\n      \
    \  }\n    }\n    return result;\n}\n/*", "{\n    bool result = false;\n    foreach(i;\
    \ 0..l.length)\n    {\n        foreach(j; i+1..l.length)\n        {\n        \
    \    if(l[i] + l[j] == 0)\n            {\n                result = true;\n   \
    \         }\n        }\n    }\n    return result;\n}", "{\n    if (l.length <\
    \ 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[] sorted\
    \ = l.sort();\n        long[] negative = sorted.filter!(x => x < 0);\n       \
    \ long[] positive = sorted.filter!(x => x > 0);\n        if (negative.length >\
    \ 0 && positive.length > 0) \n        {\n            return negative.any!(x =>\
    \ positive.any!(y => x + y == 0));\n        }\n        else \n        {\n    \
    \        return false;\n        }\n    }\n}\n/*", "{\n    if (l.length < 2)\n\
    \    {\n        return false;\n    }\n    else\n    {\n        long[] sorted =\
    \ l.dup.sort();\n        long[] negatives = sorted.filter!(x => x < 0);\n    \
    \    long[] positives = sorted.filter!(x => x > 0);\n        long[] zeros = sorted.filter!(x\
    \ => x == 0);\n        if (zeros.length > 1)\n        {\n            return true;\n\
    \        }\n        else\n        {\n            foreach (i; 0 .. negatives.length)\n\
    \            {\n                foreach (j; 0 .. positives.length)\n         \
    \       {\n                    if (negatives[i] + positives[j] == 0)\n       \
    \             {\n                        return true;\n                    }\n\
    \                }\n            }\n            return false;\n        }\n    }\n\
    }", "{\n    bool[] seen = new bool[l.length];\n    foreach(i; 0..l.length)\n \
    \   {\n        if(seen[l[i]])\n        {\n            return true;\n        }\n\
    \        seen[-l[i]] = true;\n    }\n    return false;\n}", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] l2\
    \ = l[1..$];\n        foreach (long i; l2)\n        {\n            if (l[0] +\
    \ i == 0)\n            {\n                return true;\n            }\n      \
    \  }\n        return pairs_sum_to_zero(l2);\n    }\n}\n/*", "{\n    bool result\
    \ = false;\n    foreach(i; 0..l.length)\n    {\n        foreach(j; i+1..l.length)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] l_sorted = l.dup.sort();\n        long[] l_sorted_neg = l_sorted.map!(a\
    \ => -a);\n        long[] l_sorted_neg_rev = l_sorted_neg.dup.reverse;\n     \
    \   long[] l_sorted_neg_rev_neg = l_sorted_neg_rev.map!(a => -a);\n        long[]\
    \ l_sorted_neg_rev_neg_rev = l_sorted_neg_rev_neg.dup.reverse;\n        long[]\
    \ l_sorted_neg_rev_neg_rev_sorted = l_sorted_neg_rev_neg_rev.dup.sort;\n     \
    \   long[] l_sorted_neg_rev_neg_rev_sorted_neg = l_sorted_neg_rev_neg_rev_sorted.map!(a\
    \ => -a);\n        long[] l_sorted_neg_rev_neg_rev_sorted_neg_rev = l_sorted_neg_rev_neg_rev_sorted_neg.dup.reverse;\n\
    \        long[] l_sorted_neg_rev_neg_rev_sorted_neg_rev_neg = l_sorted_neg_rev_neg_rev_sorted_neg_rev.map!(a\
    \ => -a);\n        long[] l_sorted_neg_rev_neg_rev_sorted_neg_rev_neg_rev = l_sorted_neg_rev_neg_rev_sorted_neg_rev_neg.dup.reverse;\n\
    \        long[] l_sorted_neg_rev_neg_rev_sorted_neg_rev_neg_rev_sorted = l_sorted_neg_rev_neg_rev_sorted_neg_rev_neg_rev.dup.sort;\n\
    \        long[] l_sorted_neg_rev_neg_rev_sorted_neg_rev_neg_rev_sorted_neg = l_sorted_neg_rev_neg_rev_sorted_neg_rev_",
  "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] l2 = l[1..$];\n        foreach (i; l2)\n        {\n          \
    \  if (l[0] + i == 0)\n            {\n                return true;\n         \
    \   }\n        }\n        return pairs_sum_to_zero(l2);\n    }\n}", "{\n    //\
    \ your code here\n    return false;\n}\n/*", "{\n    bool result = false;\n  \
    \  for (int i = 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j <\
    \ l.length; j++)\n        {\n            if (l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i + j == 0 && i != j)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n \
    \       foreach(j; i+1 .. l.length)\n        {\n            if (l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    if (l.length < 2)\n    {\n       \
    \ return false;\n    }\n    else\n    {\n        long[] sorted = l.sort();\n \
    \       long[] negative = sorted.filter!(x => x < 0);\n        long[] positive\
    \ = sorted.filter!(x => x > 0);\n        return negative.any!(x => positive.any!(y\
    \ => x + y == 0));\n    }\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n    long\
    \ i = 0;\n    long j = l2.length - 1;\n    while (i < j) {\n        if (l2[i]\
    \ + l2[j] == 0) {\n            return true;\n        } else if (l2[i] + l2[j]\
    \ < 0) {\n            i += 1;\n        } else {\n            j -= 1;\n       \
    \ }\n    }\n    return false;\n}\n/*", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i + 1 .. l.length)\n        {\n  \
    \          if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long[] sorted\
    \ = l.dup.sort();\n    long[] negs = sorted.filter!(x => x < 0L);\n    long[]\
    \ poss = sorted.filter!(x => x > 0L);\n    long[] zeros = sorted.filter!(x =>\
    \ x == 0L);\n    if (zeros.length > 1)\n        return true;\n    for (long n\
    \ in negs)\n    {\n        if (poss.canFind(x => x == -n))\n            return\
    \ true;\n    }\n    return false;\n}\n/*", "{\n    bool result = false;\n    for\
    \ (int i = 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j < l.length;\
    \ j++)\n        {\n            if (l[i] + l[j] == 0)\n            {\n        \
    \        result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n \
    \       foreach(j; i + 1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    bool result = false;\n    for (int i =\
    \ 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j < l.length; j++)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    long[] l1 = l.dup;\n    l1.sort();\n    long[] l2 = l1.dup;\n    long[]\
    \ l3 = l1.dup;\n    l2.popFront();\n    l3.popBack();\n    return l1.front + l2.front\
    \ == 0 || l1.back + l3.back == 0;\n}", "{\n    if (l.length < 2) \n    {\n   \
    \     return false;\n    }\n    else \n    {\n        long[] l_sorted = l.sort();\n\
    \        long[] l_sorted_unique = l_sorted.dup.unique;\n        long[] l_sorted_unique_neg\
    \ = l_sorted_unique.map!(a => -a);\n        return l_sorted_unique.any!(a => l_sorted_unique_neg.canFind(a));\n\
    \    }\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n\
    \    else\n    {\n        int i = 0;\n        int j = 0;\n        while (i < l.length)\n\
    \        {\n            j = i + 1;\n            while (j < l.length)\n       \
    \     {\n                if (l[i] + l[j] == 0)\n                {\n          \
    \          return true;\n                }\n                j = j + 1;\n     \
    \       }\n            i = i + 1;\n        }\n        return false;\n    }\n}\n\
    /*", "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i + j == 0)\n            {\n              \
    \  result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i != j && i + j == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n \
    \       foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        long[] sorted = l.sort();\n       \
    \ long[] negative = sorted.filter!(x => x < 0);\n        long[] positive = sorted.filter!(x\
    \ => x > 0);\n        long[] zero = sorted.filter!(x => x == 0);\n        if (zero.length\
    \ > 1) \n        {\n            return true;\n        }\n        else \n     \
    \   {\n            foreach (n; negative) \n            {\n                if (positive.canFind(x\
    \ => x == -n)) \n                {\n                    return true;\n       \
    \         }\n            }\n            return false;\n        }\n    }\n}\n/*",
  "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n \
    \       foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    bool result = false;\n    for (int i =\
    \ 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j < l.length; j++)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i != j && i + j == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n\
    \    {\n        long[] sorted = l.sort();\n        long[] neg = sorted.filter!(x\
    \ => x < 0);\n        long[] pos = sorted.filter!(x => x > 0);\n        foreach\
    \ (n; neg)\n        {\n            foreach (p; pos)\n            {\n         \
    \       if (n + p == 0)\n                {\n                    return true;\n\
    \                }\n            }\n        }\n        return false;\n    }\n}\n\
    /*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] l_sorted = l.sort();\n        long[] l_sorted_unique\
    \ = l_sorted.unique;\n        long[] l_sorted_unique_neg = l_sorted_unique.map!(a\
    \ => -a);\n        return l_sorted_unique.intersect(l_sorted_unique_neg).length\
    \ > 0;\n    }\n}\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; 0 .. l.length)\n        {\n            if(i != j &&\
    \ l[i] + l[j] == 0)\n            {\n                result = true;\n         \
    \   }\n        }\n    }\n    return result;\n}", "{\n    bool result = false;\n\
    \    foreach(i; l)\n    {\n        foreach(j; l)\n        {\n            if(i\
    \ != j && i + j == 0)\n            {\n                result = true;\n       \
    \     }\n        }\n    }\n    return result;\n}", "{\n    bool result = false;\n\
    \    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n \
    \       {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i != j && i + j == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    // your code here\n    return false;\n}\n/*", "{\n    bool result\
    \ = false;\n    foreach(long i; l)\n    {\n        foreach(long j; l)\n      \
    \  {\n            if(i != j && i + j == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    long[] sorted = l.dup.sort;\n    long[] negative = sorted.filter!(x\
    \ => x < 0);\n    long[] positive = sorted.filter!(x => x > 0);\n    long[] zero\
    \ = sorted.filter!(x => x == 0);\n    if (zero.length > 1)\n        return true;\n\
    \    else\n    {\n        foreach (n; negative)\n        {\n            if (positive.canFind(x\
    \ => x == -n))\n                return true;\n        }\n        return false;\n\
    \    }\n}", "{\n    bool result = false;\n    for (int i = 0; i < l.length; i++)\n\
    \    {\n        for (int j = i + 1; j < l.length; j++)\n        {\n          \
    \  if (l[i] + l[j] == 0)\n            {\n                result = true;\n    \
    \        }\n        }\n    }\n    return result;\n}\n/*", "{\n    long[] l2 =\
    \ l.dup;\n    l2.sort;\n    long i = 0;\n    long j = l2.length - 1;\n    while\
    \ (i < j) \n    {\n        if (l2[i] + l2[j] == 0) \n        {\n            return\
    \ true;\n        }\n        else if (l2[i] + l2[j] < 0) \n        {\n        \
    \    i++;\n        }\n        else \n        {\n            j--;\n        }\n\
    \    }\n    return false;\n}\n/*", "{\n    bool result = false;\n    foreach(long\
    \ x; l)\n    {\n        foreach(long y; l)\n        {\n            if(x + y ==\
    \ 0 && x != y)\n            {\n                result = true;\n            }\n\
    \        }\n    }\n    return result;\n}", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool result\
    \ = false;\n    long[] sorted_l = l.dup.sort;\n    for (size_t i = 0; i < sorted_l.length;\
    \ i++)\n    {\n        if (sorted_l[i] == 0)\n        {\n            if (i < sorted_l.length\
    \ - 1)\n            {\n                if (sorted_l[i + 1] == 0)\n           \
    \     {\n                    result = true;\n                    break;\n    \
    \            }\n            }\n        }\n        else\n        {\n          \
    \  if (sorted_l.binarySearch(0 - sorted_l[i]) != -1)\n            {\n        \
    \        result = true;\n                break;\n            }\n        }\n  \
    \  }\n    return result;\n}", "{\n    if (l.length < 2)\n    {\n        return\
    \ false;\n    }\n    else\n    {\n        long[] l_sorted = l.sort();\n      \
    \  long[] l_unique = l_sorted.unique;\n        long[] l_unique_neg = l_unique.map!(a\
    \ => -a);\n        return l_unique.intersect(l_unique_neg).length > 0;\n    }\n\
    }", "{\n    long[] sorted = l.dup.sort;\n    long[] negs = sorted.filter!(x =>\
    \ x < 0L);\n    long[] pos = sorted.filter!(x => x > 0L);\n    foreach(i; 0..negs.length)\n\
    \    {\n        foreach(j; 0..pos.length)\n        {\n            if(negs[i] +\
    \ pos[j] == 0L)\n            {\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}\n/*", "{\n    bool result = false;\n \
    \   foreach(long i; l)\n    {\n        foreach(long j; l)\n        {\n       \
    \     if (i + j == 0 && i != j)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted_l = l.dup.sort;\n        long[] negative_l = sorted_l.filter!(x => x\
    \ < 0).map!(abs);\n        long[] positive_l = sorted_l.filter!(x => x >= 0);\n\
    \        return negative_l.any!(x => positive_l.any!(y => x == y));\n    }\n}",
  "{\n    bool result = false;\n    long[] temp = l.dup;\n    temp.sort;\n    foreach(long\
    \ i; temp)\n    {\n        if(temp.count(i) > 1)\n        {\n            result\
    \ = true;\n            break;\n        }\n        if(temp.count(-i) > 0)\n   \
    \     {\n            result = true;\n            break;\n        }\n    }\n  \
    \  return result;\n}\n/*", "{\n    return l.length > 1 && l.sort.zip(l.sort[1..$]).any!((a,\
    \ b) => a + b == 0);\n}", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] +\
    \ l[j] == 0)\n            {\n                result = true;\n            }\n \
    \       }\n    }\n    return result;\n}", "{\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] +\
    \ l[j] == 0)\n            {\n                return true;\n            }\n   \
    \     }\n    }\n    return false;\n}\n/*", "{\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] +\
    \ l[j] == 0)\n            {\n                return true;\n            }\n   \
    \     }\n    }\n    return false;\n}\n/*", "{\n    if (l.length < 2) \n    {\n\
    \        return false;\n    }\n    else \n    {\n        long[] sorted = l.dup.sort;\n\
    \        long[] negs = sorted.filter!(x => x < 0);\n        long[] pos = sorted.filter!(x\
    \ => x > 0);\n        for (int i = 0; i < negs.length; i++) \n        {\n    \
    \        for (int j = 0; j < pos.length; j++) \n            {\n              \
    \  if (negs[i] + pos[j] == 0) \n                {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;\n\
    \    }\n}", "{\n    long[] l1 = l.dup;\n    l1.sort;\n    long[] l2 = l1.dup;\n\
    \    l2.reverse;\n    long[] l3 = l1.dup;\n    long[] l4 = l2.dup;\n    long[]\
    \ l5 = l3.dup;\n    long[] l6 = l4.dup;\n    long[] l7 = l5.dup;\n    long[] l8\
    \ = l6.dup;\n    long[] l9 = l7.dup;\n    long[] l10 = l8.dup;\n    long[] l11\
    \ = l9.dup;\n    long[] l12 = l10.dup;\n    long[] l13 = l11.dup;\n    long[]\
    \ l14 = l12.dup;\n    long[] l15 = l13.dup;\n    long[] l16 = l14.dup;\n    long[]\
    \ l17 = l15.dup;\n    long[] l18 = l16.dup;\n    long[] l19 = l17.dup;\n    long[]\
    \ l20 = l18.dup;\n    long[] l21 = l19.dup;\n    long[] l22 = l20.dup;\n    long[]\
    \ l23 = l21.dup;\n    long[] l24 = l22.dup;\n    long[] l25 = l23.dup;\n    long[]\
    \ l26 = l24.dup;\n    long[] l27 = l25.dup;\n    long[] l28 = l26.dup;\n    long[]\
    \ l29 = l27.dup;\n    long[] l30 = l28.dup;\n    long[] l31 = l29.dup;\n    long[]\
    \ l32 = l30.dup;\n    long[] l33 = l31.dup;\n    long[] l34 = l32.dup;\n    long[]\
    \ l35 = l33.dup;\n    long[] l36 = l34.dup;\n    long[] l37 = l35.dup;\n    long[]\
    \ l38 = l36.dup;\n    long", "{\n    bool result = false;\n    for (int i = 0;\
    \ i < l.length; i++)\n    {\n        for (int j = i + 1; j < l.length; j++)\n\
    \        {\n            if (l[i] + l[j] == 0)\n            {\n               \
    \ result = true;\n            }\n        }\n    }\n    return result;\n}\n/*",
  "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        foreach (i; 0 .. l.length)\n        {\n            foreach (j; i + 1\
    \ .. l.length)\n            {\n                if (l[i] + l[j] == 0)\n       \
    \         {\n                    return true;\n                }\n           \
    \ }\n        }\n        return false;\n    }\n}", "{\n    if (l.length < 2)\n\
    \    {\n        return false;\n    }\n    else\n    {\n        long[] sorted =\
    \ l.dup.sort;\n        long[] negative = sorted.filter!(x => x < 0);\n       \
    \ long[] positive = sorted.filter!(x => x > 0);\n        if (negative.length >\
    \ 0 && positive.length > 0)\n        {\n            long[] negative_squared =\
    \ negative.map!(x => x * x);\n            long[] positive_squared = positive.map!(x\
    \ => x * x);\n            long[] negative_squared_sorted = negative_squared.sort;\n\
    \            long[] positive_squared_sorted = positive_squared.sort;\n       \
    \     foreach (long n; negative_squared_sorted)\n            {\n             \
    \   foreach (long p; positive_squared_sorted)\n                {\n           \
    \         if (n == p)\n                    {\n                        return true;\n\
    \                    }\n                    else if (n > p)\n                \
    \    {\n                        break;\n                    }\n              \
    \  }\n            }\n            return false;\n        }\n        else\n    \
    \    {\n            return false;\n        }\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted = l.sort();\n        long[] neg = sorted.filter!(x => x < 0);\n     \
    \   long[] pos = sorted.filter!(x => x > 0);\n        long[] zeros = sorted.filter!(x\
    \ => x == 0);\n        if (zeros.length > 1) \n        {\n            return true;\n\
    \        }\n        else \n        {\n            foreach (n; neg) \n        \
    \    {\n                if (pos.canFind(-n)) \n                {\n           \
    \         return true;\n                }\n            }\n            return false;\n\
    \        }\n    }\n}\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] +\
    \ l[j] == 0)\n            {\n                result = true;\n            }\n \
    \       }\n    }\n    return result;\n}\n/*", "{\n    int n = l.length;\n    if\
    \ (n < 2) return false;\n    int i = 0;\n    while (i < n - 1) {\n        int\
    \ j = i + 1;\n        while (j < n) {\n            if (l[i] + l[j] == 0) return\
    \ true;\n            j += 1;\n        }\n        i += 1;\n    }\n    return false;\n\
    }\n/*", "{\n    bool result = false;\n    for (int i = 0; i < l.length; i++)\n\
    \    {\n        for (int j = i + 1; j < l.length; j++)\n        {\n          \
    \  if (l[i] + l[j] == 0)\n            {\n                result = true;\n    \
    \        }\n        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ l1 = l[0..$-1];\n        long[] l2 = l[1..$];\n        return (l1.length > 0\
    \ && l2.length > 0 && l1.length == l2.length && l1.sum == -l2.sum) || pairs_sum_to_zero(l1)\
    \ || pairs_sum_to_zero(l2);\n    }\n}", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i + 1 .. l.length)\n        {\n  \
    \          if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool result\
    \ = false;\n    for (int i = 0; i < l.length; i++)\n    {\n        for (int j\
    \ = i + 1; j < l.length; j++)\n        {\n            if (l[i] + l[j] == 0)\n\
    \            {\n                result = true;\n            }\n        }\n   \
    \ }\n    return result;\n}\n/*", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length\
    \ < 2)\n    {\n        return false;\n    }\n    else\n    {\n        long[] l2\
    \ = l[1..$];\n        foreach (e; l2)\n        {\n            if (l[0] + e ==\
    \ 0)\n            {\n                return true;\n            }\n        }\n\
    \        return pairs_sum_to_zero(l2);\n    }\n}\n/*", "{\n    long[] l2 = l.dup;\n\
    \    l2.sort;\n    long i = 0;\n    long j = l2.length - 1;\n    while (i < j)\
    \ {\n        if (l2[i] + l2[j] == 0) {\n            return true;\n        } else\
    \ if (l2[i] + l2[j] < 0) {\n            i++;\n        } else {\n            j--;\n\
    \        }\n    }\n    return false;\n}", "{\n    bool result = false;\n    foreach(long\
    \ i; l)\n    {\n        foreach(long j; l)\n        {\n            if(i != j &&\
    \ i + j == 0)\n            {\n                result = true;\n            }\n\
    \        }\n    }\n    return result;\n}\n/*", "{\n    bool result = false;\n\
    \    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n \
    \       {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] l_sorted = sort(l);\n        long[] l_sorted_unique = unique(l_sorted);\n\
    \        long[] l_sorted_unique_neg = map!((x) => -x)(l_sorted_unique);\n    \
    \    long[] l_sorted_unique_neg_sorted = sort(l_sorted_unique_neg);\n        long[]\
    \ l_sorted_unique_neg_sorted_unique = unique(l_sorted_unique_neg_sorted);\n  \
    \      long[] l_sorted_unique_neg_sorted_unique_neg = map!((x) => -x)(l_sorted_unique_neg_sorted_unique);\n\
    \        long[] l_sorted_unique_neg_sorted_unique_neg_sorted = sort(l_sorted_unique_neg_sorted_unique_neg);\n\
    \        long[] l_sorted_unique_neg_sorted_unique_neg_sorted_unique = unique(l_sorted_unique_neg_sorted_unique_neg_sorted);\n\
    \        long[] l_sorted_unique_neg_sorted_unique_neg_sorted_unique_neg = map!((x)\
    \ => -x)(l_sorted_unique_neg_sorted_unique_neg_sorted_unique);\n        long[]\
    \ l_sorted_unique_neg_sorted_unique_neg_sorted_unique_neg_sorted = sort(l_sorted_unique_neg_sorted_unique_neg_sorted_unique_neg);\n\
    \        long[] l_sorted_unique_neg_sorted_unique_neg_sorted_unique_neg_sorted_unique\
    \ = unique(l_sorted_unique_neg_sorted_unique_neg_sorted_unique_neg_sorted);\n\
    \        long[] l_sorted_unique_neg_sorted_unique_neg_sorted_unique_neg_sorted_unique_neg\
    \ = map!((x) => -x)(l_sorted_unique_neg_sorted_unique_neg_sorted_", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i\
    \ + 1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n \
    \       foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] l2 = l.dup;\n    l2.sort;\n   \
    \ long i = 0;\n    long j = l2.length - 1;\n    while (i < j) \n    {\n      \
    \  if (l2[i] + l2[j] == 0) \n        {\n            return true;\n        }\n\
    \        else if (l2[i] + l2[j] < 0) \n        {\n            i++;\n        }\n\
    \        else \n        {\n            j--;\n        }\n    }\n    return false;\n\
    }\n/*", "{\n    int n = l.length;\n    if (n < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        int i = 0;\n        int j = 1;\n        while\
    \ (i < n) \n        {\n            while (j < n) \n            {\n           \
    \     if (l[i] + l[j] == 0) \n                {\n                    return true;\n\
    \                }\n                j = j + 1;\n            }\n            i =\
    \ i + 1;\n            j = i + 1;\n        }\n        return false;\n    }\n}\n\
    /*", "{\n    if (l.length <= 1)\n    {\n        return false;\n    }\n    else\n\
    \    {\n        long[] l1 = l[1..$];\n        if (l1.length == 0)\n        {\n\
    \            return false;\n        }\n        else\n        {\n            return\
    \ pairs_sum_to_zero(l1) || pairs_sum_to_zero(l1[1..$]) || (l[0] + l1[0] == 0);\n\
    \        }\n    }\n}\n/*", "{\n    bool result = false;\n    foreach(long i; l)\n\
    \    {\n        foreach(long j; l)\n        {\n            if(i+j == 0 && i !=\
    \ j)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted = l.sort();\n        long[] negs = sorted.filter!(x => x < 0).array;\n\
    \        long[] poss = sorted.filter!(x => x > 0).array;\n        long[] zeros\
    \ = sorted.filter!(x => x == 0).array;\n        if (zeros.length > 1) \n     \
    \   {\n            return true;\n        }\n        else \n        {\n       \
    \     foreach (n; negs) \n            {\n                if (poss.canFind(-n))\
    \ \n                {\n                    return true;\n                }\n \
    \           }\n            return false;\n        }\n    }\n}\n/*", "{\n    bool\
    \ result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1\
    \ .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n \
    \               result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool ret = false;\n    foreach(i; 0 .. l.length)\n    {\n    \
    \    foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n\
    \            {\n                ret = true;\n            }\n        }\n    }\n\
    \    return ret;\n}", "{\n    if (l.length < 2)\n    {\n        return false;\n\
    \    }\n    else\n    {\n        long[] sorted = l.sort();\n        long[] negative\
    \ = sorted.filter!(x => x < 0)();\n        long[] positive = sorted.filter!(x\
    \ => x > 0)();\n        long[] zero = sorted.filter!(x => x == 0)();\n       \
    \ if (zero.length > 1)\n        {\n            return true;\n        }\n     \
    \   else\n        {\n            foreach (i; 0 .. negative.length)\n         \
    \   {\n                if (positive.canFind(x => x == -negative[i]))\n       \
    \         {\n                    return true;\n                }\n           \
    \ }\n            return false;\n        }\n    }\n}", "{\n    bool result = false;\n\
    \    long[] temp = l;\n    temp.sort();\n    foreach(i; 0..temp.length)\n    {\n\
    \        foreach(j; 0..temp.length)\n        {\n            if(i != j)\n     \
    \       {\n                if(temp[i] + temp[j] == 0)\n                {\n   \
    \                 result = true;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    bool found = false;\n    for (int\
    \ i = 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j < l.length;\
    \ j++)\n        {\n            if (l[i] + l[j] == 0)\n            {\n        \
    \        found = true;\n            }\n        }\n    }\n    return found;\n}\n\
    /*", "{\n    long[] sorted = l.dup.sort;\n    long[] negs = sorted.filter!(x =>\
    \ x < 0).dup;\n    long[] poss = sorted.filter!(x => x >= 0).dup;\n    long[]\
    \ negs_rev = negs.dup.reverse;\n    long[] poss_rev = poss.dup.reverse;\n    bool\
    \ found = false;\n    foreach(n; negs_rev)\n    {\n        foreach(p; poss_rev)\n\
    \        {\n            if(n + p == 0)\n            {\n                found =\
    \ true;\n                break;\n            }\n            else if(n + p < 0)\n\
    \            {\n                break;\n            }\n        }\n        if(found)\n\
    \        {\n            break;\n        }\n    }\n    return found;\n}\n/*", "{\n\
    \    int n = l.length;\n    if (n < 2)\n    {\n        return false;\n    }\n\
    \    else\n    {\n        int i = 0;\n        int j = n - 1;\n        while (i\
    \ < j)\n        {\n            if (l[i] + l[j] == 0)\n            {\n        \
    \        return true;\n            }\n            else if (l[i] + l[j] < 0)\n\
    \            {\n                i++;\n            }\n            else\n      \
    \      {\n                j--;\n            }\n        }\n        return false;\n\
    \    }\n}", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n\
    \        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    bool result\
    \ = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i + 1 ..\
    \ l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n \
    \       foreach(j; i + 1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    // your code here\n    return false;\n\
    }\n/*", "{\n    bool result = false;\n    for (int i = 0; i < l.length; i++)\n\
    \    {\n        for (int j = i + 1; j < l.length; j++)\n        {\n          \
    \  if (l[i] + l[j] == 0)\n            {\n                result = true;\n    \
    \        }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool result\
    \ = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   long[] sorted = l.dup.sort;\n    long[] negs = sorted.filter!(x => x < 0).dup;\n\
    \    long[] poss = sorted.filter!(x => x >= 0).dup;\n    long[] negs_rev = negs.reverse;\n\
    \    long[] poss_rev = poss.reverse;\n    long[] negs_rev_rev = negs_rev.reverse;\n\
    \    long[] poss_rev_rev = poss_rev.reverse;\n    bool neg_neg = false;\n    bool\
    \ pos_pos = false;\n    bool neg_pos = false;\n    bool pos_neg = false;\n   \
    \ bool neg_neg_rev = false;\n    bool pos_pos_rev = false;\n    bool neg_pos_rev\
    \ = false;\n    bool pos_neg_rev = false;\n    bool neg_neg_rev_rev = false;\n\
    \    bool pos_pos_rev_rev = false;\n    bool neg_pos_rev_rev = false;\n    bool\
    \ pos_neg_rev_rev = false;\n    if (negs.length > 1) \n    {\n        neg_neg\
    \ = negs.zip(negs[1 .. $]).any!(x => x[0] + x[1] == 0);\n    }\n    if (poss.length\
    \ > 1) \n    {\n        pos_pos = poss.zip(poss[1 .. $]).any!(x => x[0] + x[1]\
    \ == 0);\n    }\n    if (negs.length > 0 && poss.length > 0) \n    {\n       \
    \ neg_pos = negs.zip(poss).any!(x => x[0] + x[1] == 0);\n    }\n    if (poss.length\
    \ > 0 && negs.length > 0) \n    {\n        pos_neg = poss.zip(negs).any!(x =>\
    \ x[0] + x[1] == 0);\n    }\n    if (negs_rev.length > 1) \n    {\n        neg_neg_rev\
    \ = negs_rev.zip(negs_rev[1 .. $]).any!(x => x[0", "{\n    if (l.length < 2)\n\
    \    {\n        return false;\n    }\n    else\n    {\n        auto h = l[0];\n\
    \        auto t = l[1..$];\n        if (t.length < 2)\n        {\n           \
    \ return false;\n        }\n        else\n        {\n            auto h2 = t[0];\n\
    \            auto t2 = t[1..$];\n            if (h + h2 == 0)\n            {\n\
    \                return true;\n            }\n            else\n            {\n\
    \                return pairs_sum_to_zero(t);\n            }\n        }\n    }\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        return l.length > 2 && l[0] == 0L && l[1] == 0L || pairs_sum_to_zero(l[1\
    \ .. $]);\n    }\n}\n/*", "{\n    bool result = false;\n    foreach(long i; l)\
    \ \n    {\n        foreach(long j; l) \n        {\n            if(i != j && i\
    \ + j == 0) \n            {\n                result = true;\n            }\n \
    \       }\n    }\n    return result;\n}\n/*", "{\n    return l.length >= 2 &&\
    \ l.length <= 100 && l.all!(x => x >= -100 && x <= 100) && l.pairs.any!(x => x[0]\
    \ + x[1] == 0);\n}\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; i + 1 .. l.length)\n        {\n            if(l[i]\
    \ + l[j] == 0)\n            {\n                result = true;\n            }\n\
    \        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length < 2) \n  \
    \  {\n        return false;\n    }\n    else \n    {\n        long[] l1 = l[0..$-1];\n\
    \        long[] l2 = l[1..$];\n        return (l1.length > 0 && l2.length > 0\
    \ && l1.sum == -l2.sum) || pairs_sum_to_zero(l1) || pairs_sum_to_zero(l2);\n \
    \   }\n}", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n\
    \        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    bool result = false;\n    foreach(i; 0\
    \ .. l.length)\n    {\n        foreach(j; i + 1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    long[] l2\
    \ = l.dup;\n    l2.sort;\n    foreach(long i; l2)\n    {\n        if (l2.count(i)\
    \ > 1)\n        {\n            return true;\n        }\n    }\n    return false;\n\
    }", "{\n    long[] sorted = l.dup.sort;\n    long[] zeros = sorted.filter!(a =>\
    \ a == 0);\n    if (zeros.length > 1)\n        return true;\n    long[] positive\
    \ = sorted.filter!(a => a > 0);\n    long[] negative = sorted.filter!(a => a <\
    \ 0);\n    foreach (p; positive)\n    {\n        foreach (n; negative)\n     \
    \   {\n            if (p == -n)\n                return true;\n        }\n   \
    \ }\n    return false;\n}", "{\n    bool result = false;\n    foreach(long i;\
    \ l)\n    {\n        foreach(long j; l)\n        {\n            if(i != j && i\
    \ + j == 0)\n            {\n                result = true;\n            }\n  \
    \      }\n    }\n    return result;\n}", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; 0 .. l.length)\n        {\n      \
    \      if(i != j)\n            {\n                if(l[i] + l[j] == 0)\n     \
    \           {\n                    result = true;\n                }\n       \
    \     }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool result = false;\n\
    \    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n \
    \       {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   bool result = false;\n    for (int i = 0; i < l.length; i++)\n    {\n    \
    \    for (int j = i + 1; j < l.length; j++)\n        {\n            if (l[i] +\
    \ l[j] == 0)\n            {\n                result = true;\n            }\n \
    \       }\n    }\n    return result;\n}\n/*", "{\n    if (l.length < 2) \n   \
    \ {\n        return false;\n    }\n    else \n    {\n        long[] sorted = l.sort();\n\
    \        long[] negative = sorted.filter!(x => x < 0);\n        long[] positive\
    \ = sorted.filter!(x => x > 0);\n        return negative.any!(x => positive.any!(y\
    \ => x + y == 0));\n    }\n}", "{\n    return l.length > 1 && l.length.even &&\
    \ l.length.iota.all!(i => l[i] + l[i + 1] == 0);\n}", "{\n    bool result = false;\n\
    \    for (int i = 0; i < l.length; i++)\n    {\n        for (int j = i + 1; j\
    \ < l.length; j++)\n        {\n            if (l[i] + l[j] == 0)\n           \
    \ {\n                result = true;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*", "{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int\
    \ n = l.length;\n    for (i = 0; i < n; i++)\n    {\n        for (j = i + 1; j\
    \ < n; j++)\n        {\n            if (l[i] + l[j] == 0)\n            {\n   \
    \             return true;\n            }\n        }\n    }\n    return false;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n \
    \       foreach(j; i+1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted = l.sort();\n        long[] negs = sorted.filter!(x => x < 0);\n    \
    \    long[] poss = sorted.filter!(x => x > 0);\n        long[] zeros = sorted.filter!(x\
    \ => x == 0);\n        if (zeros.length > 1) \n        {\n            return true;\n\
    \        }\n        else \n        {\n            foreach (n; negs) \n       \
    \     {\n                if (poss.canFind(x => x == -n)) \n                {\n\
    \                    return true;\n                }\n            }\n        \
    \    return false;\n        }\n    }\n}", "{\n    if (l.length < 2)\n    {\n \
    \       return false;\n    }\n    else\n    {\n        long[] s = l.sort();\n\
    \        long[] r = s.take(s.length - 1);\n        long[] t = s.drop(1);\n   \
    \     return r.zip(t).any!((a, b) => a + b == 0);\n    }\n}\n/*", "{\n    bool\
    \ result = false;\n    foreach(long i; l)\n    {\n        foreach(long j; l)\n\
    \        {\n            if(i != j && i + j == 0)\n            {\n            \
    \    result = true;\n            }\n        }\n    }\n    return result;\n}\n\
    /*", "{\n    bool res = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i+j == 0 && i != j)\n            {\n      \
    \          res = true;\n            }\n        }\n    }\n    return res;\n}",
  "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j;\
    \ i+1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n \
    \       foreach(j; i + 1 .. l.length)\n        {\n            if(l[i] + l[j] ==\
    \ 0)\n            {\n                result = true;\n            }\n        }\n\
    \    }\n    return result;\n}\n/*", "{\n    bool result = false;\n    foreach(long\
    \ i; l)\n    {\n        foreach(long j; l)\n        {\n            if(i + j ==\
    \ 0 && i != j)\n            {\n                result = true;\n            }\n\
    \        }\n    }\n    return result;\n}", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; 0 .. l.length)\n        {\n      \
    \      if(i != j && l[i] + l[j] == 0)\n            {\n                result =\
    \ true;\n            }\n        }\n    }\n    return result;\n}", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted = l.dup.sort;\n        long[] diffs = sorted.map!((x) => -x).zip(sorted).map!((x)\
    \ => x[0] - x[1]).drop(1);\n        return diffs.any!((x) => x == 0);\n    }\n\
    }", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted = l.sort();\n        long[] negative = sorted.filter!(x\
    \ => x < 0);\n        long[] positive = sorted.filter!(x => x > 0);\n        foreach\
    \ (n; negative) \n        {\n            if (positive.canFind(-n)) \n        \
    \    {\n                return true;\n            }\n        }\n        return\
    \ false;\n    }\n}\n/*", "{\n    bool found = false;\n    for (int i = 0; i <\
    \ l.length; i++)\n    {\n        for (int j = i + 1; j < l.length; j++)\n    \
    \    {\n            if (l[i] + l[j] == 0)\n            {\n                found\
    \ = true;\n            }\n        }\n    }\n    return found;\n}", "{\n    int\
    \ n = l.length;\n    if (n < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        int i = 0;\n        int j = n - 1;\n        while (i < j) \n\
    \        {\n            if (l[i] + l[j] == 0) \n            {\n              \
    \  return true;\n            }\n            else if (l[i] + l[j] < 0) \n     \
    \       {\n                i += 1;\n            }\n            else \n       \
    \     {\n                j -= 1;\n            }\n        }\n        return false;\n\
    \    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n   \
    \ }\n    else \n    {\n        long[] s = l.sort();\n        long[] z = s.filter!(x\
    \ => x == 0L)();\n        if (z.length >= 2) \n        {\n            return true;\n\
    \        }\n        else \n        {\n            long[] p = s.filter!(x => x\
    \ > 0L)();\n            long[] n = s.filter!(x => x < 0L)();\n            if (p.length\
    \ == 0 || n.length == 0) \n            {\n                return false;\n    \
    \        }\n            else \n            {\n                long[] p2 = p.map!(x\
    \ => -x)();\n                long[] n2 = n.map!(x => -x)();\n                return\
    \ p2.any!(x => n.contains(x)) || n2.any!(x => p.contains(x));\n            }\n\
    \        }\n    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] sorted_l = l.dup.sort;\n        long[]\
    \ negative_l = sorted_l.filter!(x => x < 0);\n        long[] positive_l = sorted_l.filter!(x\
    \ => x > 0);\n        foreach (long i; negative_l) \n        {\n            foreach\
    \ (long j; positive_l) \n            {\n                if (i + j == 0) \n   \
    \             {\n                    return true;\n                }\n       \
    \     }\n        }\n        return false;\n    }\n}", "{\n    if (l.length < 2)\n\
    \    {\n        return false;\n    }\n    else\n    {\n        long[] l_sorted\
    \ = l.dup.sort;\n        long[] l_sorted_neg = l_sorted.map!(x => -x);\n     \
    \   long[] l_sorted_neg_unique = l_sorted_neg.unique;\n        long[] l_sorted_unique\
    \ = l_sorted.unique;\n        long[] l_sorted_unique_neg = l_sorted_unique.map!(x\
    \ => -x);\n        return l_sorted_unique.intersect(l_sorted_unique_neg).length\
    \ > 0;\n    }\n}", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n\
    \    {\n        foreach(j; i+1 .. l.length)\n        {\n            if(l[i] +\
    \ l[j] == 0)\n            {\n                result = true;\n            }\n \
    \       }\n    }\n    return result;\n}", "{\n    if (l.length < 2)\n    {\n \
    \       return false;\n    }\n    else\n    {\n        long[] l_sorted = l.sort();\n\
    \        long[] l_sorted_unique = l_sorted.unique;\n        long[] l_sorted_unique_neg\
    \ = l_sorted_unique.map!((x) => -x)();\n        long[] l_sorted_unique_neg_sorted\
    \ = l_sorted_unique_neg.sort();\n        long[] l_sorted_unique_neg_sorted_unique\
    \ = l_sorted_unique_neg_sorted.unique;\n        long[] l_sorted_unique_neg_sorted_unique_sorted\
    \ = l_sorted_unique_neg_sorted_unique.sort();\n        long[] l_sorted_unique_neg_sorted_unique_sorted_unique\
    \ = l_sorted_unique_neg_sorted_unique_sorted.unique;\n        long[] l_sorted_unique_neg_sorted_unique_sorted_unique_neg\
    \ = l_sorted_unique_neg_sorted_unique_sorted_unique.map!((x) => -x)();\n     \
    \   long[] l_sorted_unique_neg_sorted_unique_sorted_unique_neg_sorted = l_sorted_unique_neg_sorted_unique_sorted_unique_neg.sort();\n\
    \        long[] l_sorted_unique_neg_sorted_unique_sorted_unique_neg_sorted_unique\
    \ = l_sorted_unique_neg_sorted_unique_sorted_unique_neg_sorted.unique;\n     \
    \   long[] l_sorted_unique_neg_sorted_unique_sorted_unique_neg_sorted_unique_sorted\
    \ = l_sorted_unique_neg_sorted_unique_sorted_unique_neg_sorted_unique.sort();\n\
    \        long[] l_sorted_unique_neg_sorted_unique_sorted_unique_neg_sorted_unique_sorted_unique\
    \ = l_sorted_unique_neg_sorted_unique_sorted_unique_neg_sorted_unique_s", "{\n\
    \    bool result = false;\n    for (int i = 0; i < l.length; i++)\n    {\n   \
    \     for (int j = i + 1; j < l.length; j++)\n        {\n            if (l[i]\
    \ + l[j] == 0)\n            {\n                result = true;\n            }\n\
    \        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length < 2) \n  \
    \  {\n        return false;\n    }\n    else \n    {\n        long[] sorted =\
    \ l.sort();\n        long[] negative = sorted.filter!(x => x < 0);\n        long[]\
    \ positive = sorted.filter!(x => x > 0);\n        if (negative.length > 0 && positive.length\
    \ > 0) \n        {\n            return true;\n        }\n        else \n     \
    \   {\n            return false;\n        }\n    }\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted = l.sort();\n        long[] neg = sorted.filter!(x => x < 0);\n     \
    \   long[] pos = sorted.filter!(x => x > 0);\n        if (neg.length == 0 || pos.length\
    \ == 0) \n        {\n            return false;\n        }\n        else \n   \
    \     {\n            long[] neg_rev = neg.reverse();\n            long[] pos_rev\
    \ = pos.reverse();\n            long[] neg_rev_cum = neg_rev.cumulativeSum();\n\
    \            long[] pos_rev_cum = pos_rev.cumulativeSum();\n            long[]\
    \ neg_rev_cum_rev = neg_rev_cum.reverse();\n            long[] pos_rev_cum_rev\
    \ = pos_rev_cum.reverse();\n            long[] neg_rev_cum_rev_pos = neg_rev_cum_rev.map!(x\
    \ => abs(x));\n            long[] pos_rev_cum_rev_neg = pos_rev_cum_rev.map!(x\
    \ => abs(x));\n            long[] neg_rev_cum_rev_pos_sorted = neg_rev_cum_rev_pos.sort();\n\
    \            long[] pos_rev_cum_rev_neg_sorted = pos_rev_cum_rev_neg.sort();\n\
    \            long[] neg_rev_cum_rev_pos_sorted_rev = neg_rev_cum_rev_pos_sorted.reverse();\n\
    \            long[] pos_rev_cum_rev_neg_sorted_rev = pos_rev_cum_rev_neg_sorted.reverse();\n\
    \            long[] neg_rev_cum_rev_pos_sorted_rev_pos = neg_rev_cum_rev_pos_sorted_rev.filter!(x\
    \ => x > 0);\n            long[] pos_rev_cum_rev_neg_sorted_rev_neg = pos_rev_cum_rev_neg_sorted_rev.filter!(x\
    \ => x < 0);\n            long[] neg_rev_cum_rev_pos_sorted_rev_pos_rev = neg",
  "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n    {\n\
    \        long[] l2 = l.dup;\n        l2.sort;\n        long i = 0;\n        while\
    \ (i < l2.length)\n        {\n            long j = i + 1;\n            while (j\
    \ < l2.length)\n            {\n                if (l2[i] + l2[j] == 0)\n     \
    \           {\n                    return true;\n                }\n         \
    \       j += 1;\n            }\n            i += 1;\n        }\n        return\
    \ false;\n    }\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n\
    \    }\n    else \n    {\n        long[] sorted_l = l.sort();\n        long[]\
    \ negative_l = sorted_l.filter!(x => x < 0);\n        long[] positive_l = sorted_l.filter!(x\
    \ => x > 0);\n        if (negative_l.length == 0 || positive_l.length == 0) \n\
    \        {\n            return false;\n        }\n        else \n        {\n \
    \           long[] negative_sums = negative_l.map!(x => -x).zip(positive_l).map!(x\
    \ => x[0] + x[1]);\n            return negative_sums.filter!(x => x == 0).length\
    \ > 0;\n        }\n    }\n}\n/*", "{\n    if (l.length < 2)\n    {\n        return\
    \ false;\n    }\n    else\n    {\n        long[] sorted_l = l.sort();\n      \
    \  long[] negative_l = sorted_l.filter!(x => x < 0);\n        long[] positive_l\
    \ = sorted_l.filter!(x => x > 0);\n        long[] zero_l = sorted_l.filter!(x\
    \ => x == 0);\n        if (zero_l.length >= 2)\n        {\n            return\
    \ true;\n        }\n        else\n        {\n            foreach (long i; negative_l)\n\
    \            {\n                if (positive_l.canFind(x => x == -i))\n      \
    \          {\n                    return true;\n                }\n          \
    \  }\n            return false;\n        }\n    }\n}", "{\n    bool result = false;\n\
    \    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i + 1 .. l.length)\n\
    \        {\n            if(l[i] + l[j] == 0)\n            {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n/*", "{\n \
    \   if (l.length < 2) \n    {\n        return false;\n    }\n    else \n    {\n\
    \        long[] sorted = l.sort();\n        long[] neg = sorted.filter!(x => x\
    \ < 0);\n        long[] pos = sorted.filter!(x => x > 0);\n        if (neg.length\
    \ == 0 || pos.length == 0) \n        {\n            return false;\n        }\n\
    \        else \n        {\n            long[] neg_sq = neg.map!(x => x * x).sort();\n\
    \            long[] pos_sq = pos.map!(x => x * x).sort();\n            long[]\
    \ neg_sq_rev = neg_sq.reverse();\n            long[] pos_sq_rev = pos_sq.reverse();\n\
    \            long[] neg_sq_rev_pos_sq = neg_sq_rev.zip(pos_sq);\n            long[]\
    \ neg_sq_pos_sq_rev = neg_sq.zip(pos_sq_rev);\n            return neg_sq_rev_pos_sq.any!(x\
    \ => x[0] == x[1]) || neg_sq_pos_sq_rev.any!(x => x[0] == x[1]);\n        }\n\
    \    }\n}", "{\n    bool result = false;\n    foreach(long i; l)\n    {\n    \
    \    foreach(long j; l)\n        {\n            if(i + j == 0)\n            {\n\
    \                result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    if (l.length < 2)\n    {\n        return false;\n    }\n    else\n\
    \    {\n        long[] sorted = l.sort();\n        long[] negs = sorted.filter!(x\
    \ => x < 0).array;\n        long[] pos = sorted.filter!(x => x >= 0).array;\n\
    \        long[] negs_reversed = negs.reverse();\n        foreach (n; negs_reversed)\n\
    \        {\n            foreach (p; pos)\n            {\n                if (n\
    \ + p == 0)\n                {\n                    return true;\n           \
    \     }\n                else if (n + p > 0)\n                {\n            \
    \        break;\n                }\n            }\n        }\n        return false;\n\
    \    }\n}", "{\n    bool found = false;\n    foreach(i; 0 .. l.length)\n    {\n\
    \        foreach(j; i + 1 .. l.length)\n        {\n            if(l[i] + l[j]\
    \ == 0)\n            {\n                found = true;\n            }\n       \
    \ }\n    }\n    return found;\n}", "{\n    if (l.length < 2) return false;\n \
    \   foreach (i; 0 .. l.length)\n    {\n        foreach (j; i + 1 .. l.length)\n\
    \        {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n\
    \    return false;\n}\n/*", "{\n    bool result = false;\n    foreach(i; 0 ..\
    \ l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n         \
    \   if(l[i] + l[j] == 0)\n            {\n                result = true;\n    \
    \        }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool result\
    \ = false;\n    foreach(i; 0 .. l.length)\n    {\n        foreach(j; i + 1 ..\
    \ l.length)\n        {\n            if(l[i] + l[j] == 0)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    bool result = false;\n    foreach(long i; l)\n    {\n        foreach(long\
    \ j; l)\n        {\n            if(i + j == 0 && i != j)\n            {\n    \
    \            result = true;\n            }\n        }\n    }\n    return result;\n\
    }\n/*", "{\n    auto s = set!(long)();\n    foreach(e; l)\n    {\n        if(s.count(e)\
    \ > 0)\n        {\n            return true;\n        }\n        s.insert(e);\n\
    \    }\n    return false;\n}", "{\n    bool result = false;\n    foreach(i; 0\
    \ .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n      \
    \      if(l[i] + l[j] == 0)\n            {\n                result = true;\n \
    \           }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool found\
    \ = false;\n    for (int i = 0; i < l.length; i++) \n    {\n        for (int j\
    \ = i + 1; j < l.length; j++) \n        {\n            if (l[i] + l[j] == 0) \n\
    \            {\n                found = true;\n            }\n        }\n    }\n\
    \    return found;\n}\n/*", "{\n    if (l.length < 2) \n    {\n        return\
    \ false;\n    }\n    else \n    {\n        auto h = l[0];\n        auto t = l[1..$];\n\
    \        return pairs_sum_to_zero(t) || pairs_sum_to_zero(t.filter!(x => x + h\
    \ != 0));\n    }\n}\n/*", "{\n    long[] a = l.dup;\n    a.sort;\n    long i =\
    \ 0L;\n    long j = a.length - 1L;\n    while (i < j)\n    {\n        if (a[i]\
    \ + a[j] == 0L)\n        {\n            return true;\n        }\n        else\
    \ if (a[i] + a[j] < 0L)\n        {\n            i += 1L;\n        }\n        else\n\
    \        {\n            j -= 1L;\n        }\n    }\n    return false;\n}\n/*",
  "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else \n   \
    \ {\n        long[] sorted_l = l.sort();\n        long[] negative_l = sorted_l.filter!(x\
    \ => x < 0)();\n        long[] positive_l = sorted_l.filter!(x => x > 0)();\n\
    \        return negative_l.any!(x => positive_l.any!(y => x + y == 0))();\n  \
    \  }\n}", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n  \
    \  else \n    {\n        long[] sorted_l = sort(l);\n        long[] negative_l\
    \ = filter!(x => x < 0)(sorted_l);\n        long[] positive_l = filter!(x => x\
    \ > 0)(sorted_l);\n        return any!(x => binarySearch(negative_l, -x) != -1)(positive_l);\n\
    \    }\n}\n/*", "{\n    bool result = false;\n    for (int i = 0; i < l.length;\
    \ i++) \n    {\n        for (int j = i + 1; j < l.length; j++) \n        {\n \
    \           if (l[i] + l[j] == 0) \n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    if (l.length\
    \ < 2) \n    {\n        return false;\n    }\n    else \n    {\n        long[]\
    \ sorted_l = l.sort();\n        long[] negative_l = sorted_l.filter!(x => x <\
    \ 0)();\n        long[] positive_l = sorted_l.filter!(x => x > 0)();\n       \
    \ foreach (long x; negative_l) \n        {\n            foreach (long y; positive_l)\
    \ \n            {\n                if (x + y == 0) \n                {\n     \
    \               return true;\n                }\n            }\n        }\n  \
    \      return false;\n    }\n}\n/*", "{\n    bool result = false;\n    for (size_t\
    \ i = 0; i < l.length; i++)\n    {\n        for (size_t j = i + 1; j < l.length;\
    \ j++)\n        {\n            if (l[i] + l[j] == 0)\n            {\n        \
    \        result = true;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    bool result = false;\n    foreach(i; 0 .. l.length)\n    {\n     \
    \   foreach(j; i + 1 .. l.length)\n        {\n            if(l[i] + l[j] == 0)\n\
    \            {\n                result = true;\n            }\n        }\n   \
    \ }\n    return result;\n}\n/*", "{\n    auto n = l.length;\n    if (n < 2) \n\
    \    {\n        return false;\n    }\n    auto i = 0;\n    while (i < n) \n  \
    \  {\n        auto j = i + 1;\n        while (j < n) \n        {\n           \
    \ if (l[i] + l[j] == 0) \n            {\n                return true;\n      \
    \      }\n            j += 1;\n        }\n        i += 1;\n    }\n    return false;\n\
    }\n/*", "{\n    if (l.length < 2) \n    {\n        return false;\n    }\n    else\
    \ \n    {\n        long[] sorted = l.sort();\n        long[] negative = sorted.takeWhile!(x\
    \ => x < 0);\n        long[] positive = sorted.dropWhile!(x => x < 0);\n     \
    \   long[] negative_reversed = negative.reverse();\n        long[] positive_reversed\
    \ = positive.reverse();\n        return negative_reversed.zip(positive).any!(x\
    \ => x[0] + x[1] == 0);\n    }\n}", "{\n    bool result = false;\n    foreach(i;\
    \ 0 .. l.length)\n    {\n        foreach(j; i+1 .. l.length)\n        {\n    \
    \        if(l[i] + l[j] == 0)\n            {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*", "{\n    bool result\
    \ = false;\n    for (int i = 0; i < l.length; i++) \n    {\n        for (int j\
    \ = i + 1; j < l.length; j++) \n        {\n            if (l[i] + l[j] == 0) \n\
    \            {\n                result = true;\n            }\n        }\n   \
    \ }\n    return result;\n}\n/*", "{\n    long[] l2 = l.sort();\n    long[] l3\
    \ = l2.dup;\n    long[] l4 = l3.dup;\n    long[] l5 = l4.dup;\n    long[] l6 =\
    \ l5.dup;\n    long[] l7 = l6.dup;\n    long[] l8 = l7.dup;\n    long[] l9 = l8.dup;\n\
    \    long[] l10 = l9.dup;\n    long[] l11 = l10.dup;\n    long[] l12 = l11.dup;\n\
    \    long[] l13 = l12.dup;\n    long[] l14 = l13.dup;\n    long[] l15 = l14.dup;\n\
    \    long[] l16 = l15.dup;\n    long[] l17 = l16.dup;\n    long[] l18 = l17.dup;\n\
    \    long[] l19 = l18.dup;\n    long[] l20 = l19.dup;\n    long[] l21 = l20.dup;\n\
    \    long[] l22 = l21.dup;\n    long[] l23 = l22.dup;\n    long[] l24 = l23.dup;\n\
    \    long[] l25 = l24.dup;\n    long[] l26 = l25.dup;\n    long[] l27 = l26.dup;\n\
    \    long[] l28 = l27.dup;\n    long[] l29 = l28.dup;\n    long[] l30 = l29.dup;\n\
    \    long[] l31 = l30.dup;\n    long[] l32 = l31.dup;\n    long[] l33 = l32.dup;\n\
    \    long[] l34 = l33.dup;\n    long[] l35 = l34.dup;\n    long[] l36 = l35.dup;\n\
    \    long[] l37 = l36.dup;\n    long[] l38 = l37.dup;\n    long[] l39 = l38.dup;\n\
    \    long[] l40 = l39.dup;\n    long[] l"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
