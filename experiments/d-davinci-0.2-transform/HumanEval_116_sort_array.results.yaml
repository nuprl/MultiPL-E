language: d
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ma_g_e7.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ma_g_e7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    int[] ones = new int[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        ones[i] = countOnes(arr[i]);\n\
    \    }\n    sort(ones, arr);\n    return arr;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7iu0oycb.d(24): Error: undefined identifier `countOnes`\n/tmp/tmp7iu0oycb.d(26):
    Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp7iu0oycb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count(\"\
    1\");\n        auto b2 = b1.count(\"1\");\n        if (a2 == b2)\n           \
    \ return a < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvfqua9uh.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvfqua9uh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1\
    \ == b1 ? a.compare(b) : a1.compare(b1);\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4us6omlg.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4us6omlg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes(), a.countOnes()\
    \ == 0 ? a : a.countOnes()));\n    arr_tuple.sort!((a, b) => a[1] < b[1] || (a[1]\
    \ == b[1] && a[2] < b[2]));\n    return arr_tuple.map!(a => a[0]).array;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6ywis4rc.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ywis4rc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes >\
    \ b.countOnes) ? 1 : (a.countOnes < b.countOnes) ? -1 : (a > b) ? 1 : -1);\n \
    \   return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_40zr8pq.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_40zr8pq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aa = a.to!string(2);\n        auto bb = b.to!string(2);\n        if (aa.count('1')\
    \ == bb.count('1'))\n            return a < b;\n        return aa.count('1') <\
    \ bb.count('1');\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp80u6gxld.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80u6gxld.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // sort by number of ones in binary representation\n    arr.sort!((a,\
    \ b) => countOnes(a) < countOnes(b));\n    // sort by decimal value\n    arr.sort!((a,\
    \ b) => a < b);\n    return arr;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8x2cvsb5.d(21): Error: no property `sort` for type `long[]`\n/tmp/tmp8x2cvsb5.d(23):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8x2cvsb5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5g5esbvh.d(21): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5g5esbvh.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ma_g_e7.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ma_g_e7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int a_ones = countOnes(a);\n        int b_ones = countOnes(b);\n    \
    \    if (a_ones == b_ones)\n            return a < b ? -1 : 1;\n        return\
    \ a_ones < b_ones ? -1 : 1;\n    });\n    return sorted;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpugv_tksz.d(21): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpugv_tksz.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) {\n        int\
    \ a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n        return a_ones\
    \ == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1s13t1ov.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1s13t1ov.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        int aOnes = a.countOnes();\n\
    \        int bOnes = b.countOnes();\n        return aOnes == bOnes ? a - b : aOnes\
    \ - bOnes;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpplv6lmsg.d(20): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpplv6lmsg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_map = arr.map!(a => tuple(a, a.countOnes)).sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_map.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp14zz869t.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp14zz869t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopq3ynh4.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopq3ynh4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) {\n  \
    \      auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n    \
    \    if (a_ones == b_ones)\n            return a < b;\n        return a_ones <\
    \ b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq626fqx1.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq626fqx1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcn3yptl2.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcn3yptl2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto list = arr.map!(a => tuple(a, a.countOnes)).array;\n    list.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return list.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqd0crx_0.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqd0crx_0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpasanm9y3.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasanm9y3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) =>\n    {\n\
    \        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n        return\
    \ aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n    return result;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51kg2hhg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto cmp = (long a, long b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    };\n    return arr.sort!cmp;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppggc3r5r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 =\
    \ aa.count('1');\n        auto b1 = bb.count('1');\n        if (a1 == b1)\n  \
    \          return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcmphqsrb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes, a)\
    \ < (b.countOnes, b));\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa44ycvt1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        auto aOnes = a.countOnes;\n\
    \        auto bOnes = b.countOnes;\n        return aOnes == bOnes ? a - b : aOnes\
    \ - bOnes;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5f3poecb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => {\n\
    \        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n    \
    \    if (a_ones == b_ones)\n            return a < b;\n        return a_ones <\
    \ b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsh11n992.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, bits(a).count(true))).sort!((a,\
    \ b) => a[1] > b[1] || (a[1] == b[1] && a[0] > b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpecrqwnz7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) =>\n    {\n        auto\
    \ a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1 == b1 ?\
    \ a - b : a1 - b1;\n    });\n    return a;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpibzdjbzz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) => \n    {\n     \
    \   auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        if (a1 ==\
    \ b1)\n            return a < b;\n        return a1 < b1;\n    });\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ldehp89.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes();\n\
    \        auto b_ones = b.countOnes();\n        return a_ones == b_ones ? a - b\
    \ : a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd8a1_0ai.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72xpcm1m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  int a1 = a.countOnes;\n        int b1 = b.countOnes;\n        if (a1 == b1)\n\
    \            return a - b;\n        return a1 - b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhgwef6g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpor8tws3z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_len = arr.length;\n    auto arr_ones = new long[arr_len];\n\
    \    auto arr_sorted = new long[arr_len];\n    auto arr_sorted_ones = new long[arr_len];\n\
    \    auto arr_sorted_dec = new long[arr_len];\n    auto arr_sorted_dec_ones =\
    \ new long[arr_len];\n    auto arr_sorted_dec_ones_index = new long[arr_len];\n\
    \    auto arr_sorted_dec_ones_index_sorted = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted_index_sorted\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted_index_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted_index_sorted_index_sorted\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted_index_sorted_index_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_dec_ones_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted\
    \ = new long[arr\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkgdgoief.d(38): Error: found \''unittest\'' when expecting \'']\''\n/tmp/tmpkgdgoief.d(39):
    Error: semicolon expected following auto declaration, not \''{\''\n/tmp/tmpkgdgoief.d(51):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkgdgoief.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffcelspa.d(67): Error: no identifier for declarator arr\n/tmp/tmpffcelspa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpffcelspa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    long[] result = arr.dup;\n    result.sort!((a,\
    \ b) =>\n    {\n        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n\
    \        return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_2p3s0s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1 ==\
    \ b1 ? a - b : a1 - b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3rdpyche.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    int[] ones = new int[arr.length];\n   \
    \ for(int i = 0; i < arr.length; i++)\n    {\n        ones[i] = countOnes(arr[i]);\n\
    \    }\n    auto tuple = zip(ones, arr);\n    tuple.sort!((a, b) => a[0] < b[0]\
    \ || (a[0] == b[0] && a[1] < b[1]));\n    return tuple.map!(a => a[1]).array;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8z2nav6v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) =>\n    {\n        auto\
    \ a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1 == b1 ?\
    \ a - b : a1 - b1;\n    });\n    return a;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpibzdjbzz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 = aa.count('1');\n\
    \        auto b1 = bb.count('1');\n        if (a1 == b1)\n            return a\
    \ > b;\n        return a1 > b1;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkq1e76hn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto cmp = (long a, long b) =>\n    {\n        auto aOnes = countOnes(a);\n\
    \        auto bOnes = countOnes(b);\n        if (aOnes == bOnes)\n           \
    \ return a - b;\n        return aOnes - bOnes;\n    };\n    return arr.sort!cmp;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb2ndmpfz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes()));\n   \
    \ arr_tuple.sort!((a, b) => a[1] == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return\
    \ arr_tuple.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcl4nguhz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) => \n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfscqovwj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcn3yptl2.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcn3yptl2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5945zx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 = aa.count(\"\
    1\");\n        auto b1 = bb.count(\"1\");\n        if (a1 == b1)\n           \
    \ return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8swu_i8p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72xpcm1m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        long a_ones = a.countOnes;\n\
    \        long b_ones = b.countOnes;\n        return a_ones == b_ones ? a.compare(b)\
    \ : a_ones.compare(b_ones);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0p2bj8h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int a_ones = a.countOnes;\n\
    \        int b_ones = b.countOnes;\n        if (a_ones == b_ones)\n          \
    \  return a - b;\n        return a_ones - b_ones;\n    });\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7jbkrto4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        return\
    \ a_ones == b_ones ? a < b : a_ones < b_ones;\n    });\n    return arr2;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u8wvnm3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpor8tws3z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes != bOnes)\n            return aOnes - bOnes;\n        return a -\
    \ b;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0rfx6iky.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes.cmp(b.countOnes)\
    \ == 0) ? a.cmp(b) : a.countOnes.cmp(b.countOnes));\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr8wan05g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aOnes = a.countOnes;\n        auto bOnes = b.countOnes;\n        if (aOnes\
    \ == bOnes)\n            return a < b;\n        return aOnes < bOnes;\n    });\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagxp29zj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffcelspa.d(67): Error: no identifier for declarator arr\n/tmp/tmpffcelspa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpffcelspa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    long[] result = new long[arr.length];\n\
    \    int[] count = new int[arr.length];\n    for(int i = 0; i < arr.length; i++)\n\
    \    {\n        count[i] = countOnes(arr[i]);\n    }\n    int[] index = sort(count);\n\
    \    for(int i = 0; i < arr.length; i++)\n    {\n        result[i] = arr[index[i]];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpla6e6bg1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) => \n    {\n        auto\
    \ a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1 == b1 ?\
    \ a - b : a1 - b1;\n    });\n    return a;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptpsopwkh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) {\n        auto a1\
    \ = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1 == b1 ? a.compare(b)\
    \ : a1.compare(b1);\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoe6uzo02.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_copy = arr.dup;\n    auto arr_copy_sorted = arr_copy.sort;\n\
    \    auto arr_copy_sorted_ones = arr_copy_sorted.map!(a => a.countOnes);\n   \
    \ auto arr_copy_sorted_ones_sorted = arr_copy_sorted_ones.sort;\n    auto arr_copy_sorted_ones_sorted_unique\
    \ = arr_copy_sorted_ones_sorted.unique;\n    auto arr_copy_sorted_ones_sorted_unique_sorted\
    \ = arr_copy_sorted_ones_sorted_unique.sort;\n    auto arr_copy_sorted_ones_sorted_unique_sorted_map\
    \ = arr_copy_sorted_ones_sorted_unique_sorted.map!(a => arr_copy_sorted.filter!(b\
    \ => b.countOnes == a).sort);\n    auto arr_copy_sorted_ones_sorted_unique_sorted_map_flatten\
    \ = arr_copy_sorted_ones_sorted_unique_sorted_map.flatten;\n    return arr_copy_sorted_ones_sorted_unique_sorted_map_flatten;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2q0qkeu2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffcelspa.d(67): Error: no identifier for declarator arr\n/tmp/tmpffcelspa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpffcelspa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffcelspa.d(67): Error: no identifier for declarator arr\n/tmp/tmpffcelspa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpffcelspa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3oyzolhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int a_ones = a.countOnes();\n\
    \        int b_ones = b.countOnes();\n        return a_ones == b_ones ? a.compare(b)\
    \ : a_ones.compare(b_ones);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4qsyh5d5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkdfkidto.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) =>\n    {\n        auto\
    \ a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if (a_ones\
    \ == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n   \
    \ });\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiz9b5v_s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopq3ynh4.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopq3ynh4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcn3yptl2.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcn3yptl2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72xpcm1m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) => \n    {\n\
    \        long aOnes = countOnes(a);\n        long bOnes = countOnes(b);\n    \
    \    return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg3il024r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        return a1 == b1 ? a - b : a1 - b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj064g5zl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcn3yptl2.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcn3yptl2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5945zx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcn3yptl2.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcn3yptl2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpign88sh9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        int a_ones = countOnes(a);\n\
    \        int b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuz9ara1x.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) {\n  \
    \      auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n      \
    \  return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpon_9pg6v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffcelspa.d(67): Error: no identifier for declarator arr\n/tmp/tmpffcelspa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpffcelspa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto sort_by_ones = (a, b) =>\n    {\n        auto a_ones = a.countOneBits;\n\
    \        auto b_ones = b.countOneBits;\n        return a_ones == b_ones ? a -\
    \ b : a_ones - b_ones;\n    };\n    return arr.sort(sort_by_ones);\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8zzhmeln.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    int[] ones = new int[arr.length];\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        ones[i] = countOnes(arr[i]);\n    }\n    return arr.sort!((a,\
    \ b) => ones[a] == ones[b] ? a - b : ones[a] - ones[b]);\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprzx5esdx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ma_g_e7.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ma_g_e7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopq3ynh4.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopq3ynh4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3oyzolhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) => \n    {\n\
    \        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n    \
    \    return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0mor71l_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        if (a1 == b1)\n\
    \            return a - b;\n        return a1 - b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6221ofy7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpor8tws3z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    int[] ones = new int[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        ones[i] = countOnes(arr[i]);\n\
    \    }\n    int[] sorted = sort(ones);\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        result[i] = arr[sorted[i]];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajvb8f2u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    auto arr_sorted = arr_.sort!((a, b)\
    \ => a.countOnes() < b.countOnes() || (a.countOnes() == b.countOnes() && a < b));\n\
    \    return arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1v5ysgas.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    sort!((a, b) =>\n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    })(arr_sorted);\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpitiind2t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int a_ones = countOnes(a);\n        int b_ones = countOnes(b);\n    \
    \    if (a_ones == b_ones)\n            return a - b;\n        return a_ones -\
    \ b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5kkf8wpa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0tjp3keg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0tjp3keg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string.count(\"1\");\n        auto bb = b.to!string.count(\"\
    1\");\n        if (aa == bb)\n            return a < b;\n        return aa < bb;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5idd8ipw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes, a).cmp(b.countOnes,\
    \ b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy01tq1x7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        int aOnes = a.countOnes();\n\
    \        int bOnes = b.countOnes();\n        return aOnes == bOnes ? a - b : aOnes\
    \ - bOnes;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpplv6lmsg.d(20): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpplv6lmsg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        if (a == b)\n            return 0;\n        else if (a < 0)\n       \
    \     return -1;\n        else if (b < 0)\n            return 1;\n        else\n\
    \        {\n            int a_ones = countOnes(a);\n            int b_ones = countOnes(b);\n\
    \            if (a_ones == b_ones)\n                return a < b ? -1 : 1;\n \
    \           else\n                return a_ones < b_ones ? -1 : 1;\n        }\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg4n6i_l5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes));\n\
    \    arr2.sort!((a, b) => a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp42oup92w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto result = arr.dup;\n    sort!((a, b) => cast(int)a.countOnes\
    \ > cast(int)b.countOnes || (a.countOnes == b.countOnes && a > b))(result);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjizx_74.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => {\n        int aOnes = a.countOnes();\n\
    \        int bOnes = b.countOnes();\n        return aOnes == bOnes ? a - b : aOnes\
    \ - bOnes;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpna0uyu1j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffcelspa.d(67): Error: no identifier for declarator arr\n/tmp/tmpffcelspa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpffcelspa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3oyzolhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5945zx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) => \n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a < b ? -1 : 1;\n        return aOnes\
    \ < bOnes ? -1 : 1;\n    });\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu06c4sjf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    int[] ones = new int[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        ones[i] = countOnes(arr[i]);\n\
    \    }\n    sort(ones, arr);\n    return arr;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7iu0oycb.d(24): Error: undefined identifier `countOnes`\n/tmp/tmp7iu0oycb.d(26):
    Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp7iu0oycb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] res = arr.dup;\n    res.sort!((a, b) => \n    {\n     \
    \   int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n        return\
    \ a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return res;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpptvb79kt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5945zx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_with_ones = arr.map!(a => tuple(a, a.countOnes));\n \
    \   arr_with_ones.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n\
    \    return arr_with_ones.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5cyrv8dr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes, a.countOnes\
    \ == 0 ? a : a.countOnes));\n    arr_tuple.sort!((a, b) => a[1] == b[1] ? a[2]\
    \ < b[2] : a[1] < b[1]);\n    return arr_tuple.map!(a => a[0]).array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphln8mgcp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72xpcm1m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = new Tuple!(long, long)[arr.length];\n    foreach(i,\
    \ x; arr)\n    {\n        arr_tuple[i] = tuple(x, x.countOnes);\n    }\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    foreach(i, x; arr_tuple)\n\
    \    {\n        arr[i] = x[0];\n    }\n    return arr;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv7jtimfd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) {\n        auto a_ones\
    \ = a.countOnes;\n        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n\
    \            return a.cmp(b);\n        return a_ones.cmp(b_ones);\n    });\n \
    \   return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppp_74k3c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopq3ynh4.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopq3ynh4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 =\
    \ aa.count('1');\n        auto b1 = bb.count('1');\n        if (a1 == b1)\n  \
    \          return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcmphqsrb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOneBits;\n        auto b_ones = b.countOneBits;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp333ndry_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes > b.countOnes);\n\
    \    arr2.sort!((a, b) => a.countOnes == b.countOnes && a > b);\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ypjdtta.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8db3x5s4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_with_ones = arr.map!(a => tuple(a, a.countOnes));\n \
    \   arr_with_ones.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n\
    \    return arr_with_ones.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5cyrv8dr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcv_6f75r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    auto sorted = sort!((a, b) => a.countOnes\
    \ > b.countOnes || (a.countOnes == b.countOnes && a > b))(arr_);\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp19v4r9ht.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpor8tws3z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ma_g_e7.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ma_g_e7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        return\
    \ a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return arr2;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpec8l1c62.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpor8tws3z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!((a, b) =>\n    {\n      \
    \  auto a_ = a.to!string;\n        auto b_ = b.to!string;\n        auto a_ones\
    \ = a_.count('1');\n        auto b_ones = b_.count('1');\n        if (a_ones ==\
    \ b_ones)\n            return a < b;\n        return a_ones < b_ones;\n    });\n\
    \    return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp454aotmg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7u0f_08e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto sort_by_ones = (long a, long b) =>\n    {\n        auto count_ones\
    \ = (long n) =>\n        {\n            long count = 0;\n            while (n\
    \ > 0)\n            {\n                count += n % 2;\n                n /= 2;\n\
    \            }\n            return count;\n        };\n        auto a_ones = count_ones(a);\n\
    \        auto b_ones = count_ones(b);\n        if (a_ones == b_ones)\n       \
    \     return a < b ? -1 : 1;\n        return a_ones < b_ones ? -1 : 1;\n    };\n\
    \    return arr.sort!(sort_by_ones);\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5mvf1qx5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    auto arr_sorted = arr_.sort!((a, b)\
    \ => \n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldqbvd8f.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto aaa =\
    \ aa.count('1');\n        auto bbb = bb.count('1');\n        if (aaa == bbb)\n\
    \            return a < b;\n        return aaa < bbb;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp34slcv21.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string.count(\"1\");\n        auto bb = b.to!string.count(\"\
    1\");\n        if (aa == bb)\n            return a < b;\n        return aa < bb;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5idd8ipw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto cmp = (long a, long b) {\n        int onesA = 0;\n      \
    \  int onesB = 0;\n        while (a != 0) {\n            onesA += a & 1;\n   \
    \         a >>= 1;\n        }\n        while (b != 0) {\n            onesB +=\
    \ b & 1;\n            b >>= 1;\n        }\n        if (onesA != onesB) {\n   \
    \         return onesA < onesB ? -1 : 1;\n        }\n        return a < b ? -1\
    \ : 1;\n    };\n    return arr.sort!cmp;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn5zoppcz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ma_g_e7.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ma_g_e7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72xpcm1m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes >\
    \ b.countOnes) ? 1 : (a.countOnes < b.countOnes) ? -1 : (a > b) ? 1 : -1);\n \
    \   return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_40zr8pq.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_40zr8pq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(x => tuple(x, x.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(x\
    \ => x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwz56xj5v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) =>\n    {\n        auto\
    \ a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1 < b1 ?\
    \ -1 : a1 > b1 ? 1 : a < b ? -1 : a > b ? 1 : 0;\n    });\n    return a;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4oce63a3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ir9cuum.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        long a_ones = count_ones(a);\n        long b_ones = count_ones(b);\n\
    \        if (a_ones == b_ones)\n            return a - b;\n        return a_ones\
    \ - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphuuegn3z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    auto arr_sorted = arr_.sort!((a, b)\
    \ => a.countOnes > b.countOnes || (a.countOnes == b.countOnes && a > b));\n  \
    \  return arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n \
    \   assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbrk31ckt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffcelspa.d(67): Error: no identifier for declarator arr\n/tmp/tmpffcelspa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpffcelspa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes ==\
    \ b.countOnes ? a < b : a.countOnes < b.countOnes);\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpolpombb6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmlgycr0d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // sort by number of ones, then by value\n    return arr.sort!((a,\
    \ b) =>\n    {\n        auto a_ones = a.countOnes();\n        auto b_ones = b.countOnes();\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnh66kc9v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgto9rezr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(x => tuple(x, x.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return arr_tuple.map!(x\
    \ => x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpktwngwkf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto result = arr.dup;\n    result.sort!((a, b) => \n    {\n \
    \       auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n     \
    \   return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfew8a9p5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgto9rezr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    return arr.sort!((a, b) => \n    {\n  \
    \      auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n    \
    \    if (a_ones == b_ones)\n            return a < b;\n        return a_ones <\
    \ b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7dida2mc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => {\n        auto\
    \ a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        if (a1 == b1)\n \
    \           return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg1bmotpy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_with_ones = arr.map!(x => tuple(x, x.countOnes)).sort!((a,\
    \ b) => a[1] > b[1] || (a[1] == b[1] && a[0] > b[0]));\n    return arr_with_ones.map!(x\
    \ => x[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcv1_1e9v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5945zx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpign88sh9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopq3ynh4.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopq3ynh4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto cmp = (long a, long b) =>\n    {\n        auto a_ones = count(a.to!string,\
    \ '1');\n        auto b_ones = count(b.to!string, '1');\n        return a_ones\
    \ == b_ones ? a - b : a_ones - b_ones;\n    };\n    return arr.sort!cmp;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplpbginu7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffcelspa.d(67): Error: no identifier for declarator arr\n/tmp/tmpffcelspa.d(67):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpffcelspa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(x => tuple(x, x.countOnes, x.countOnes\
    \ == 0 ? x : x.countOnes));\n    arr_tuple.sort!((a, b) => a[1] < b[1] || (a[1]\
    \ == b[1] && a[2] < b[2]));\n    return arr_tuple.map!(x => x[0]).array;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbcoxc5tm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto sort_func = (a, b) =>\n    {\n        int a_ones = a.countOnes();\n\
    \        int b_ones = b.countOnes();\n        if (a_ones == b_ones)\n        \
    \    return a < b ? -1 : 1;\n        return a_ones < b_ones ? -1 : 1;\n    };\n\
    \    arr.sort(sort_func);\n    return arr;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp282dld15.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprzir9uj5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopq3ynh4.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopq3ynh4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ma_g_e7.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ma_g_e7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int a_ones = count_ones(a);\n        int b_ones = count_ones(b);\n  \
    \      if (a_ones == b_ones)\n            return a - b;\n        return a_ones\
    \ - b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5n4c6pkw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    long[] ones = new long[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        ones[i] = countOnes(arr[i]);\n\
    \    }\n    long[] sorted = sort(ones);\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        result[i] = getValue(arr, sorted[i]);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn3pkr5a7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5945zx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes > b.countOnes\
    \ || (a.countOnes == b.countOnes && a > b));\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcsrxpyir.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int a_ones = a.countOnes;\n\
    \        int b_ones = b.countOnes;\n        return a_ones == b_ones ? a.compare(b)\
    \ : a_ones.compare(b_ones);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0vfk9xj3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes, a.countOnes\
    \ == 0 ? a : a.countOnes));\n    arr_tuple.sort!((a, b) => a[1] == b[1] ? a[2]\
    \ < b[2] : a[1] < b[1]);\n    return arr_tuple.map!(a => a[0]).array;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphln8mgcp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) => \n    {\n\
    \        int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n      \
    \  return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoyq_8tqy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) => \n    {\n\
    \        long a_ones = countOnes(a);\n        long b_ones = countOnes(b);\n  \
    \      if (a_ones == b_ones)\n            return a < b ? -1 : 1;\n        return\
    \ a_ones < b_ones ? -1 : 1;\n    });\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiq7r1c7f.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => {\n        auto\
    \ a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        return a_ones\
    \ == b_ones ? a - b : a_ones - b_ones;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchrm9b65.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3oyzolhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    foreach(i, e; arr)\n\
    \    {\n        result[i] = e;\n    }\n    sort!((a, b) =>\n    {\n        int\
    \ a_ones = countOnes(a);\n        int b_ones = countOnes(b);\n        if(a_ones\
    \ == b_ones)\n        {\n            return a < b;\n        }\n        return\
    \ a_ones < b_ones;\n    })(result);\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ctx68n1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5945zx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aa = a.to!string(2);\n        auto bb = b.to!string(2);\n        if (aa.count('1')\
    \ == bb.count('1'))\n            return a < b;\n        return aa.count('1') <\
    \ bb.count('1');\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp80u6gxld.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80u6gxld.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int aOnes = a.countOnes();\n\
    \        int bOnes = b.countOnes();\n        return aOnes == bOnes ? a - b : aOnes\
    \ - bOnes;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn5nw3qlu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) =>\n    {\n\
    \        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n        if\
    \ (aOnes == bOnes)\n            return a.compare(b);\n        return aOnes.compare(bOnes);\n\
    \    });\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_9z4tjq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    auto arr_sorted = arr_.sort!((a, b)\
    \ =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxo2f8vka.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopq3ynh4.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopq3ynh4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ma_g_e7.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ma_g_e7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) => (a.countOnes ==\
    \ b.countOnes) ? a - b : a.countOnes - b.countOnes);\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6npkecyh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpasanm9y3.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasanm9y3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpor8tws3z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_with_ones = arr.map!(a => tuple(a, a.countOnes));\n \
    \   arr_with_ones.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n\
    \    return arr_with_ones.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5cyrv8dr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2jwgv4v.d(20): Error: no property `map` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2jwgv4v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a >\
    \ b ? 1 : 0;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqj9ee88m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkdfkidto.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes ==\
    \ b.countOnes) ? a - b : a.countOnes - b.countOnes);\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptr33xd7y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aBin = a.to!string(2);\n        auto bBin = b.to!string(2);\n        auto\
    \ aOnes = aBin.count('1');\n        auto bOnes = bBin.count('1');\n        if\
    \ (aOnes == bOnes)\n            return a < b;\n        return aOnes < bOnes;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2c93wctk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto sort_by_ones = (long a, long b) {\n        auto a_ones =\
    \ count(a.to!string, '1');\n        auto b_ones = count(b.to!string, '1');\n \
    \       return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a > b\
    \ ? 1 : 0;\n    };\n    return arr.sort!sort_by_ones;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpklmbe7g4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a >\
    \ b ? 1 : 0;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqj9ee88m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72xpcm1m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    long[] result = arr.dup;\n    result.sort!((a,\
    \ b) =>\n    {\n        int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a - b;\n        return a_ones\
    \ - b_ones;\n    });\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbxwuwhdl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopq3ynh4.d(21): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopq3ynh4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 = aa.count('1');\n\
    \        auto b1 = bb.count('1');\n        if (a1 == b1)\n            return a\
    \ < b;\n        return a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedxa2qv1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794684
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5945zx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794683
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5g5esbvh.d(21): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5g5esbvh.d",
    "-I/tmp"]\n'''
  stdout: b''
