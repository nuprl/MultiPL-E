name: HumanEval_18_how_many_times
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n    >>>\
  \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
  \    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
  \ string, string substring) \n"
tests: "unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
  \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
  cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n\
  }\nvoid main(){}"
completions: ["{\n    long result = 0;\n    long string_length = string.length;\n\
    \    long substring_length = substring.length;\n    if (substring_length == 0)\n\
    \        return 0;\n    for (long i = 0; i < string_length; i++)\n    {\n    \
    \    if (string[i..i+substring_length] == substring)\n            result++;\n\
    \    }\n    return result;\n}", "{\n    long count = 0;\n    long index = 0;\n\
    \    while (true)\n    {\n        index = string.find(substring, index);\n   \
    \     if (index == -1)\n            break;\n        count++;\n        index++;\n\
    \    }\n    return count;\n}\n/*\n    >>> how_many_times_kmp(\"\", \"a\")\n  \
    \  0L\n    >>> how_many_times_kmp(\"aaa\", \"a\")\n    3L\n    >>> how_many_times_kmp(\"\
    aaaa\", \"aa\")\n    3L\n*/\nlong how_many_times_kmp(string string, string substring)\
    \ \n{\n    auto table = kmp_table(substring);\n    long count = 0;\n    long index\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    while (i < string.length)\n    {\n\
    \        if (string[i] == substring[j])\n        {\n            if (j == substring.length\
    \ - 1)\n            {\n                count++;\n                j = table[j];\n\
    \            }\n            else\n            {\n                i++;\n      \
    \          j++;\n            }\n        }\n        else if (j > 0)\n        {\n\
    \            j = table[j - 1];\n        }\n        else\n        {\n         \
    \   i++;\n        }\n    }\n    return count;\n}\n/*\n    >>> kmp_table(\"a\"\
    )\n    [0L]\n    >>> kmp_table(\"aa\")\n    [0L, 1L]\n    >>> kmp_table(\"ab\"\
    )\n    [0L, 0L]\n    >>> kmp_table(\"aba\")\n    [0L, 0L, 1L]\n    >>> kmp_table(\"\
    abab\")\n    [0L, 0L, 1L, 2L]\n    >>> kmp_table(\"ababa\")\n    [0L, 0L, 1L,\
    \ 2L, 3L]\n    >>> kmp_table(\"ababab\")\n    [0L, 0L, 1L, 2L, 3L, 4L]\n    >>>\
    \ kmp_table(\"abababa\")\n    [0L, 0L", "{\n    long count = 0;\n    size_t pos\
    \ = 0;\n    while ((pos = string.find(substring, pos)) != string.npos) {\n   \
    \     ++count;\n        ++pos;\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    long index = 0;\n    while (true)\n    {\n        index = string.find(substring,\
    \ index);\n        if (index == -1)\n            break;\n        count++;\n  \
    \      index++;\n    }\n    return count;\n}", "{\n    long count = 0;\n    long\
    \ index = 0;\n    while (index != -1) \n    {\n        index = string.find(substring,\
    \ index);\n        if (index != -1) \n        {\n            count++;\n      \
    \      index++;\n        }\n    }\n    return count;\n}", "{\n    long count =\
    \ 0;\n    long index = 0;\n    while (true)\n    {\n        index = string.find(substring,\
    \ index);\n        if (index == -1)\n            break;\n        count++;\n  \
    \      index++;\n    }\n    return count;\n}", "{\n    long count = 0;\n    long\
    \ pos = 0;\n    while (true)\n    {\n        pos = string.find(substring, pos);\n\
    \        if (pos == -1)\n            break;\n        count++;\n        pos++;\n\
    \    }\n    return count;\n}", "{\n    long count = 0;\n    long index = 0;\n\
    \    while (true) \n    {\n        index = string.find(substring, index);\n  \
    \      if (index == -1) \n        {\n            break;\n        }\n        count++;\n\
    \        index++;\n    }\n    return count;\n}\n/*\n Find the longest substring\
    \ of a given string that is a palindrome.\n    >>> longest_palindrome(\"\")\n\
    \    \"\"\n    >>> longest_palindrome(\"a\")\n    \"a\"\n    >>> longest_palindrome(\"\
    aa\")\n    \"aa\"\n    >>> longest_palindrome(\"baa\")\n    \"aa\"\n    >>> longest_palindrome(\"\
    aab\")\n    \"aa\"\n    >>> longest_palindrome(\"baabcd\")\n    \"baab\"\n   \
    \ >>> longest_palindrome(\"baablkj12345432133d\")\n    \"123454321\"\n*/\nstring\
    \ longest_palindrome(string string) \n{\n    string longest = \"\";\n    for (long\
    \ i = 0; i < string.length; i++) \n    {\n        for (long j = i + 1; j <= string.length;\
    \ j++) \n        {\n            string substring = string[i..j];\n           \
    \ if (substring.length > longest.length && is_palindrome(substring)) \n      \
    \      {\n                longest = substring;\n            }\n        }\n   \
    \ }\n    return longest;\n}", "{\n    long count = 0;\n    long index = 0;\n \
    \   while (index != -1) \n    {\n        index = string.find(substring, index);\n\
    \        if (index != -1) \n        {\n            count++;\n            index++;\n\
    \        }\n    }\n    return count;\n}", "{\n    long count = 0;\n    long pos\
    \ = 0;\n    while ((pos = string.find(substring, pos)) != string.npos) \n    {\n\
    \        ++count;\n        ++pos;\n    }\n    return count;\n}", "{\n    long\
    \ result = 0;\n    long index = 0;\n    while (true)\n    {\n        index = string.find(substring,\
    \ index);\n        if (index == -1)\n            break;\n        result++;\n \
    \       index++;\n    }\n    return result;\n}", "{\n    long count = 0;\n   \
    \ long sub_len = substring.length;\n    long str_len = string.length;\n    if\
    \ (sub_len > str_len)\n        return 0;\n    for (long i = 0; i < str_len; i++)\n\
    \    {\n        if (string[i..i+sub_len] == substring)\n            count++;\n\
    \    }\n    return count;\n}", "{\n    long count = 0;\n    long i = 0;\n    while(i\
    \ < string.length)\n    {\n        if(string[i..$] == substring)\n        {\n\
    \            count++;\n            i += substring.length;\n        }\n       \
    \ else\n        {\n            i++;\n        }\n    }\n    return count;\n}",
  "{\n    long count = 0;\n    long pos = 0;\n    while (true)\n    {\n        pos\
    \ = string.find(substring, pos);\n        if (pos == -1)\n            break;\n\
    \        count++;\n        pos++;\n    }\n    return count;\n}", "{\n    long\
    \ count = 0;\n    for (size_t i = 0; i < string.length; i++)\n    {\n        if\
    \ (string[i..$] == substring)\n        {\n            count++;\n        }\n  \
    \  }\n    return count;\n}", "{\n    long count = 0;\n    long index = 0;\n  \
    \  while (index != -1)\n    {\n        index = string.find(substring, index);\n\
    \        if (index != -1)\n        {\n            count++;\n            index++;\n\
    \        }\n    }\n    return count;\n}", "{\n    long count = 0;\n    long index\
    \ = 0;\n    while (true)\n    {\n        index = string.find(substring, index);\n\
    \        if (index == -1)\n            break;\n        count++;\n        index++;\n\
    \    }\n    return count;\n}", "{\n    long count = 0;\n    long index = 0;\n\
    \    while ((index = string.find(substring, index)) != -1) \n    {\n        count++;\n\
    \        index += substring.length;\n    }\n    return count;\n}", "{\n    long\
    \ count = 0;\n    long index = 0;\n    while (true)\n    {\n        index = string.find(substring,\
    \ index);\n        if (index == -1)\n            break;\n        count++;\n  \
    \      index++;\n    }\n    return count;\n}", "{\n    long count = 0;\n    long\
    \ index = 0;\n    while ((index = string.find(substring, index)) != -1) \n   \
    \ {\n        count++;\n        index += substring.length;\n    }\n    return count;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
