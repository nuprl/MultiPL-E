name: HumanEval_6_parse_nested_parens
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Input to this function is a\
  \ string represented multiple groups for nested parentheses separated by spaces.\n\
  \    For each of the group, output the deepest level of nesting of parentheses.\n\
  \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n \
  \   >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L, 3L]\n\
  \    \n*/\nlong[] parse_nested_parens(string paren_string) \n"
tests: "unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
  (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"()\
  \ (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
  ) == [4L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result;\n    long[] stack;\n    long max_level = 0;\n\
    \    long level = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            stack ~= 1;\n            level++;\n            max_level\
    \ = max(max_level, level);\n        }\n        else if(c == ')')\n        {\n\
    \            stack ~= -1;\n            level--;\n        }\n        else if(c\
    \ == ' ')\n        {\n            if(stack.length > 0)\n            {\n      \
    \          result ~= max_level;\n                stack = [];\n               \
    \ max_level = 0;\n                level = 0;\n            }\n        }\n    }\n\
    \    if(stack.length > 0)\n    {\n        result ~= max_level;\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long max_level = 0;\n    long current_level\
    \ = 0;\n    foreach(char c; paren_string)\n    {\n        if(c == '(')\n     \
    \   {\n            current_level++;\n            max_level = max(max_level, current_level);\n\
    \        }\n        else if(c == ')')\n        {\n            current_level--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_level;\n\
    \            max_level = 0;\n            current_level = 0;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[];\n    string[] paren_groups\
    \ = paren_string.split(\" \");\n    foreach(paren_group; paren_groups) \n    {\n\
    \        long max_nesting = 0;\n        long current_nesting = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             current_nesting++;\n                max_nesting = max(max_nesting,\
    \ current_nesting);\n            }\n            else if(paren == ')') \n     \
    \       {\n                current_nesting--;\n            }\n        }\n    \
    \    result ~= max_nesting;\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    long count = 0;\n    long max = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            count++;\n            max = max(max,\
    \ count);\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max;\n\
    \            max = 0;\n            count = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long max_nesting = 0;\n    long current_nesting\
    \ = 0;\n    foreach(c; paren_string) \n    {\n        if(c == '(') \n        {\n\
    \            current_nesting++;\n            max_nesting = max(max_nesting, current_nesting);\n\
    \        } \n        else if(c == ')') \n        {\n            current_nesting--;\n\
    \        } \n        else if(c == ' ') \n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            current_nesting = 0;\n        }\n \
    \   }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n   \
    \ long max_depth;\n    long depth;\n    long i;\n    long j;\n    long k;\n  \
    \  long l;\n    long m;\n    long n;\n    long o;\n    long p;\n    long q;\n\
    \    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n\
    \    long x;\n    long y;\n    long z;\n    long aa;\n    long ab;\n    long ac;\n\
    \    long ad;\n    long ae;\n    long af;\n    long ag;\n    long ah;\n    long\
    \ ai;\n    long aj;\n    long ak;\n    long al;\n    long am;\n    long an;\n\
    \    long ao;\n    long ap;\n    long aq;\n    long ar;\n    long as;\n    long\
    \ at;\n    long au;\n    long av;\n    long aw;\n    long ax;\n    long ay;\n\
    \    long az;\n    long ba;\n    long bb;\n    long bc;\n    long bd;\n    long\
    \ be;\n    long bf;\n    long bg;\n    long bh;\n    long bi;\n    long bj;\n\
    \    long bk;\n    long bl;\n    long bm;\n    long bn;\n    long bo;\n    long\
    \ bp;\n    long bq;\n    long br;\n    long bs;\n    long bt;\n    long bu;\n\
    \    long bv;\n    long bw;\n    long bx;\n    long by;\n    long bz;\n    long\
    \ ca;\n    long cb;\n    long cc;\n    long cd;\n    long ce;\n    long cf;\n\
    \    long cg;\n    long ch;\n    long ci;\n    long cj;\n    long ck;\n    long\
    \ cl;\n    long cm;\n    long cn;\n    long co;\n    long cp;\n    long cq;\n\
    \    long cr;\n    long cs;\n    long ct;\n    long cu;", "{\n    long[] result;\n\
    \    int[] stack;\n    int i;\n    int len;\n    int max_depth;\n    int depth;\n\
    \    int paren_count;\n    int paren_index;\n    int paren_start;\n    int paren_end;\n\
    \    int paren_start_index;\n    int paren_end_index;\n    int paren_start_index_prev;\n\
    \    int paren_end_index_prev;\n    int paren_start_index_next;\n    int paren_end_index_next;\n\
    \    int paren_start_index_next_next;\n    int paren_end_index_next_next;\n  \
    \  int paren_start_index_prev_prev;\n    int paren_end_index_prev_prev;\n    int\
    \ paren_start_index_prev_prev_prev;\n    int paren_end_index_prev_prev_prev;\n\
    \    int paren_start_index_next_next_next;\n    int paren_end_index_next_next_next;\n\
    \    int paren_start_index_next_next_next_next;\n    int paren_end_index_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next;\n    int paren_end_index_next_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next_next;\n    int paren_end_index_next_next_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next_next_next;\n    int paren_end_index_next_next_next_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next_next_next_next;\n    int paren_end_index_next_next_next_next_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next_next_next_next_next;\n   \
    \ int paren_end_", "{\n    long[] result = new long[];\n    long[] stack = new\
    \ long[];\n    foreach(paren; paren_string.split(\" \"))\n    {\n        foreach(c;\
    \ paren)\n        {\n            if(c == '(')\n            {\n               \
    \ stack ~= 1;\n            }\n            else if(c == ')')\n            {\n \
    \               stack ~= -1;\n            }\n        }\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        foreach(c; stack)\n        {\n      \
    \      depth += c;\n            max_depth = max(max_depth, depth);\n        }\n\
    \        result ~= max_depth;\n        stack = new long[];\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n\
    \    foreach (paren_group; paren_string.split(\" \")) \n    {\n        stack =\
    \ [];\n        max_depth = 0;\n        foreach (paren; paren_group) \n       \
    \ {\n            if (paren == '(') \n            {\n                stack ~= 1;\n\
    \                max_depth = max(max_depth, stack.length);\n            }\n  \
    \          else if (paren == ')') \n            {\n                stack.pop;\n\
    \            }\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n \
    \   int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n \
    \   int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo\
    \ = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n \
    \   int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx\
    \ = 0;\n    int by = 0", "{\n    long[] result;\n    long[] stack;\n    long current_level;\n\
    \    long max_level;\n    long i;\n    long j;\n    long len;\n    long len2;\n\
    \    char c;\n    char c2;\n    string s;\n    string[] paren_groups;\n    paren_groups\
    \ = split(paren_string, \" \");\n    len = paren_groups.length;\n    result =\
    \ new long[len];\n    for (i = 0; i < len; i++) {\n        s = paren_groups[i];\n\
    \        stack = new long[s.length];\n        current_level = 0;\n        max_level\
    \ = 0;\n        len2 = s.length;\n        for (j = 0; j < len2; j++) {\n     \
    \       c = s[j];\n            if (c == '(') {\n                current_level++;\n\
    \                stack[current_level] = j;\n            } else if (c == ')') {\n\
    \                if (current_level > 0) {\n                    current_level--;\n\
    \                } else {\n                    throw new Exception(\"Invalid input\"\
    );\n                }\n            } else {\n                throw new Exception(\"\
    Invalid input\");\n            }\n            max_level = max(max_level, current_level);\n\
    \        }\n        if (current_level != 0) {\n            throw new Exception(\"\
    Invalid input\");\n        }\n        result[i] = max_level;\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] stack;\n    long[] stack_temp;\n\
    \    long[] stack_temp2;\n    long[] stack_temp3;\n    long[] stack_temp4;\n \
    \   long[] stack_temp5;\n    long[] stack_temp6;\n    long[] stack_temp7;\n  \
    \  long[] stack_temp8;\n    long[] stack_temp9;\n    long[] stack_temp10;\n  \
    \  long[] stack_temp11;\n    long[] stack_temp12;\n    long[] stack_temp13;\n\
    \    long[] stack_temp14;\n    long[] stack_temp15;\n    long[] stack_temp16;\n\
    \    long[] stack_temp17;\n    long[] stack_temp18;\n    long[] stack_temp19;\n\
    \    long[] stack_temp20;\n    long[] stack_temp21;\n    long[] stack_temp22;\n\
    \    long[] stack_temp23;\n    long[] stack_temp24;\n    long[] stack_temp25;\n\
    \    long[] stack_temp26;\n    long[] stack_temp27;\n    long[] stack_temp28;\n\
    \    long[] stack_temp29;\n    long[] stack_temp30;\n    long[] stack_temp31;\n\
    \    long[] stack_temp32;\n    long[] stack_temp33;\n    long[] stack_temp34;\n\
    \    long[] stack_temp35;\n    long[] stack_temp36;\n    long[] stack_temp37;\n\
    \    long[] stack_temp38;\n    long[] stack_temp39;\n    long[] stack_temp40;\n\
    \    long[] stack_temp41;\n    long[] stack_temp42;\n    long[] stack_temp43;\n\
    \    long[] stack_temp44;\n    long[] stack_temp45;\n    long[] stack_temp46;\n\
    \    long[] stack_temp47;\n    long[] stack_temp48;\n    long[] stack_temp49;\n\
    \    long[] stack_temp50;\n    long[] stack_temp51;\n    long[] stack_temp52;\n\
    \    long[] stack_temp53;\n    long[] stack_temp54;\n    long[] stack_temp55;\n\
    \    long[]", "{\n    long[] result;\n    int max_depth = 0;\n    int depth =\
    \ 0;\n    foreach(c; paren_string) \n    {\n        if (c == '(') \n        {\n\
    \            depth++;\n            max_depth = max(max_depth, depth);\n      \
    \  } \n        else if (c == ')') \n        {\n            depth--;\n        }\
    \ \n        else if (c == ' ') \n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    int i = 0;\n    foreach(paren_string;\
    \ paren_string.length > 0)\n    {\n        auto paren_group = paren_string.split(\"\
    \ \")[0];\n        paren_string = paren_string.split(\" \")[1];\n        int max_depth\
    \ = 0;\n        int depth = 0;\n        foreach(paren_group; paren_group.length\
    \ > 0)\n        {\n            auto paren = paren_group.split(\"\")[0];\n    \
    \        paren_group = paren_group.split(\"\")[1];\n            if(paren == \"\
    (\")\n            {\n                depth += 1;\n                max_depth =\
    \ max(max_depth, depth);\n            }\n            else if(paren == \")\")\n\
    \            {\n                depth -= 1;\n            }\n        }\n      \
    \  result[i] = max_depth;\n        i += 1;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    int max_nesting = 0;\n    int nesting = 0;\n    bool\
    \ in_parens = false;\n    foreach (c; paren_string)\n    {\n        if (c == '(')\n\
    \        {\n            in_parens = true;\n            nesting++;\n          \
    \  max_nesting = max(max_nesting, nesting);\n        }\n        else if (c ==\
    \ ')')\n        {\n            nesting--;\n        }\n        else if (c == '\
    \ ' && in_parens)\n        {\n            result ~= max_nesting;\n           \
    \ max_nesting = 0;\n            nesting = 0;\n            in_parens = false;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    int max_nesting = 0;\n    int nesting = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            nesting++;\n            max_nesting\
    \ = max(max_nesting, nesting);\n        }\n        else if(c == ')')\n       \
    \ {\n            nesting--;\n        }\n        else if(c == ' ')\n        {\n\
    \            result ~= max_nesting;\n            max_nesting = 0;\n          \
    \  nesting = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    long[] stack;\n    long[] max_stack;\n    long max_stack_size;\n    long\
    \ stack_size;\n    long max_depth;\n    long depth;\n    long i;\n    long j;\n\
    \    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n    long p;\n\
    \    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n\
    \    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n    long ab;\n\
    \    long ac;\n    long ad;\n    long ae;\n    long af;\n    long ag;\n    long\
    \ ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n    long am;\n\
    \    long an;\n    long ao;\n    long ap;\n    long aq;\n    long ar;\n    long\
    \ as;\n    long at;\n    long au;\n    long av;\n    long aw;\n    long ax;\n\
    \    long ay;\n    long az;\n    long ba;\n    long bb;\n    long bc;\n    long\
    \ bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n    long bi;\n\
    \    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long bn;\n    long\
    \ bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n    long bt;\n\
    \    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long by;\n    long\
    \ bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n    long ce;\n\
    \    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long cj;\n    long\
    \ ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n    long cp;\n\
    \    long", "{\n    long[] result = new long[];\n    foreach(paren_group; paren_string.split(\"\
    \ \")) \n    {\n        long max_nesting = 0;\n        long nesting = 0;\n   \
    \     foreach(paren; paren_group) \n        {\n            if(paren == '(') \n\
    \            {\n                nesting++;\n                max_nesting = max(max_nesting,\
    \ nesting);\n            } \n            else if(paren == ')') \n            {\n\
    \                nesting--;\n            }\n        }\n        result ~= max_nesting;\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    long[] paren_count;\n\
    \    long[] max_paren_count;\n    long[] max_paren_count_index;\n    long[] max_paren_count_index_temp;\n\
    \    long[] max_paren_count_index_temp_temp;\n    long[] max_paren_count_index_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp;\n    long[] max_paren_count_index_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp;\n    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp;\n \
    \   long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count", "{\n    long[] result;\n    foreach(paren_group;\
    \ paren_string.split(\" \"))\n    {\n        long max_level = 0;\n        long\
    \ level = 0;\n        foreach(paren; paren_group)\n        {\n            if(paren\
    \ == '(')\n            {\n                level++;\n                max_level\
    \ = max(max_level, level);\n            }\n            else if(paren == ')')\n\
    \            {\n                level--;\n            }\n        }\n        result\
    \ ~= max_level;\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
