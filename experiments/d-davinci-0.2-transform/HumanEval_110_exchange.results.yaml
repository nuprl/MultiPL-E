language: d
name: HumanEval_110_exchange
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    //\
    \ Check if the lists are empty\n    if (lst1.length == 0 || lst2.length == 0)\n\
    \    {\n        return \"NO\";\n    }\n    // Check if the lists are the same\
    \ size\n    if (lst1.length != lst2.length)\n    {\n        return \"NO\";\n \
    \   }\n    // Check if the lists are the same\n    if (lst1 == lst2)\n    {\n\
    \        return \"YES\";\n    }\n    // Check if the lists are the same but in\
    \ reverse order\n    if (lst1 == lst2.reverse)\n    {\n        return \"YES\"\
    ;\n    }\n    // Check if the lists are the same but in reverse order\n    if\
    \ (lst1.reverse == lst2)\n    {\n        return \"YES\";\n    }\n    // Check\
    \ if the lists are the same but in reverse order\n    if (lst1.reverse == lst2.reverse)\n\
    \    {\n        return \"YES\";\n    }\n    // Check if the lists are the same\
    \ but in reverse order\n    if (lst1 == lst2.reverse.reverse)\n    {\n       \
    \ return \"YES\";\n    }\n    // Check if the lists are the same but in reverse\
    \ order\n    if (lst1.reverse == lst2.reverse)\n    {\n        return \"YES\"\
    ;\n    }\n    // Check if the lists are the same but in reverse order\n    if\
    \ (lst1.reverse == lst2.reverse.reverse)\n    {\n        return \"YES\";\n   \
    \ }\n    // Check if the lists are the same but in reverse order\n    if (lst1.reverse.reverse\
    \ == lst2.reverse)\n    {\n        return \"YES\";\n    }\n    // Check if the\
    \ lists are the same but in reverse order\n    if (lst1.reverse.reverse == lst2.reverse.reverse)\n\
    \    {\n        return \"YES\";\n    }\n    // Check if the lists are the same\
    \ but in reverse order\n    if (lst1.reverse.reverse == lst2)\n    {\n       \
    \ return \"YES\";\n    }\n    // Check if the lists are the same but in reverse\
    \ order\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpymu123t4.d(82): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymu123t4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    bool[]\
    \ lst1_even = lst1.map!(a => a % 2 == 0);\n    bool[] lst2_even = lst2.map!(a\
    \ => a % 2 == 0);\n    return lst1_even.count!(a => a) == lst1.length ||\n   \
    \        lst2_even.count!(a => a) == lst2.length ? \"YES\" : \"NO\";\n}\nunittest\n\
    {\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmwwxe_bi.d(21): Error: no property `map` for type `long[]`\n/tmp/tmpmwwxe_bi.d(22):
    Error: no property `map` for type `long[]`\n/tmp/tmpmwwxe_bi.d(23): Error: no
    property `count` for type `bool[]`\n/tmp/tmpmwwxe_bi.d(24): Error: no property
    `count` for type `bool[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmwwxe_bi.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    int\
    \ evens = 0;\n    int odds = 0;\n    foreach(l; lst1)\n    {\n        if(l % 2\
    \ == 0)\n            evens++;\n        else\n            odds++;\n    }\n    foreach(l;\
    \ lst2)\n    {\n        if(l % 2 == 0)\n            evens++;\n        else\n \
    \           odds++;\n    }\n    if(evens > odds)\n        return \"YES\";\n  \
    \  else\n        return \"NO\";\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpixhr65c0.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x42870d]\n??:? void tmpixhr65c0.__unittest_L42_C1() [0x427f5a]\n??:?
    void tmpixhr65c0.__modtest() [0x42848c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b585]\n??:? runModuleUnitTests [0x42c475]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428ae3]\n??:? _d_run_main [0x428a4e]\n??:? main [0x42849f]\n??:?
    __libc_start_main [0x47e69554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    //\
    \ Write your code here\n    int count = 0;\n    foreach(i; lst1)\n    {\n    \
    \    if(i % 2 == 0)\n        {\n            count++;\n        }\n    }\n    if(count\
    \ == lst1.length)\n    {\n        return \"YES\";\n    }\n    else\n    {\n  \
    \      return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp0vx_j8_4.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286a5]\n??:? void tmp0vx_j8_4.__unittest_L39_C1() [0x427ef6]\n??:?
    void tmp0vx_j8_4.__modtest() [0x428428]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c637]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b546]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43065d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b0c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4305e9]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b51d]\n??:? runModuleUnitTests [0x42c40d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428af4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428a7b]\n??:? _d_run_main [0x4289e6]\n??:? main [0x42843b]\n??:?
    __libc_start_main [0x17f4554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    int\
    \ evenCount = 0;\n    int oddCount = 0;\n    foreach(long i; lst1)\n    {\n  \
    \      if(i % 2 == 0)\n        {\n            evenCount++;\n        }\n      \
    \  else\n        {\n            oddCount++;\n        }\n    }\n    foreach(long\
    \ i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            evenCount++;\n\
    \        }\n        else\n        {\n            oddCount++;\n        }\n    }\n\
    \    if(evenCount > oddCount)\n    {\n        return \"YES\";\n    }\n    else\n\
    \    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_x_23p66.d(58): unittest failure\n----------------\n??:?
    _d_unittestp [0x42870d]\n??:? void tmp_x_23p66.__unittest_L54_C1() [0x427f5a]\n??:?
    void tmp_x_23p66.__modtest() [0x42848c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b585]\n??:? runModuleUnitTests [0x42c475]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428ae3]\n??:? _d_run_main [0x428a4e]\n??:? main [0x42849f]\n??:?
    __libc_start_main [0x3aa07554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    auto\
    \ even = (long x) => x % 2 == 0;\n    auto odd = (long x) => x % 2 != 0;\n   \
    \ auto lst1_even = lst1.filter!even;\n    auto lst1_odd = lst1.filter!odd;\n \
    \   auto lst2_even = lst2.filter!even;\n    auto lst2_odd = lst2.filter!odd;\n\
    \    if (lst1_even.length == lst1.length)\n        return \"YES\";\n    if (lst1_odd.length\
    \ == lst1.length)\n        return \"NO\";\n    if (lst1_even.length + lst2_even.length\
    \ >= lst1.length)\n        return \"YES\";\n    if (lst1_odd.length + lst2_odd.length\
    \ >= lst1.length)\n        return \"NO\";\n    return \"NO\";\n}\n/*\n    In this\
    \ problem, you will implement a function that takes a list of\n    numbers, and\
    \ returns the sum of the numbers.\n    For example:\n    >>> sum_list([1L, 2L,\
    \ 3L])\n    6L\n    >>> sum_list([1L, 2L, 3L, 4L])\n    10L\n    >>> sum_list([1L,\
    \ 2L, 3L, 4L, 5L])\n    15L\n    It is assumed that the input list will be non-empty.\n\
    */\nlong sum_list(long[] lst) \n{\n    return lst.reduce!((a, b) => a + b)(0L);\n\
    }\n/*\n    In this problem, you will implement a function that takes a list of\n\
    \    numbers, and returns the sum of the numbers.\n    For example:\n    >>> sum_list([1L,\
    \ 2L, 3L])\n    6L\n    >>> sum_list([1L, 2L, 3L, 4L])\n    10L\n    >>> sum_list([1L,\
    \ 2L, 3L, 4L, 5L])\n    15L\n    It is assumed that the input list will be non-empty.\n\
    */\nlong sum_list2(long[] l\nunittest\n{\n    alias candidate = exchange;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwcuw61ju.d(66): Error: found `unittest` when expecting `)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwcuw61ju.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    bool\
    \ flag = false;\n    foreach(i; lst1)\n    {\n        if(i % 2 == 0)\n       \
    \ {\n            flag = true;\n            break;\n        }\n    }\n    if(flag)\n\
    \    {\n        return \"YES\";\n    }\n    else\n    {\n        foreach(i; lst1)\n\
    \        {\n            foreach(j; lst2)\n            {\n                if(i\
    \ % 2 != 0 && j % 2 == 0)\n                {\n                    return \"YES\"\
    ;\n                }\n            }\n        }\n    }\n    return \"NO\";\n}\n\
    unittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j5nkpfd.d(54): unittest failure\n----------------\n??:?
    _d_unittestp [0x42877d]\n??:? void tmp3j5nkpfd.__unittest_L49_C1() [0x4280a9]\n??:?
    void tmp3j5nkpfd.__modtest() [0x428500]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c70f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b61e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430735]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430be4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306c1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f5]\n??:? runModuleUnitTests [0x42c4e5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bcc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b53]\n??:? _d_run_main [0x428abe]\n??:? main [0x428513]\n??:?
    __libc_start_main [0xcf480554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    long[]\
    \ lst1_even = lst1.filter!(x => x % 2 == 0);\n    long[] lst2_odd = lst2.filter!(x\
    \ => x % 2 != 0);\n    if (lst1_even.length == lst1.length)\n        return \"\
    YES\";\n    else if (lst1_even.length + lst2_odd.length >= lst1.length)\n    \
    \    return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg8j266is.d(21): Error: no property `filter` for type `long[]`\n/tmp/tmpg8j266is.d(22):
    Error: no property `filter` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpg8j266is.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    int\
    \ lst1_even = 0;\n    int lst2_even = 0;\n    foreach(i; lst1)\n    {\n      \
    \  if(i % 2 == 0)\n        {\n            lst1_even++;\n        }\n    }\n   \
    \ foreach(i; lst2)\n    {\n        if(i % 2 == 0)\n        {\n            lst2_even++;\n\
    \        }\n    }\n    if(lst1_even == lst1.length)\n    {\n        return \"\
    YES\";\n    }\n    else if(lst2_even == lst2.length)\n    {\n        return \"\
    YES\";\n    }\n    else if(lst1_even + lst2_even >= lst1.length)\n    {\n    \
    \    return \"YES\";\n    }\n    else\n    {\n        return \"NO\";\n    }\n\
    }\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L, 2L,\
    \ 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L,\
    \ 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    int\
    \ len1 = lst1.length;\n    int len2 = lst2.length;\n    int[] even1 = new int[len1];\n\
    \    int[] even2 = new int[len2];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    for (int i = 0; i < len1; i++)\n    {\n        if (lst1[i] % 2 == 0)\n  \
    \      {\n            even1[count1] = i;\n            count1++;\n        }\n \
    \   }\n    for (int i = 0; i < len2; i++)\n    {\n        if (lst2[i] % 2 == 0)\n\
    \        {\n            even2[count2] = i;\n            count2++;\n        }\n\
    \    }\n    if (count1 == len1)\n    {\n        return \"YES\";\n    }\n    if\
    \ (count2 == 0)\n    {\n        return \"NO\";\n    }\n    for (int i = 0; i <\
    \ count1; i++)\n    {\n        for (int j = 0; j < count2; j++)\n        {\n \
    \           long temp = lst1[even1[i]];\n            lst1[even1[i]] = lst2[even2[j]];\n\
    \            lst2[even2[j]] = temp;\n            count1 = 0;\n            count2\
    \ = 0;\n            for (int k = 0; k < len1; k++)\n            {\n          \
    \      if (lst1[k] % 2 == 0)\n                {\n                    count1++;\n\
    \                }\n            }\n            for (int k = 0; k < len2; k++)\n\
    \            {\n                if (lst2[k] % 2 == 0)\n                {\n   \
    \                 count2++;\n                }\n            }\n            if\
    \ (count1 == len1)\n            {\n                return \"YES\";\n         \
    \   }\n            if (count2 == 0)\n            {\n                return \"\
    NO\";\n            }\n            temp = lst1[even1[i]];\n            lst1[even1[i]]\
    \ = lst2[even2[j]];\n            lst2\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnnw9q6yv.d(85): Error: found `unittest` when expecting `;` following
    statement\n/tmp/tmpnnw9q6yv.d(97): Error: found `End of File` when expecting `}`
    following compound statement\n/tmp/tmpnnw9q6yv.d(97): Error: found `End of File`
    when expecting `}` following compound statement\n/tmp/tmpnnw9q6yv.d(97): Error:
    found `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnnw9q6yv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    int\
    \ lst1_len = lst1.length;\n    int lst2_len = lst2.length;\n    int lst1_even_count\
    \ = 0;\n    int lst2_even_count = 0;\n    int lst1_odd_count = 0;\n    int lst2_odd_count\
    \ = 0;\n    for (int i = 0; i < lst1_len; i++)\n    {\n        if (lst1[i] % 2\
    \ == 0)\n        {\n            lst1_even_count++;\n        }\n        else\n\
    \        {\n            lst1_odd_count++;\n        }\n    }\n    for (int i =\
    \ 0; i < lst2_len; i++)\n    {\n        if (lst2[i] % 2 == 0)\n        {\n   \
    \         lst2_even_count++;\n        }\n        else\n        {\n           \
    \ lst2_odd_count++;\n        }\n    }\n    if (lst1_even_count + lst2_odd_count\
    \ == lst1_len)\n    {\n        return \"YES\";\n    }\n    else\n    {\n     \
    \   return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps88d8l4u.d(21): Error: cannot implicitly convert expression
    `lst1.length` of type `ulong` to `int`\n/tmp/tmps88d8l4u.d(22): Error: cannot
    implicitly convert expression `lst2.length` of type `ulong` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps88d8l4u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    int\
    \ i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n   \
    \ int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb =\
    \ 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n   \
    \ int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk =\
    \ 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n   \
    \ int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt =\
    \ 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n   \
    \ int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n    int bbb = 0;\n    int ccc\
    \ = 0;\n    int ddd = 0;\n    int eee = 0;\n    int fff = 0;\n    int ggg = 0;\n\
    \    int hhh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int\
    \ lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo = 0;\n    int ppp\
    \ = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int sss = 0;\n    int ttt = 0;\n\
    \    int uuu = 0;\n    int vvv = 0;\n    int www = 0;\n    int\nunittest\n{\n\
    \    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8oqqv66k.d(89): Error: no identifier for declarator `int`\n/tmp/tmp8oqqv66k.d(89):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8oqqv66k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    bool\
    \ isEven(long n) { return n % 2 == 0; }\n    bool isOdd(long n) { return n % 2\
    \ != 0; }\n    int evenCount = 0;\n    int oddCount = 0;\n    foreach(n; lst1)\
    \ if(isEven(n)) evenCount++; else oddCount++;\n    foreach(n; lst2) if(isEven(n))\
    \ evenCount++; else oddCount++;\n    return evenCount > oddCount ? \"YES\" : \"\
    NO\";\n}\n/*\n    In this problem, you will implement a function that takes a\
    \ list of numbers,\n    and returns the number of elements in the list that are\
    \ greater than the\n    average value of the list.\n    For example:\n    >>>\
    \ greaterThanAverage([1L, 2L, 3L, 4L, 5L])\n    2\n    >>> greaterThanAverage([1L,\
    \ 2L, 3L, 4L, 5L, 6L])\n    3\n    It is assumed that the input list will be non-empty.\n\
    */\nunittest\n{\n    alias candidate = exchange;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L,\
    \ 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L])\
    \ == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n\
    \    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"\
    NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_s_71ftc.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x4287d5]\n??:? void tmp_s_71ftc.__unittest_L40_C1() [0x428022]\n??:?
    void tmp_s_71ftc.__modtest() [0x428554]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c767]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b676]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43078d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c3c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430719]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b64d]\n??:? runModuleUnitTests [0x42c53d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c24]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428bab]\n??:? _d_run_main [0x428b16]\n??:? main [0x428567]\n??:?
    __libc_start_main [0xe22ff554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    bool\
    \ isEven(long n)\n    {\n        return n % 2 == 0;\n    }\n    bool isOdd(long\
    \ n)\n    {\n        return n % 2 != 0;\n    }\n    bool isEvenList(long[] lst)\n\
    \    {\n        return lst.all!isEven;\n    }\n    bool isOddList(long[] lst)\n\
    \    {\n        return lst.all!isOdd;\n    }\n    bool isEvenOddList(long[] lst)\n\
    \    {\n        return lst.all!isEven || lst.all!isOdd;\n    }\n    bool isEvenOddList(long[]\
    \ lst1, long[] lst2)\n    {\n        return isEvenOddList(lst1) && isEvenOddList(lst2);\n\
    \    }\n    if (isEvenOddList(lst1, lst2))\n    {\n        return \"YES\";\n \
    \   }\n    else\n    {\n        return \"NO\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnt__t_e2.d(31): Error: no property `all` for type `long[]`\n/tmp/tmpnt__t_e2.d(35):
    Error: no property `all` for type `long[]`\n/tmp/tmpnt__t_e2.d(39): Error: no
    property `all` for type `long[]`\n/tmp/tmpnt__t_e2.d(39): Error: no property `all`
    for type `long[]`\n/tmp/tmpnt__t_e2.d(41): Error: declaration `isEvenOddList`
    is already defined\n/tmp/tmpnt__t_e2.d(45): Error: function `tmpnt__t_e2.exchange.isEvenOddList(long[]
    lst)` is not callable using argument types `(long[], long[])`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnt__t_e2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    int\
    \ lst1_odd_count = 0;\n    int lst2_odd_count = 0;\n    foreach(num; lst1)\n \
    \   {\n        if(num % 2 != 0)\n        {\n            lst1_odd_count++;\n  \
    \      }\n    }\n    foreach(num; lst2)\n    {\n        if(num % 2 != 0)\n   \
    \     {\n            lst2_odd_count++;\n        }\n    }\n    if(lst1_odd_count\
    \ == lst2_odd_count)\n    {\n        return \"YES\";\n    }\n    else\n    {\n\
    \        return \"NO\";\n    }\n}\nunittest\n{\n    alias candidate = exchange;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L,\
    \ 2L, 3L, 4L], [1L, 5L, 3L, 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L,\
    \ 4L], [2L, 1L, 4L, 3L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L,\
    \ 6L, 4L]) == \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"\
    NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L])\
    \ == \"NO\");\n    assert(candidate([100L, 200L], [200L, 200L]) == \"YES\");\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7vgupq9s.d(53): unittest failure\n----------------\n??:?
    _d_unittestp [0x428705]\n??:? void tmp7vgupq9s.__unittest_L46_C1() [0x428199]\n??:?
    void tmp7vgupq9s.__modtest() [0x428484]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b6c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430649]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b57d]\n??:? runModuleUnitTests [0x42c46d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b54]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428adb]\n??:? _d_run_main [0x428a46]\n??:? main [0x428497]\n??:?
    __libc_start_main [0xe7511554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    //\
    \ Write your code here\n    bool isEven(long n) { return n % 2 == 0; }\n    bool\
    \ isOdd(long n) { return n % 2 != 0; }\n    bool isEvenList(long[] lst) { return\
    \ all!(isEven)(lst); }\n    bool isOddList(long[] lst) { return all!(isOdd)(lst);\
    \ }\n    bool isEvenList1 = isEvenList(lst1);\n    bool isEvenList2 = isEvenList(lst2);\n\
    \    bool isOddList1 = isOddList(lst1);\n    bool isOddList2 = isOddList(lst2);\n\
    \    if (isEvenList1 && isEvenList2) return \"YES\";\n    if (isOddList1 && isOddList2)\
    \ return \"NO\";\n    if (isEvenList1 && isOddList2) return \"YES\";\n    if (isOddList1\
    \ && isEvenList2) return \"YES\";\n    return \"NO\";\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjd7wdcg4.d(24): Error: template instance `all!isEven` template
    `all` is not defined\n/tmp/tmpjd7wdcg4.d(25): Error: template instance `all!isOdd`
    template `all` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjd7wdcg4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    long[]\
    \ lst1_even = lst1.filter!(x => x % 2 == 0);\n    long[] lst2_odd = lst2.filter!(x\
    \ => x % 2 != 0);\n    if (lst1_even.length == lst1.length)\n        return \"\
    YES\";\n    else if (lst1_even.length + lst2_odd.length >= lst1.length)\n    \
    \    return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n    alias\
    \ candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 2L, 3L,\
    \ 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L, 4L])\
    \ == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) == \"\
    YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n    assert(candidate([5L,\
    \ 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L, 2L, 6L, 1L, 8L,\
    \ 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L, 200L],\
    \ [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg8j266is.d(21): Error: no property `filter` for type `long[]`\n/tmp/tmpg8j266is.d(22):
    Error: no property `filter` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpg8j266is.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    //\
    \ TODO: Implement this function.\n    // Hint: You may find the std.math.isOdd\
    \ function useful.\n    // Hint: You may find the std.typecons.tuple function\
    \ useful.\n    // Hint: You may find the std.algorithm.filter function useful.\n\
    \    // Hint: You may find the std.algorithm.count function useful.\n    // Hint:\
    \ You may find the std.algorithm.map function useful.\n    // Hint: You may find\
    \ the std.algorithm.sort function useful.\n    // Hint: You may find the std.algorithm.take\
    \ function useful.\n    // Hint: You may find the std.algorithm.drop function\
    \ useful.\n    // Hint: You may find the std.algorithm.find function useful.\n\
    \    // Hint: You may find the std.algorithm.findSplit function useful.\n    //\
    \ Hint: You may find the std.algorithm.findSplit function useful.\n    // Hint:\
    \ You may find the std.algorithm.findSplit function useful.\n    // Hint: You\
    \ may find the std.algorithm.findSplit function useful.\n    // Hint: You may\
    \ find the std.algorithm.findSplit function useful.\n    // Hint: You may find\
    \ the std.algorithm.findSplit function useful.\n    // Hint: You may find the\
    \ std.algorithm.findSplit function useful.\n    // Hint: You may find the std.algorithm.findSplit\
    \ function useful.\n    // Hint: You may find the std.algorithm.findSplit function\
    \ useful.\n    // Hint: You may find the std.algorithm.findSplit function useful.\n\
    \    // Hint: You may find the std.algorithm.findSplit function useful.\n    //\
    \ Hint: You may find the std.algorithm.findSplit function useful.\n    // Hint:\
    \ You may find the std.algorithm.findSplit function useful.\n    // Hint: You\
    \ may find the std.algorithm.findSplit function useful.\n    // Hint: You may\
    \ find the std.algorithm.findSplit function useful.\n    // Hint: You may find\
    \ the std.algorithm.findSplit function useful.\n    // Hint: You\nunittest\n{\n\
    \    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_58bgoa3.d(48): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_58bgoa3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    int\
    \ i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n   \
    \ int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb =\
    \ 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n   \
    \ int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk =\
    \ 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n   \
    \ int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt =\
    \ 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n   \
    \ int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n    int bbb = 0;\n    int ccc\
    \ = 0;\n    int ddd = 0;\n    int eee = 0;\n    int fff = 0;\n    int ggg = 0;\n\
    \    int hhh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int\
    \ lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo = 0;\n    int ppp\
    \ = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int sss = 0;\n    int ttt = 0;\n\
    \    int uuu = 0;\n    int vvv = 0;\n    int www = 0;\n    int\nunittest\n{\n\
    \    alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8oqqv66k.d(89): Error: no identifier for declarator `int`\n/tmp/tmp8oqqv66k.d(89):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8oqqv66k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nIn this problem, you will\
    \ implement a function that takes two lists of numbers,\n    and determines whether\
    \ it is possible to perform an exchange of elements\n    between them to make\
    \ lst1 a list of only even numbers.\n    There is no limit on the number of exchanged\
    \ elements between lst1 and lst2.\n    If it is possible to exchange elements\
    \ between the lst1 and lst2 to make\n    all the elements of lst1 to be even,\
    \ return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    >>> exchange([1L,\
    \ 2L, 3L, 4L], [1L, 2L, 3L, 4L])\n    \"YES\"\n    >>> exchange([1L, 2L, 3L, 4L],\
    \ [1L, 5L, 3L, 4L])\n    \"NO\"\n    It is assumed that the input lists will be\
    \ non-empty.\n    \n*/\nstring exchange(long[] lst1, long[] lst2) \n{\n    //\
    \ Your code here\n    int even = 0;\n    int odd = 0;\n    foreach(e; lst1)\n\
    \    {\n        if(e % 2 == 0)\n            even++;\n        else\n          \
    \  odd++;\n    }\n    foreach(e; lst2)\n    {\n        if(e % 2 == 0)\n      \
    \      even++;\n        else\n            odd++;\n    }\n    if(even > odd)\n\
    \        return \"YES\";\n    else\n        return \"NO\";\n}\nunittest\n{\n \
    \   alias candidate = exchange;\n\n    assert(candidate([1L, 2L, 3L, 4L], [1L,\
    \ 2L, 3L, 4L]) == \"YES\");\n    assert(candidate([1L, 2L, 3L, 4L], [1L, 5L, 3L,\
    \ 4L]) == \"NO\");\n    assert(candidate([1L, 2L, 3L, 4L], [2L, 1L, 4L, 3L]) ==\
    \ \"YES\");\n    assert(candidate([5L, 7L, 3L], [2L, 6L, 4L]) == \"YES\");\n \
    \   assert(candidate([5L, 7L, 3L], [2L, 6L, 3L]) == \"NO\");\n    assert(candidate([3L,\
    \ 2L, 6L, 1L, 8L, 9L], [3L, 5L, 5L, 1L, 1L, 1L]) == \"NO\");\n    assert(candidate([100L,\
    \ 200L], [200L, 200L]) == \"YES\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4b_f_jmj.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x42870d]\n??:? void tmp4b_f_jmj.__unittest_L43_C1() [0x427f5a]\n??:?
    void tmp4b_f_jmj.__modtest() [0x42848c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c69f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b585]\n??:? runModuleUnitTests [0x42c475]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b5c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428ae3]\n??:? _d_run_main [0x428a4e]\n??:? main [0x42849f]\n??:?
    __libc_start_main [0x3c215554]\n1/1 unittests FAILED\n'''
  stdout: b''
