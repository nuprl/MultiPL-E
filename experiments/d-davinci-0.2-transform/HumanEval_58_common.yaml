name: HumanEval_58_common
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common elements\
  \ for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
  \ 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n\
  \    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n"
tests: "unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
  \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
  \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L,\
  \ 8L], []) == []);\n}\nvoid main(){}"
completions: ["{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n      \
    \  if (elem in l2) \n        {\n            result ~= elem;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n\
    \    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]", "{\n    long[]\
    \ result = new long[];\n    foreach (l; l1) {\n        if (l2.canFind(l)) {\n\
    \            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n\
    \    long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length)\n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j])\n        {\n            result = result ~ l1_sorted[i];\n \
    \           i++;\n            j++;\n        }\n        else if (l1_sorted[i] <\
    \ l2_sorted[j])\n        {\n            i++;\n        }\n        else\n      \
    \  {\n            j++;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n    >>> common([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n\
    \    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[] result\
    \ = new long[0];\n    foreach (long i; l1)\n    {\n        foreach (long j; l2)\n\
    \        {\n            if (i == j)\n            {\n                result ~=\
    \ i;\n            }\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; sort(l1))\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result;\n}", "{\n    long[] result;\n    long[] l1_copy = l1.dup;\n \
    \   long[] l2_copy = l2.dup;\n    l1_copy.sort;\n    l2_copy.sort;\n    foreach(long\
    \ i; l1_copy)\n    {\n        if(l2_copy.canFind(i))\n        {\n            result\
    \ ~= i;\n        }\n    }\n    return result.dup.sort.uniq;\n}", "{\n    long[]\
    \ result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n\
    \    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    long[] l1_unique_sorted = l1_unique.sort;\n    long[] l2_unique_sorted =\
    \ l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.toSet.array;\n    long[] l1_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set.sort;\n    long[] l2_unique_sorted_set_sorted = l2_unique_sorted_set.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique = l1_unique_sorted_set_sorted.unique;\n\
    \    long[] l2_unique_sorted_set_sorted_unique = l2_unique_sorted_set_sorted.unique;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted = l1_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted = l2_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set = l1_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted_set = l2_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted = l1_unique_sorted_set_sorted_unique_sorted",
  "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] res = [];\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}", "{\n    long[] result = [];\n    foreach (l; l1) \n\
    \    {\n        if (l2.canFind(l)) \n        {\n            result ~= l;\n   \
    \     }\n    }\n    return result.sort().uniq;\n}", "{ \n    long[] result = [];\n\
    \    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n         \
    \   result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n \
    \   long[] result = new long[];\n    foreach (e1; l1) \n    {\n        foreach\
    \ (e2; l2) \n        {\n            if (e1 == e2) \n            {\n          \
    \      result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L,\
    \ 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[] result = new long[0];\n  \
    \  foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n   \
    \ long[] result = new long[0];\n    if (l1.length == 0 || l2.length == 0)\n  \
    \      return result;\n    long[] l1s = l1.dup.sort;\n    long[] l2s = l2.dup.sort;\n\
    \    long[] l1u = l1s.dup.uniq;\n    long[] l2u = l2s.dup.uniq;\n    long[] l1l\
    \ = l1u.dup.length;\n    long[] l2l = l2u.dup.length;\n    long[] l1i = l1u.dup.indices;\n\
    \    long[] l2i = l2u.dup.indices;\n    long[] l1f = l1u.dup.front;\n    long[]\
    \ l2f = l2u.dup.front;\n    long[] l1b = l1u.dup.back;\n    long[] l2b = l2u.dup.back;\n\
    \    long[] l1m = l1u.dup.mid;\n    long[] l2m = l2u.dup.mid;\n    long[] l1e\
    \ = l1u.dup.empty;\n    long[] l2e = l2u.dup.empty;\n    long[] l1r = l1u.dup.retro;\n\
    \    long[] l2r = l2u.dup.retro;\n    long[] l1d = l1u.dup.dup;\n    long[] l2d\
    \ = l2u.dup.dup;\n    long[] l1c = l1u.dup.idup;\n    long[] l2c = l2u.dup.idup;\n\
    \    long[] l1t = l1u.dup.take;\n    long[] l2t = l2u.dup.take;\n    long[] l1g\
    \ = l1u.dup.takeExactly;\n    long[] l2g = l2u.dup.takeExactly;\n    long[] l1o\
    \ = l1u.dup.takeExactly;\n    long[] l2"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
