name: HumanEval_58_common
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common elements\
  \ for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
  \ 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n\
  \    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n"
tests: "unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
  \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
  \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L,\
  \ 8L], []) == []);\n}\nvoid main(){}"
completions: ["{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n      \
    \  if (elem in l2) \n        {\n            result ~= elem;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for\
    \ two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n\
    \    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]", "{\n    long[]\
    \ result = new long[];\n    foreach (l; l1) {\n        if (l2.canFind(l)) {\n\
    \            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n\
    \    long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length)\n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j])\n        {\n            result = result ~ l1_sorted[i];\n \
    \           i++;\n            j++;\n        }\n        else if (l1_sorted[i] <\
    \ l2_sorted[j])\n        {\n            i++;\n        }\n        else\n      \
    \  {\n            j++;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result;\n}\n/*\n\
    Return sorted unique common elements for two lists.\n    >>> common([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n\
    \    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[] result\
    \ = new long[0];\n    foreach (long i; l1)\n    {\n        foreach (long j; l2)\n\
    \        {\n            if (i == j)\n            {\n                result ~=\
    \ i;\n            }\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; sort(l1))\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result;\n}", "{\n    long[] result;\n    long[] l1_copy = l1.dup;\n \
    \   long[] l2_copy = l2.dup;\n    l1_copy.sort;\n    l2_copy.sort;\n    foreach(long\
    \ i; l1_copy)\n    {\n        if(l2_copy.canFind(i))\n        {\n            result\
    \ ~= i;\n        }\n    }\n    return result.dup.sort.uniq;\n}", "{\n    long[]\
    \ result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n\
    \    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    long[] l1_unique_sorted = l1_unique.sort;\n    long[] l2_unique_sorted =\
    \ l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.toSet.array;\n    long[] l1_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set.sort;\n    long[] l2_unique_sorted_set_sorted = l2_unique_sorted_set.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique = l1_unique_sorted_set_sorted.unique;\n\
    \    long[] l2_unique_sorted_set_sorted_unique = l2_unique_sorted_set_sorted.unique;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted = l1_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted = l2_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set = l1_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted_set = l2_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted = l1_unique_sorted_set_sorted_unique_sorted",
  "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] res = [];\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}", "{\n    long[] result = [];\n    foreach (l; l1) \n\
    \    {\n        if (l2.canFind(l)) \n        {\n            result ~= l;\n   \
    \     }\n    }\n    return result.sort().uniq;\n}", "{ \n    long[] result = [];\n\
    \    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n         \
    \   result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n \
    \   long[] result = new long[];\n    foreach (e1; l1) \n    {\n        foreach\
    \ (e2; l2) \n        {\n            if (e1 == e2) \n            {\n          \
    \      result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique\
    \ common elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L,\
    \ 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[] result = new long[0];\n  \
    \  foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n   \
    \ long[] result = new long[0];\n    if (l1.length == 0 || l2.length == 0)\n  \
    \      return result;\n    long[] l1s = l1.dup.sort;\n    long[] l2s = l2.dup.sort;\n\
    \    long[] l1u = l1s.dup.uniq;\n    long[] l2u = l2s.dup.uniq;\n    long[] l1l\
    \ = l1u.dup.length;\n    long[] l2l = l2u.dup.length;\n    long[] l1i = l1u.dup.indices;\n\
    \    long[] l2i = l2u.dup.indices;\n    long[] l1f = l1u.dup.front;\n    long[]\
    \ l2f = l2u.dup.front;\n    long[] l1b = l1u.dup.back;\n    long[] l2b = l2u.dup.back;\n\
    \    long[] l1m = l1u.dup.mid;\n    long[] l2m = l2u.dup.mid;\n    long[] l1e\
    \ = l1u.dup.empty;\n    long[] l2e = l2u.dup.empty;\n    long[] l1r = l1u.dup.retro;\n\
    \    long[] l2r = l2u.dup.retro;\n    long[] l1d = l1u.dup.dup;\n    long[] l2d\
    \ = l2u.dup.dup;\n    long[] l1c = l1u.dup.idup;\n    long[] l2c = l2u.dup.idup;\n\
    \    long[] l1t = l1u.dup.take;\n    long[] l2t = l2u.dup.take;\n    long[] l1g\
    \ = l1u.dup.takeExactly;\n    long[] l2g = l2u.dup.takeExactly;\n    long[] l1o\
    \ = l1u.dup.takeExactly;\n    long[] l2", "{\n    long[] result = [];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    return l1.filter!(a\
    \ => l2.canFind(a)).sort().uniq;\n}", "{\n    auto s1 = l1.sort().uniq;\n    auto\
    \ s2 = l2.sort().uniq;\n    long[] result;\n    foreach(i; s1)\n    {\n      \
    \  if(s2.canFind(i))\n        {\n            result ~= i;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result = [];\n    foreach (l; l1) \n \
    \   {\n        if (l in l2) \n        {\n            result ~= l;\n        }\n\
    \    }\n    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n\
    \    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n         \
    \   result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n \
    \   long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.count(l)\
    \ > 0)\n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long[] l1_unique = unique(l1_sorted);\n\
    \    long[] l2_unique = unique(l2_sorted);\n    long[] l1_unique_sorted = sort(l1_unique);\n\
    \    long[] l2_unique_sorted = sort(l2_unique);\n    long[] l1_unique_sorted_reversed\
    \ = reverse(l1_unique_sorted);\n    long[] l2_unique_sorted_reversed = reverse(l2_unique_sorted);\n\
    \    long[] l1_unique_sorted_reversed_unique = unique(l1_unique_sorted_reversed);\n\
    \    long[] l2_unique_sorted_reversed_unique = unique(l2_unique_sorted_reversed);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted = sort(l1_unique_sorted_reversed_unique);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted = sort(l2_unique_sorted_reversed_unique);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted_reversed = reverse(l1_unique_sorted_reversed_unique_sorted);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted_reversed = reverse(l2_unique_sorted_reversed_unique_sorted);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted_reversed_unique = unique(l1_unique_sorted_reversed_unique_sorted_reversed);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted_reversed_unique = unique(l2_unique_sorted_reversed_unique_sorted_reversed);\n\
    \    long[] l1_unique_sorted_reversed_unique_s", "{\n    long[] result = [];\n\
    \    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n         \
    \   result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n \
    \   long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().unique;\n\
    }", "{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0];\n    foreach (long i; l1) \n    {\n \
    \       if (l2.canFind(i)) \n        {\n            result ~= i;\n        }\n\
    \    }\n    return result.sort().dup.unique;\n}", "{\n    long[] result = new\
    \ long[0];\n    foreach (long i; l1)\n    {\n        if (l2.canFind(i))\n    \
    \    {\n            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L,\
    \ 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n \
    \   [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        result ~= l;\n    }\n    foreach\
    \ (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L,\
    \ 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n \
    \   [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        result ~= l;\n    }\n    foreach\
    \ (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n", "{\n    long[] res = [];\n\
    \    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n         \
    \   res ~= l;\n        }\n    }\n    return res.sort().uniq;\n}", "{\n    long[]\
    \ ret = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n \
    \       {\n            ret ~= l;\n        }\n    }\n    ret = ret.sort().uniq;\n\
    \    return ret;\n}", "{\n    long[] result = [];\n    foreach (l; l1) \n    {\n\
    \        if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n\
    \    }\n    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n\
    \    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n         \
    \   if (!result.canFind(l))\n            {\n                result ~= l;\n   \
    \         }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n\
    \    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[]\
    \ unique(long[] l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach\
    \ (l; l1)\n    {\n        if (!result.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    foreach (l; l2)\n    {\n        if (!result.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique elements for two lists.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L,\
    \ 5L, 7L, 9L, 34L, 121L, 653L]\n    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n \
    \   [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = new long[];\n    foreach (l; l1)\n    {\n        if (!result.can",
  "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}",
  "{\n    long[] result = new long[0];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort.uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}",
  "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().dup.unique;\n}", "{\n    long[] result = new long[0];\n\
    \    foreach (long l; l1) \n    {\n        if (l2.canFind(l)) \n        {\n  \
    \          result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    auto s1 = set(l1);\n    auto s2 = set(l2);\n    return s1.intersection(s2).array;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] res = [];\n    foreach (l;\
    \ l1)\n    {\n        if (l2.canFind(l))\n        {\n            res ~= l;\n \
    \       }\n    }\n    return res.sort().uniq;\n}", "{\n    long[] result = new\
    \ long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n\
    \            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set & l2_set;\n    return common_set.array;\n}", "{\n    long[] result\
    \ = new long[0];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l)) \n \
    \       {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] l3 = new long[l1.length + l2.length];\n    long[] l4 = new\
    \ long[l1.length + l2.length];\n    long[] l5 = new long[l1.length + l2.length];\n\
    \    long[] l6 = new long[l1.length + l2.length];\n    long[] l7 = new long[l1.length\
    \ + l2.length];\n    long[] l8 = new long[l1.length + l2.length];\n    long[]\
    \ l9 = new long[l1.length + l2.length];\n    long[] l10 = new long[l1.length +\
    \ l2.length];\n    long[] l11 = new long[l1.length + l2.length];\n    long[] l12\
    \ = new long[l1.length + l2.length];\n    long[] l13 = new long[l1.length + l2.length];\n\
    \    long[] l14 = new long[l1.length + l2.length];\n    long[] l15 = new long[l1.length\
    \ + l2.length];\n    long[] l16 = new long[l1.length + l2.length];\n    long[]\
    \ l17 = new long[l1.length + l2.length];\n    long[] l18 = new long[l1.length\
    \ + l2.length];\n    long[] l19 = new long[l1.length + l2.length];\n    long[]\
    \ l20 = new long[l1.length + l2.length];\n    long[] l21 = new long[l1.length\
    \ + l2.length];\n    long[] l22 = new long[l1.length + l2.length];\n    long[]\
    \ l23 = new long[l1.length + l2.length];\n    long[] l24 = new long[l1.length\
    \ + l2.length];\n    long[] l25 = new long[l1.length + l2.length];\n    long[]\
    \ l26 = new long[l1.length + l2.length];\n    long[] l27 = new long[l1.length\
    \ + l2.length];\n    long[] l28 = new long[", "{\n    long[] ret = new long[0];\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ ret ~= l;\n        }\n    }\n    return ret.sort().uniq;\n}", "{\n    long[]\
    \ result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l)) \n   \
    \     {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    long[] l1_unique;\n    long[] l2_unique;\n   \
    \ long[] l1_sorted;\n    long[] l2_sorted;\n    long[] l1_sorted_unique;\n   \
    \ long[] l2_sorted_unique;\n    long[] l1_sorted_unique_common;\n    long[] l2_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted;\n    long[] l2_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique;\n    long[] l2_sorted_unique_common_sorted_unique;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common;\n    long[] l2_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted;\n    long[] l2_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique;\n    long[]\
    \ l2_sorted_unique_common_sorted_unique_common_sorted_unique;\n    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l1_sorted_unique_common_sorted", "{\n    long[] result = new long[0L];\n\
    \    foreach (e; l1)\n    {\n        if (e in l2)\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ result = new long[];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}", "{\n    long[] result = [];\n    foreach (e1;\
    \ l1) \n    {\n        foreach (e2; l2) \n        {\n            if (e1 == e2)\
    \ \n            {\n                result ~= e1;\n            }\n        }\n \
    \   }\n    return result.sort().uniq;\n}", "{\n    long[] result;\n    long[]\
    \ l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n    long[] l1_unique\
    \ = uniq(l1_sorted);\n    long[] l2_unique = uniq(l2_sorted);\n    foreach(l1_u;\
    \ l1_unique)\n    {\n        foreach(l2_u; l2_unique)\n        {\n           \
    \ if(l1_u == l2_u)\n            {\n                result ~= l1_u;\n         \
    \   }\n        }\n    }\n    return result;\n}", "{\n    long[] l3 = new long[l1.length];\n\
    \    int j = 0;\n    foreach(l; l1)\n    {\n        foreach(l2; l2)\n        {\n\
    \            if(l == l2)\n            {\n                l3[j] = l;\n        \
    \        j++;\n            }\n        }\n    }\n    return l3;\n}", "{\n    long[]\
    \ result = new long[0];\n    if (l1.length == 0 || l2.length == 0)\n    {\n  \
    \      return result;\n    }\n    long[] l1_sorted = l1.dup.sort;\n    long[]\
    \ l2_sorted = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[]\
    \ l2_unique = l2_sorted.unique;\n    foreach (l1_elem; l1_unique)\n    {\n   \
    \     foreach (l2_elem; l2_unique)\n        {\n            if (l1_elem == l2_elem)\n\
    \            {\n                result ~= l1_elem;\n            }\n        }\n\
    \    }\n    return result;\n}", "{\n    auto l1_set = l1.sort().uniq;\n    auto\
    \ l2_set = l2.sort().uniq;\n    auto result = new long[](max(l1_set.length, l2_set.length));\n\
    \    auto result_len = 0;\n    foreach (i, e; l1_set) {\n        if (l2_set.canFind(e))\
    \ {\n            result[result_len] = e;\n            result_len++;\n        }\n\
    \    }\n    return result[0..result_len];\n}", "{\n    long[] result;\n    long[]\
    \ l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n    long[] l1_unique\
    \ = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n    foreach(l1_u;\
    \ l1_unique)\n    {\n        foreach(l2_u; l2_unique)\n        {\n           \
    \ if(l1_u == l2_u)\n            {\n                result ~= l1_u;\n         \
    \   }\n        }\n    }\n    return result;\n}", "{\n    long[] l3 = new long[l1.length\
    \ + l2.length];\n    long[] l4 = new long[l1.length + l2.length];\n    long[]\
    \ l5 = new long[l1.length + l2.length];\n    long[] l6 = new long[l1.length +\
    \ l2.length];\n    long[] l7 = new long[l1.length + l2.length];\n    long[] l8\
    \ = new long[l1.length + l2.length];\n    long[] l9 = new long[l1.length + l2.length];\n\
    \    long[] l10 = new long[l1.length + l2.length];\n    long[] l11 = new long[l1.length\
    \ + l2.length];\n    long[] l12 = new long[l1.length + l2.length];\n    long[]\
    \ l13 = new long[l1.length + l2.length];\n    long[] l14 = new long[l1.length\
    \ + l2.length];\n    long[] l15 = new long[l1.length + l2.length];\n    long[]\
    \ l16 = new long[l1.length + l2.length];\n    long[] l17 = new long[l1.length\
    \ + l2.length];\n    long[] l18 = new long[l1.length + l2.length];\n    long[]\
    \ l19 = new long[l1.length + l2.length];\n    long[] l20 = new long[l1.length\
    \ + l2.length];\n    long[] l21 = new long[l1.length + l2.length];\n    long[]\
    \ l22 = new long[l1.length + l2.length];\n    long[] l23 = new long[l1.length\
    \ + l2.length];\n    long[] l24 = new long[l1.length + l2.length];\n    long[]\
    \ l25 = new long[l1.length + l2.length];\n    long[] l26 = new long[l1.length\
    \ + l2.length];\n    long[] l27 = new long[l1.length + l2.length];\n    long[]\
    \ l28 = new long[", "{\n    auto result = new long[](0);\n    auto l1_set = new\
    \ long[](0);\n    auto l2_set = new long[](0);\n    l1_set = l1.dup;\n    l2_set\
    \ = l2.dup;\n    l1_set.sort;\n    l2_set.sort;\n    l1_set = l1_set.uniq;\n \
    \   l2_set = l2_set.uniq;\n    foreach(i; 0..l1_set.length)\n    {\n        foreach(j;\
    \ 0..l2_set.length)\n        {\n            if(l1_set[i] == l2_set[j])\n     \
    \       {\n                result ~= l1_set[i];\n            }\n        }\n  \
    \  }\n    return result;\n}", "{\n    long[] result = new long[];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n\
    \            {\n                result ~= l;\n            }\n        }\n    }\n\
    \    return result;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two lists.\n    >>>\
    \ common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n   \
    \ long[] result;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n     \
    \   {\n            result ~= e;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[0];\n    foreach (elem; l1) \n    {\n        if\
    \ (elem in l2) \n        {\n            result ~= elem;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    return l1.filter!(x\
    \ => l2.canFind(x)).sort().uniq;\n}", "{\n    long[] result = [];\n    foreach\
    \ (l; l1) \n    {\n        if (l2.canFind(l)) \n        {\n            if (!result.canFind(l))\
    \ \n            {\n                result ~= l;\n            }\n        }\n  \
    \  }\n    return result.sort();\n}", "{\n    long[] result = [];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] res\
    \ = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n \
    \           res ~= l;\n        }\n    }\n    return res.sort().uniq;\n}", "{\n\
    \    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n   \
    \ long[] result;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n     \
    \   {\n            result ~= e;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    foreach (l; l1) {\n        if (l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort.uniq;\n\
    }", "{\n    long[] result;\n    long[] l1_unique = l1.unique;\n    long[] l2_unique\
    \ = l2.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        result\
    \ ~= l;\n    }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \   >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        result\
    \ ~= l;\n    }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\n", "{\n    auto s1 = l1.sort().unique;\n    auto\
    \ s2 = l2.sort().unique;\n    long[] res;\n    foreach(e; s1)\n    {\n       \
    \ if(s2.canFind(e))\n        {\n            res ~= e;\n        }\n    }\n    return\
    \ res;\n}", "{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n\
    \        if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n\
    \    }\n    return result.sort().uniq;\n}", "{\n    long[] result = new long[0L];\n\
    \    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n         \
    \   result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n \
    \   long[] result = new long[0L];\n    long[] l1_unique = unique(l1);\n    long[]\
    \ l2_unique = unique(l2);\n    foreach (l1_item; l1_unique)\n    {\n        foreach\
    \ (l2_item; l2_unique)\n        {\n            if (l1_item == l2_item)\n     \
    \       {\n                result ~= l1_item;\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result = [];\n    foreach (l; l1) \n \
    \   {\n        if (l2.canFind(l)) \n        {\n            result ~= l;\n    \
    \    }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result = new\
    \ long[0L];\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n\
    \    long i = 0L;\n    long j = 0L;\n    while (i < l1_sorted.length && j < l2_sorted.length)\n\
    \    {\n        if (l1_sorted[i] == l2_sorted[j])\n        {\n            result\
    \ = result ~ l1_sorted[i];\n            i++;\n            j++;\n        }\n  \
    \      else if (l1_sorted[i] < l2_sorted[j])\n        {\n            i++;\n  \
    \      }\n        else\n        {\n            j++;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n \
    \   long[] l2_sorted = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n\
    \    long[] l2_unique = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n\
    \    long[] l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_set\
    \ = l1_unique_sorted.set;\n    long[] l2_unique_sorted_set = l2_unique_sorted.set;\n\
    \    long[] l1_unique_sorted_set_sorted = l1_unique_sorted_set.sort;\n    long[]\
    \ l2_unique_sorted_set_sorted = l2_unique_sorted_set.sort;\n    long[] l1_unique_sorted_set_sorted_unique\
    \ = l1_unique_sorted_set_sorted.unique;\n    long[] l2_unique_sorted_set_sorted_unique\
    \ = l2_unique_sorted_set_sorted.unique;\n    long[] l1_unique_sorted_set_sorted_unique_sorted\
    \ = l1_unique_sorted_set_sorted_unique.sort;\n    long[] l2_unique_sorted_set_sorted_unique_sorted\
    \ = l2_unique_sorted_set_sorted_unique.sort;\n    long[] l1_unique_sorted_set_sorted_unique_sorted_set\
    \ = l1_unique_sorted_set_sorted_unique_sorted.set;\n    long[] l2_unique_sorted_set_sorted_unique_sorted_set\
    \ = l2_unique_sorted_set_sorted_unique_sorted.set;\n    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set_sorted_unique_sorted_set.sort;\n    long[] l2_", "{\n\
    \    long[] result = [];\n    foreach (long i; l1)\n    {\n        foreach (long\
    \ j; l2)\n        {\n            if (i == j)\n            {\n                result\
    \ ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort.uniq;\n\
    }", "{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach (l; l1) \n    {\n        if (l2.canFind(l)) \n        {\n          \
    \  if (!result.canFind(l)) \n            {\n                result ~= l;\n   \
    \         }\n        }\n    }\n    return result.sort();\n}", "{\n    long[] result\
    \ = [];\n    foreach (e1; l1)\n    {\n        foreach (e2; l2)\n        {\n  \
    \          if (e1 == e2)\n            {\n                result ~= e1;\n     \
    \       }\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n      \
    \  if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] l3 = l1.dup;\n    l3 ~= l2;\n    l3.sort;\n    l3 = l3.uniq;\n\
    \    return l3;\n}", "{\n    long[] ret = new long[0];\n    long[] l3 = new long[0];\n\
    \    long[] l4 = new long[0];\n    if (l1.length < l2.length) \n    {\n      \
    \  l3 = l1;\n        l4 = l2;\n    }\n    else \n    {\n        l3 = l2;\n   \
    \     l4 = l1;\n    }\n    foreach (e; l3) \n    {\n        if (e in l4) \n  \
    \      {\n            ret ~= e;\n        }\n    }\n    ret.sort();\n    return\
    \ ret;\n}", "{\n    auto r = new long[](0);\n    foreach (e; l1)\n    {\n    \
    \    if (e in l2)\n        {\n            r ~= e;\n        }\n    }\n    return\
    \ r.sort().uniq;\n}", "{\n    long[] result = new long[0];\n    long[] l1_sorted\
    \ = sort(l1);\n    long[] l2_sorted = sort(l2);\n    int i = 0;\n    int j = 0;\n\
    \    while (i < l1_sorted.length && j < l2_sorted.length) \n    {\n        if\
    \ (l1_sorted[i] == l2_sorted[j]) \n        {\n            result ~= l1_sorted[i];\n\
    \            i++;\n            j++;\n        }\n        else if (l1_sorted[i]\
    \ < l2_sorted[j]) \n        {\n            i++;\n        }\n        else \n  \
    \      {\n            j++;\n        }\n    }\n    return result;\n}\n/*\nReturn\
    \ sorted unique elements of two lists.\n    >>> union([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L,\
    \ 34L, 121L, 653L]\n    >>> union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L,\
    \ 8L]\n*/\nlong[] union(long[] l1, long[] l2) \n{\n    long[] result = new long[0];\n\
    \    long[] l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n    int i\
    \ = 0;\n    int j = 0;\n    while (i < l1_sorted.length && j < l2_sorted.length)\
    \ \n    {\n        if (l1_sorted[i] == l2_sorted[j]) \n        {\n           \
    \ result ~= l1_sorted[i];\n            i++;\n            j++;\n        }\n   \
    \     else if (l1_sorted[i] < l2_sorted[j]) \n        {\n            result ~=\
    \ l1_s", "{ \n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}", "{\n\
    \    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (long l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[0];\n  \
    \  foreach (long i; l1)\n    {\n        foreach (long j; l2)\n        {\n    \
    \        if (i == j)\n            {\n                result ~= i;\n          \
    \  }\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result\
    \ = new long[];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l)) \n  \
    \      {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result;\n    result = new long[l1.length];\n    int i = 0;\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            result[i]\
    \ = e;\n            i++;\n        }\n    }\n    return result[0..i];\n}", "{\n\
    \    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] l3 = new long[l1.length];\n    long[] l4 = new long[l2.length];\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab =\
    \ 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n   \
    \ int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak =\
    \ 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n   \
    \ int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at =\
    \ 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n   \
    \ int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc =\
    \ 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n   \
    \ int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl =\
    \ 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n   \
    \ int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu =\
    \ 0;\n    int bv =", "{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n\
    \        foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n\
    \                result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n       \
    \ foreach (e2; l2)\n        {\n            if (e1 == e2)\n            {\n    \
    \            result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n  \
    \      foreach (long j; l2)\n        {\n            if (i == j)\n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}", "{\n    long[] result = [];\n    foreach (l;\
    \ l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort();\n    long[] l2_sorted = l2.dup.sort();\n\
    \    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique = l2_sorted.dup.uniq;\n\
    \    long[] l1_unique_sorted = l1_unique.dup.sort;\n    long[] l2_unique_sorted\
    \ = l2_unique.dup.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.dup.toSet;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.dup.toSet;\n    long[] l1_unique_sorted_set_intersection\
    \ = l1_unique_sorted_set.dup.intersection(l2_unique_sorted_set);\n    result =\
    \ l1_unique_sorted_set_intersection.dup.toArray;\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements that are in either of the lists.\n    >>>\
    \ union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n \
    \   [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> union([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        result\
    \ ~= l;\n    }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements that are in both lists.\n\
    \    >>> intersection([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L])\n    [1L, 5L, 653L]\n    >>> intersection([5L, 3L, 2L, 8L], [3L, 2L])\n\
    \    [2L, 3L]\n*/\nlong[] intersection(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n    \
    \    {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements that are in the first list but not in the\
    \ second.\n    >>> difference([1L, 4L", "{ \n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n\
    }", "{\n    auto result = new long[](0);\n    foreach (i; l1) \n    {\n      \
    \  if (l2.canFind(i)) \n        {\n            result ~= i;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}", "{\n    long[] result = new long[0L];\n    foreach\
    \ (l; l1) \n    {\n        if (l2.canFind(l)) \n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    auto result\
    \ = new long[](max(l1.length, l2.length));\n    size_t i = 0;\n    foreach (e1;\
    \ l1)\n    {\n        foreach (e2; l2)\n        {\n            if (e1 == e2)\n\
    \            {\n                result[i] = e1;\n                i++;\n      \
    \      }\n        }\n    }\n    return result[0 .. i];\n}", "{\n    long[] result;\n\
    \    if (l1.length < l2.length) \n    {\n        result = common(l2, l1);\n  \
    \  }\n    else \n    {\n        result = new long[l1.length];\n        size_t\
    \ j = 0;\n        foreach (i; l1) \n        {\n            if (l2.canFind(i))\
    \ \n            {\n                result[j] = i;\n                j++;\n    \
    \        }\n        }\n        result = result[0..j];\n    }\n    return result.sort().unique;\n\
    }", "{ \n    long[] result = new long[0]; \n    long[] l1_sorted = sort(l1); \n\
    \    long[] l2_sorted = sort(l2); \n    long[] l1_unique = unique(l1_sorted);\
    \ \n    long[] l2_unique = unique(l2_sorted); \n    foreach (long i; l1_unique)\
    \ \n    { \n        foreach (long j; l2_unique) \n        { \n            if (i\
    \ == j) \n            { \n                result ~= i; \n            } \n    \
    \    } \n    } \n    return result; \n}", "{\n    long[] result = [];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    return sort(uniq(l1)).intersect(sort(uniq(l2)));\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}", "{\n    long[] result = new long[0];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result\
    \ = new long[0];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n   \
    \     {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            if (e !in result)\n            {\n       \
    \         result ~= e;\n            }\n        }\n    }\n    return result.sort();\n\
    }", "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l1_elem; l1_unique)\n    {\n        foreach(l2_elem;\
    \ l2_unique)\n        {\n            if(l1_elem == l2_elem)\n            {\n \
    \               result ~= l1_elem;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[l1.length];\n    int i = 0;\n\
    \    foreach(l; l1)\n    {\n        if (l2.canFind(l))\n        {\n          \
    \  result[i] = l;\n            i++;\n        }\n    }\n    return result[0..i];\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] ret = [];\n    foreach(e1; l1)\n    {\n        foreach(e2;\
    \ l2)\n        {\n            if(e1 == e2)\n            {\n                ret\
    \ ~= e1;\n            }\n        }\n    }\n    return ret.sort().uniq;\n}", "{\n\
    \    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n        if\
    \ (l2.canFind(i))\n        {\n            result ~= i;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result\
    \ = new long[0];\n    foreach (elem; l1)\n    {\n        if (elem in l2)\n   \
    \     {\n            result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    foreach(long\
    \ l; l1)\n    {\n        if(l2.find(l) != -1)\n        {\n            l3[i] =\
    \ l;\n            i++;\n        }\n    }\n    l3 = l3[0..i];\n    l3.sort();\n\
    \    return l3.dup.unique;\n}", "{\n    long[] result = [];\n    foreach (l; l1)\n\
    \    {\n        if (l2.canFind(l))\n        {\n            result ~= l;\n    \
    \    }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result = new\
    \ long[0];\n    foreach (long i; l1)\n    {\n        if (l2.canFind(i))\n    \
    \    {\n            result ~= i;\n        }\n    }\n    return result.sort().dup.unique;\n\
    }", "{\n    auto s1 = l1.sort();\n    auto s2 = l2.sort();\n    long[] res = new\
    \ long[];\n    foreach(i; 0 .. s1.length)\n    {\n        if(s1[i] == s2[i])\n\
    \        {\n            res ~= s1[i];\n        }\n    }\n    return res;\n}",
  "{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_common = l1_unique_sorted.common;\n\
    \    long[] l2_unique_sorted_common = l2_unique_sorted.common;\n    long[] l1_unique_sorted_common_sorted\
    \ = l1_unique_sorted_common.sort;\n    long[] l2_unique_sorted_common_sorted =\
    \ l2_unique_sorted_common.sort;\n    result = l1_unique_sorted_common_sorted.common;\n\
    \    return result;\n}", "{\n    long[] l3 = new long[l1.length];\n    int i =\
    \ 0;\n    foreach(l; l1)\n    {\n        foreach(l4; l2)\n        {\n        \
    \    if(l == l4)\n            {\n                l3[i] = l;\n                i++;\n\
    \            }\n        }\n    }\n    l3 = l3.sort();\n    l3 = l3.uniq;\n   \
    \ return l3;\n}", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n  \
    \      if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n  \
    \  }\n    return result.sort().uniq;\n}", "{\n    return sort(toSet(l1) & toSet(l2));\n\
    }", "{\n    return sort(array(uniq(l1) & uniq(l2)));\n}", "{\n    long[] res =\
    \ new long[l1.length];\n    int i = 0;\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            res[i] = l;\n            i++;\n        }\n    }\n    return\
    \ res[0..i];\n}", "{\n    long[] result = new long[0];\n    long[] l1_sorted =\
    \ sort(l1);\n    long[] l2_sorted = sort(l2);\n    long[] l1_unique = unique(l1_sorted);\n\
    \    long[] l2_unique = unique(l2_sorted);\n    foreach(long i; l1_unique)\n \
    \   {\n        foreach(long j; l2_unique)\n        {\n            if(i == j)\n\
    \            {\n                result ~= i;\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[0];\n    foreach (l;\
    \ l1) \n    {\n        if (l2.canFind(l)) \n        {\n            result ~= l;\n\
    \        }\n    }\n    return result.sort().uniq;\n}", "{ \n    auto l1_set =\
    \ set(l1);\n    auto l2_set = set(l2);\n    auto l1_set_len = l1_set.length;\n\
    \    auto l2_set_len = l2_set.length;\n    auto l1_set_max = max(l1_set);\n  \
    \  auto l2_set_max = max(l2_set);\n    auto max_len = max(l1_set_len, l2_set_len);\n\
    \    auto max_val = max(l1_set_max, l2_set_max);\n    auto result = new long[](max_len);\n\
    \    auto result_len = 0;\n    foreach (i; 0 .. max_val + 1)\n    {\n        if\
    \ (l1_set.count(i) && l2_set.count(i))\n        {\n            result[result_len]\
    \ = i;\n            result_len++;\n        }\n    }\n    return result[0 .. result_len];\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            if\
    \ (!result.canFind(l))\n            {\n                result ~= l;\n        \
    \    }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n  \
    \  >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (!result.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    foreach (l; l2)\n    {\n        if (!result.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique elements for two lists.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L,\
    \ 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n \
    \   [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = new long[];\n    foreach (l; l1)\n    {\n        if (!result.can",
  "{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set.intersection(l2_set);\n    return common_set.array;\n}", "{\n    long[]\
    \ result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l)) \n   \
    \     {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    auto result = new long[](0);\n    auto l1_set = new long[](0);\n \
    \   auto l2_set = new long[](0);\n    foreach(i; l1)\n    {\n        l1_set ~=\
    \ i;\n    }\n    foreach(i; l2)\n    {\n        l2_set ~= i;\n    }\n    l1_set\
    \ = sort(l1_set);\n    l2_set = sort(l2_set);\n    l1_set = unique(l1_set);\n\
    \    l2_set = unique(l2_set);\n    foreach(i; l1_set)\n    {\n        if(i in\
    \ l2_set)\n        {\n            result ~= i;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result\
    \ ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[]\
    \ result = new long[];\n    foreach (e1; l1)\n    {\n        foreach (e2; l2)\n\
    \        {\n            if (e1 == e2)\n            {\n                result ~=\
    \ e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem in\
    \ l2) \n        {\n            result ~= elem;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}", "{\n    long[] result = new long[0L];\n    long[]\
    \ l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n    long l1_len = l1_sorted.length;\n\
    \    long l2_len = l2_sorted.length;\n    long i = 0L;\n    long j = 0L;\n   \
    \ while (i < l1_len && j < l2_len)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            result ~= l1_sorted[i];\n            i++;\n          \
    \  j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\n        {\n\
    \            i++;\n        }\n        else\n        {\n            j++;\n    \
    \    }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L,\
    \ 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>> union([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n\
    \    long[] l2_sorted = sort(l2);\n    long l1_len = l1_sorted.length;\n    long\
    \ l2_len = l2_sorted.length;\n    long i = 0L;\n    long j = 0L;\n    while (i\
    \ < l1_len && j < l2_len)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            result ~= l1", "{\n    long[] result = [];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result\
    \ = new long[];\n    foreach (e; l1)\n    {\n        if (e in l2)\n        {\n\
    \            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set & l2_set;\n    return common_set.array;\n}", "{\n    long[] ret = new\
    \ long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n       \
    \     ret ~= e;\n        }\n    }\n    return ret.sort().uniq;\n}", "{\n    return\
    \ sort(uniq(l1)).filter!(x => l2.canFind(x));\n}", "{\n    long[] res = new long[];\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ res ~= l;\n        }\n    }\n    return res;\n}", "{\n    long[] l3 = new long[l1.length];\n\
    \    int i = 0;\n    foreach(long x; l1)\n    {\n        foreach(long y; l2)\n\
    \        {\n            if(x == y)\n            {\n                l3[i] = x;\n\
    \                i++;\n            }\n        }\n    }\n    l3 = l3[0..i];\n \
    \   l3.sort();\n    l3 = l3.dup.uniq;\n    return l3;\n}", "{\n    long[] result\
    \ = new long[];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n    \
    \    {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0L];\n    long[] l1_unique = unique(l1);\n\
    \    long[] l2_unique = unique(l2);\n    foreach (l1_elem; l1_unique) \n    {\n\
    \        foreach (l2_elem; l2_unique) \n        {\n            if (l1_elem ==\
    \ l2_elem) \n            {\n                result ~= l1_elem;\n            }\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = [];\n    foreach\
    \ (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n            result ~=\
    \ l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result\
    \ = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n        {\n \
    \           result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n    long[]\
    \ l2_sorted = sort(l2);\n    long i = 0L;\n    while (i < l1_sorted.length)\n\
    \    {\n        long j = 0L;\n        while (j < l2_sorted.length)\n        {\n\
    \            if (l1_sorted[i] == l2_sorted[j])\n            {\n              \
    \  result = result ~ l1_sorted[i];\n                break;\n            }\n  \
    \          j += 1L;\n        }\n        i += 1L;\n    }\n    return result;\n}",
  "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}", "{\n    long[] result = new long[];\n   \
    \ foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n            if(!result.canFind(l))\n\
    \            {\n                result ~= l;\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[];\n    foreach(l; l1)\n\
    \    {\n        if(l2.canFind(l))\n        {\n            result ~= l;\n     \
    \   }\n    }\n    return result.sort().uniq;\n}", "{\n    long[] result = [];\n\
    \    foreach (l; l1) \n    {\n        if (l2.canFind(l)) \n        {\n       \
    \     result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}", "{\n\
    \    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (e1; l1) \n    {\n        foreach\
    \ (e2; l2) \n        {\n            if (e1 == e2) \n            {\n          \
    \      result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }", "{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            if (!result.canFind(l))\n            {\n             \
    \   result ~= l;\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    foreach(l; l1)\n    {\n        foreach(r;\
    \ l2)\n        {\n            if(l == r)\n            {\n                result\
    \ ~= l;\n            }\n        }\n    }\n    return result.sort().uniq;\n}",
  "{\n    long[] result = new long[l1.length];\n    int result_index = 0;\n    foreach(l;\
    \ l1)\n    {\n        if(l2.canFind(l))\n        {\n            result[result_index]\
    \ = l;\n            result_index++;\n        }\n    }\n    return result[0..result_index];\n\
    }", "{\n    long[] result = [];\n    foreach (long i; l1) \n    {\n        if\
    \ (l2.canFind(i)) \n        {\n            result ~= i;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
