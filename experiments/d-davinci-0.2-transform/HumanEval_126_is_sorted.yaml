name: HumanEval_126_is_sorted
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a list of numbers,\
  \ return whether or not they are sorted\n    in ascending order. If list has more\
  \ than 1 duplicate of the same\n    number, return False. Assume no negative numbers\
  \ and only integers.\n\n    Examples\n    >>> is_sorted([5L])\n    true\n    >>>\
  \ is_sorted([1L, 2L, 3L, 4L, 5L])\n    true\n    >>> is_sorted([1L, 3L, 2L, 4L,\
  \ 5L])\n    false\n    >>> is_sorted([1L, 2L, 3L, 4L, 5L, 6L])\n    true\n    >>>\
  \ is_sorted([1L, 2L, 3L, 4L, 5L, 6L, 7L])\n    true\n    >>> is_sorted([1L, 3L,\
  \ 2L, 4L, 5L, 6L, 7L])\n    false\n    >>> is_sorted([1L, 2L, 2L, 3L, 3L, 4L])\n\
  \    true\n    >>> is_sorted([1L, 2L, 2L, 2L, 3L, 4L])\n    false\n    \n*/\nbool\
  \ is_sorted(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = is_sorted;\n\n    assert(candidate([5L])\
  \ == true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == true);\n    assert(candidate([1L,\
  \ 3L, 2L, 4L, 5L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L]) ==\
  \ true);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L]) == true);\n    assert(candidate([1L,\
  \ 3L, 2L, 4L, 5L, 6L, 7L]) == false);\n    assert(candidate([]) == true);\n    assert(candidate([1L])\
  \ == true);\n    assert(candidate([3L, 2L, 1L]) == false);\n    assert(candidate([1L,\
  \ 2L, 2L, 2L, 3L, 4L]) == false);\n    assert(candidate([1L, 2L, 3L, 3L, 3L, 4L])\
  \ == false);\n    assert(candidate([1L, 2L, 2L, 3L, 3L, 4L]) == true);\n    assert(candidate([1L,\
  \ 2L, 3L, 4L]) == true);\n}\nvoid main(){}"
completions: ["{\n    if (lst.length == 1)\n        return true;\n    for (int i =\
    \ 0; i < lst.length - 1; i++)\n    {\n        if (lst[i] > lst[i + 1])\n     \
    \       return false;\n    }\n    return true;\n}", "{\n    if (lst.length ==\
    \ 1)\n        return true;\n    else if (lst.length == 2)\n        return lst[0]\
    \ <= lst[1];\n    else\n    {\n        long[] temp = lst[1..$];\n        return\
    \ lst[0] <= lst[1] && is_sorted(temp);\n    }\n}", "{\n    if (lst.length == 1)\n\
    \        return true;\n    else if (lst.length == 2)\n        return lst[0] <\
    \ lst[1];\n    else\n    {\n        long[] lst1 = lst[0..$/2];\n        long[]\
    \ lst2 = lst[$/2..$];\n        return is_sorted(lst1) && is_sorted(lst2) && lst1[$-1]\
    \ < lst2[0];\n    }\n}", "{\n    if (lst.length == 1) \n    {\n        return\
    \ true;\n    }\n    else \n    {\n        bool sorted = true;\n        long prev\
    \ = lst[0];\n        foreach (long i; lst[1..$]) \n        {\n            if (i\
    \ < prev) \n            {\n                sorted = false;\n                break;\n\
    \            }\n            prev = i;\n        }\n        return sorted;\n   \
    \ }\n}", "{\n    if (lst.length == 1) return true;\n    if (lst.length == 2) return\
    \ lst[0] <= lst[1];\n    long prev = lst[0];\n    long curr = lst[1];\n    for\
    \ (int i = 2; i < lst.length; i++)\n    {\n        if (prev > curr) return false;\n\
    \        prev = curr;\n        curr = lst[i];\n    }\n    return true;\n}", "{\n\
    \    if (lst.length == 1)\n        return true;\n    else\n    {\n        long[]\
    \ sorted = lst.dup;\n        sort(sorted);\n        return lst == sorted;\n  \
    \  }\n}", "{\n    if (lst.length <= 1)\n        return true;\n    else\n    {\n\
    \        long prev = lst[0];\n        foreach (long i; lst[1..$])\n        {\n\
    \            if (i < prev)\n                return false;\n            prev =\
    \ i;\n        }\n        return true;\n    }\n}", "{\n    if (lst.length == 1)\n\
    \        return true;\n    else\n    {\n        long prev = lst[0];\n        foreach\
    \ (long i; lst[1..$])\n        {\n            if (i < prev)\n                return\
    \ false;\n            prev = i;\n        }\n        return true;\n    }\n}", "{\n\
    \    if (lst.length == 1)\n        return true;\n    else\n    {\n        long\
    \ prev = lst[0];\n        for (long i = 1; i < lst.length; i++)\n        {\n \
    \           if (prev > lst[i])\n                return false;\n            prev\
    \ = lst[i];\n        }\n        return true;\n    }\n}", "{\n    if (lst.length\
    \ == 1)\n        return true;\n    else\n    {\n        long prev = lst[0];\n\
    \        foreach (long i; lst[1..$])\n        {\n            if (i < prev)\n \
    \               return false;\n            prev = i;\n        }\n        return\
    \ true;\n    }\n}", "{\n    if (lst.length == 1)\n        return true;\n    else\
    \ if (lst.length == 2)\n        return lst[0] <= lst[1];\n    else\n    {\n  \
    \      long[] left = lst[0..$/2];\n        long[] right = lst[$/2..$];\n     \
    \   return is_sorted(left) && is_sorted(right);\n    }\n}", "{\n    if (lst.length\
    \ == 1)\n        return true;\n    else\n    {\n        long prev = lst[0];\n\
    \        foreach (long i; lst[1..$])\n        {\n            if (i < prev)\n \
    \               return false;\n            prev = i;\n        }\n        return\
    \ true;\n    }\n}", "{\n    if (lst.length == 1)\n        return true;\n    else\n\
    \    {\n        long prev = lst[0];\n        foreach (i; lst[1..$])\n        {\n\
    \            if (i < prev)\n                return false;\n            prev =\
    \ i;\n        }\n        return true;\n    }\n}", "{\n    bool sorted = true;\n\
    \    int i = 0;\n    while (i < lst.length - 1) \n    {\n        if (lst[i] >\
    \ lst[i + 1]) \n        {\n            sorted = false;\n            break;\n \
    \       }\n        i++;\n    }\n    return sorted;\n}", "{\n    if (lst.length\
    \ == 1)\n        return true;\n    else\n    {\n        long prev = lst[0];\n\
    \        foreach (long i; lst[1..$])\n        {\n            if (i < prev)\n \
    \               return false;\n            prev = i;\n        }\n        return\
    \ true;\n    }\n}", "{\n    if (lst.length == 1)\n        return true;\n    else\n\
    \    {\n        long prev = lst[0];\n        foreach (long i; lst[1..$])\n   \
    \     {\n            if (i < prev)\n                return false;\n          \
    \  prev = i;\n        }\n        return true;\n    }\n}", "{\n    if (lst.length\
    \ == 1)\n        return true;\n    else\n    {\n        long[] sorted = lst.dup;\n\
    \        sort(sorted);\n        for (int i = 0; i < lst.length; i++)\n       \
    \ {\n            if (lst[i] != sorted[i])\n                return false;\n   \
    \     }\n        return true;\n    }\n}", "{\n    if (lst.length == 1)\n     \
    \   return true;\n    else\n    {\n        long prev = lst[0];\n        foreach\
    \ (long i; lst[1..$])\n        {\n            if (i < prev)\n                return\
    \ false;\n            prev = i;\n        }\n        return true;\n    }\n}", "{\n\
    \    if (lst.length <= 1)\n        return true;\n    long prev = lst[0];\n   \
    \ foreach (i; 1..lst.length)\n    {\n        if (prev > lst[i])\n            return\
    \ false;\n        prev = lst[i];\n    }\n    return true;\n}", "{\n    if (lst.length\
    \ <= 1)\n        return true;\n    else\n    {\n        long prev = lst[0];\n\
    \        foreach (long i; lst[1..$])\n        {\n            if (i < prev)\n \
    \               return false;\n            prev = i;\n        }\n        return\
    \ true;\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
