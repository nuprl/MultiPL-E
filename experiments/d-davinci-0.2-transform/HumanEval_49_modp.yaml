name: HumanEval_49_modp
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n\
  \    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
  \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n"
tests: "unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
  \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
  \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
  \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
  \ == 3L);\n}\nvoid main(){}"
completions: ["{\n    long result = 1L;\n    long a = 2L;\n    long b = n;\n    while\
    \ (b > 0L) \n    {\n        if ((b & 1L) != 0L) \n        {\n            result\
    \ = (result * a) % p;\n        }\n        a = (a * a) % p;\n        b >>= 1L;\n\
    \    }\n    return result;\n}", "{\n    long result = 1L;\n    long base = 2L;\n\
    \    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n        {\n       \
    \     result = (result * base) % p;\n        }\n        base = (base * base) %\
    \ p;\n        n >>= 1L;\n    }\n    return result;\n}", "{\n    long result =\
    \ 1L;\n    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n\
    \        {\n            result = (result * power) % n;\n        }\n        power\
    \ = (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}", "{\n\
    \    long result = 1L;\n    long base = 2L;\n    while (n > 0L) \n    {\n    \
    \    if ((n & 1L) != 0L) \n        {\n            result = (result * base) % p;\n\
    \        }\n        base = (base * base) % p;\n        n >>= 1L;\n    }\n    return\
    \ result;\n}\n/*\nReturn the number of bits in the binary representation of n.\n\
    \    >>> bitlen(0L)\n    0\n    >>> bitlen(1L)\n    1\n    >>> bitlen(2L)\n  \
    \  2\n    >>> bitlen(3L)\n    2\n    >>> bitlen(4L)\n    3\n    >>> bitlen(5L)\n\
    \    3\n    >>> bitlen(6L)\n    3\n    >>> bitlen(7L)\n    3\n    >>> bitlen(8L)\n\
    \    4\n    >>> bitlen(9L)\n    4\n    >>> bitlen(10L)\n    4\n    >>> bitlen(11L)\n\
    \    4\n    >>> bitlen(12L)\n    4\n    >>> bitlen(13L)\n    4\n    >>> bitlen(14L)\n\
    \    4\n    >>> bitlen(15L)\n    4\n    >>> bitlen(16L)\n    5\n    >>> bitlen(17L)\n\
    \    5\n    >>> bitlen(18L)\n    5\n    >>> bitlen(19L)\n    5\n    >>> bitlen(20L)\n\
    \    5\n    >>> bitlen(21L)\n    5\n    >>> bitlen(22L)\n    5\n    >>> bitlen(23L)\n\
    \    5\n    >>> bitlen(24L)\n    5\n    >>> bitlen(25L)\n    5\n    >>> bitlen(26L)\n\
    \    5\n    >>> bitlen(27L)\n    5\n    >>> bitlen(28L)\n    5\n    >>> bitlen(29L)\n\
    \    5\n    >>> bitlen(30L)\n    5\n    >>> bitlen(31L)\n    5\n    >>> bitlen(32L)\n\
    \    6\n    >>> bitlen(33L", "{\n    long res = 1L;\n    long a = 2L;\n    while\
    \ (n > 0L) {\n        if ((n & 1L) != 0L) {\n            res = (res * a) % p;\n\
    \        }\n        a = (a * a) % p;\n        n >>= 1L;\n    }\n    return res;\n\
    }", "{\n    long r = 1L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L)\
    \ \n        {\n            r = (r * 2L) % p;\n        }\n        n = n / 2L;\n\
    \    }\n    return r;\n}\n/*\nReturn the number of bits in the binary representation\
    \ of n.\n    >>> bitlength(0L)\n    0\n    >>> bitlength(1L)\n    1\n    >>> bitlength(2L)\n\
    \    2\n    >>> bitlength(3L)\n    2\n    >>> bitlength(4L)\n    3\n    >>> bitlength(5L)\n\
    \    3\n    >>> bitlength(6L)\n    3\n    >>> bitlength(7L)\n    3\n    >>> bitlength(8L)\n\
    \    4\n    >>> bitlength(9L)\n    4\n    >>> bitlength(10L)\n    4\n    >>> bitlength(11L)\n\
    \    4\n    >>> bitlength(12L)\n    4\n    >>> bitlength(13L)\n    4\n    >>>\
    \ bitlength(14L)\n    4\n    >>> bitlength(15L)\n    4\n    >>> bitlength(16L)\n\
    \    5\n    >>> bitlength(17L)\n    5\n    >>> bitlength(18L)\n    5\n    >>>\
    \ bitlength(19L)\n    5\n    >>> bitlength(20L)\n    5\n    >>> bitlength(21L)\n\
    \    5\n    >>> bitlength(22L)\n    5\n    >>> bitlength(23L)\n    5\n    >>>\
    \ bitlength(24L)\n    5\n    >>> bitlength(25L)\n    5\n    >>> bitlength(26L)\n\
    \    5\n    >>> bitlength(27L)\n    5\n    >>> bitlength(28L)\n    5\n    >>>\
    \ bitlength(29L)\n    5\n    >>> bitlength(30L)\n    5\n    >>> bitlength(31L)\n\
    \    5\n    >>> bitlength(32L)\n    6\n    >>> bitlength(33L)\n    6\n    >>>\
    \ bitlength(34L)\n    6\n    >>>", "{\n    long result = 1L;\n    while (n > 0L)\
    \ {\n        if (n % 2L == 1L) {\n            result = (result * 2L) % p;\n  \
    \      }\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of bits in the binary representation of n.\n    >>> bits(0L)\n    0\n    >>>\
    \ bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n\
    \    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n    3\n    >>> bits(7L)\n \
    \   3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n    4\n    >>> bits(10L)\n \
    \   4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n    4\n    >>> bits(13L)\n\
    \    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n    4\n    >>> bits(16L)\n\
    \    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n    5\n    >>> bits(19L)\n\
    \    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n    5\n    >>> bits(22L)\n\
    \    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n    5\n    >>> bits(25L)\n\
    \    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n    5\n    >>> bits(28L)\n\
    \    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n    5\n    >>> bits(31L)\n\
    \    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n    6\n    >>> bits(34L)\n\
    \    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n    6\n    >>> bits(37L)\n\
    \    6\n    >>> bits(38L)\n    6", "{\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    else\n    {\n        return (modp(n - 1, p) * 2) % p;\n    }\n\
    }", "{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else if (n == 1)\n\
    \    {\n        return 2;\n    }\n    else if (n % 2 == 0)\n    {\n        long\
    \ m = modp(n / 2, p);\n        return (m * m) % p;\n    }\n    else\n    {\n \
    \       long m = modp(n - 1, p);\n        return (2 * m) % p;\n    }\n}", "{\n\
    \    if (n == 0)\n    {\n        return 1;\n    }\n    else if (n == 1)\n    {\n\
    \        return 2;\n    }\n    else if (n % 2 == 0)\n    {\n        long x = modp(n\
    \ / 2, p);\n        return (x * x) % p;\n    }\n    else\n    {\n        return\
    \ (2 * modp(n - 1, p)) % p;\n    }\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789L)\n    9\n\
    */\nlong numdigits(long n) \n{\n    if (n == 0)\n    {\n        return 1;\n  \
    \  }\n    else\n    {\n        return cast(long) floor(log10(n)) + 1;\n    }\n\
    }\n/*\nReturn the nth digit of n.\n    >>> nthdigit(0L, 0L)\n    0L\n    >>> nthdigit(0L,\
    \ 1L)\n    0L\n    >>> nthdigit(1L, 0L)\n    1L\n    >>> nthdigit(12345L, 0L)\n\
    \    5L\n    >>> nthdigit(12345L, 1L)\n    4L\n    >>> nthdigit(12345L, 2L)\n\
    \    3L\n    >>> nthdigit(12345L, 3L)\n    2L\n    >>> nthdigit(12345L, 4L)\n\
    \    1L\n    >>> nthdigit(12345L, 5L)\n    0L\n*/\nlong nthdigit(long n, long\
    \ d) \n{\n    return (n / pow(10L, d)) % 10L;\n}\n/*\nReturn the sum of the digits\
    \ of n.\n    >>> sumdigits(0L)\n    0L\n    >>> sumdigits(1L)\n    1L\n    >>>\
    \ sumdigits(10L)\n    1", "{\n    long result = 1L;\n    long base = 2L;\n   \
    \ while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n        {\n          \
    \  result = (result * base) % p;\n        }\n        base = (base * base) % p;\n\
    \        n >>= 1L;\n    }\n    return result;\n}\n/*\nReturn the number of bits\
    \ in the binary representation of n.\n    >>> bitlength(0L)\n    0\n    >>> bitlength(1L)\n\
    \    1\n    >>> bitlength(2L)\n    2\n    >>> bitlength(3L)\n    2\n    >>> bitlength(4L)\n\
    \    3\n    >>> bitlength(5L)\n    3\n    >>> bitlength(6L)\n    3\n    >>> bitlength(7L)\n\
    \    3\n    >>> bitlength(8L)\n    4\n    >>> bitlength(9L)\n    4\n    >>> bitlength(10L)\n\
    \    4\n    >>> bitlength(11L)\n    4\n    >>> bitlength(12L)\n    4\n    >>>\
    \ bitlength(13L)\n    4\n    >>> bitlength(14L)\n    4\n    >>> bitlength(15L)\n\
    \    4\n    >>> bitlength(16L)\n    5\n    >>> bitlength(17L)\n    5\n    >>>\
    \ bitlength(18L)\n    5\n    >>> bitlength(19L)\n    5\n    >>> bitlength(20L)\n\
    \    5\n    >>> bitlength(21L)\n    5\n    >>> bitlength(22L)\n    5\n    >>>\
    \ bitlength(23L)\n    5\n    >>> bitlength(24L)\n    5\n    >>> bitlength(25L)\n\
    \    5\n    >>> bitlength(26L)\n    5\n    >>> bitlength(27L)\n    5\n    >>>\
    \ bitlength(28L)\n    5\n    >>> bitlength(29L)\n    5\n    >>> bitlength(30L)\n\
    \    5\n    >>> bitlength(31L)\n    5\n    >>> bitlength(32L)\n    6\n    >>>\
    \ bitlength(33L", "{\n    if (n == 0)\n        return 1;\n    else if (n == 1)\n\
    \        return n % p;\n    else if (n % 2 == 0)\n        return (modp(n / 2,\
    \ p) * modp(n / 2, p)) % p;\n    else\n        return (modp(n / 2, p) * modp(n\
    \ / 2, p) * n) % p;\n}\n/*\nReturn the number of digits of n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(11L)\n    2\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n    \n*/\nlong digits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    else\n        return (long)floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the n-th digit of n.\n    >>> nthdigit(0L, 0L)\n    0L\n\
    \    >>> nthdigit(1L, 0L)\n    1L\n    >>> nthdigit(11L, 0L)\n    1L\n    >>>\
    \ nthdigit(11L, 1L)\n    1L\n    >>> nthdigit(123456789L, 0L)\n    9L\n    >>>\
    \ nthdigit(123456789L, 1L)\n    8L\n    >>> nthdigit(123456789L, 2L)\n    7L\n\
    \    >>> nthdigit(123456789L, 3L)\n    6L\n    >>> nthdigit(123456789L, 4L)\n\
    \    5L\n    >>> nthdigit(123456789L, 5L)\n    4L\n    >>> nthdigit(123456789L,\
    \ 6L)\n    3L\n    >>> nthdigit(123456789L, 7L)\n    2L\n    >>> nthdigit(123456789L,\
    \ 8L)\n    1L\n    >>> nthdigit(1234567890123456789L, 0L)\n    9L", "{\n    long\
    \ result = 1L;\n    while (n != 0L) {\n        if (n & 1L) {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n    }\n    return result;\n\
    }", "{\n    long result = 1L;\n    long b = 2L;\n    while (n != 0L) {\n     \
    \   if ((n & 1L) != 0L) {\n            result = (result * b) % p;\n        }\n\
    \        n >>= 1L;\n        b = (b * b) % p;\n    }\n    return result;\n}", "{\n\
    \    long r = 1L;\n    foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return\
    \ r;\n}\n/*\nReturn the number of digits in the binary representation of n.\n\
    \    >>> ndigits(0L)\n    0\n    >>> ndigits(1L)\n    1\n    >>> ndigits(2L)\n\
    \    2\n    >>> ndigits(3L)\n    2\n    >>> ndigits(4L)\n    3\n    >>> ndigits(5L)\n\
    \    3\n    >>> ndigits(6L)\n    3\n    >>> ndigits(7L)\n    3\n    >>> ndigits(8L)\n\
    \    4\n    >>> ndigits(9L)\n    4\n    >>> ndigits(10L)\n    4\n    >>> ndigits(11L)\n\
    \    4\n    >>> ndigits(12L)\n    4\n    >>> ndigits(13L)\n    4\n    >>> ndigits(14L)\n\
    \    4\n    >>> ndigits(15L)\n    4\n    >>> ndigits(16L)\n    5\n    >>> ndigits(17L)\n\
    \    5\n    >>> ndigits(18L)\n    5\n    >>> ndigits(19L)\n    5\n    >>> ndigits(20L)\n\
    \    5\n    >>> ndigits(21L)\n    5\n    >>> ndigits(22L)\n    5\n    >>> ndigits(23L)\n\
    \    5\n    >>> ndigits(24L)\n    5\n    >>> ndigits(25L)\n    5\n    >>> ndigits(26L)\n\
    \    5\n    >>> ndigits(27L)\n    5\n    >>> ndigits(28L)\n    5\n    >>> ndigits(29L)\n\
    \    5\n    >>> ndigits(30L)\n    5\n    >>> ndigits(31L)\n    5\n    >>> ndigits(32L)\n\
    \    6\n    >>> ndigits(33L)\n    6\n    >>> ndigits(34L)\n    6\n", "{\n    long\
    \ res = 1L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n\
    \            res = (res * n) % p;\n        }\n        n = n / 2L;\n        n =\
    \ n % p;\n    }\n    return res;\n}", "{\n    if (n == 0)\n        return 1;\n\
    \    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n  \
    \  else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 % p;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n  \
    \  1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n    >>> digits(12345678901234567890)\n    20\n*/\nlong digits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    return floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n \
    \   >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n \
    \   5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\n    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)", "{\n    if (n < 0)\n    {\n        return modp(-n, p);\n\
    \    }\n    if (n == 0)\n    {\n        return 1;\n    }\n    if (n == 1)\n  \
    \  {\n        return n;\n    }\n    if (n % 2 == 0)\n    {\n        long m = modp(n\
    \ / 2, p);\n        return (m * m) % p;\n    }\n    else\n    {\n        return\
    \ (n * modp(n - 1, p)) % p;\n    }\n}", "{\n    if (n == 0)\n        return 1;\n\
    \    else if (n == 1)\n        return n % p;\n    else if (n % 2 == 0)\n     \
    \   return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n        return (modp(n\
    \ / 2, p) * modp(n / 2, p) * n) % p;\n}", "{\n    if (n == 0)\n        return\
    \ 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n        long\
    \ half = modp(n / 2, p);\n        long result = (half * half) % p;\n        if\
    \ (n % 2 == 1)\n            result = (result * n) % p;\n        return result;\n\
    \    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
