language: d
name: HumanEval_41_car_race_collision
results:
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i = 0;\n\
    \    long j = 0;\n    long count = 0;\n    long[] left_to_right = new long[n];\n\
    \    long[] right_to_left = new long[n];\n    for (i = 0; i < n; i++) \n    {\n\
    \        left_to_right[i] = i;\n        right_to_left[i] = n - i - 1;\n    }\n\
    \    for (i = 0; i < n; i++) \n    {\n        for (j = 0; j < n; j++) \n     \
    \   {\n            if (left_to_right[i] == right_to_left[j]) \n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpktc8m3g9.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x428155]\n??:? void tmpktc8m3g9.__unittest_L39_C1() [0x427e3c]\n??:?
    void tmpktc8m3g9.__modtest() [0x427ed4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c153]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42afe6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430271]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430720]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4301fd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42afbd]\n??:? runModuleUnitTests [0x42bf29]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428618]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42859f]\n??:? _d_run_main [0x42850a]\n??:? main [0x427ee7]\n??:?
    __libc_start_main [0x9f3f3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k;\n\
    \    long count = 0;\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n;\
    \ j++) {\n            for (k = 0; k < n; k++) {\n                if (i == j &&\
    \ j == k) {\n                    count++;\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnukjmd8k.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dc5]\n??:? void tmpnukjmd8k.__unittest_L30_C1() [0x427aac]\n??:?
    void tmpnukjmd8k.__modtest() [0x427b44]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baeb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a97e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa9d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a955]\n??:? runModuleUnitTests [0x42b8c1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428214]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42819b]\n??:? _d_run_main [0x428106]\n??:? main [0x427b57]\n??:?
    __libc_start_main [0x171d9554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k;\n\
    \    long collisions = 0;\n    long *car_positions = new long[n];\n    long *car_velocities\
    \ = new long[n];\n    for (i = 0; i < n; i++) {\n        car_positions[i] = rand();\n\
    \        car_velocities[i] = rand();\n    }\n    for (i = 0; i < n; i++) {\n \
    \       for (j = 0; j < n; j++) {\n            if (car_velocities[i] > 0 && car_velocities[j]\
    \ < 0) {\n                if (car_positions[i] < car_positions[j]) {\n       \
    \             collisions++;\n                }\n            }\n        }\n   \
    \ }\n    return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_aljvwlf.d(19): Error: cannot implicitly convert expression
    `new long[](cast(ulong)n)` of type `long[]` to `long*`\n/tmp/tmp_aljvwlf.d(20):
    Error: cannot implicitly convert expression `new long[](cast(ulong)n)` of type
    `long[]` to `long*`\n/tmp/tmp_aljvwlf.d(22): Error: undefined identifier `rand`,
    did you mean function `round`?\n/tmp/tmp_aljvwlf.d(23): Error: undefined identifier
    `rand`, did you mean function `round`?\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp_aljvwlf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k,\
    \ l;\n    long result = 0;\n    long[] left_to_right = new long[n];\n    long[]\
    \ right_to_left = new long[n];\n    for (i = 0; i < n; i++) \n    {\n        left_to_right[i]\
    \ = i;\n        right_to_left[i] = n - i - 1;\n    }\n    for (i = 0; i < n; i++)\
    \ \n    {\n        for (j = 0; j < n; j++) \n        {\n            if (left_to_right[i]\
    \ == right_to_left[j]) \n            {\n                result++;\n          \
    \  }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmptma2lth0.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x428155]\n??:? void tmptma2lth0.__unittest_L38_C1() [0x427e3c]\n??:?
    void tmptma2lth0.__modtest() [0x427ed4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c153]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42afe6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430271]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430720]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4301fd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42afbd]\n??:? runModuleUnitTests [0x42bf29]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428618]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42859f]\n??:? _d_run_main [0x42850a]\n??:? main [0x427ee7]\n??:?
    __libc_start_main [0x41c85554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    long[] left_to_right = new long[n];\n\
    \    long[] right_to_left = new long[n];\n    for (i = 0; i < n; i++) {\n    \
    \    left_to_right[i] = i;\n        right_to_left[i] = n - i - 1;\n    }\n   \
    \ i = 0;\n    j = 0;\n    while (i < n && j < n) {\n        if (left_to_right[i]\
    \ < right_to_left[j]) {\n            collisions++;\n            i++;\n       \
    \ } else {\n            j++;\n        }\n    }\n    return collisions;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8j8ifwem.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x428145]\n??:? void tmp8j8ifwem.__unittest_L38_C1() [0x427e2c]\n??:?
    void tmp8j8ifwem.__modtest() [0x427ec4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c143]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42afd6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430261]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430710]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4301ed]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42afad]\n??:? runModuleUnitTests [0x42bf19]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428608]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42858f]\n??:? _d_run_main [0x4284fa]\n??:? main [0x427ed7]\n??:?
    __libc_start_main [0xb1809554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k;\n\
    \    long result;\n    long[] cars_left;\n    long[] cars_right;\n    long[] cars_left_sorted;\n\
    \    long[] cars_right_sorted;\n    long[] cars_left_sorted_index;\n    long[]\
    \ cars_right_sorted_index;\n    long[] cars_left_sorted_index_sorted;\n    long[]\
    \ cars_right_sorted_index_sorted;\n    long[] cars_left_sorted_index_sorted_index;\n\
    \    long[] cars_right_sorted_index_sorted_index;\n    long[] cars_left_sorted_index_sorted_index_sorted;\n\
    \    long[] cars_right_sorted_index_sorted_index_sorted;\n    long[] cars_left_sorted_index_sorted_index_sorted_index;\n\
    \    long[] cars_right_sorted_index_sorted_index_sorted_index;\n    long[] cars_left_sorted_index_sorted_index_sorted_index_sorted;\n\
    \    long[] cars_right_sorted_index_sorted_index_sorted_index_sorted;\n    long[]\
    \ cars_left_sorted_index_sorted_index_sorted_index_sorted_index;\n    long[] cars_right_sorted_index_sorted_index_sorted_index_sorted_index;\n\
    \    long[] cars_left_sorted_index_sorted_index_sorted_index_sorted_index_sorted;\n\
    \    long[] cars_right_sorted_index_sorted_index_sorted_index_sorted_index_sorted;\n\
    \    long[] cars_left_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index;\n\
    \    long[] cars_right_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index;\n\
    \    long[] cars_left_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted;\n\
    \    long[]\nunittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv1zs8hu0.d(43): Error: no identifier for declarator `long[]`\n/tmp/tmpv1zs8hu0.d(43):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpv1zs8hu0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpo8znh84h.d(23): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d5d]\n??:? void tmpo8znh84h.__unittest_L19_C1() [0x427a44]\n??:?
    void tmpo8znh84h.__modtest() [0x427adc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428133]\n??:? _d_run_main [0x42809e]\n??:? main [0x427aef]\n??:?
    __libc_start_main [0xcbbb8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k;\n\
    \    long count = 0;\n    long* left_to_right = new long[n];\n    long* right_to_left\
    \ = new long[n];\n    for (i = 0; i < n; i++) \n    {\n        left_to_right[i]\
    \ = i;\n        right_to_left[i] = n - i - 1;\n    }\n    for (i = 0; i < n; i++)\
    \ \n    {\n        for (j = 0; j < n; j++) \n        {\n            if (left_to_right[i]\
    \ == right_to_left[j]) \n            {\n                count++;\n           \
    \ }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprffhmcrj.d(19): Error: cannot implicitly convert expression
    `new long[](cast(ulong)n)` of type `long[]` to `long*`\n/tmp/tmprffhmcrj.d(20):
    Error: cannot implicitly convert expression `new long[](cast(ulong)n)` of type
    `long[]` to `long*`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprffhmcrj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n \
    \   long m = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r\
    \ = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n \
    \   long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long aa\
    \ = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n\
    \    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long\
    \ jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long oo =\
    \ 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n\
    \    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long\
    \ xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long aaa = 0;\n    long bbb\
    \ = 0;\n    long ccc = 0;\n    long ddd = 0;\n    long eee = 0;\n    long fff\
    \ = 0;\n    long ggg = 0;\n    long hhh = 0;\n    long iii = 0;\n    long jjj\
    \ = 0;\n    long kkk = 0;\n    long lll = 0;\n    long mmm = 0;\n    long ooo\
    \ = 0;\n    long ppp = 0;\n    long qqq = 0;\n    long rrr = 0;\n    long sss\
    \ = 0;\n    long ttt = 0;\n    long uuu = 0;\n    long vvv = 0;\n    long www\
    \ = 0;\n    long xxx = 0;\n    long yyy = 0;\n    long\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpln__y2ac.d(85): Error: no identifier for declarator `long`\n/tmp/tmpln__y2ac.d(85):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpln__y2ac.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k,\
    \ l, m, o, p, q, r, s, t, u, v, w, x, y, z;\n    long a, b, c, d, e, f, g, h;\n\
    \    long result;\n    long[] cars_left;\n    long[] cars_right;\n    long[] cars_left_sorted;\n\
    \    long[] cars_right_sorted;\n    long[] cars_left_sorted_unique;\n    long[]\
    \ cars_right_sorted_unique;\n    long[] cars_left_sorted_unique_count;\n    long[]\
    \ cars_right_sorted_unique_count;\n    long[] cars_left_sorted_unique_count_cumulative;\n\
    \    long[] cars_right_sorted_unique_count_cumulative;\n    long[] cars_left_sorted_unique_count_cumulative_sorted;\n\
    \    long[] cars_right_sorted_unique_count_cumulative_sorted;\n    long[] cars_left_sorted_unique_count_cumulative_sorted_unique;\n\
    \    long[] cars_right_sorted_unique_count_cumulative_sorted_unique;\n    long[]\
    \ cars_left_sorted_unique_count_cumulative_sorted_unique_count;\n    long[] cars_right_sorted_unique_count_cumulative_sorted_unique_count;\n\
    \    long[] cars_left_sorted_unique_count_cumulative_sorted_unique_count_cumulative;\n\
    \    long[] cars_right_sorted_unique_count_cumulative_sorted_unique_count_cumulative;\n\
    \    long[] cars_left_sorted_unique_count_cumulative_sorted_unique_count_cumulative_sorted;\n\
    \    long[] cars_right_sorted_unique_count_cumulative_sorted_unique_count_cumulative_sorted;\n\
    \    long[] cars_left_sorted_unique_count_cumulative_sorted_unique_count_cumulative_sorted_unique;\n\
    \    long[] cars_right_sorted_unique_count_cumulative_sorted_unique_count_cumulative_sorted\n\
    unittest\n{\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L)\
    \ == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n\
    \    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpirq0fwpm.d(42): Error: semicolon expected, not `unittest`\n/tmp/tmpirq0fwpm.d(42):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpirq0fwpm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n \
    \   long m = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r\
    \ = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n \
    \   long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long aa\
    \ = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n\
    \    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long\
    \ jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long oo =\
    \ 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n\
    \    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long\
    \ xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long aaa = 0;\n    long bbb\
    \ = 0;\n    long ccc = 0;\n    long ddd = 0;\n    long eee = 0;\n    long fff\
    \ = 0;\n    long ggg = 0;\n    long hhh = 0;\n    long iii = 0;\n    long jjj\
    \ = 0;\n    long kkk = 0;\n    long lll = 0;\n    long mmm = 0;\n    long ooo\
    \ = 0;\n    long ppp = 0;\n    long qqq = 0;\n    long rrr = 0;\n    long sss\
    \ = 0;\n    long ttt = 0;\n    long uuu = 0;\n    long vvv = 0;\n    long www\
    \ = 0;\n    long xxx = 0;\n    long yyy = 0;\n    long\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpln__y2ac.d(85): Error: no identifier for declarator `long`\n/tmp/tmpln__y2ac.d(85):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpln__y2ac.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    return n * (n\
    \ - 1) / 2;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\n   \
    \ assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpo8znh84h.d(23): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d5d]\n??:? void tmpo8znh84h.__unittest_L19_C1() [0x427a44]\n??:?
    void tmpo8znh84h.__modtest() [0x427adc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff58]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa35]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8ed]\n??:? runModuleUnitTests [0x42b859]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428133]\n??:? _d_run_main [0x42809e]\n??:? main [0x427aef]\n??:?
    __libc_start_main [0xcbbb8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k;\n\
    \    long collisions = 0;\n    long left_to_right[n];\n    long right_to_left[n];\n\
    \    for (i = 0; i < n; i++) \n    {\n        left_to_right[i] = i;\n        right_to_left[i]\
    \ = n - i - 1;\n    }\n    for (i = 0; i < n; i++) \n    {\n        for (j = 0;\
    \ j < n; j++) \n        {\n            if (left_to_right[i] == right_to_left[j])\
    \ \n            {\n                collisions++;\n            }\n        }\n \
    \   }\n    return collisions;\n}\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzip25f42.d(19): Deprecation: instead of C-style syntax, use
    D-style syntax `long[n] left_to_right`\n/tmp/tmpzip25f42.d(20): Deprecation: instead
    of C-style syntax, use D-style syntax `long[n] right_to_left`\n/tmp/tmpzip25f42.d(19):
    Error: variable `n` cannot be read at compile time\n/tmp/tmpzip25f42.d(20): Error:
    variable `n` cannot be read at compile time\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpzip25f42.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long count =\
    \ 0;\n    for (long i = 0; i < n; i++)\n    {\n        for (long j = 0; j < n;\
    \ j++)\n        {\n            if (i < j)\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4oivydsp.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d9d]\n??:? void tmp4oivydsp.__unittest_L30_C1() [0x427a84]\n??:?
    void tmp4oivydsp.__modtest() [0x427b1c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff98]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa75]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a92d]\n??:? runModuleUnitTests [0x42b899]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428173]\n??:? _d_run_main [0x4280de]\n??:? main [0x427b2f]\n??:?
    __libc_start_main [0x67bc2554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n \
    \   long m = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r\
    \ = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n \
    \   long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long aa\
    \ = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n\
    \    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long\
    \ jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long oo =\
    \ 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n\
    \    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long\
    \ xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long aaa = 0;\n    long bbb\
    \ = 0;\n    long ccc = 0;\n    long ddd = 0;\n    long eee = 0;\n    long fff\
    \ = 0;\n    long ggg = 0;\n    long hhh = 0;\n    long iii = 0;\n    long jjj\
    \ = 0;\n    long kkk = 0;\n    long lll = 0;\n    long mmm = 0;\n    long ooo\
    \ = 0;\n    long ppp = 0;\n    long qqq = 0;\n    long rrr = 0;\n    long sss\
    \ = 0;\n    long ttt = 0;\n    long uuu = 0;\n    long vvv = 0;\n    long www\
    \ = 0;\n    long xxx = 0;\n    long yyy = 0;\n    long\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpln__y2ac.d(85): Error: no identifier for declarator `long`\n/tmp/tmpln__y2ac.d(85):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpln__y2ac.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z;\n\
    \    long a[100000];\n    long b[100000];\n    long c[100000];\n    long d[100000];\n\
    \    long e[100000];\n    long f[100000];\n    long g[100000];\n    long h[100000];\n\
    \    long i[100000];\n    long j[100000];\n    long k[100000];\n    long l[100000];\n\
    \    long m[100000];\n    long n[100000];\n    long o[100000];\n    long p[100000];\n\
    \    long q[100000];\n    long r[100000];\n    long s[100000];\n    long t[100000];\n\
    \    long u[100000];\n    long v[100000];\n    long w[100000];\n    long x[100000];\n\
    \    long y[100000];\n    long z[100000];\n    long aa[100000];\n    long bb[100000];\n\
    \    long cc[100000];\n    long dd[100000];\n    long ee[100000];\n    long ff[100000];\n\
    \    long gg[100000];\n    long hh[100000];\n    long ii[100000];\n    long jj[100000];\n\
    \    long kk[100000];\n    long ll[100000];\n    long mm[100000];\n    long nn[100000];\n\
    \    long oo[100000];\n    long pp[100000];\n    long qq[100000];\n    long rr[100000];\n\
    \    long ss[100000];\n    long tt[100000];\n    long uu[100000];\n    long vv[100000];\n\
    \    long ww[100000];\n    long xx[100000];\n    long yy[100000];\n    long zz[100000];\n\
    \    long aaa[100000];\n    long bbb[100000];\n    long ccc[100000];\n    long\
    \ ddd[100000];\n   \nunittest\n{\n    alias candidate = car_race_collision;\n\n\
    \    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe7yuxzbu.d(18): Deprecation: instead of C-style syntax, use
    D-style syntax `long[100000] a`\n/tmp/tmpe7yuxzbu.d(19): Deprecation: instead
    of C-style syntax, use D-style syntax `long[100000] b`\n/tmp/tmpe7yuxzbu.d(20):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] c`\n/tmp/tmpe7yuxzbu.d(21):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] d`\n/tmp/tmpe7yuxzbu.d(22):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] e`\n/tmp/tmpe7yuxzbu.d(23):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] f`\n/tmp/tmpe7yuxzbu.d(24):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] g`\n/tmp/tmpe7yuxzbu.d(25):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] h`\n/tmp/tmpe7yuxzbu.d(26):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] i`\n/tmp/tmpe7yuxzbu.d(27):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] j`\n/tmp/tmpe7yuxzbu.d(28):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] k`\n/tmp/tmpe7yuxzbu.d(29):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] l`\n/tmp/tmpe7yuxzbu.d(30):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] m`\n/tmp/tmpe7yuxzbu.d(31):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] n`\n/tmp/tmpe7yuxzbu.d(32):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] o`\n/tmp/tmpe7yuxzbu.d(33):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] p`\n/tmp/tmpe7yuxzbu.d(34):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] q`\n/tmp/tmpe7yuxzbu.d(35):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] r`\n/tmp/tmpe7yuxzbu.d(36):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] s`\n/tmp/tmpe7yuxzbu.d(37):
    Deprecation: instead of C-style syntax, use D-style syntax `long[100000] t`\n/tmp/tmpe7yuxzbu.d(38):
    De'
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long collisions\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n \
    \   long m = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r\
    \ = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n \
    \   long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long aa\
    \ = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n\
    \    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long\
    \ jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long oo =\
    \ 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n\
    \    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long\
    \ xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long aaa = 0;\n    long bbb\
    \ = 0;\n    long ccc = 0;\n    long ddd = 0;\n    long eee = 0;\n    long fff\
    \ = 0;\n    long ggg = 0;\n    long hhh = 0;\n    long iii = 0;\n    long jjj\
    \ = 0;\n    long kkk = 0;\n    long lll = 0;\n    long mmm = 0;\n    long ooo\
    \ = 0;\n    long ppp = 0;\n    long qqq = 0;\n    long rrr = 0;\n    long sss\
    \ = 0;\n    long ttt = 0;\n    long uuu = 0;\n    long vvv = 0;\n    long www\
    \ = 0;\n    long xxx = 0;\n    long yyy = 0;\n    long\nunittest\n{\n    alias\
    \ candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpln__y2ac.d(85): Error: no identifier for declarator `long`\n/tmp/tmpln__y2ac.d(85):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpln__y2ac.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k,\
    \ collisions = 0;\n    float x[n], y[n], z[n];\n    float a[n], b[n], c[n];\n\
    \    float t[n];\n    float d[n];\n    float e[n];\n    float f[n];\n    float\
    \ g[n];\n    float h[n];\n    float m[n];\n    float p[n];\n    float q[n];\n\
    \    float r[n];\n    float s[n];\n    float u[n];\n    float v[n];\n    float\
    \ w[n];\n    float x1[n];\n    float y1[n];\n    float z1[n];\n    float a1[n];\n\
    \    float b1[n];\n    float c1[n];\n    float t1[n];\n    float d1[n];\n    float\
    \ e1[n];\n    float f1[n];\n    float g1[n];\n    float h1[n];\n    float m1[n];\n\
    \    float p1[n];\n    float q1[n];\n    float r1[n];\n    float s1[n];\n    float\
    \ u1[n];\n    float v1[n];\n    float w1[n];\n    float x2[n];\n    float y2[n];\n\
    \    float z2[n];\n    float a2[n];\n    float b2[n];\n    float c2[n];\n    float\
    \ t2[n];\n    float d2[n];\n    float e2[n];\n    float f2[n];\n    float g2[n];\n\
    \    float h2[n];\n    float m2[n];\n    float p2[n];\n    float q2[n];\n    float\
    \ r2[n];\n    float s2[n];\n    float u2[n];\n    float v2[n];\n    float w2[n];\n\
    \    float x3[n];\n    float y3[n];\n    float z3[n];\n    float a3[n];\n    float\
    \ b3[n];\n    float c3[n];\n\nunittest\n{\n    alias candidate = car_race_collision;\n\
    \n    assert(candidate(2L) == 4L);\n    assert(candidate(3L) == 9L);\n    assert(candidate(4L)\
    \ == 16L);\n    assert(candidate(8L) == 64L);\n    assert(candidate(10L) == 100L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpim88o54o.d(18): Deprecation: instead of C-style syntax, use
    D-style syntax `float[n] x`\n/tmp/tmpim88o54o.d(18): Error: multiple declarations
    must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpim88o54o.d(18):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] y`\n/tmp/tmpim88o54o.d(18):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpim88o54o.d(18):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] z`\n/tmp/tmpim88o54o.d(19):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] a`\n/tmp/tmpim88o54o.d(19):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpim88o54o.d(19):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] b`\n/tmp/tmpim88o54o.d(19):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpim88o54o.d(19):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] c`\n/tmp/tmpim88o54o.d(20):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] t`\n/tmp/tmpim88o54o.d(21):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] d`\n/tmp/tmpim88o54o.d(22):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] e`\n/tmp/tmpim88o54o.d(23):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] f`\n/tmp/tmpim88o54o.d(24):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] g`\n/tmp/tmpim88o54o.d(25):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] h`\n/tmp/tmpim88o54o.d(26):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] m`\n/tmp/tmpim88o54o.d(27):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] p`\n/tmp/tmpim88o54o.d(28):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] q`\n/tmp/tmpim88o54o.d(29):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] r`\n/tmp/tmpim88o54o.d(30):
    Deprecation: instead of C-style sy'
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long i, j, k,\
    \ count;\n    float x, y, z;\n    float a[n], b[n];\n    float c[n], d[n];\n \
    \   float e[n], f[n];\n    float g[n], h[n];\n    float p[n], q[n];\n    float\
    \ r[n], s[n];\n    float t[n], u[n];\n    float v[n], w[n];\n    float x1[n],\
    \ y1[n];\n    float z1[n], a1[n];\n    float b1[n], c1[n];\n    float d1[n], e1[n];\n\
    \    float f1[n], g1[n];\n    float h1[n], p1[n];\n    float q1[n], r1[n];\n \
    \   float s1[n], t1[n];\n    float u1[n], v1[n];\n    float w1[n], x2[n];\n  \
    \  float y2[n], z2[n];\n    float a2[n], b2[n];\n    float c2[n], d2[n];\n   \
    \ float e2[n], f2[n];\n    float g2[n], h2[n];\n    float p2[n], q2[n];\n    float\
    \ r2[n], s2[n];\n    float t2[n], u2[n];\n    float v2[n], w2[n];\n    float x3[n],\
    \ y3[n];\n    float z3[n], a3[n];\n    float b3[n], c3[n];\n    float d3[n], e3[n];\n\
    \    float f3[n], g3[n];\n    float h3[n], p3[n];\n    float q3[n], r3[n];\n \
    \   float s3[n], t3[n];\n    float u3[n], v3[n];\n    float w3[n], x4[n];\n  \
    \  float y4[n], z4[n];\n    float a4[n], b4[n\nunittest\n{\n    alias candidate\
    \ = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n    assert(candidate(3L)\
    \ == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L) == 64L);\n\
    \    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg8wsnu8f.d(19): Deprecation: instead of C-style syntax, use
    D-style syntax `float[n] a`\n/tmp/tmpg8wsnu8f.d(19): Error: multiple declarations
    must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpg8wsnu8f.d(19):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] b`\n/tmp/tmpg8wsnu8f.d(20):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] c`\n/tmp/tmpg8wsnu8f.d(20):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpg8wsnu8f.d(20):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] d`\n/tmp/tmpg8wsnu8f.d(21):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] e`\n/tmp/tmpg8wsnu8f.d(21):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpg8wsnu8f.d(21):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] f`\n/tmp/tmpg8wsnu8f.d(22):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] g`\n/tmp/tmpg8wsnu8f.d(22):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpg8wsnu8f.d(22):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] h`\n/tmp/tmpg8wsnu8f.d(23):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] p`\n/tmp/tmpg8wsnu8f.d(23):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpg8wsnu8f.d(23):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] q`\n/tmp/tmpg8wsnu8f.d(24):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] r`\n/tmp/tmpg8wsnu8f.d(24):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpg8wsnu8f.d(24):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] s`\n/tmp/tmpg8wsnu8f.d(25):
    Deprecation: instead of C-style syntax, use D-style syntax `float[n] t`\n/tmp/tmpg8wsnu8f.d(25):
    Error: multiple declarations must have the same type, not `float[n]` and `float[n]`\n/tmp/tmpg8wsnu8f.d(25)'
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.\n\n    This function outputs the number of such\
    \ collisions.\n    \n*/\nlong car_race_collision(long n) \n{\n    long result\
    \ = 0;\n    for (long i = 0; i < n; i++) \n    {\n        for (long j = 0; j <\
    \ n; j++) \n        {\n            if (i < j) \n            {\n              \
    \  result++;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = car_race_collision;\n\n    assert(candidate(2L) == 4L);\n\
    \    assert(candidate(3L) == 9L);\n    assert(candidate(4L) == 16L);\n    assert(candidate(8L)\
    \ == 64L);\n    assert(candidate(10L) == 100L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpl5wv9ugw.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d9d]\n??:? void tmpl5wv9ugw.__unittest_L30_C1() [0x427a84]\n??:?
    void tmpl5wv9ugw.__modtest() [0x427b1c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff98]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa75]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a92d]\n??:? runModuleUnitTests [0x42b899]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428173]\n??:? _d_run_main [0x4280de]\n??:? main [0x427b2f]\n??:?
    __libc_start_main [0x83577554]\n1/1 unittests FAILED\n'''
  stdout: b''
