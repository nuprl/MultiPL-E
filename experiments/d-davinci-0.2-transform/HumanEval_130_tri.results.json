{
  "language": "d",
  "name": "HumanEval_130_tri",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++) \n    {\n        if (i % 2 == 0) \n        {\n            result[i] = 1 + i / 2;\n        } \n        else \n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\n/*\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n*/\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpd3p0o1cu.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpd3p0o1cu.tri(long) [0x427f7c]\n??:? void tmpd3p0o1cu.__unittest_L45_C1() [0x427fbb]\n??:? void tmpd3p0o1cu.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[(int)n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i < n + 1; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8avrtww.d(24): Error: C style cast illegal, use `cast(int)n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8avrtww.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    if (n == 3)\n        return result;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpme4glhns.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288ed]\n??:? void tmpme4glhns.__unittest_L45_C1() [0x42809d]\n??:? void tmpme4glhns.__modtest() [0x428670]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b83a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b811]\n??:? runModuleUnitTests [0x42c77d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428db0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + (i / 2);\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpy__dpic6.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmpy__dpic6.tri(long) [0x427f82]\n??:? void tmpy__dpic6.__unittest_L41_C1() [0x427fbf]\n??:? void tmpy__dpic6.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[(int)n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7fol30aa.d(24): Error: C style cast illegal, use `cast(int)n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7fol30aa.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    auto result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpxjlb2het.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpxjlb2het.tri(long) [0x427f7c]\n??:? void tmpxjlb2het.__unittest_L41_C1() [0x427fbb]\n??:? void tmpxjlb2het.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmprlzvq7mv.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmprlzvq7mv.tri(long) [0x427f82]\n??:? void tmprlzvq7mv.__unittest_L41_C1() [0x427fbf]\n??:? void tmprlzvq7mv.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(long i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp9f9f50dc.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp9f9f50dc.tri(long) [0x427f7f]\n??:? void tmp9f9f50dc.__unittest_L41_C1() [0x427fbf]\n??:? void tmp9f9f50dc.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + (i / 2);\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpy__dpic6.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmpy__dpic6.tri(long) [0x427f82]\n??:? void tmpy__dpic6.__unittest_L41_C1() [0x427fbf]\n??:? void tmpy__dpic6.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[(int)n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i < n + 1; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8avrtww.d(24): Error: C style cast illegal, use `cast(int)n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8avrtww.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] ret = new long[n+1];\n    ret[0] = 1;\n    ret[1] = 3;\n    ret[2] = 2;\n    for(long i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            ret[i] = 1 + i / 2;\n        }\n        else\n        {\n            ret[i] = ret[i-1] + ret[i-2] + ret[i+1];\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpj6g5qeig.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmpj6g5qeig.tri(long) [0x427f7f]\n??:? void tmpj6g5qeig.__unittest_L41_C1() [0x427fbf]\n??:? void tmpj6g5qeig.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    foreach(i; 3 .. n + 1)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpngjae97b.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42894e]\n??:? long[] tmpngjae97b.tri(long) [0x427f90]\n??:? void tmpngjae97b.__unittest_L41_C1() [0x427fcf]\n??:? void tmpngjae97b.__modtest() [0x42861c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c957]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a75]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f24]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a01]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7c1]\n??:? runModuleUnitTests [0x42c72d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + (i / 2);\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpceup0k6x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpceup0k6x.tri(long) [0x427f7c]\n??:? void tmpceup0k6x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpceup0k6x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[(int)n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i < n + 1; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8avrtww.d(24): Error: C style cast illegal, use `cast(int)n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8avrtww.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n+1];\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            res[i] = 1 + i / 2;\n        }\n        else\n        {\n            res[i] = res[i-1] + res[i-2] + res[i+1];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpwhkdjah3.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpwhkdjah3.tri(long) [0x427f7c]\n??:? void tmpwhkdjah3.__unittest_L41_C1() [0x427fbb]\n??:? void tmpwhkdjah3.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    if(n == 0)\n        return result;\n    result[0] = 1;\n    if(n == 1)\n        return result;\n    result[1] = 3;\n    if(n == 2)\n        return result;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp8v85mckg.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x428986]\n??:? long[] tmp8v85mckg.tri(long) [0x427fc9]\n??:? void tmp8v85mckg.__unittest_L43_C1() [0x428007]\n??:? void tmp8v85mckg.__modtest() [0x428654]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c98f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b822]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430aad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f5c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a39]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7f9]\n??:? runModuleUnitTests [0x42c765]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++) \n    {\n        if (i % 2 == 0) \n        {\n            result[i] = 1 + i / 2;\n        } \n        else \n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp2mxnv2b6.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp2mxnv2b6.tri(long) [0x427f7f]\n??:? void tmp2mxnv2b6.__unittest_L41_C1() [0x427fbf]\n??:? void tmp2mxnv2b6.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[(int)n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i < n + 1; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8avrtww.d(24): Error: C style cast illegal, use `cast(int)n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8avrtww.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n+1];\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            res[i] = 1 + i / 2;\n        }\n        else\n        {\n            res[i] = res[i-1] + res[i-2] + res[i+1];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp5ua4em9z.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp5ua4em9z.tri(long) [0x427f82]\n??:? void tmp5ua4em9z.__unittest_L41_C1() [0x427fbf]\n??:? void tmp5ua4em9z.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmprlzvq7mv.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmprlzvq7mv.tri(long) [0x427f82]\n??:? void tmprlzvq7mv.__unittest_L41_C1() [0x427fbf]\n??:? void tmprlzvq7mv.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[(int)n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i < n + 1; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8avrtww.d(24): Error: C style cast illegal, use `cast(int)n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8avrtww.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n + 1];\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            res[i] = 1 + i / 2;\n        }\n        else\n        {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpmiyeynve.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpmiyeynve.tri(long) [0x427f7c]\n??:? void tmpmiyeynve.__unittest_L41_C1() [0x427fbb]\n??:? void tmpmiyeynve.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n+1];\n    res[0] = 1;\n    if(n > 0)\n    {\n        res[1] = 3;\n        if(n > 1)\n        {\n            res[2] = 2;\n            if(n > 2)\n            {\n                for(long i = 3; i <= n; i++)\n                {\n                    if(i % 2 == 0)\n                    {\n                        res[i] = 1 + i / 2;\n                    }\n                    else\n                    {\n                        res[i] = res[i-1] + res[i-2] + res[i+1];\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpvssvyrd4.d(42): Range violation\n----------------\n??:? _d_arrayboundsp [0x428966]\n??:? long[] tmpvssvyrd4.tri(long) [0x427fa9]\n??:? void tmpvssvyrd4.__unittest_L50_C1() [0x427fe7]\n??:? void tmpvssvyrd4.__modtest() [0x428634]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c96f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b802]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a8d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a19]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d9]\n??:? runModuleUnitTests [0x42c745]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(long i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp9f9f50dc.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp9f9f50dc.tri(long) [0x427f7f]\n??:? void tmp9f9f50dc.__unittest_L41_C1() [0x427fbf]\n??:? void tmp9f9f50dc.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++) \n    {\n        if (i % 2 == 0) \n        {\n            result[i] = 1 + i / 2;\n        } \n        else \n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpqg27o11q.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpqg27o11q.tri(long) [0x427f7c]\n??:? void tmpqg27o11q.__unittest_L41_C1() [0x427fbb]\n??:? void tmpqg27o11q.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    if (n == 3)\n        return result;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpme4glhns.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4288ed]\n??:? void tmpme4glhns.__unittest_L45_C1() [0x42809d]\n??:? void tmpme4glhns.__modtest() [0x428670]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b83a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b811]\n??:? runModuleUnitTests [0x42c77d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428db0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[(int)n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb27ka23u.d(24): Error: C style cast illegal, use `cast(int)n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb27ka23u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + (i / 2);\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpceup0k6x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpceup0k6x.tri(long) [0x427f7c]\n??:? void tmpceup0k6x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpceup0k6x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    return n < 0 ? new long[0] : n == 0 ? new long[] {1L} : n == 1 ? new long[] {1L, 3L} : n == 2 ? new long[] {1L, 3L, 2L} : n == 3 ? new long[] {1L, 3L, 2L, 8L} : n == 4 ? new long[] {1L, 3L, 2L, 8L, 5L} : n == 5 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L} : n == 6 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L} : n == 7 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L, 34L} : n == 8 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L, 34L, 55L} : n == 9 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L, 34L, 55L, 89L} : n == 10 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L, 34L, 55L, 89L, 144L} : n == 11 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L, 34L, 55L, 89L, 144L, 233L} : n == 12 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L, 34L, 55L, 89L, 144L, 233L, 377L} : n == 13 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L, 34L, 55L, 89L, 144L, 233L, 377L, 610L} : n == 14 ? new long[] {1L, 3L, 2L, 8L, 5L, 13L, 21L, 34L, 55L, 89L, 144L, 233L, 377L, 610L, 987L} : n\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpchyjerqw.d(24): Error: found `{` when expecting `:`\n/tmp/tmpchyjerqw.d(24): Error: found `}` when expecting `;` following `return` statement\n/tmp/tmpchyjerqw.d(24): Error: found `:` instead of statement\n/tmp/tmpchyjerqw.d(24): Error: declaration expected, not `:`\n/tmp/tmpchyjerqw.d(29): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(30): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(31): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(32): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(33): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(34): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(35): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(36): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(37): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(38): Error: declaration expected, not `assert`\n/tmp/tmpchyjerqw.d(39): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    if (n > 2)\n    {\n        for (long i = 3; i <= n; i++)\n        {\n            if (i % 2 == 0)\n            {\n                result[i] = 1 + i / 2;\n            }\n            else\n            {\n                result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp69x7v4qo.d(38): Range violation\n----------------\n??:? _d_arrayboundsp [0x428946]\n??:? long[] tmp69x7v4qo.tri(long) [0x427f8b]\n??:? void tmp69x7v4qo.__unittest_L44_C1() [0x427fcb]\n??:? void tmp69x7v4qo.__modtest() [0x428618]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c94f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a6d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b9]\n??:? runModuleUnitTests [0x42c725]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++) \n    {\n        if (i % 2 == 0) \n        {\n            result[i] = 1 + i / 2;\n        }\n        else \n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_orpu1xt.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_orpu1xt.tri(long) [0x427f7f]\n??:? void tmp_orpu1xt.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_orpu1xt.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmprlzvq7mv.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmprlzvq7mv.tri(long) [0x427f82]\n??:? void tmprlzvq7mv.__unittest_L41_C1() [0x427fbf]\n??:? void tmprlzvq7mv.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmprlzvq7mv.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmprlzvq7mv.tri(long) [0x427f82]\n??:? void tmprlzvq7mv.__unittest_L41_C1() [0x427fbf]\n??:? void tmprlzvq7mv.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    for (long i = 2; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpw5sh2qsq.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x42891e]\n??:? long[] tmpw5sh2qsq.tri(long) [0x427f5f]\n??:? void tmpw5sh2qsq.__unittest_L40_C1() [0x427f9f]\n??:? void tmpw5sh2qsq.__modtest() [0x4285ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c927]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a45]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ef4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b791]\n??:? runModuleUnitTests [0x42c6fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i <= n; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpn0pg5c4x.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmpn0pg5c4x.tri(long) [0x427f7c]\n??:? void tmpn0pg5c4x.__unittest_L41_C1() [0x427fbb]\n??:? void tmpn0pg5c4x.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    if (n == 0)\n        return result;\n    result[0] = 1;\n    if (n == 1)\n        return result;\n    result[1] = 3;\n    if (n == 2)\n        return result;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n            result[i] = 1 + i / 2;\n        else\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmptp4dcix_.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x42898e]\n??:? long[] tmptp4dcix_.tri(long) [0x427fcf]\n??:? void tmptp4dcix_.__unittest_L43_C1() [0x42800f]\n??:? void tmptp4dcix_.__modtest() [0x42865c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c997]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b82a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ab5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f64]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b801]\n??:? runModuleUnitTests [0x42c76d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n == 0)\n        return [1L];\n    if (n == 1)\n        return [1L, 3L];\n    if (n == 2)\n        return [1L, 3L, 2L];\n    auto result = [1L, 3L, 2L];\n    foreach (i; 2 .. n)\n    {\n        if (i % 2 == 0)\n            result ~= 1 + i / 2;\n        else\n            result ~= result[$ - 1] + result[$ - 2] + result[$ - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp71nmeiym.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42890d]\n??:? void tmp71nmeiym.__unittest_L40_C1() [0x4280bd]\n??:? void tmp71nmeiym.__modtest() [0x428690]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c3d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c1c1]\n??:? runModuleUnitTests [0x42d12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[(int)n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i < n + 1; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb8avrtww.d(24): Error: C style cast illegal, use `cast(int)n`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8avrtww.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmprlzvq7mv.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmprlzvq7mv.tri(long) [0x427f82]\n??:? void tmprlzvq7mv.__unittest_L41_C1() [0x427fbf]\n??:? void tmprlzvq7mv.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    if(n > 0)\n    {\n        result[1] = 3;\n        if(n > 1)\n        {\n            result[2] = 2;\n            if(n > 2)\n            {\n                for(int i = 3; i <= n; i++)\n                {\n                    if(i % 2 == 0)\n                    {\n                        result[i] = 1 + (i / 2);\n                    }\n                    else\n                    {\n                        result[i] = result[i-1] + result[i-2] + result[i+1];\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp9w6drrmm.d(42): Range violation\n----------------\n??:? _d_arrayboundsp [0x42895e]\n??:? long[] tmp9w6drrmm.tri(long) [0x427fa3]\n??:? void tmp9w6drrmm.__unittest_L50_C1() [0x427fdf]\n??:? void tmp9w6drrmm.__modtest() [0x42862c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c967]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f34]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7d1]\n??:? runModuleUnitTests [0x42c73d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmprlzvq7mv.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmprlzvq7mv.tri(long) [0x427f82]\n??:? void tmprlzvq7mv.__unittest_L41_C1() [0x427fbf]\n??:? void tmprlzvq7mv.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmprlzvq7mv.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmprlzvq7mv.tri(long) [0x427f82]\n??:? void tmprlzvq7mv.__unittest_L41_C1() [0x427fbf]\n??:? void tmprlzvq7mv.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    if (n > 2)\n    {\n        for (long i = 3; i <= n; i++)\n        {\n            if (i % 2 == 0)\n            {\n                result[i] = 1 + i / 2;\n            }\n            else\n            {\n                result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp69x7v4qo.d(38): Range violation\n----------------\n??:? _d_arrayboundsp [0x428946]\n??:? long[] tmp69x7v4qo.tri(long) [0x427f8b]\n??:? void tmp69x7v4qo.__unittest_L44_C1() [0x427fcb]\n??:? void tmp69x7v4qo.__modtest() [0x428618]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c94f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a6d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b9]\n??:? runModuleUnitTests [0x42c725]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmplfdizdd_.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428936]\n??:? long[] tmplfdizdd_.tri(long) [0x427f7c]\n??:? void tmplfdizdd_.__unittest_L41_C1() [0x427fbb]\n??:? void tmplfdizdd_.__modtest() [0x428608]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c93f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7a9]\n??:? runModuleUnitTests [0x42c715]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n+1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for(int i = 3; i < n+1; i++)\n    {\n        if(i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i-1] + result[i-2] + result[i+1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmprlzvq7mv.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmprlzvq7mv.tri(long) [0x427f82]\n??:? void tmprlzvq7mv.__unittest_L41_C1() [0x427fbf]\n??:? void tmprlzvq7mv.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; i++)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = 1 + i / 2;\n        }\n        else\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp_fnsw0jz.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x42893e]\n??:? long[] tmp_fnsw0jz.tri(long) [0x427f7f]\n??:? void tmp_fnsw0jz.__unittest_L41_C1() [0x427fbf]\n??:? void tmp_fnsw0jz.__modtest() [0x42860c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c947]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b1]\n??:? runModuleUnitTests [0x42c71d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "stdout": "",
      "timestamp": 1660161275
    }
  ]
}