language: d
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n        else\n        {\n            continue;\n        }\n      \
    \  if(stack.sum == 0)\n        {\n            end = paren_string.length - stack.length;\n\
    \            result ~= paren_string[start..end];\n            start = end + 1;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp318saq2a.d(32): Error: no property `sum` for type `int[]`

    /tmp/tmp318saq2a.d(34): Error: cannot implicitly convert expression `paren_string.length
    - stack.length` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp318saq2a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = i;\n            count++;\n        }\n       \
    \ else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprfum3fno.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmprfum3fno.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprfum3fno.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren = 0;\n    int close_paren = 0;\n    int start =\
    \ 0;\n    int end = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_paren++;\n        }\n        else if(c ==\
    \ ')')\n        {\n            close_paren++;\n        }\n        if(open_paren\
    \ == close_paren)\n        {\n            end = i;\n            result ~= paren_string[start..end];\n\
    \            start = i + 1;\n            open_paren = 0;\n            close_paren\
    \ = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hw5l_p4.d(31): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp5hw5l_p4.d(33): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hw5l_p4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int current_count = 0;\n    int current_start\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            current_count++;\n        }\n        else if(c == ')')\n    \
    \    {\n            current_count--;\n        }\n        if(current_count == 0)\n\
    \        {\n            result ~= paren_string[current_start..i];\n          \
    \  current_start = i + 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr9jzpvaa.d(31): Error: cannot implicitly convert expression `i
    + 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9jzpvaa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.range;\n    import std.string;\n\
    \    import std.typecons;\n    import std.math;\n    import std.conv;\n    import\
    \ std.stdio;\n    import std.traits;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.string;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.conv;\n    import std.stdio;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.algorithm;\n    import std.array;\n    import\
    \ std.range;\n    import std.string;\n    import std.typecons;\n    import std.math;\n\
    \    import std.conv;\n    import std.stdio;\n    import std.traits;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.string;\n    import std.typecons;\n   \
    \ import std.math;\n    import std.conv;\n    import std.stdio;\n    import std.traits;\n\
    \    import std.typecons;\n    import std.math;\n    import std.algorithm;\n \
    \   import std.array;\n    import std.range;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.conv;\n    import std.stdio;\n\
    \    import std.traits;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.range;\n    import std.string;\n\
    \    import std.typecons;\n    import std.math;\n    import std.conv;\n    import\
    \ std.stdio;\n    import std.traits;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import\nunittest\n{\n \
    \   alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo5nottd5.d(83): Error: identifier expected following `import`

    /tmp/tmpo5nottd5.d(83): Error: `;` expected

    /tmp/tmpo5nottd5.d(92): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo5nottd5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= i;\n        }\n\
    \        else if(c == ')')\n        {\n            if(stack.length == 0)\n   \
    \         {\n                throw new Exception(\"Unbalanced parentheses\");\n\
    \            }\n            else\n            {\n                int start = stack.pop;\n\
    \                result ~= paren_string[start..i];\n            }\n        }\n\
    \    }\n    if(stack.length != 0)\n    {\n        throw new Exception(\"Unbalanced\
    \ parentheses\");\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj7zn8a5f.d(21): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpj7zn8a5f.d(31): Error: no property `pop` for type `int[]`

    /tmp/tmpj7zn8a5f.d(31): Error: variable `start` is shadowing variable `tmpj7zn8a5f.separate_paren_groups.start`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj7zn8a5f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ string current_paren_group = \"\";\n    foreach(char c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open_paren_count++;\n          \
    \  current_paren_group ~= c;\n        }\n        else if(c == ')')\n        {\n\
    \            close_paren_count++;\n            current_paren_group ~= c;\n   \
    \     }\n        if(open_paren_count == close_paren_count && open_paren_count\
    \ != 0)\n        {\n            result ~= current_paren_group;\n            current_paren_group\
    \ = \"\";\n            open_paren_count = 0;\n            close_paren_count =\
    \ 0;\n        }\n    }\n    return result;\n}\n/*\n    Given a string containing\
    \ a list of integers separated by spaces, return the sum of all integers.\n  \
    \  >>> sum_of_integers(\"1 2 3 4\")\n    10\n*/\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            if(count\
    \ == 0) \n            {\n                start = end;\n            }\n       \
    \     count++;\n        }\n        else if(c == ')') \n        {\n           \
    \ count--;\n            if(count == 0) \n            {\n                result\
    \ ~= paren_string[start..end];\n            }\n        }\n        end++;\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpplbpv9u9.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpplbpv9u9.__unittest_L40_C1() [0x427d93]

    ??:? void tmpplbpv9u9.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ end = c;\n            result ~= paren_string[start..end];\n            start\
    \ = end;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpf5174j7j.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f36]

    ??:? immutable(char)[][] tmpf5174j7j.separate_paren_groups(immutable(char)[])
    [0x427c38]

    ??:? void tmpf5174j7j.__unittest_L38_C1() [0x427cd1]

    ??:? void tmpf5174j7j.__modtest() [0x4280ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int start = 0;\n    int end = 0;\n    int\
    \ i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            paren_count ~= 1;\n        }\n        else if(c == ')')\n       \
    \ {\n            paren_count ~= -1;\n        }\n    }\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            start = i;\n        }\n \
    \       else if(c == ')')\n        {\n            end = i;\n            if(paren_count[start]\
    \ == -1)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwhu8m3g1.d(39): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x429316]

    ??:? immutable(char)[][] tmpwhu8m3g1.separate_paren_groups(immutable(char)[])
    [0x427fcb]

    ??:? void tmpwhu8m3g1.__unittest_L48_C1() [0x4280b5]

    ??:? void tmpwhu8m3g1.__modtest() [0x4284d0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e783]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428fbe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b44d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b4dc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b3d9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f95]

    ??:? runModuleUnitTests [0x42e559]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_parens = 0;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    foreach(i, c; paren_string) \n    {\n        if(c == '(') \n     \
    \   {\n            if(open_parens == 0) \n            {\n                start_index\
    \ = i;\n            }\n            open_parens++;\n        }\n        else if(c\
    \ == ')') \n        {\n            open_parens--;\n            if(open_parens\
    \ == 0) \n            {\n                end_index = i;\n                result\
    \ ~= paren_string[start_index..end_index + 1];\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ghsxu42.d(24): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp7ghsxu42.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ghsxu42.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ groups;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_parens++;\n        }\n        else if(c ==\
    \ ')')\n        {\n            close_parens++;\n        }\n        if(open_parens\
    \ == close_parens)\n        {\n            groups ~= paren_string[start..end];\n\
    \            start = end + 1;\n            open_parens = 0;\n            close_parens\
    \ = 0;\n        }\n        end++;\n    }\n    return groups;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm6c17ah7.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpm6c17ah7.__unittest_L40_C1() [0x427d97]

    ??:? void tmpm6c17ah7.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_count = 0;\n   \
    \ int close_count = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            close_count++;\n        }\n        end++;\n        if(open_count\
    \ == close_count)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n            open_count = 0;\n            close_count\
    \ = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptbjzlsl8.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmptbjzlsl8.__unittest_L40_C1() [0x427d97]

    ??:? void tmptbjzlsl8.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_paren_count++;\n   \
    \         if(open_paren_count == 1)\n            {\n                start_index\
    \ = i;\n            }\n        }\n        else if(c == ')')\n        {\n     \
    \       close_paren_count++;\n            if(close_paren_count == open_paren_count)\n\
    \            {\n                end_index = i;\n                result ~= paren_string[start_index..end_index+1];\n\
    \                open_paren_count = 0;\n                close_paren_count = 0;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps0wyujjb.d(26): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmps0wyujjb.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0wyujjb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open++;\n        }\n        else if(c == ')')\n      \
    \  {\n            close++;\n        }\n        if(open == close)\n        {\n\
    \            end = i;\n            result ~= paren_string[start..end];\n     \
    \       start = i + 1;\n            open = 0;\n            close = 0;\n      \
    \  }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf7d6i554.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf7d6i554.__unittest_L42_C1() [0x427d97]

    ??:? void tmpf7d6i554.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = i;\n            count++;\n        }\n       \
    \ else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\n    Given a string\
    \ of parentheses, return true if the string is balanced.\n    A string is balanced\
    \ if it contains the same number of open and closed parentheses.\n    >>> is_balanced(\"\
    ()\")\n    true\n    >>> is_balanced(\"(()\")\n    false\n    >>> is_balanced(\"\
    ())\")\n    false\n    >>> is_balanced(\"(())\")\n    true\n*/\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnvpst9p6.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpnvpst9p6.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnvpst9p6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int len = paren_string.length;\n    foreach(i; 0..len)\n    {\n  \
    \      if(paren_string[i] == '(')\n        {\n            open++;\n        }\n\
    \        else if(paren_string[i] == ')')\n        {\n            close++;\n  \
    \      }\n        if(open == close)\n        {\n            end = i;\n       \
    \     result ~= paren_string[start..end];\n            start = i+1;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1fe0e1kj.d(19): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1fe0e1kj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int start = 0;\n    int end = 0;\n    while(i <\
    \ paren_string.length)\n    {\n        if(paren_string[i] == '(')\n        {\n\
    \            start = i;\n            end = i;\n            while(paren_string[end]\
    \ != ')')\n            {\n                end++;\n            }\n            result\
    \ ~= paren_string[start..end+1];\n            i = end + 1;\n        }\n      \
    \  else\n        {\n            i++;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3bx2mezr.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmp3bx2mezr.__unittest_L38_C1() [0x427dab]

    ??:? void tmp3bx2mezr.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int paren_count_index = 0;\n    int paren_count_length\
    \ = 0;\n    int paren_count_capacity = 0;\n    int paren_count_capacity_increment\
    \ = 10;\n    int paren_count_capacity_max = 100;\n    int paren_count_capacity_min\
    \ = 10;\n    int paren_count_capacity_decrement = 10;\n    int paren_count_capacity_decrement_max\
    \ = 10;\n    int paren_count_capacity_decrement_min = 1;\n    int paren_count_capacity_decrement_factor\
    \ = 2;\n    int paren_count_capacity_decrement_factor_max = 10;\n    int paren_count_capacity_decrement_factor_min\
    \ = 1;\n    int paren_count_capacity_decrement_factor_increment = 1;\n    int\
    \ paren_count_capacity_decrement_factor_increment_max = 10;\n    int paren_count_capacity_decrement_factor_increment_min\
    \ = 1;\n    int paren_count_capacity_decrement_factor_increment_factor = 2;\n\
    \    int paren_count_capacity_decrement_factor_increment_factor_max = 10;\n  \
    \  int paren_count_capacity_decrement_factor_increment_factor_min = 1;\n    int\
    \ paren_count_capacity_decrement_factor_increment_factor_increment = 1;\n    int\
    \ paren_count_capacity_decrement_factor_increment_factor_increment_max = 10;\n\
    \    int paren_count_capacity_decrement_factor_increment_factor_increment_min\
    \ = 1;\n    int paren_count_capacity_decrement_factor_increment_factor_increment_factor\
    \ = 2;\n    int paren_count_capacity_decrement_factor_increment_factor_increment_factor_max\
    \ = 10;\n    int paren_count_capacity_decrement_factor_increment_factor_increment_factor_\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpimebx1vn.d(40): Error: semicolon expected, not `unittest`

    /tmp/tmpimebx1vn.d(40): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpimebx1vn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open = 0;\n    string temp;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open++;\n            temp\
    \ ~= c;\n        }\n        else if(c == ')')\n        {\n            open--;\n\
    \            temp ~= c;\n        }\n        if(open == 0 && temp.length > 0)\n\
    \        {\n            result ~= temp;\n            temp = \"\";\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            count++;\n\
    \        }\n        else if(c == ')')\n        {\n            count--;\n     \
    \   }\n        if(count == 0)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n        }\n        end++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppo8b4lrw.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e7d]

    ??:? void tmppo8b4lrw.__unittest_L37_C1() [0x427d87]

    ??:? void tmppo8b4lrw.__modtest() [0x4280e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b065]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bad]

    ??:? runModuleUnitTests [0x42df8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= start;\n       \
    \ }\n        else if(c == ')')\n        {\n            if(stack.length == 0)\n\
    \            {\n                throw new Exception(\"Unbalanced parentheses\"\
    );\n            }\n            else\n            {\n                int end =\
    \ start;\n                start = stack.pop;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        start++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprjo5gmwc.d(32): Error: no property `pop` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjo5gmwc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indices;\n    int[] close_paren_indices;\n   \
    \ int[] open_paren_counts;\n    int[] close_paren_counts;\n    int[] open_paren_counts_cumulative;\n\
    \    int[] close_paren_counts_cumulative;\n    int[] open_paren_counts_cumulative_diff;\n\
    \    int[] close_paren_counts_cumulative_diff;\n    int[] open_paren_counts_cumulative_diff_diff;\n\
    \    int[] close_paren_counts_cumulative_diff_diff;\n    int[] open_paren_counts_cumulative_diff_diff_diff;\n\
    \    int[] close_paren_counts_cumulative_diff_diff_diff;\n    int[] open_paren_counts_cumulative_diff_diff_diff_diff;\n\
    \    int[] close_paren_counts_cumulative_diff_diff_diff_diff;\n    int[] open_paren_counts_cumulative_diff_diff_diff_diff_diff;\n\
    \    int[] close_paren_counts_cumulative_diff_diff_diff_diff_diff;\n    int[]\
    \ open_paren_counts_cumulative_diff_diff_diff_diff_diff_diff;\n    int[] close_paren_counts_cumulative_diff_diff_diff_diff_diff_diff;\n\
    \    int[] open_paren_counts_cumulative_diff_diff_diff_diff_diff_diff_diff;\n\
    \    int[] close_paren_counts_cumulative_diff_diff_diff_diff_diff_diff_diff;\n\
    \    int[] open_paren_counts_cumulative_diff_diff_diff_diff_diff_diff_diff_diff;\n\
    \    int[] close_paren_counts_cumulative_diff_diff_diff_diff_diff_diff_diff_diff;\n\
    \    int[] open_paren_counts_cumulative_diff_diff_diff_diff_diff_diff_diff_diff_diff;\n\
    \    int[] close_paren_counts_cumulative_diff_diff_diff_diff_diff_diff_diff_diff_diff;\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4u1fo4k2.d(39): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4u1fo4k2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n        else if(c == ' ')\n        {\n            continue;\n    \
    \    }\n        else\n        {\n            assert(false);\n        }\n     \
    \   if(stack.empty)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n        }\n        end++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjldeaxex.d(36): Error: no property `empty` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjldeaxex.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= i;\n        }\n\
    \        else if(c == ')')\n        {\n            if(stack.length == 0)\n   \
    \         {\n                throw new Exception(\"Invalid string\");\n      \
    \      }\n            int end = stack.pop;\n            if(end == start)\n   \
    \         {\n                result ~= paren_string[start..i+1];\n           \
    \     start = i+1;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe9yesllp.d(21): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpe9yesllp.d(29): Error: no property `pop` for type `int[]`

    /tmp/tmpe9yesllp.d(33): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9yesllp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto\
    \ result = new string[];\n    int open_paren_count = 0;\n    int start_index =\
    \ 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(open_paren_count == 0)\n            {\n                start_index\
    \ = i;\n            }\n            open_paren_count++;\n        }\n        else\
    \ if(c == ')')\n        {\n            open_paren_count--;\n            if(open_paren_count\
    \ == 0)\n            {\n                result ~= paren_string[start_index..i+1];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvakrytxe.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpvakrytxe.d(23): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvakrytxe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_parens++;\n        }\n        else if(c ==\
    \ ')')\n        {\n            close_parens++;\n        }\n        end++;\n  \
    \      if(open_parens == close_parens)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n            open_parens = 0;\n            close_parens\
    \ = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2nagyyio.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmp2nagyyio.__unittest_L40_C1() [0x427d97]

    ??:? void tmp2nagyyio.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            count++;\n\
    \        }\n        else if(c == ')')\n        {\n            count--;\n     \
    \   }\n        if(count == 0)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n        }\n        end++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppo8b4lrw.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e7d]

    ??:? void tmppo8b4lrw.__unittest_L37_C1() [0x427d87]

    ??:? void tmppo8b4lrw.__modtest() [0x4280e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b065]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bad]

    ??:? runModuleUnitTests [0x42df8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            count++;\n\
    \        }\n        else if(c == ')')\n        {\n            count--;\n     \
    \   }\n        if(count == 0)\n        {\n            end = paren_string.indexOf(c);\n\
    \            result ~= paren_string[start..end];\n            start = end + 1;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx02q68vr.d(30): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx02q68vr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_count = 0;\n   \
    \ int close_count = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            close_count++;\n        }\n        end++;\n        if(open_count\
    \ == close_count)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n            open_count = 0;\n            close_count\
    \ = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptbjzlsl8.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmptbjzlsl8.__unittest_L40_C1() [0x427d97]

    ??:? void tmptbjzlsl8.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    int len\
    \ = paren_string.length;\n    foreach(i; 0..len)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            if(count == 0)\n            {\n            \
    \    start = i;\n            }\n            count++;\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            count--;\n            if(count\
    \ == 0)\n            {\n                end = i;\n                result ~= paren_string[start..end+1];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq4ruh6o3.d(18): Error: cannot implicitly convert expression `paren_string.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4ruh6o3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    // TODO:\
    \ Implement this function\n    return [];\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp7zn6kvs.d(21): unittest failure

    ----------------

    ??:? _d_unittestp [0x428d75]

    ??:? void tmpp7zn6kvs.__unittest_L17_C1() [0x427c7f]

    ??:? void tmpp7zn6kvs.__modtest() [0x427fdc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d64f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ace]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a4fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a58c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a489]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428aa5]

    ??:? runModuleUnitTests [0x42d425]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4291c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n        else\n        {\n            continue;\n        }\n      \
    \  if(stack.length == 0)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n        }\n        end++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeidpzvfg.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291b5]

    ??:? void tmpeidpzvfg.__unittest_L41_C1() [0x4280bf]

    ??:? void tmpeidpzvfg.__modtest() [0x42841c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b39d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b42c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b329]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ee5]

    ??:? runModuleUnitTests [0x42e4a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429678]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string) \n    {\n        if(c == '(') \n        {\n\
    \            open++;\n        }\n        else if(c == ')') \n        {\n     \
    \       close++;\n        }\n        if(open == close) \n        {\n         \
    \   result ~= paren_string[start..end];\n            start = end + 1;\n      \
    \      open = 0;\n            close = 0;\n        }\n        end++;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphzutf9gw.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmphzutf9gw.__unittest_L40_C1() [0x427d97]

    ??:? void tmphzutf9gw.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ res;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                res ~= paren_string[start..end];\n        }\n        end++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqu2dk34_.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpqu2dk34_.__unittest_L36_C1() [0x427d93]

    ??:? void tmpqu2dk34_.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_parens;\n    int[] close_parens;\n    int open_count\
    \ = 0;\n    int close_count = 0;\n    int i = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_count++;\n         \
    \   open_parens ~= i;\n        }\n        else if(c == ')')\n        {\n     \
    \       close_count++;\n            close_parens ~= i;\n        }\n        i++;\n\
    \    }\n    if(open_count != close_count)\n    {\n        return result;\n   \
    \ }\n    int start = 0;\n    int end = 0;\n    for(int i = 0; i < open_parens.length;\
    \ i++)\n    {\n        start = open_parens[i];\n        end = close_parens[i];\n\
    \        result ~= paren_string[start..end+1];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpemprsm9o.d(40): Error: variable `i` is shadowing variable `tmpemprsm9o.separate_paren_groups.i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpemprsm9o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(open_paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        open_paren_count++;\n        }\n        else if(c == ')')\n        {\n\
    \            open_paren_count--;\n            if(open_paren_count == 0)\n    \
    \        {\n                result ~= paren_string[start_index..i];\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwa8rzexd.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwa8rzexd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string current_group;\n    int open_count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            open_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            open_count--;\n            current_group ~= c;\n          \
    \  if(open_count == 0)\n            {\n                result ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_top = 0;\n    int start = 0;\n    int\
    \ end = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n      \
    \  {\n            stack[stack_top++] = end;\n        }\n        else if(c == ')')\n\
    \        {\n            if(stack_top == 0)\n            {\n                throw\
    \ new Exception(\"Unbalanced parentheses\");\n            }\n            else\n\
    \            {\n                start = stack[--stack_top];\n                result\
    \ ~= paren_string[start..end];\n            }\n        }\n        end++;\n   \
    \ }\n    if(stack_top != 0)\n    {\n        throw new Exception(\"Unbalanced parentheses\"\
    );\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpxfr1o8an.d(23): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4290fe]

    ??:? immutable(char)[][] tmpxfr1o8an.separate_paren_groups(immutable(char)[])
    [0x427c2f]

    ??:? void tmpxfr1o8an.__unittest_L45_C1() [0x427e01]

    ??:? void tmpxfr1o8an.__modtest() [0x42821c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e483]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b235]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2c4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1c1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ce5]

    ??:? runModuleUnitTests [0x42e259]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open = 0;\n    int close = 0;\n    int start = 0;\n    int\
    \ end = 0;\n    for(int i = 0; i < paren_string.length; i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            open++;\n            if(open == 1)\n       \
    \     {\n                start = i;\n            }\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            close++;\n            if(open == close)\n  \
    \          {\n                end = i;\n                result ~= paren_string[start..end+1];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzqfedvjb.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428eb5]

    ??:? void tmpzqfedvjb.__unittest_L43_C1() [0x427f7c]

    ??:? void tmpzqfedvjb.__modtest() [0x42811c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b09d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b12c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b029]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428be5]

    ??:? runModuleUnitTests [0x42dfc5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429378]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result = [];\n    int start = 0;\n    int end = 0;\n    int count = 0;\n   \
    \ for(int i = 0; i < paren_string.length; i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            count++;\n            if(count == 1)\n     \
    \       {\n                start = i;\n            }\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            count--;\n            if(count\
    \ == 0)\n            {\n                end = i;\n                result ~= paren_string[start..end+1];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpagubu_nl.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ead]

    ??:? void tmpagubu_nl.__unittest_L40_C1() [0x427f78]

    ??:? void tmpagubu_nl.__modtest() [0x428118]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b095]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b124]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b021]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bdd]

    ??:? runModuleUnitTests [0x42dfbd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429370]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.conv;\n    import std.range;\n\
    \    import std.string;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.stdio;\n    import std.traits;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7gqr25gr.d(79): Error: identifier expected following `import`

    /tmp/tmp7gqr25gr.d(79): Error: `;` expected

    /tmp/tmp7gqr25gr.d(88): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gqr25gr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.conv;\n    import std.range;\n\
    \    import std.string;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.algorithm : filter, map;\n    import std.range : take, drop;\n    import\
    \ std.stdio;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons :\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaps8xo6w.d(65): Error: identifier expected following `:`

    /tmp/tmpaps8xo6w.d(65): Error: `;` expected

    /tmp/tmpaps8xo6w.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaps8xo6w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto\
    \ result = new string[];\n    auto start = 0;\n    auto end = 0;\n    auto count\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            if(count == 0)\n            {\n                start = i;\n \
    \           }\n            count++;\n        }\n        else if(c == ')')\n  \
    \      {\n            count--;\n            if(count == 0)\n            {\n  \
    \              end = i;\n                result ~= paren_string[start..end+1];\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\n    Given a string,\
    \ return a string where for every char in the original, there are two chars.\n\
    \    >>> double_char(\"The\")\n    \"TThhee\"\n    >>> double_char(\"AAbb\")\n\
    \    \"AAAAbbbb\"\n    >>> double_char(\"Hi-There\")\n    \"HHii--TThheerree\"\
    \n*/\nstring double_char(string s)\n{\n    auto result = new string;\n    foreach(c;\
    \ s)\n    {\n        result ~= c;\n        result ~= c;\n    }\n    return result;\n\
    }\n/*\n    Return the number of times that the string \"hi\" appears anywhere\
    \ in the given string.\n    >>> count_hi(\"abc hi ho\")\n    1\n    >>> count_hi(\"\
    ABChi hi\")\n    2\n    >>> count_hi(\"hihi\")\n    2\n*/\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbg64o0fz.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpbg64o0fz.d(24): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpbg64o0fz.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpbg64o0fz.d(51): Error: new can only create structs, dynamic arrays or
    class objects, not `string`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbg64o0fz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ end = c;\n            result ~= paren_string[start..end];\n            start\
    \ = end + 1;\n            open = 0;\n            close = 0;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpr15ihu18.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f3e]

    ??:? immutable(char)[][] tmpr15ihu18.separate_paren_groups(immutable(char)[])
    [0x427c38]

    ??:? void tmpr15ihu18.__unittest_L40_C1() [0x427cd9]

    ??:? void tmpr15ihu18.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int start = 0;\n    int end = 0;\n    int count\
    \ = 0;\n    while(i < paren_string.length)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            if(count == 0)\n            {\n            \
    \    start = i;\n            }\n            count++;\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            count--;\n            if(count\
    \ == 0)\n            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxwzxd81d.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmpxwzxd81d.__unittest_L42_C1() [0x427dab]

    ??:? void tmpxwzxd81d.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = i;\n            count++;\n        }\n       \
    \ else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n            {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprfum3fno.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmprfum3fno.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprfum3fno.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= i;\n        }\n\
    \        else if(c == ')')\n        {\n            if(stack.length == 0)\n   \
    \         {\n                throw new Exception(\"Unbalanced parentheses\");\n\
    \            }\n            else\n            {\n                int last = stack[$-1];\n\
    \                stack = stack[0..$-1];\n                if(stack.length == 0)\n\
    \                {\n                    result ~= paren_string[start..i];\n  \
    \                  start = i + 1;\n                }\n            }\n        }\n\
    \    }\n    if(stack.length != 0)\n    {\n        throw new Exception(\"Unbalanced\
    \ parentheses\");\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9zwkcio1.d(21): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmp9zwkcio1.d(36): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9zwkcio1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto\
    \ result = new string[];\n    int start = 0;\n    int end = 0;\n    int count\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            if(count == 0)\n                start = i;\n            count++;\n\
    \        }\n        else if(c == ')')\n        {\n            count--;\n     \
    \       if(count == 0)\n            {\n                end = i;\n            \
    \    result ~= paren_string[start..end+1];\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2rwrzwt.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpq2rwrzwt.d(23): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpq2rwrzwt.d(31): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2rwrzwt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int paren_count = 0;\n    string current_paren_group = \"\";\n\
    \    foreach(char c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           paren_count++;\n            current_paren_group ~= c;\n        }\n\
    \        else if(c == ')')\n        {\n            paren_count--;\n          \
    \  current_paren_group ~= c;\n            if(paren_count == 0)\n            {\n\
    \                result ~= current_paren_group;\n                current_paren_group\
    \ = \"\";\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    // Write\
    \ your code here\n    string[] result;\n    int open_paren = 0;\n    int close_paren\
    \ = 0;\n    int start = 0;\n    int end = 0;\n    int i = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_paren++;\n        }\n\
    \        else if(c == ')')\n        {\n            close_paren++;\n        }\n\
    \        if(open_paren == close_paren)\n        {\n            end = i;\n    \
    \        result ~= paren_string[start..end];\n            open_paren = 0;\n  \
    \          close_paren = 0;\n            start = i+1;\n        }\n        i++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjmap2ss5.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpjmap2ss5.__unittest_L43_C1() [0x427d97]

    ??:? void tmpjmap2ss5.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzq7imnq4.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzq7imnq4.__unittest_L40_C1() [0x427d93]

    ??:? void tmpzq7imnq4.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int start_idx = 0;\n    int end_idx = 0;\n\
    \    int paren_count_idx = 0;\n    foreach(c; paren_string) \n    {\n        if(c\
    \ == '(') \n        {\n            paren_count ~= 1;\n            start_idx =\
    \ end_idx;\n            paren_count_idx = paren_count.length - 1;\n        }\n\
    \        else if(c == ')') \n        {\n            paren_count[paren_count_idx]--;\n\
    \            if(paren_count[paren_count_idx] == 0) \n            {\n         \
    \       result ~= paren_string[start_idx..end_idx];\n                paren_count.popBack();\n\
    \                paren_count_idx--;\n            }\n        }\n        end_idx++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9llq1gy.d(25): Error: cannot implicitly convert expression `paren_count.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpl9llq1gy.d(33): Error: no property `popBack` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9llq1gy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_count;\n    int start_index = 0;\n    int end_index\
    \ = 0;\n    int paren_index = 0;\n    foreach(c; paren_string)\n    {\n      \
    \  if(c == '(')\n        {\n            paren_count ~= 1;\n            start_index\
    \ = paren_index;\n        }\n        else if(c == ')')\n        {\n          \
    \  paren_count ~= -1;\n            end_index = paren_index;\n        }\n     \
    \   if(paren_count.length > 0 && paren_count.sum == 0)\n        {\n          \
    \  result ~= paren_string[start_index..end_index+1];\n            paren_count\
    \ = [];\n        }\n        paren_index++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1pzmaiyp.d(31): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1pzmaiyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_paren_count++;\n   \
    \         if(open_paren_count == 1)\n            {\n                start_index\
    \ = i;\n            }\n        }\n        else if(c == ')')\n        {\n     \
    \       close_paren_count++;\n            if(close_paren_count == open_paren_count)\n\
    \            {\n                end_index = i;\n                result ~= paren_string[start_index..end_index+1];\n\
    \                open_paren_count = 0;\n                close_paren_count = 0;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps0wyujjb.d(26): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmps0wyujjb.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0wyujjb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            open++;\n        }\n        else if(c == ')')\n        {\n  \
    \          close++;\n        }\n        if(open == close)\n        {\n       \
    \     result ~= paren_string[start..end];\n            start = i + 1;\n      \
    \      open = 0;\n            close = 0;\n        }\n        end++;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp58ju6vs9.d(32): Error: cannot implicitly convert expression `i
    + 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp58ju6vs9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            open++;\n        }\n        else if(c == ')')\n        {\n  \
    \          close++;\n        }\n        if(open == close)\n        {\n       \
    \     end = i;\n            result ~= paren_string[start..end];\n            start\
    \ = end + 1;\n            open = 0;\n            close = 0;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfbaakxh9.d(31): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfbaakxh9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int level = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(level\
    \ == 0)\n                start = end;\n            level++;\n        }\n     \
    \   else if(c == ')')\n        {\n            level--;\n            if(level ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ else if(c != ' ')\n            throw new Exception(\"Invalid character\");\n\
    \        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1k6kjg72.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f85]

    ??:? void tmp1k6kjg72.__unittest_L38_C1() [0x427df7]

    ??:? void tmp1k6kjg72.__modtest() [0x428154]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b16d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b1fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b0f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c1d]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429448]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\n/*\n    Given a string containing a single group of nested\
    \ parentheses, return the minimum number of\n    parentheses that would need to\
    \ be removed to make the string valid.\n    >>> minimum_removals(\"()())()\")\n\
    \    1\n    >>> minimum_removals(\"(()()))\")\n    2\n    >>> minimum_removals(\"\
    ()()()()\")\n    0\n*/\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv9hlftsk.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpv9hlftsk.__unittest_L50_C1() [0x427d97]

    ??:? void tmpv9hlftsk.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string[] paren_list = paren_string.split(\" \");\n    string temp_string;\n\
    \    int count = 0;\n    foreach(string paren; paren_list)\n    {\n        temp_string\
    \ ~= paren;\n        count += paren.count(\"(\");\n        count -= paren.count(\"\
    )\");\n        if(count == 0)\n        {\n            result ~= temp_string;\n\
    \            temp_string = \"\";\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8isrwe0b.d(15): Error: no property `split` for type `string`

    /tmp/tmp8isrwe0b.d(21): Error: no property `count` for type `string`

    /tmp/tmp8isrwe0b.d(22): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8isrwe0b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_index = 0;\n    int end_index = 0;\n    int open_paren_count\
    \ = 0;\n    int close_paren_count = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open_paren_count++;\n        }\n\
    \        else if(c == ')')\n        {\n            close_paren_count++;\n    \
    \    }\n        if(open_paren_count == close_paren_count)\n        {\n       \
    \     result ~= paren_string[start_index..end_index];\n            start_index\
    \ = end_index + 1;\n            open_paren_count = 0;\n            close_paren_count\
    \ = 0;\n        }\n        end_index++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmch3vwaw.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpmch3vwaw.__unittest_L40_C1() [0x427d97]

    ??:? void tmpmch3vwaw.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto\
    \ paren_groups = [];\n    auto paren_stack = [];\n    auto cur_paren_group = \"\
    \";\n    foreach(paren; paren_string)\n    {\n        if(paren == '(')\n     \
    \   {\n            paren_stack ~= paren;\n            cur_paren_group ~= paren;\n\
    \        }\n        else if(paren == ')')\n        {\n            if(paren_stack.length\
    \ == 0)\n            {\n                throw new Exception(\"Unbalanced parentheses\"\
    );\n            }\n            else\n            {\n                paren_stack.popBack();\n\
    \                cur_paren_group ~= paren;\n                if(paren_stack.length\
    \ == 0)\n                {\n                    paren_groups ~= cur_paren_group;\n\
    \                    cur_paren_group = \"\";\n                }\n            }\n\
    \        }\n    }\n    if(paren_stack.length != 0)\n    {\n        throw new Exception(\"\
    Unbalanced parentheses\");\n    }\n    return paren_groups;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpye3op2vo.d(21): Error: cannot append type `immutable(char)` to
    type `void[]`

    /tmp/tmpye3op2vo.d(32): Error: no property `popBack` for type `void[]`

    /tmp/tmpye3op2vo.d(36): Error: cannot append type `string` to type `void[]`

    /tmp/tmpye3op2vo.d(46): Error: cannot implicitly convert expression `paren_groups`
    of type `void[]` to `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpye3op2vo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    string current_group;\n    int paren_count = 0;\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            current_group ~= c;\n        }\n        else if(c == ')')\n     \
    \   {\n            paren_count--;\n            current_group ~= c;\n         \
    \   if(paren_count == 0)\n            {\n                paren_groups ~= current_group;\n\
    \                current_group = \"\";\n            }\n        }\n    }\n    return\
    \ paren_groups;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_paren_count++;\n   \
    \         if(open_paren_count == 1)\n            {\n                start_index\
    \ = i;\n            }\n        }\n        else if(c == ')')\n        {\n     \
    \       close_paren_count++;\n            if(close_paren_count == open_paren_count)\n\
    \            {\n                end_index = i;\n                result ~= paren_string[start_index..end_index+1];\n\
    \                open_paren_count = 0;\n                close_paren_count = 0;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps0wyujjb.d(26): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmps0wyujjb.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0wyujjb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            open++;\n        }\n        else if(c == ')')\n        {\n  \
    \          close++;\n        }\n        if(open == close)\n        {\n       \
    \     result ~= paren_string[start..end];\n            start = i + 1;\n      \
    \      open = 0;\n            close = 0;\n        }\n        end++;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp58ju6vs9.d(32): Error: cannot implicitly convert expression `i
    + 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp58ju6vs9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ string current_paren_group = \"\";\n    foreach(char c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open_paren_count++;\n          \
    \  current_paren_group ~= c;\n        }\n        else if(c == ')')\n        {\n\
    \            close_paren_count++;\n            current_paren_group ~= c;\n   \
    \     }\n        if(open_paren_count == close_paren_count && open_paren_count\
    \ != 0)\n        {\n            result ~= current_paren_group;\n            current_paren_group\
    \ = \"\";\n            open_paren_count = 0;\n            close_paren_count =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ else if(c == ' ')\n            continue;\n        else\n            assert(0);\n\
    \        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjl4h4ac_.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f89]

    ??:? void tmpjl4h4ac_.__unittest_L40_C1() [0x427ddf]

    ??:? void tmpjl4h4ac_.__modtest() [0x42813c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2c3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b171]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b200]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b0fd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c05]

    ??:? runModuleUnitTests [0x42e099]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string temp;\n    int open_parens = 0;\n    foreach(char c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_parens++;\n        \
    \    temp ~= c;\n        }\n        else if(c == ')')\n        {\n           \
    \ open_parens--;\n            temp ~= c;\n        }\n        if(open_parens ==\
    \ 0 && temp.length > 0)\n        {\n            result ~= temp;\n            temp\
    \ = \"\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ end = c;\n            result ~= paren_string[start..end];\n            start\
    \ = end + 1;\n            open = 0;\n            close = 0;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpr15ihu18.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f3e]

    ??:? immutable(char)[][] tmpr15ihu18.separate_paren_groups(immutable(char)[])
    [0x427c38]

    ??:? void tmpr15ihu18.__unittest_L40_C1() [0x427cd9]

    ??:? void tmpr15ihu18.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_parens = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(open_parens\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        open_parens++;\n        }\n        else if(c == ')')\n        {\n   \
    \         open_parens--;\n            if(open_parens == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int count = 0;\n    string temp;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            count++;\n            temp\
    \ ~= c;\n        }\n        else if(c == ')')\n        {\n            count--;\n\
    \            temp ~= c;\n        }\n        if(count == 0 && temp != \"\")\n \
    \       {\n            result ~= temp;\n            temp = \"\";\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    while (i < paren_string.length)\n    {\n      \
    \  if (paren_string[i] == '(')\n        {\n            int j = i + 1;\n      \
    \      int count = 1;\n            while (j < paren_string.length)\n         \
    \   {\n                if (paren_string[j] == '(')\n                    count++;\n\
    \                else if (paren_string[j] == ')')\n                    count--;\n\
    \                if (count == 0)\n                    break;\n               \
    \ j++;\n            }\n            result ~= paren_string[i..j];\n           \
    \ i = j + 1;\n        }\n        else\n            i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3wko_oy0.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428edd]

    ??:? void tmp3wko_oy0.__unittest_L40_C1() [0x427deb]

    ??:? void tmp3wko_oy0.__modtest() [0x428148]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e217]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b0c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b154]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b051]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c0d]

    ??:? runModuleUnitTests [0x42dfed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4293a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open++;\n        }\n        else if(c == ')')\n      \
    \  {\n            close++;\n        }\n        if(open == close)\n        {\n\
    \            end = i;\n            result ~= paren_string[start..end];\n     \
    \       start = i + 1;\n            open = 0;\n            close = 0;\n      \
    \  }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf7d6i554.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf7d6i554.__unittest_L42_C1() [0x427d97]

    ??:? void tmpf7d6i554.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_index = 0;\n    int start_index = 0;\n\
    \    int end_index = 0;\n    foreach(i, c; paren_string) \n    {\n        if(c\
    \ == '(') \n        {\n            stack[stack_index] = i;\n            stack_index++;\n\
    \        }\n        else if(c == ')') \n        {\n            if(stack_index\
    \ == 0) \n            {\n                throw new Exception(\"Invalid input\"\
    );\n            }\n            stack_index--;\n            if(stack_index == 0)\
    \ \n            {\n                end_index = i;\n                result ~= paren_string[start_index..end_index];\n\
    \                start_index = end_index + 1;\n            }\n        }\n    }\n\
    \    if(stack_index != 0) \n    {\n        throw new Exception(\"Invalid input\"\
    );\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpilto121f.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpilto121f.d(35): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilto121f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_parens = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(open_parens\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        open_parens++;\n        }\n        else if(c == ')')\n        {\n   \
    \         open_parens--;\n            if(open_parens == 0)\n            {\n  \
    \              result ~= paren_string[start_index..i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ string current_group = \"\";\n    foreach(char c; paren_string)\n    {\n   \
    \     if(c == '(')\n        {\n            open_paren_count++;\n            current_group\
    \ ~= c;\n        }\n        else if(c == ')')\n        {\n            close_paren_count++;\n\
    \            current_group ~= c;\n        }\n        if(open_paren_count == close_paren_count\
    \ && open_paren_count != 0)\n        {\n            result ~= current_group;\n\
    \            current_group = \"\";\n            open_paren_count = 0;\n      \
    \      close_paren_count = 0;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            open++;\n\
    \        }\n        else if(c == ')')\n        {\n            open--;\n      \
    \  }\n        if(open == 0)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n        }\n        end++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsd0pibuk.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e7d]

    ??:? void tmpsd0pibuk.__unittest_L37_C1() [0x427d87]

    ??:? void tmpsd0pibuk.__modtest() [0x4280e4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bd6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b065]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bad]

    ??:? runModuleUnitTests [0x42df8d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429340]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index;\n\
    \    int close_paren_index;\n    int i;\n    int j;\n    int k;\n    int l;\n\
    \    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int\
    \ s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n\
    \    int z;\n    int aa;\n    int bb;\n    int cc;\n    int dd;\n    int ee;\n\
    \    int ff;\n    int gg;\n    int hh;\n    int ii;\n    int jj;\n    int kk;\n\
    \    int ll;\n    int mm;\n    int nn;\n    int oo;\n    int pp;\n    int qq;\n\
    \    int rr;\n    int ss;\n    int tt;\n    int uu;\n    int vv;\n    int ww;\n\
    \    int xx;\n    int yy;\n    int zz;\n    int aaa;\n    int bbb;\n    int ccc;\n\
    \    int ddd;\n    int eee;\n    int fff;\n    int ggg;\n    int hhh;\n    int\
    \ iii;\n    int jjj;\n    int kkk;\n    int lll;\n    int mmm;\n    int nnn;\n\
    \    int ooo;\n    int ppp;\n    int qqq;\n    int rrr;\n    int sss;\n    int\
    \ ttt;\n    int uuu;\n    int vvv;\n    int www;\n    int xxx;\n    int yyy;\n\
    \    int zzz;\n    int aaaa;\n    int bbbb;\n    int cccc;\n    int dddd;\n  \
    \  int eeee;\n    int ffff;\n    int gggg;\n    int h\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwdyum75r.d(99): Error: semicolon expected, not `unittest`

    /tmp/tmpwdyum75r.d(99): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwdyum75r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    int i =\
    \ 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           stack ~= i;\n        }\n        else if(c == ')')\n        {\n   \
    \         if(stack.length == 0)\n            {\n                throw new Exception(\"\
    Unbalanced parentheses\");\n            }\n            else\n            {\n \
    \               stack.popBack();\n                if(stack.length == 0)\n    \
    \            {\n                    end = i;\n                    result ~= paren_string[start..end+1];\n\
    \                    start = end + 1;\n                }\n            }\n    \
    \    }\n        i++;\n    }\n    if(stack.length != 0)\n    {\n        throw new\
    \ Exception(\"Unbalanced parentheses\");\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplazocv41.d(33): Error: no property `popBack` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplazocv41.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n        else if(c == ' ')\n        {\n            if(stack.length\
    \ == 0)\n            {\n                start = end + 1;\n            }\n    \
    \        else if(stack.length == 1)\n            {\n                result ~=\
    \ paren_string[start..end];\n                start = end + 1;\n            }\n\
    \        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4o6vveei.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291dd]

    ??:? void tmp4o6vveei.__unittest_L44_C1() [0x4280e7]

    ??:? void tmp4o6vveei.__modtest() [0x428444]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6fb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b3c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b454]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f0d]

    ??:? runModuleUnitTests [0x42e4d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_index = 0;\n    int start_index = 0;\n\
    \    int end_index = 0;\n    foreach(int i, char c; paren_string)\n    {\n   \
    \     if(c == '(')\n        {\n            stack[stack_index] = i;\n         \
    \   stack_index++;\n        }\n        else if(c == ')')\n        {\n        \
    \    stack_index--;\n            if(stack_index == 0)\n            {\n       \
    \         end_index = i;\n                result ~= paren_string[start_index..end_index];\n\
    \                start_index = end_index + 1;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp_5n8kg2f.d(23): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f76]

    ??:? immutable(char)[][] tmp_5n8kg2f.separate_paren_groups(immutable(char)[])
    [0x427c20]

    ??:? void tmp_5n8kg2f.__unittest_L39_C1() [0x427d15]

    ??:? void tmp_5n8kg2f.__modtest() [0x428130]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b0ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b13c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b039]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bf5]

    ??:? runModuleUnitTests [0x42dfd5]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    foreach(int i, char c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_paren_count++;\n   \
    \         if(open_paren_count == 1)\n            {\n                start_index\
    \ = i;\n            }\n        }\n        else if(c == ')')\n        {\n     \
    \       close_paren_count++;\n            if(close_paren_count == open_paren_count)\n\
    \            {\n                end_index = i;\n                result ~= paren_string[start_index..end_index];\n\
    \                open_paren_count = 0;\n                close_paren_count = 0;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqfrfb4oc.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpqfrfb4oc.__unittest_L43_C1() [0x427d9f]

    ??:? void tmpqfrfb4oc.__modtest() [0x4280fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open++;\n        }\n        else if(c == ')')\n      \
    \  {\n            close++;\n        }\n        if(open == close)\n        {\n\
    \            result ~= paren_string[start..end];\n            start = i+1;\n \
    \           open = 0;\n            close = 0;\n        }\n        end++;\n   \
    \     i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf16u8j2t.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e95]

    ??:? void tmpf16u8j2t.__unittest_L42_C1() [0x427da3]

    ??:? void tmpf16u8j2t.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429358]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    import\
    \ std.algorithm : filter, map;\n    import std.array : array;\n    import std.conv\
    \ : to;\n    import std.range : takeWhile, dropWhile;\n    import std.string :\
    \ strip;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc4c6l71b.d(65): Error: `;` expected

    /tmp/tmpc4c6l71b.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc4c6l71b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            stack\
    \ ~= i;\n        }\n        else if(c == ')')\n        {\n            if(stack.length\
    \ == 0)\n            {\n                throw new Exception(\"Unbalanced parentheses\"\
    );\n            }\n            else\n            {\n                start = stack.pop;\n\
    \                end = i;\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    if(stack.length != 0)\n    {\n        throw\
    \ new Exception(\"Unbalanced parentheses\");\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx4qua7cn.d(22): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpx4qua7cn.d(32): Error: no property `pop` for type `int[]`

    /tmp/tmpx4qua7cn.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx4qua7cn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= i;\n        }\n\
    \        else if(c == ')')\n        {\n            if(stack.length == 0)\n   \
    \         {\n                throw new Exception(\"Unbalanced parentheses\");\n\
    \            }\n            int end = stack.pop;\n            result ~= paren_string[start..end];\n\
    \            start = i + 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy_g534j7.d(21): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpy_g534j7.d(29): Error: no property `pop` for type `int[]`

    /tmp/tmpy_g534j7.d(31): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy_g534j7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    int i =\
    \ 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           stack ~= i;\n        }\n        else if(c == ')')\n        {\n   \
    \         if(stack.length == 0)\n            {\n                throw new Exception(\"\
    Invalid input\");\n            }\n            else\n            {\n          \
    \      stack.length--;\n            }\n        }\n        i++;\n    }\n    if(stack.length\
    \ != 0)\n    {\n        throw new Exception(\"Invalid input\");\n    }\n    i\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            start = i;\n        }\n        else if(c == ')')\n        {\n   \
    \         end = i;\n            result ~= paren_string[start..end+1];\n      \
    \  }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4z2vw6gm.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x429385]

    ??:? void tmp4z2vw6gm.__unittest_L58_C1() [0x4281f7]

    ??:? void tmp4z2vw6gm.__modtest() [0x428554]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42fa6f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x429046]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42c63d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42c6cc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42c5c9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42901d]

    ??:? runModuleUnitTests [0x42f845]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429848]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto\
    \ result = new string[];\n    int start = 0;\n    int end = 0;\n    int open =\
    \ 0;\n    int close = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            open++;\n            if(open == 1)\n       \
    \     {\n                start = i;\n            }\n        }\n        else if(c\
    \ == ')')\n        {\n            close++;\n            if(open == close)\n  \
    \          {\n                end = i;\n                result ~= paren_string[start..end+1];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr5e9josi.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmpr5e9josi.d(26): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpr5e9josi.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr5e9josi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int paren_string_length = paren_string.length;\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab =\
    \ 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n   \
    \ int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak =\
    \ 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n   \
    \ int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at =\
    \ 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n   \
    \ int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc =\
    \ 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n   \
    \ int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl =\
    \ 0;\n    int bm = 0;\n    int bn = 0;\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr24w2sad.d(80): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr24w2sad.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int i;\n    int j;\n    int k;\n    int l;\n\
    \    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int\
    \ s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n\
    \    int z;\n    int aa;\n    int bb;\n    int cc;\n    int dd;\n    int ee;\n\
    \    int ff;\n    int gg;\n    int hh;\n    int ii;\n    int jj;\n    int kk;\n\
    \    int ll;\n    int mm;\n    int nn;\n    int oo;\n    int pp;\n    int qq;\n\
    \    int rr;\n    int ss;\n    int tt;\n    int uu;\n    int vv;\n    int ww;\n\
    \    int xx;\n    int yy;\n    int zz;\n    int aaa;\n    int bbb;\n    int ccc;\n\
    \    int ddd;\n    int eee;\n    int fff;\n    int ggg;\n    int hhh;\n    int\
    \ iii;\n    int jjj;\n    int kkk;\n    int lll;\n    int mmm;\n    int nnn;\n\
    \    int ooo;\n    int ppp;\n    int qqq;\n    int rrr;\n    int sss;\n    int\
    \ ttt;\n    int uuu;\n    int vvv;\n    int www;\n    int xxx;\n    int yyy;\n\
    \    int zzz;\n    int aaaa;\n    int bbbb;\n    int cccc;\n    int dddd;\n  \
    \  int eeee;\n    int ffff;\n    int gggg;\n    int hhhh;\n    int iiii;\n   \
    \ int jjjj;\n    int kkkk;\n    int llll;\n    int mmmm;\n    int nnnn;\n    int\
    \ oooo;\n    int pppp;\n   \nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn40k5o52.d(103): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn40k5o52.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int[] open_paren_counts;\n    int[] close_paren_counts;\n    int open_paren_count;\n\
    \    int close_paren_count;\n    int open_paren_index;\n    int close_paren_index;\n\
    \    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int\
    \ o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n\
    \    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int aa;\n   \
    \ int ab;\n    int ac;\n    int ad;\n    int ae;\n    int af;\n    int ag;\n \
    \   int ah;\n    int ai;\n    int aj;\n    int ak;\n    int al;\n    int am;\n\
    \    int an;\n    int ao;\n    int ap;\n    int aq;\n    int ar;\n    int as;\n\
    \    int at;\n    int au;\n    int av;\n    int aw;\n    int ax;\n    int ay;\n\
    \    int az;\n    int ba;\n    int bb;\n    int bc;\n    int bd;\n    int be;\n\
    \    int bf;\n    int bg;\n    int bh;\n    int bi;\n    int bj;\n    int bk;\n\
    \    int bl;\n    int bm;\n    int bn;\n    int bo;\n    int bp;\n    int bq;\n\
    \    int br;\n    int bs;\n    int bt;\n    int bu;\n    int bv;\n    int bw;\n\
    \    int bx;\n    int by;\n    int bz;\n    int ca;\n    int cb;\n    int cc;\n\
    \    int cd;\n    int ce;\n    int cf;\n    int cg;\n    int ch;\n    int ci;\n\
    \    int\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4544wd0l.d(103): Error: no identifier for declarator `int`

    /tmp/tmp4544wd0l.d(103): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4544wd0l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            count++;\n\
    \        }\n        else if(c == ')')\n        {\n            count--;\n     \
    \   }\n        if(count == 0)\n        {\n            end = paren_string.indexOf(c);\n\
    \            result ~= paren_string[start..end];\n            start = end + 1;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx02q68vr.d(30): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx02q68vr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= i;\n        }\n\
    \        else if(c == ')')\n        {\n            if(stack.length == 0)\n   \
    \         {\n                throw new Exception(\"Unbalanced parentheses\");\n\
    \            }\n            else\n            {\n                int last_open\
    \ = stack[$-1];\n                stack = stack[0..$-1];\n                if(stack.length\
    \ == 0)\n                {\n                    result ~= paren_string[start..i];\n\
    \                    start = i + 1;\n                }\n            }\n      \
    \  }\n    }\n    if(stack.length != 0)\n    {\n        throw new Exception(\"\
    Unbalanced parentheses\");\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpef7y9me5.d(21): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpef7y9me5.d(36): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpef7y9me5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ groups;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    for(int\
    \ i = 0; i < paren_string.length; i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            if(count == 0)\n            {\n                start =\
    \ i;\n            }\n            count++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            count--;\n            if(count == 0)\n     \
    \       {\n                end = i;\n                groups ~= paren_string[start..end];\n\
    \            }\n        }\n    }\n    return groups;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsqe_dgpc.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmpsqe_dgpc.__unittest_L40_C1() [0x427dab]

    ??:? void tmpsqe_dgpc.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    foreach(char c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            open_paren_count++;\n   \
    \     }\n        else if(c == ')')\n        {\n            close_paren_count++;\n\
    \        }\n        if(open_paren_count == close_paren_count)\n        {\n   \
    \         end_index = paren_string.indexOf(c);\n            result ~= paren_string[start_index..end_index];\n\
    \            start_index = end_index + 1;\n            open_paren_count = 0;\n\
    \            close_paren_count = 0;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy2z7z18_.d(31): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy2z7z18_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(c; paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            open_parens++;\n        }\n        else if(c ==\
    \ ')')\n        {\n            close_parens++;\n        }\n        if(open_parens\
    \ == close_parens)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n            open_parens = 0;\n            close_parens\
    \ = 0;\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf_vdp3yy.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf_vdp3yy.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf_vdp3yy.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_top = 0;\n    int start = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(stack_top\
    \ == 0)\n            {\n                start = i;\n            }\n          \
    \  stack[stack_top++] = i;\n        }\n        else if(c == ')')\n        {\n\
    \            if(stack_top == 0)\n            {\n                return result;\n\
    \            }\n            stack_top--;\n            if(stack_top == 0)\n   \
    \         {\n                result ~= paren_string[start..i];\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpswny8omc.d(24): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpswny8omc.d(26): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswny8omc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n        else if(c == ' ')\n        {\n            if(stack.length\
    \ == 0)\n            {\n                start = end + 1;\n            }\n    \
    \        else if(stack.length == 1)\n            {\n                result ~=\
    \ paren_string[start..end];\n                start = end + 1;\n            }\n\
    \        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4o6vveei.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291dd]

    ??:? void tmp4o6vveei.__unittest_L44_C1() [0x4280e7]

    ??:? void tmp4o6vveei.__modtest() [0x428444]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6fb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b3c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b454]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f0d]

    ??:? runModuleUnitTests [0x42e4d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    int[int]\
    \ paren_map;\n    int paren_count = 0;\n    int paren_start = 0;\n    int paren_end\
    \ = 0;\n    string[] paren_groups;\n    foreach(i, c; paren_string)\n    {\n \
    \       if(c == '(')\n        {\n            paren_count++;\n            if(paren_count\
    \ == 1)\n            {\n                paren_start = i;\n            }\n    \
    \    }\n        else if(c == ')')\n        {\n            paren_count--;\n   \
    \         if(paren_count == 0)\n            {\n                paren_end = i;\n\
    \                paren_map[paren_start] = paren_end;\n            }\n        }\n\
    \    }\n    foreach(k, v; paren_map)\n    {\n        paren_groups ~= paren_string[k..v];\n\
    \    }\n    return paren_groups;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp719f9pxt.d(26): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp719f9pxt.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp719f9pxt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto\
    \ paren_groups = new string[];\n    auto paren_stack = new Stack!(char[])();\n\
    \    auto paren_group = new char[];\n    foreach(c; paren_string) \n    {\n  \
    \      if(c == '(') \n        {\n            paren_stack.push(paren_group);\n\
    \            paren_group = new char[];\n        }\n        else if(c == ')') \n\
    \        {\n            paren_group ~= ')';\n            paren_groups ~= paren_group.idup;\n\
    \            paren_group = paren_stack.pop;\n        }\n        else if(c != '\
    \ ') \n        {\n            paren_group ~= c;\n        }\n    }\n    return\
    \ paren_groups;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp62rl0hvr.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `string[]`''s

    /tmp/tmp62rl0hvr.d(15): Error: template instance `Stack!(char[])` template `Stack`
    is not defined

    /tmp/tmp62rl0hvr.d(16): Error: new can only create structs, dynamic arrays or
    class objects, not `char[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp62rl0hvr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_count = 0;\n    int close_count = 0;\n    int start =\
    \ 0;\n    int end = 0;\n    foreach(i, ch; paren_string)\n    {\n        if(ch\
    \ == '(')\n        {\n            if(open_count == 0)\n            {\n       \
    \         start = i;\n            }\n            open_count++;\n        }\n  \
    \      else if(ch == ')')\n        {\n            close_count++;\n           \
    \ if(open_count == close_count)\n            {\n                end = i;\n   \
    \             result ~= paren_string[start..end];\n                open_count\
    \ = 0;\n                close_count = 0;\n            }\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6m8za6og.d(25): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp6m8za6og.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6m8za6og.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_parens = 0;\n    int close_parens = 0;\n    string temp_string;\n\
    \    foreach(char c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           open_parens++;\n            temp_string ~= c;\n        }\n       \
    \ else if(c == ')')\n        {\n            close_parens++;\n            temp_string\
    \ ~= c;\n        }\n        if(open_parens == close_parens)\n        {\n     \
    \       result ~= temp_string;\n            temp_string = \"\";\n            open_parens\
    \ = 0;\n            close_parens = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphki70rjr.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428eb5]

    ??:? void tmphki70rjr.__unittest_L40_C1() [0x427dc3]

    ??:? void tmphki70rjr.__modtest() [0x428120]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e17b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b029]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42afb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428be5]

    ??:? runModuleUnitTests [0x42df51]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429304]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n   \
    \ int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj =\
    \ 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n   \
    \ int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss =\
    \ 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n   \
    \ int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n    int bbb\
    \ = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int fff = 0;\n\
    \    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int\
    \ kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo\
    \ = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int sss = 0;\n\
    \    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4wdc2vkp.d(82): Error: semicolon expected, not `unittest`

    /tmp/tmp4wdc2vkp.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4wdc2vkp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    string[] paren_groups;\n    int[] group_start_index;\n    int[]\
    \ group_end_index;\n    int group_count;\n    int group_start_index_count;\n \
    \   int group_end_index_count;\n    int i;\n    int j;\n    int k;\n    int l;\n\
    \    int m;\n    int n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int\
    \ s;\n    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n\
    \    int z;\n    int aa;\n    int ab;\n    int ac;\n    int ad;\n    int ae;\n\
    \    int af;\n    int ag;\n    int ah;\n    int ai;\n    int aj;\n    int ak;\n\
    \    int al;\n    int am;\n    int an;\n    int ao;\n    int ap;\n    int aq;\n\
    \    int ar;\n    int as;\n    int at;\n    int au;\n    int av;\n    int aw;\n\
    \    int ax;\n    int ay;\n    int az;\n    int ba;\n    int bb;\n    int bc;\n\
    \    int bd;\n    int be;\n    int bf;\n    int bg;\n    int bh;\n    int bi;\n\
    \    int bj;\n    int bk;\n    int bl;\n    int bm;\n    int bn;\n    int bo;\n\
    \    int bp;\n    int bq;\n    int br;\n    int bs;\n    int bt;\n    int bu;\n\
    \    int bv;\n    int bw;\n    int bx;\n    int by;\n    int bz;\n    int ca;\n\
    \    int cb;\n    int cc;\n    int cd;\n    int ce;\n    int cf;\n    int cg;\n\
    \    int ch;\n    int ci;\n    int cj;\n    int ck;\n    int cl;\n    int cm;\n\
    \    int\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqz46p7hi.d(105): Error: no identifier for declarator `int`

    /tmp/tmpqz46p7hi.d(105): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqz46p7hi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int start_index = 0;\n    foreach(i,\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            if(open_paren_count\
    \ == 0)\n            {\n                start_index = i;\n            }\n    \
    \        open_paren_count++;\n        }\n        else if(c == ')')\n        {\n\
    \            open_paren_count--;\n            if(open_paren_count == 0)\n    \
    \        {\n                result ~= paren_string[start_index..i];\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwa8rzexd.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwa8rzexd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ else if(c == ' ')\n            continue;\n        else\n            assert(0);\n\
    \        end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjl4h4ac_.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f89]

    ??:? void tmpjl4h4ac_.__unittest_L40_C1() [0x427ddf]

    ??:? void tmpjl4h4ac_.__modtest() [0x42813c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e2c3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c2e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b171]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b200]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b0fd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c05]

    ??:? runModuleUnitTests [0x42e099]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int start_index = 0;\n    int end_index = 0;\n    int paren_count\
    \ = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n       \
    \ {\n            if(paren_count == 0)\n            {\n                start_index\
    \ = i;\n            }\n            paren_count++;\n        }\n        else if(c\
    \ == ')')\n        {\n            paren_count--;\n            if(paren_count ==\
    \ 0)\n            {\n                end_index = i;\n                paren_groups\
    \ ~= paren_string[start_index..end_index];\n            }\n        }\n    }\n\
    \    return paren_groups;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsgagxbf7.d(24): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpsgagxbf7.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsgagxbf7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    import\
    \ std.algorithm : filter, map;\n    import std.array : array;\n    import std.conv\
    \ : to;\n    import std.range : takeWhile, dropWhile;\n    import std.string :\
    \ strip;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons :\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9o1l_q4p.d(65): Error: identifier expected following `:`

    /tmp/tmp9o1l_q4p.d(65): Error: `;` expected

    /tmp/tmp9o1l_q4p.d(74): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9o1l_q4p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_index = 0;\n    int end_index = 0;\n    int open_paren_count\
    \ = 0;\n    int close_paren_count = 0;\n    foreach(i, c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open_paren_count++;\n        }\n\
    \        else if(c == ')')\n        {\n            close_paren_count++;\n    \
    \    }\n        if(open_paren_count == close_paren_count)\n        {\n       \
    \     result ~= paren_string[start_index..end_index];\n            start_index\
    \ = end_index + 1;\n            open_paren_count = 0;\n            close_paren_count\
    \ = 0;\n        }\n        end_index++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9njms_ig.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmp9njms_ig.__unittest_L40_C1() [0x427d97]

    ??:? void tmp9njms_ig.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n    }\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            stack ~= 1;\n        }\n        else if(c == ')')\n  \
    \      {\n            stack ~= -1;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk892qv3h.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291cd]

    ??:? void tmpk892qv3h.__unittest_L42_C1() [0x4280db]

    ??:? void tmpk892qv3h.__modtest() [0x428438]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e677]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b341]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b3d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b2cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428efd]

    ??:? runModuleUnitTests [0x42e44d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42961c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n    }\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            stack ~= 1;\n        }\n        else if(c == ')')\n  \
    \      {\n            stack ~= -1;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk892qv3h.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291cd]

    ??:? void tmpk892qv3h.__unittest_L42_C1() [0x4280db]

    ??:? void tmpk892qv3h.__modtest() [0x428438]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e677]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b341]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b3d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b2cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428efd]

    ??:? runModuleUnitTests [0x42e44d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42961c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int i;\n    int j;\n    int k;\n    int open_paren_count;\n\
    \    int close_paren_count;\n    int open_paren_index;\n    int close_paren_index;\n\
    \    int stack_top;\n    int stack_bottom;\n    int paren_string_length;\n   \
    \ int paren_string_length_minus_one;\n    int paren_string_length_minus_two;\n\
    \    int paren_string_length_minus_three;\n    int paren_string_length_minus_four;\n\
    \    int paren_string_length_minus_five;\n    int paren_string_length_minus_six;\n\
    \    int paren_string_length_minus_seven;\n    int paren_string_length_minus_eight;\n\
    \    int paren_string_length_minus_nine;\n    int paren_string_length_minus_ten;\n\
    \    int paren_string_length_minus_eleven;\n    int paren_string_length_minus_twelve;\n\
    \    int paren_string_length_minus_thirteen;\n    int paren_string_length_minus_fourteen;\n\
    \    int paren_string_length_minus_fifteen;\n    int paren_string_length_minus_sixteen;\n\
    \    int paren_string_length_minus_seventeen;\n    int paren_string_length_minus_eighteen;\n\
    \    int paren_string_length_minus_nineteen;\n    int paren_string_length_minus_twenty;\n\
    \    int paren_string_length_minus_twenty_one;\n    int paren_string_length_minus_twenty_two;\n\
    \    int paren_string_length_minus_twenty_three;\n    int paren_string_length_minus_twenty_four;\n\
    \    int paren_string_length_minus_twenty_five;\n    int paren_string_length_minus_twenty_six;\n\
    \    int paren_string_length_minus_twenty_seven;\n    int paren_string_length_minus_tw\n\
    unittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptjplu33h.d(54): Error: semicolon expected, not `unittest`

    /tmp/tmptjplu33h.d(54): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptjplu33h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ end = c;\n            result ~= paren_string[start..end];\n            start\
    \ = end + 1;\n            open = 0;\n            close = 0;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpr15ihu18.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f3e]

    ??:? immutable(char)[][] tmpr15ihu18.separate_paren_groups(immutable(char)[])
    [0x427c38]

    ??:? void tmpr15ihu18.__unittest_L40_C1() [0x427cd9]

    ??:? void tmpr15ihu18.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            open_parens++;\n        }\n        else if(c\
    \ == ')')\n        {\n            close_parens++;\n        }\n        if(open_parens\
    \ == close_parens)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = i + 1;\n            end = i + 1;\n            open_parens\
    \ = 0;\n            close_parens = 0;\n        }\n        else\n        {\n  \
    \          end++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nt599br.d(32): Error: cannot implicitly convert expression `i
    + 1LU` of type `ulong` to `int`

    /tmp/tmp3nt599br.d(33): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nt599br.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            count++;\n\
    \        }\n        else if(c == ')')\n        {\n            count--;\n     \
    \   }\n        if(count == 0)\n        {\n            end = paren_string.indexOf(c);\n\
    \            result ~= paren_string[start..end+1];\n            start = end +\
    \ 2;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq_2tacyp.d(30): Error: no property `indexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_2tacyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] paren_stack;\n    int paren_stack_top = 0;\n    int start_index\
    \ = 0;\n    int end_index = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    int l = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n \
    \       {\n            paren_stack[paren_stack_top] = i;\n            paren_stack_top++;\n\
    \        }\n        else if(c == ')')\n        {\n            if(paren_stack_top\
    \ == 0)\n            {\n                return null;\n            }\n        \
    \    else\n            {\n                paren_stack_top--;\n               \
    \ start_index = paren_stack[paren_stack_top];\n                end_index = i;\n\
    \                if(paren_stack_top == 0)\n                {\n               \
    \     result[j] = paren_string[start_index..end_index+1];\n                  \
    \  j++;\n                }\n            }\n        }\n        i++;\n    }\n  \
    \  if(paren_stack_top != 0)\n    {\n        return null;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpj0tz01ab.d(27): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428fae]

    ??:? immutable(char)[][] tmpj0tz01ab.separate_paren_groups(immutable(char)[])
    [0x427c22]

    ??:? void tmpj0tz01ab.__unittest_L56_C1() [0x427d4d]

    ??:? void tmpj0tz01ab.__modtest() [0x428168]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d84b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6f9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a788]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a685]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c2d]

    ??:? runModuleUnitTests [0x42d621]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ paren_groups;\n    int start_index = 0;\n    int end_index = 0;\n    int paren_count\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(paren_count == 0)\n            {\n                start_index\
    \ = end_index;\n            }\n            paren_count++;\n        }\n       \
    \ else if(c == ')')\n        {\n            paren_count--;\n            if(paren_count\
    \ == 0)\n            {\n                paren_groups ~= paren_string[start_index..end_index];\n\
    \            }\n        }\n        end_index++;\n    }\n    return paren_groups;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwqfdzjt_.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpwqfdzjt_.__unittest_L40_C1() [0x427d93]

    ??:? void tmpwqfdzjt_.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    foreach(i, c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= i;\n        }\n\
    \        else if(c == ')')\n        {\n            if(stack.length == 0)\n   \
    \         {\n                throw new Exception(\"Unbalanced parentheses\");\n\
    \            }\n            else\n            {\n                int j = stack.pop;\n\
    \                if(i - j == 1)\n                {\n                    result\
    \ ~= \"()\";\n                }\n                else\n                {\n   \
    \                 result ~= paren_string[j..i];\n                }\n         \
    \   }\n        }\n    }\n    if(stack.length != 0)\n    {\n        throw new Exception(\"\
    Unbalanced parentheses\");\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgtotyawl.d(21): Error: cannot append type `ulong` to type `int[]`

    /tmp/tmpgtotyawl.d(31): Error: no property `pop` for type `int[]`

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    int i =\
    \ 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= 1;\n        }\n\
    \        else if(c == ')')\n        {\n            stack ~= -1;\n        }\n \
    \   }\n    foreach(c; stack)\n    {\n        if(c == 1)\n        {\n         \
    \   start = i;\n        }\n        else if(c == -1)\n        {\n            end\
    \ = i;\n            result ~= paren_string[start..end];\n        }\n        i++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_iru62lr.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x429225]

    ??:? void tmp_iru62lr.__unittest_L48_C1() [0x42812f]

    ??:? void tmp_iru62lr.__modtest() [0x42848c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e743]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b40d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b49c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b399]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f55]

    ??:? runModuleUnitTests [0x42e519]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n   \
    \ int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad\
    \ = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n \
    \   int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am\
    \ = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n \
    \   int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av\
    \ = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n \
    \   int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be\
    \ = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n \
    \   int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn\
    \ = 0;\n    int bo = 0;\n    int bp = 0;\n   \nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp14z5i2u_.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp14z5i2u_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ groups;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int close_parens = 0;\n    for(int i = 0; i < paren_string.length; i++)\n \
    \   {\n        if(paren_string[i] == '(')\n        {\n            open_parens++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            close_parens++;\n\
    \        }\n        if(open_parens == close_parens)\n        {\n            end\
    \ = i;\n            groups ~= paren_string[start..end];\n            start = i\
    \ + 1;\n            open_parens = 0;\n            close_parens = 0;\n        }\n\
    \    }\n    return groups;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqs52m8rh.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ea5]

    ??:? void tmpqs52m8rh.__unittest_L40_C1() [0x427daf]

    ??:? void tmpqs52m8rh.__modtest() [0x42810c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bfe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b08d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b11c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b019]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bd5]

    ??:? runModuleUnitTests [0x42dfb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429368]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int i, j;\n    foreach(c; paren_string)\n   \
    \ {\n        if(c == '(')\n        {\n            stack ~= 1;\n        }\n   \
    \     else if(c == ')')\n        {\n            stack ~= -1;\n        }\n    }\n\
    \    foreach(c; stack)\n    {\n        if(c == 1)\n        {\n            i =\
    \ stack.indexOf(c);\n            j = stack.indexOf(-1, i);\n            result\
    \ ~= paren_string[i..j];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9rh5xdhp.d(32): Error: no property `indexOf` for type `int[]`

    /tmp/tmp9rh5xdhp.d(33): Error: no property `indexOf` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9rh5xdhp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    int i =\
    \ 0;\n    int j = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            stack ~= 1;\n            if(stack.length == 1)\n     \
    \       {\n                start = i;\n            }\n        }\n        else\
    \ if(c == ')')\n        {\n            stack ~= -1;\n            if(stack.length\
    \ == 0)\n            {\n                end = i;\n                result ~= paren_string[start..end+1];\n\
    \            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptzs4qanj.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291c5]

    ??:? void tmptzs4qanj.__unittest_L43_C1() [0x4280cf]

    ??:? void tmptzs4qanj.__modtest() [0x42842c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b3ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b43c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b339]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ef5]

    ??:? runModuleUnitTests [0x42e4b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429688]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ end = c;\n            result ~= paren_string[start..end];\n            start\
    \ = end + 1;\n            open = 0;\n            close = 0;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpr15ihu18.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f3e]

    ??:? immutable(char)[][] tmpr15ihu18.separate_paren_groups(immutable(char)[])
    [0x427c38]

    ??:? void tmpr15ihu18.__unittest_L40_C1() [0x427cd9]

    ??:? void tmpr15ihu18.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ string current_group;\n    foreach(char c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            open_paren_count++;\n            current_group\
    \ ~= c;\n        }\n        else if(c == ')')\n        {\n            close_paren_count++;\n\
    \            current_group ~= c;\n        }\n        if(open_paren_count == close_paren_count\
    \ && open_paren_count != 0)\n        {\n            result ~= current_group;\n\
    \            current_group = \"\";\n            open_paren_count = 0;\n      \
    \      close_paren_count = 0;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int stack_top = 0;\n    int start = 0;\n    int\
    \ end = 0;\n    foreach(i, c; paren_string)\n    {\n        if(c == '(')\n   \
    \     {\n            stack[stack_top++] = i;\n        }\n        else if(c ==\
    \ ')')\n        {\n            if(stack_top == 0)\n            {\n           \
    \     throw new Exception(\"Unbalanced parentheses\");\n            }\n      \
    \      else\n            {\n                start = stack[--stack_top];\n    \
    \            end = i;\n                result ~= paren_string[start..end];\n \
    \           }\n        }\n    }\n    if(stack_top != 0)\n    {\n        throw\
    \ new Exception(\"Unbalanced parentheses\");\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfdj6z_cr.d(23): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpfdj6z_cr.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfdj6z_cr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ int start_index = 0;\n    int end_index = 0;\n    int i = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            open_paren_count++;\n\
    \            if(open_paren_count == 1)\n            {\n                start_index\
    \ = i;\n            }\n        }\n        else if(c == ')')\n        {\n     \
    \       close_paren_count++;\n            if(close_paren_count == open_paren_count)\n\
    \            {\n                end_index = i;\n                result ~= paren_string[start_index..end_index];\n\
    \                open_paren_count = 0;\n                close_paren_count = 0;\n\
    \            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7adwxv0o.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmp7adwxv0o.__unittest_L45_C1() [0x427da7]

    ??:? void tmp7adwxv0o.__modtest() [0x428104]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n   \
    \ int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int ii = 0;\n    int jj =\
    \ 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n   \
    \ int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss =\
    \ 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n   \
    \ int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aaa = 0;\n    int bbb\
    \ = 0;\n    int ccc = 0;\n    int ddd = 0;\n    int eee = 0;\n    int fff = 0;\n\
    \    int ggg = 0;\n    int hhh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int\
    \ kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo\
    \ = 0;\n    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\n    int sss = 0;\n\
    \    int ttt = 0;\n    int uuu = 0;\n    int vvv = 0;\n    int www\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4wdc2vkp.d(82): Error: semicolon expected, not `unittest`

    /tmp/tmp4wdc2vkp.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4wdc2vkp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_indexes;\n    int[] close_paren_indexes;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int paren_string_length = paren_string.length;\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab =\
    \ 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n   \
    \ int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak =\
    \ 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n   \
    \ int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at =\
    \ 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n   \
    \ int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc =\
    \ 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n   \
    \ int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl =\
    \ 0;\n    int bm = 0;\n    int bn = 0;\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr24w2sad.d(80): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr24w2sad.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n    }\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            stack ~= 1;\n        }\n        else if(c == ')')\n  \
    \      {\n            stack ~= -1;\n        }\n        if(stack.empty)\n     \
    \   {\n            result ~= paren_string[start..end];\n            start = end\
    \ + 1;\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc2colagr.d(39): Error: no property `empty` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc2colagr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open_parens = 0;\n  \
    \  int closed_parens = 0;\n    foreach(char c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            open_parens++;\n        }\n        else if(c\
    \ == ')')\n        {\n            closed_parens++;\n        }\n        if(open_parens\
    \ == closed_parens)\n        {\n            result ~= paren_string[start..end];\n\
    \            start = end + 1;\n            open_parens = 0;\n            closed_parens\
    \ = 0;\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxq_ki1wm.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpxq_ki1wm.__unittest_L40_C1() [0x427d97]

    ??:? void tmpxq_ki1wm.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    int i = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open++;\n        }\n        else if(c == ')')\n      \
    \  {\n            close++;\n        }\n        if(open == close)\n        {\n\
    \            end = i;\n            result ~= paren_string[start..end];\n     \
    \       start = i+1;\n            open = 0;\n            close = 0;\n        }\n\
    \        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpe5ovxu2z.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpe5ovxu2z.__unittest_L42_C1() [0x427d97]

    ??:? void tmpe5ovxu2z.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto\
    \ paren_groups = [];\n    auto paren_stack = [];\n    auto current_group = \"\"\
    ;\n    foreach(char c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            paren_stack ~= c;\n            current_group ~= c;\n        }\n \
    \       else if(c == ')')\n        {\n            if(paren_stack.length == 0)\n\
    \            {\n                throw new Exception(\"Unbalanced parens\");\n\
    \            }\n            paren_stack.popBack();\n            current_group\
    \ ~= c;\n            if(paren_stack.length == 0)\n            {\n            \
    \    paren_groups ~= current_group;\n                current_group = \"\";\n \
    \           }\n        }\n    }\n    if(paren_stack.length != 0)\n    {\n    \
    \    throw new Exception(\"Unbalanced parens\");\n    }\n    return paren_groups;\n\
    }\nunittest\n{\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]);\n    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp61rwelvw.d(21): Error: cannot append type `char` to type `void[]`

    /tmp/tmp61rwelvw.d(30): Error: no property `popBack` for type `void[]`

    /tmp/tmp61rwelvw.d(34): Error: cannot append type `string` to type `void[]`

    /tmp/tmp61rwelvw.d(43): Error: cannot implicitly convert expression `paren_groups`
    of type `void[]` to `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61rwelvw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n        else if(c == ' ')\n        {\n            if(stack.length\
    \ == 0)\n            {\n                start = end + 1;\n            }\n    \
    \        else if(stack.sum == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \                start = end + 1;\n            }\n        }\n        end++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_p3zzzw.d(34): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_p3zzzw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] stack;\n    int start = 0;\n    int end = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n\
    \        }\n        else if(c == ' ')\n        {\n            if(stack.length\
    \ == 0)\n            {\n                start = end + 1;\n            }\n    \
    \        else if(stack.sum == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \                start = end + 1;\n            }\n        }\n        end++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_p3zzzw.d(34): Error: no property `sum` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_p3zzzw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ groups;\n    int[] open_paren_indices;\n    int[] close_paren_indices;\n   \
    \ int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n   \
    \ int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad\
    \ = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n \
    \   int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am\
    \ = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n \
    \   int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au = 0;\n    int av\
    \ = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n \
    \   int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be\
    \ = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n \
    \   int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn\
    \ = 0;\n    int bo = 0;\n    int bp = 0;\n   \nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm664lm__.d(82): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm664lm__.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(depth\
    \ == 0)\n            {\n                start = end;\n            }\n        \
    \    depth++;\n        }\n        else if(c == ')')\n        {\n            depth--;\n\
    \            if(depth == 0)\n            {\n                result ~= paren_string[start..end];\n\
    \            }\n        }\n        else if(c != ' ')\n        {\n            throw\
    \ new Exception(\"Invalid character\");\n        }\n        end++;\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp423ie4tz.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f85]

    ??:? void tmp423ie4tz.__unittest_L44_C1() [0x427df7]

    ??:? void tmp423ie4tz.__modtest() [0x428154]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b16d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b1fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b0f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c1d]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429448]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int i = 0;\n    int start = 0;\n    int end = 0;\n    while(i <\
    \ paren_string.length)\n    {\n        if(paren_string[i] == '(')\n        {\n\
    \            start = i;\n            end = i;\n            while(paren_string[end]\
    \ != ')')\n            {\n                end++;\n            }\n            result\
    \ ~= paren_string[start..end+1];\n            i = end+1;\n        }\n        else\n\
    \        {\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgyj25yv8.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e9d]

    ??:? void tmpgyj25yv8.__unittest_L38_C1() [0x427dab]

    ??:? void tmpgyj25yv8.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bf6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b085]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b114]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b011]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bcd]

    ??:? runModuleUnitTests [0x42dfad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429360]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163092
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    int\
    \ open_parens = 0;\n    int close_parens = 0;\n    int start_index = 0;\n    int\
    \ end_index = 0;\n    string[] result;\n    foreach(i, c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            if(open_parens == 0)\n         \
    \   {\n                start_index = i;\n            }\n            open_parens++;\n\
    \        }\n        else if(c == ')')\n        {\n            close_parens++;\n\
    \            if(open_parens == close_parens)\n            {\n                end_index\
    \ = i;\n                result ~= paren_string[start_index..end_index+1];\n  \
    \              open_parens = 0;\n                close_parens = 0;\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9avqo2t9.d(25): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmp9avqo2t9.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9avqo2t9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start_index = 0;\n    int end_index = 0;\n    int open_paren_count\
    \ = 0;\n    int close_paren_count = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            open_paren_count++;\n        }\n\
    \        else if(c == ')')\n        {\n            close_paren_count++;\n    \
    \    }\n        if(open_paren_count == close_paren_count)\n        {\n       \
    \     end_index = start_index + open_paren_count + close_paren_count;\n      \
    \      result ~= paren_string[start_index..end_index];\n            start_index\
    \ = end_index + 1;\n            open_paren_count = 0;\n            close_paren_count\
    \ = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpmrbwoprr.d(32): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428f46]

    ??:? immutable(char)[][] tmpmrbwoprr.separate_paren_groups(immutable(char)[])
    [0x427c3f]

    ??:? void tmpmrbwoprr.__unittest_L40_C1() [0x427ce1]

    ??:? void tmpmrbwoprr.__modtest() [0x4280fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b07d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b10c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b009]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bc5]

    ??:? runModuleUnitTests [0x42dfa5]

    ??:? void rt.dmain2._d_run_main(int'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\n/*\n    Given a string of parentheses,\
    \ return true if it is balanced, false otherwise.\n    >>> is_balanced(\"(()()()())\"\
    )\n    true\n    >>> is_balanced(\"(((())))\")\n    true\n    >>> is_balanced(\"\
    ((((((())\")\n    false\n    >>> is_balanced(\"()))\")\n    false\n    >>> is_balanced(\"\
    (()()))(\")\n    false\n*/\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7rynn47.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpt7rynn47.__unittest_L49_C1() [0x427d93]

    ??:? void tmpt7rynn47.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    auto\
    \ result = [];\n    auto start = 0;\n    auto end = 0;\n    auto count = 0;\n\
    \    for(int i = 0; i < paren_string.length; i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            count++;\n            if(count == 1)\n     \
    \       {\n                start = i;\n            }\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            count--;\n            if(count\
    \ == 0)\n            {\n                end = i;\n                result ~= paren_string[start..end+1];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n\
    \    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"]);\n    assert(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9078wu_5.d(34): Error: cannot append type `string` to type `void[]`

    /tmp/tmp9078wu_5.d(38): Error: cannot implicitly convert expression `result` of
    type `void[]` to `string[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9078wu_5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int open_paren_count = 0;\n    int close_paren_count = 0;\n   \
    \ string temp_string;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            open_paren_count++;\n            temp_string ~= c;\n \
    \       }\n        else if(c == ')')\n        {\n            close_paren_count++;\n\
    \            temp_string ~= c;\n        }\n        if(open_paren_count == close_paren_count)\n\
    \        {\n            result ~= temp_string;\n            temp_string = \"\"\
    ;\n            open_paren_count = 0;\n            close_paren_count = 0;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphxzealck.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428eb5]

    ??:? void tmphxzealck.__unittest_L40_C1() [0x427dc3]

    ??:? void tmphxzealck.__modtest() [0x428120]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e17b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c0e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b029]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42afb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428be5]

    ??:? runModuleUnitTests [0x42df51]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429304]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163092
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            if(count\
    \ == 0)\n                start = end;\n            count++;\n        }\n     \
    \   else if(c == ')')\n        {\n            count--;\n            if(count ==\
    \ 0)\n                result ~= paren_string[start..end];\n        }\n       \
    \ end++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6zi5cexv.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmp6zi5cexv.__unittest_L36_C1() [0x427d93]

    ??:? void tmp6zi5cexv.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            open++;\n        }\n        else if(c == ')')\n        {\n      \
    \      close++;\n        }\n        if(open == close)\n        {\n           \
    \ result ~= paren_string[start..end];\n            start = end + 1;\n        \
    \    open = 0;\n            close = 0;\n        }\n        end++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf2i5qemx.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e8d]

    ??:? void tmpf2i5qemx.__unittest_L40_C1() [0x427d97]

    ??:? void tmpf2i5qemx.__modtest() [0x4280f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428be6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b075]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b104]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b001]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bbd]

    ??:? runModuleUnitTests [0x42df9d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429350]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int[] open_paren_positions;\n    int[] close_paren_positions;\n\
    \    int open_paren_count = 0;\n    int close_paren_count = 0;\n    int open_paren_index\
    \ = 0;\n    int close_paren_index = 0;\n    int paren_string_length = paren_string.length;\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab =\
    \ 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n   \
    \ int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak =\
    \ 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n   \
    \ int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at =\
    \ 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n   \
    \ int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc =\
    \ 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n   \
    \ int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl =\
    \ 0;\n    int bm = 0;\n    int bn = 0;\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzhzet_h2.d(80): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzhzet_h2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163091
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int open = 0;\n    int close\
    \ = 0;\n    for(int i = 0; i < paren_string.length; i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            open++;\n            if(open == 1)\n       \
    \     {\n                start = i;\n            }\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            close++;\n            if(open == close)\n  \
    \          {\n                end = i;\n                result ~= paren_string[start..end];\n\
    \                open = 0;\n                close = 0;\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = separate_paren_groups;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_3byml2j.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ead]

    ??:? void tmp_3byml2j.__unittest_L43_C1() [0x427dbb]

    ??:? void tmp_3byml2j.__modtest() [0x428118]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b095]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b124]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b021]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bdd]

    ??:? runModuleUnitTests [0x42dfbd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429370]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163092
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string containing multiple groups of nested parentheses. Your goal is to\n\
    \    separate those group into separate strings and return the list of those.\n\
    \    Separate groups are balanced (each open brace is properly closed) and not\
    \ nested within each other\n    Ignore any spaces in the input string.\n    >>>\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"\
    ]\n    \n*/\nstring[] separate_paren_groups(string paren_string) \n{\n    string[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int paren_count = 0;\n  \
    \  foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n        \
    \    if(paren_count == 0)\n            {\n                start = end;\n     \
    \       }\n            paren_count++;\n        }\n        else if(c == ')')\n\
    \        {\n            paren_count--;\n            if(paren_count == 0)\n   \
    \         {\n                result ~= paren_string[start..end];\n           \
    \ }\n        }\n        end++;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = separate_paren_groups;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n   \
    \ assert(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]);\n    assert(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ]);\n    assert(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzq7imnq4.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428e85]

    ??:? void tmpzq7imnq4.__unittest_L40_C1() [0x427d93]

    ??:? void tmpzq7imnq4.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e1bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428bde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b06d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b0fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42aff9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428bb5]

    ??:? runModuleUnitTests [0x42df95]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429348]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163090
