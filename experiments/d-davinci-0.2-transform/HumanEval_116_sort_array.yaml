name: HumanEval_116_sort_array
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
  \ to sort an array of non-negative integers according to\n    number of ones in\
  \ their binary representation in ascending order.\n    For similar number of ones,\
  \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
  \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
  \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L, 0L,\
  \ 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[] arr)\
  \ \n"
tests: "unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
  \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
  \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L,\
  \ 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
  \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
  \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
  \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
  \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
  \ 16L, 32L]);\n}\nvoid main(){}"
completions: ["{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}", "{\n    long[] result = new long[arr.length];\n\
    \    int[] ones = new int[arr.length];\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        ones[i] = countOnes(arr[i]);\n    }\n    sort(ones, arr);\n  \
    \  return arr;\n}", "{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n\
    \    arr_tuple.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n\
    \    return arr_tuple.map!(a => a[0]).array;\n}", "{\n    auto arr2 = arr.dup;\n\
    \    arr2.sort!((a, b) =>\n    {\n        auto a1 = a.to!string;\n        auto\
    \ b1 = b.to!string;\n        auto a2 = a1.count(\"1\");\n        auto b2 = b1.count(\"\
    1\");\n        if (a2 == b2)\n            return a < b;\n        return a2 < b2;\n\
    \    });\n    return arr2;\n}", "{\n    auto arr2 = arr.dup;\n    arr2.sort!((a,\
    \ b) => \n    {\n        auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n\
    \        return a1 == b1 ? a.compare(b) : a1.compare(b1);\n    });\n    return\
    \ arr2;\n}", "{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes(), a.countOnes()\
    \ == 0 ? a : a.countOnes()));\n    arr_tuple.sort!((a, b) => a[1] < b[1] || (a[1]\
    \ == b[1] && a[2] < b[2]));\n    return arr_tuple.map!(a => a[0]).array;\n}",
  "{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes > b.countOnes)\
    \ ? 1 : (a.countOnes < b.countOnes) ? -1 : (a > b) ? 1 : -1);\n    return arr2;\n\
    }", "{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n        auto\
    \ aa = a.to!string(2);\n        auto bb = b.to!string(2);\n        if (aa.count('1')\
    \ == bb.count('1'))\n            return a < b;\n        return aa.count('1') <\
    \ bb.count('1');\n    });\n    return arr2;\n}", "{\n    // sort by number of\
    \ ones in binary representation\n    arr.sort!((a, b) => countOnes(a) < countOnes(b));\n\
    \    // sort by decimal value\n    arr.sort!((a, b) => a < b);\n    return arr;\n\
    }", "{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n    \
    \    int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n        if\
    \ (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return sorted;\n}", "{\n    auto arr2 = arr.dup;\n    arr2.sort!((a,\
    \ b) => a.countOnes.cmp(b.countOnes) || a.cmp(b));\n    return arr2;\n}", "{\n\
    \    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n        int\
    \ a_ones = countOnes(a);\n        int b_ones = countOnes(b);\n        if (a_ones\
    \ == b_ones)\n            return a < b ? -1 : 1;\n        return a_ones < b_ones\
    \ ? -1 : 1;\n    });\n    return sorted;\n}", "{\n    long[] result = arr.dup;\n\
    \    result.sort!((a, b) {\n        int a_ones = a.countOnes;\n        int b_ones\
    \ = b.countOnes;\n        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n\
    \    });\n    return result;\n}", "{\n    return arr.sort!((a, b) => \n    {\n\
    \        int aOnes = a.countOnes();\n        int bOnes = b.countOnes();\n    \
    \    return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n}", "{\n    auto\
    \ arr_map = arr.map!(a => tuple(a, a.countOnes)).sort!((a, b) => a[1] < b[1] ||\
    \ (a[1] == b[1] && a[0] < b[0]));\n    return arr_map.map!(a => a[0]).array;\n\
    }", "{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n        auto\
    \ a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"1\");\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}", "{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a,\
    \ b) {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}", "{\n    auto arr_sorted = arr.dup;\n\
    \    arr_sorted.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        if (a_ones == b_ones)\n         \
    \   return a < b;\n        return a_ones < b_ones;\n    });\n    return arr_sorted;\n\
    }", "{\n    auto list = arr.map!(a => tuple(a, a.countOnes)).array;\n    list.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return list.map!(a\
    \ => a[0]).array;\n}", "{\n    auto a = arr.dup;\n    a.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return a;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
