language: d
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2\
    \ != 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"\
    No\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\";\n    if(c1 > 0 && c2 >\
    \ 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n    {\n        if(abs(c1)\
    \ == abs(c2))\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    if(c1 < 0 && c2 > 0)\n    {\n        if(abs(c1) == abs(c2))\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1zkv7dtt.d(80): unittest failure\n----------------\n??:?
    _d_unittestp [0x4291ed]\n??:? void tmp1zkv7dtt.__unittest_L67_C1() [0x428286]\n??:?
    void tmp1zkv7dtt.__modtest() [0x428454]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa78]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a975]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428f1d]\n??:? runModuleUnitTests [0x42d911]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296b0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x429637]\n??:? _d_run_main [0x4295a2]\n??:? main [0x428467]\n??:?
    __libc_start_main [0x511db554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n\
    \    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n           \
    \ open++;\n        else\n            close++;\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpwu5dljo6.d(56): unittest failure\n----------------\n??:?
    _d_unittestp [0x42904d]\n??:? void tmpwu5dljo6.__unittest_L43_C1() [0x4280fa]\n??:?
    void tmpwu5dljo6.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x429497]\n??:? _d_run_main [0x429402]\n??:? main [0x4282c7]\n??:?
    __libc_start_main [0xe94d1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    return count1 == count2 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpwd22oyxv.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x42904d]\n??:? void tmpwd22oyxv.__unittest_L43_C1() [0x427c8c]\n??:?
    void tmpwd22oyxv.__modtest() [0x4282b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x429497]\n??:? _d_run_main [0x429402]\n??:? main [0x4282cb]\n??:?
    __libc_start_main [0xa2d21554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcblvh4we.d(50): unittest failure\n----------------\n??:?
    _d_unittestp [0x429055]\n??:? void tmpcblvh4we.__unittest_L46_C1() [0x427c94]\n??:?
    void tmpcblvh4we.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42949f]\n??:? _d_run_main [0x42940a]\n??:? main [0x4282d3]\n??:?
    __libc_start_main [0x73607554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpq0fs3jwt.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x429025]\n??:? void tmpq0fs3jwt.__unittest_L36_C1() [0x427dee]\n??:?
    void tmpq0fs3jwt.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42946f]\n??:? _d_run_main [0x4293da]\n??:? main [0x4282a3]\n??:?
    __libc_start_main [0x1c39e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmphn_es_fm.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x42902d]\n??:? void tmphn_es_fm.__unittest_L36_C1() [0x427df6]\n??:?
    void tmphn_es_fm.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x429477]\n??:? _d_run_main [0x4293e2]\n??:? main [0x4282ab]\n??:?
    __libc_start_main [0xa3f63554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjj3obxs0.d(45): unittest failure\n----------------\n??:?
    _d_unittestp [0x429045]\n??:? void tmpjj3obxs0.__unittest_L38_C1() [0x427e0a]\n??:?
    void tmpjj3obxs0.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42941b]\n??:? _d_run_main [0x429386]\n??:? main [0x4282bf]\n??:?
    __libc_start_main [0x55cb1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(e; s)\n    {\n        if(e == '(')\n            count++;\n\
    \        else if(e == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpowszunp7.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x429045]\n??:? void tmpowszunp7.__unittest_L40_C1() [0x427e0e]\n??:?
    void tmpowszunp7.__modtest() [0x4282b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42941b]\n??:? _d_run_main [0x429386]\n??:? main [0x4282c3]\n??:?
    __libc_start_main [0xbf607554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n\
    \    return s.balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp93bghc8z.d(26): Error: no property `balance` for type `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp93bghc8z.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n        if(count1\
    \ < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            count2++;\n        else\n            count2--;\n \
    \       if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmdw9vmtj.d(53): unittest failure\n----------------\n??:?
    _d_unittestp [0x429085]\n??:? void tmpmdw9vmtj.__unittest_L49_C1() [0x427cc0]\n??:?
    void tmpmdw9vmtj.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4294cf]\n??:? _d_run_main [0x42943a]\n??:? main [0x4282ff]\n??:?
    __libc_start_main [0xb1440554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnp9n7mfj.d(50): unittest failure\n----------------\n??:?
    _d_unittestp [0x429055]\n??:? void tmpnp9n7mfj.__unittest_L46_C1() [0x427c94]\n??:?
    void tmpnp9n7mfj.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42949f]\n??:? _d_run_main [0x42940a]\n??:? main [0x4282d3]\n??:?
    __libc_start_main [0xe8ec6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == count2 && count1 >= 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpzbcics2l.d(50): unittest failure\n----------------\n??:?
    _d_unittestp [0x429055]\n??:? void tmpzbcics2l.__unittest_L46_C1() [0x427c94]\n??:?
    void tmpzbcics2l.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42949f]\n??:? _d_run_main [0x42940a]\n??:? main [0x4282d3]\n??:?
    __libc_start_main [0x8984c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnp9n7mfj.d(50): unittest failure\n----------------\n??:?
    _d_unittestp [0x429055]\n??:? void tmpnp9n7mfj.__unittest_L46_C1() [0x427c94]\n??:?
    void tmpnp9n7mfj.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42949f]\n??:? _d_run_main [0x42940a]\n??:? main [0x4282d3]\n??:?
    __libc_start_main [0xe8ec6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n\
    \    int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    for\
    \ (int i = 0; i < len1; i++)\n    {\n        if (s1[i] == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    for (int i = 0; i < len2; i++)\n\
    \    {\n        if (s2[i] == '(')\n            count2++;\n        else\n     \
    \       count2--;\n    }\n    if (count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp06ybvnul.d(25): Error: cannot implicitly convert expression
    `s1.length` of type `ulong` to `int`\n/tmp/tmp06ybvnul.d(26): Error: cannot implicitly
    convert expression `s2.length` of type `ulong` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp06ybvnul.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpi12qrwep.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x42902d]\n??:? void tmpi12qrwep.__unittest_L36_C1() [0x427df6]\n??:?
    void tmpi12qrwep.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x429477]\n??:? _d_run_main [0x4293e2]\n??:? main [0x4282ab]\n??:?
    __libc_start_main [0x62f0e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(el; lst)\n        s ~= el;\n   \
    \ int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n           \
    \ count++;\n        else if(c == ')')\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7iqwjtbr.d(45): unittest failure\n----------------\n??:?
    _d_unittestp [0x429045]\n??:? void tmp7iqwjtbr.__unittest_L38_C1() [0x427e0a]\n??:?
    void tmp7iqwjtbr.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42941b]\n??:? _d_run_main [0x429386]\n??:? main [0x4282bf]\n??:?
    __libc_start_main [0x77c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjj3obxs0.d(45): unittest failure\n----------------\n??:?
    _d_unittestp [0x429045]\n??:? void tmpjj3obxs0.__unittest_L38_C1() [0x427e0a]\n??:?
    void tmpjj3obxs0.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42941b]\n??:? _d_run_main [0x429386]\n??:? main [0x4282bf]\n??:?
    __libc_start_main [0x55cb1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n   \
    \         s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return\
    \ \"Yes\";\n    else if(s1_open < 0 && s2_open > 0)\n        return \"Yes\";\n\
    \    else if(s1_open > 0 && s2_open < 0)\n        return \"Yes\";\n    else\n\
    \        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprrl_b9nn.d(56): unittest failure\n----------------\n??:?
    _d_unittestp [0x429095]\n??:? void tmprrl_b9nn.__unittest_L50_C1() [0x427ddc]\n??:?
    void tmprrl_b9nn.__modtest() [0x4282fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428dc5]\n??:? runModuleUnitTests [0x42d7b9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4294df]\n??:? _d_run_main [0x42944a]\n??:? main [0x42830f]\n??:?
    __libc_start_main [0xd17be554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnp9n7mfj.d(50): unittest failure\n----------------\n??:?
    _d_unittestp [0x429055]\n??:? void tmpnp9n7mfj.__unittest_L46_C1() [0x427c94]\n??:?
    void tmpnp9n7mfj.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42949f]\n??:? _d_run_main [0x42940a]\n??:? main [0x4282d3]\n??:?
    __libc_start_main [0xe8ec6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len =\
    \ s1.length;\n    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open\
    \ = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n   \
    \ {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_close++;\n\
    \    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n\
    \        else\n            s2_close++;\n    }\n    if(s1_open == s1_close && s2_open\
    \ == s2_close)\n        return \"Yes\";\n    else if(s1_open == s1_close && s2_open\
    \ != s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open\
    \ == s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open\
    \ != s2_close)\n    {\n        if(s1_open > s1_close)\n        {\n           \
    \ if(s2_open > s2_close)\n            {\n                if(s1_open - s1_close\
    \ == s2_open - s2_close)\n                    return \"Yes\";\n              \
    \  else\n                    return \"No\";\n            }\n            else\n\
    \            {\n                if(s1_open - s1_close == s2_close - s2_open)\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n        else\n        {\n      \
    \      if(s2_open > s2_close)\n            {\n                if(s1_close - s1_open\
    \ == s2_open - s2_close)\n                    return \"Yes\";\n              \
    \  else\n                    return \"No\";\n            }\n            else\n\
    \            {\n                if(s1_close - s1_open == s2_close - s\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi3_fv3x8.d(82): Error: found `unittest` when expecting `)`\n/tmp/tmpi3_fv3x8.d(99):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpi3_fv3x8.d(99):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpi3_fv3x8.d(99):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpi3_fv3x8.d(99):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi3_fv3x8.d", "-I/tmp"]\n'''
  stdout: b''
