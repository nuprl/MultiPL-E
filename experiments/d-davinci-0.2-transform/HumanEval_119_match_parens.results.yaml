language: d
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2\
    \ != 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"\
    No\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\";\n    if(c1 > 0 && c2 >\
    \ 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n    {\n        if(abs(c1)\
    \ == abs(c2))\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    if(c1 < 0 && c2 > 0)\n    {\n        if(abs(c1) == abs(c2))\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpag398bg4.d(80): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291ed]

    ??:? void tmpag398bg4.__unittest_L67_C1() [0x428286]

    ??:? void tmpag398bg4.__modtest() [0x428454]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9e9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a975]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f1d]

    ??:? runModuleUnitTests [0x42d911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n\
    \    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n           \
    \ open++;\n        else\n            close++;\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprpfk05xu.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmprpfk05xu.__unittest_L43_C1() [0x4280fa]

    ??:? void tmprpfk05xu.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    return count1 == count2 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1xjl7klg.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmp1xjl7klg.__unittest_L43_C1() [0x427c8c]

    ??:? void tmp1xjl7klg.__modtest() [0x4282b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]

    ??:? void tmpkwtm4p5r.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]

    ??:? void tmpnyosqxjb.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]

    ??:? void tmpj3bfejzp.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2tivff1d.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmp2tivff1d.__unittest_L38_C1() [0x427e0a]

    ??:? void tmp2tivff1d.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(e; s)\n    {\n        if(e == '(')\n            count++;\n\
    \        else if(e == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcmd0rit1.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpcmd0rit1.__unittest_L40_C1() [0x427e0e]

    ??:? void tmpcmd0rit1.__modtest() [0x4282b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n\
    \    return s.balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph47lkzlz.d(26): Error: no property `balance` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph47lkzlz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161274
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n        if(count1\
    \ < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            count2++;\n        else\n            count2--;\n \
    \       if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf1qtzcsm.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpf1qtzcsm.__unittest_L49_C1() [0x427cc0]

    ??:? void tmpf1qtzcsm.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == count2 && count1 >= 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm50lws27.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpm50lws27.__unittest_L46_C1() [0x427c94]

    ??:? void tmpm50lws27.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n\
    \    int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    for\
    \ (int i = 0; i < len1; i++)\n    {\n        if (s1[i] == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    for (int i = 0; i < len2; i++)\n\
    \    {\n        if (s2[i] == '(')\n            count2++;\n        else\n     \
    \       count2--;\n    }\n    if (count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfnzy__1.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpjfnzy__1.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfnzy__1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161274
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(el; lst)\n        s ~= el;\n   \
    \ int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n           \
    \ count++;\n        else if(c == ')')\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk8182_te.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpk8182_te.__unittest_L38_C1() [0x427e0a]

    ??:? void tmpk8182_te.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2tivff1d.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmp2tivff1d.__unittest_L38_C1() [0x427e0a]

    ??:? void tmp2tivff1d.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n   \
    \         s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return\
    \ \"Yes\";\n    else if(s1_open < 0 && s2_open > 0)\n        return \"Yes\";\n\
    \    else if(s1_open > 0 && s2_open < 0)\n        return \"Yes\";\n    else\n\
    \        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptge4ijeo.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmptge4ijeo.__unittest_L50_C1() [0x427ddc]

    ??:? void tmptge4ijeo.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len =\
    \ s1.length;\n    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open\
    \ = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n   \
    \ {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_close++;\n\
    \    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n\
    \        else\n            s2_close++;\n    }\n    if(s1_open == s1_close && s2_open\
    \ == s2_close)\n        return \"Yes\";\n    else if(s1_open == s1_close && s2_open\
    \ != s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open\
    \ == s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open\
    \ != s2_close)\n    {\n        if(s1_open > s1_close)\n        {\n           \
    \ if(s2_open > s2_close)\n            {\n                if(s1_open - s1_close\
    \ == s2_open - s2_close)\n                    return \"Yes\";\n              \
    \  else\n                    return \"No\";\n            }\n            else\n\
    \            {\n                if(s1_open - s1_close == s2_close - s2_open)\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n        else\n        {\n      \
    \      if(s2_open > s2_close)\n            {\n                if(s1_close - s1_open\
    \ == s2_open - s2_close)\n                    return \"Yes\";\n              \
    \  else\n                    return \"No\";\n            }\n            else\n\
    \            {\n                if(s1_close - s1_open == s2_close - s\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppz2zznfz.d(82): Error: found `unittest` when expecting `)`

    /tmp/tmppz2zznfz.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppz2zznfz.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppz2zznfz.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppz2zznfz.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz2zznfz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161274
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2g7h0v0h.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmp2g7h0v0h.__unittest_L37_C1() [0x4280a6]

    ??:? void tmp2g7h0v0h.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]

    ??:? void tmp_yuh_5m2.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]

    ??:? void tmpkwtm4p5r.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int cnt1 = 0;\n\
    \    int cnt2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n        \
    \    cnt1++;\n        else\n            cnt1--;\n    }\n    foreach(c; s2)\n \
    \   {\n        if(c == '(')\n            cnt2++;\n        else\n            cnt2--;\n\
    \    }\n    if(cnt1 == 0 && cnt2 == 0)\n        return \"Yes\";\n    if(cnt1 ==\
    \ 0 && cnt2 < 0)\n        return \"No\";\n    if(cnt1 > 0 && cnt2 == 0)\n    \
    \    return \"No\";\n    if(cnt1 > 0 && cnt2 < 0)\n    {\n        if(cnt1 == abs(cnt2))\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    if(cnt1 < 0 && cnt2 == 0)\n        return \"No\";\n    if(cnt1 < 0 && cnt2\
    \ > 0)\n    {\n        if(abs(cnt1) == cnt2)\n            return \"Yes\";\n  \
    \      else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl5mmhy5z.d(78): unittest failure

    ----------------

    ??:? _d_unittestp [0x42918d]

    ??:? void tmpl5mmhy5z.__unittest_L65_C1() [0x428226]

    ??:? void tmpl5mmhy5z.__modtest() [0x4283f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dadb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428ee6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a989]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa18]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a915]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ebd]

    ??:? runModuleUnitTests [0x42d8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429650]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n  \
    \  int[] b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n\
    \    int[] e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n\
    \    int[] h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n\
    \    int[] k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n\
    \    int[] o = new int[n];\n    int[] p = new int[n];\n    int[] q = new int[n];\n\
    \    int[] r = new int[n];\n    int[] t = new int[n];\n    int[] u = new int[n];\n\
    \    int[] v = new int[n];\n    int[] w = new int[n];\n    int[] x = new int[n];\n\
    \    int[] y = new int[n];\n    int[] z = new int[n];\n    int[] aa = new int[n];\n\
    \    int[] bb = new int[n];\n    int[] cc = new int[n];\n    int[] dd = new int[n];\n\
    \    int[] ee = new int[n];\n    int[] ff = new int[n];\n    int[] gg = new int[n];\n\
    \    int[] hh = new int[n];\n    int[] ii = new int[n];\n    int[] jj = new int[n];\n\
    \    int[] kk = new int[n];\n    int[] ll = new int[n];\n    int[] mm = new int[n];\n\
    \    int[] oo = new int[n];\n    int[] pp = new int[n];\n    int[] qq = new int[n];\n\
    \    int[] rr\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9qmihhzn.d(69): Error: semicolon expected, not `unittest`

    /tmp/tmp9qmihhzn.d(69): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9qmihhzn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161274
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if(count1 == 0 && count2 != 0)\n        return \"No\";\n    if(count1\
    \ != 0 && count2 == 0)\n        return \"No\";\n    if(count1 > 0 && count2 >\
    \ 0)\n        return \"No\";\n    if(count1 < 0 && count2 < 0)\n        return\
    \ \"No\";\n    if(count1 > 0 && count2 < 0)\n    {\n        if(abs(count1) ==\
    \ abs(count2))\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    if(count1 < 0 && count2 > 0)\n    {\n        if(abs(count1)\
    \ == abs(count2))\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp15db9irr.d(80): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291ed]

    ??:? void tmp15db9irr.__unittest_L67_C1() [0x428286]

    ??:? void tmp15db9irr.__modtest() [0x428454]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42db3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a9e9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42aa78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a975]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f1d]

    ??:? runModuleUnitTests [0x42d911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4296b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n\
    \    int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    for\
    \ (int i = 0; i < len1; i++)\n    {\n        if (s1[i] == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    for (int i = 0; i < len2; i++)\n\
    \    {\n        if (s2[i] == '(')\n            count2++;\n        else\n     \
    \       count2--;\n    }\n    if (count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfnzy__1.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpjfnzy__1.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfnzy__1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161274
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    return (open == close) ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsv99zlg5.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpsv99zlg5.__unittest_L41_C1() [0x4280f6]

    ??:? void tmpsv99zlg5.__modtest() [0x4282b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]

    ??:? void tmpkwtm4p5r.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2tivff1d.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmp2tivff1d.__unittest_L38_C1() [0x427e0a]

    ??:? void tmp2tivff1d.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    return\
    \ s.balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpydjdcrn8.d(26): Error: no property `balance` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpydjdcrn8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n  \
    \  int cnt = 0;\n    int i = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            cnt++;\n        else\n            cnt--;\n        a[i++] = cnt;\n\
    \    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            cnt++;\n\
    \        else\n            cnt--;\n        a[i++] = cnt;\n    }\n    if(cnt !=\
    \ 0)\n        return \"No\";\n    int min = a[0];\n    foreach(x; a)\n       \
    \ min = min(min, x);\n    if(min < 0)\n        return \"No\";\n    return \"Yes\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi40xu3gj.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpi40xu3gj.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpi40xu3gj.d(51): Error: function expected before `()`, not `min` of type
    `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi40xu3gj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]

    ??:? void tmpnyosqxjb.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  count++;\n        else\n            count--;\n        if(count < 0)\n     \
    \       return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n \
    \   else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq6nlulyh.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpq6nlulyh.__unittest_L49_C1() [0x427e4a]

    ??:? void tmpq6nlulyh.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]

    ??:? void tmp_yuh_5m2.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpka8yz1m4.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmpka8yz1m4.__unittest_L37_C1() [0x4280a6]

    ??:? void tmpka8yz1m4.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n\
    \    string s3 = s1 ~ s2;\n    int count = 0;\n    foreach(char c; s3)\n    {\n\
    \        if(c == '(')\n            count++;\n        else if(c == ')')\n     \
    \       count--;\n        if(count < 0)\n            return \"No\";\n    }\n \
    \   if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyw01dcjp.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpyw01dcjp.__unittest_L42_C1() [0x427e0a]

    ??:? void tmpyw01dcjp.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]

    ??:? void tmpj3bfejzp.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n\
    \    dp[0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        if (dp[i] ==\
    \ 0)\n            continue;\n        if (i < n1 && s1[i] == '(')\n           \
    \ dp[i + 1] = 1;\n        if (i < n2 && s2[i] == '(')\n            dp[i + 1] =\
    \ 1;\n        if (i < n1 && s1[i] == ')')\n            dp[i + 1] = dp[i - 1];\n\
    \        if (i < n2 && s2[i] == ')')\n            dp[i + 1] = dp[i - 1];\n   \
    \ }\n    return dp[n] == 1 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgiif9oy6.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpgiif9oy6.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgiif9oy6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    int i = 0;\n \
    \   int j = 0;\n    while (i < n1)\n    {\n        if (s1[i] == '(')\n       \
    \     c1++;\n        else\n            c1--;\n        i++;\n    }\n    while (j\
    \ < n2)\n    {\n        if (s2[j] == '(')\n            c2++;\n        else\n \
    \           c2--;\n        j++;\n    }\n    if (c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hmqba_8.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp5hmqba_8.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hmqba_8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]

    ??:? void tmpj3bfejzp.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2g7h0v0h.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmp2g7h0v0h.__unittest_L37_C1() [0x4280a6]

    ??:? void tmp2g7h0v0h.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int l1 = s1.length;\n\
    \    int l2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    for (int i = 0;\
    \ i < l1; i++)\n    {\n        if (s1[i] == '(')\n            c1++;\n        else\n\
    \            c1--;\n    }\n    for (int i = 0; i < l2; i++)\n    {\n        if\
    \ (s2[i] == '(')\n            c2++;\n        else\n            c2--;\n    }\n\
    \    if (c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if (c1 == 0 && c2 >\
    \ 0)\n        return \"No\";\n    if (c1 < 0 && c2 == 0)\n        return \"No\"\
    ;\n    if (c1 < 0 && c2 > 0)\n    {\n        if (c1 + c2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if (c1 > 0 &&\
    \ c2 == 0)\n    {\n        if (c1 + c2 == 0)\n            return \"Yes\";\n  \
    \      else\n            return \"No\";\n    }\n    if (c1 > 0 && c2 > 0)\n  \
    \  {\n        if (c1 + c2 == 0)\n            return \"Yes\";\n        else\n \
    \           return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5_51pyom.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp5_51pyom.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_51pyom.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n        if(count1\
    \ < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            count2++;\n        else\n            count2--;\n \
    \       if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf1qtzcsm.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpf1qtzcsm.__unittest_L49_C1() [0x427cc0]

    ??:? void tmpf1qtzcsm.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n\
    \    int len2 = s2.length;\n    int count = 0;\n    foreach(c; s1)\n    {\n  \
    \      if(c == '(')\n            count++;\n        else\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count\
    \ == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpri_rvon2.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpri_rvon2.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpri_rvon2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]

    ??:? void tmp4bm1qg_e.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]

    ??:? void tmpkwtm4p5r.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(i; lst)\n        s ~= i;\n    int\
    \ count = 0;\n    foreach(i; s)\n    {\n        if(i == '(')\n            count++;\n\
    \        else if(i == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmfbiecl3.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpmfbiecl3.__unittest_L40_C1() [0x427e0e]

    ??:? void tmpmfbiecl3.__modtest() [0x4282b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n   \
    \         s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return\
    \ \"Yes\";\n    if(s1_open == 0 && s2_open < 0)\n        return \"No\";\n    if(s1_open\
    \ > 0 && s2_open == 0)\n        return \"No\";\n    if(s1_open > 0 && s2_open\
    \ < 0)\n    {\n        if(s1_open == abs(s2_open))\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw4ofb4z3.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x429135]

    ??:? void tmpw4ofb4z3.__unittest_L56_C1() [0x427ee6]

    ??:? void tmpw4ofb4z3.__modtest() [0x42839c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a931]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e65]

    ??:? runModuleUnitTests [0x42d859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ str)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpexenojmg.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpexenojmg.__unittest_L36_C1() [0x427df6]

    ??:? void tmpexenojmg.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int n = lst[0].length;\n    int m = lst[1].length;\n    int[][]\
    \ dp = new int[n + 1][m + 1];\n    dp[0][0] = 1;\n    foreach (i; 0 .. n + 1)\n\
    \    {\n        foreach (j; 0 .. m + 1)\n        {\n            if (i > 0 && lst[0][i\
    \ - 1] == '(')\n            {\n                dp[i][j] |= dp[i - 1][j];\n   \
    \         }\n            if (j > 0 && lst[1][j - 1] == '(')\n            {\n \
    \               dp[i][j] |= dp[i][j - 1];\n            }\n            if (i >\
    \ 0 && lst[0][i - 1] == ')')\n            {\n                dp[i][j] |= dp[i\
    \ - 1][j];\n            }\n            if (j > 0 && lst[1][j - 1] == ')')\n  \
    \          {\n                dp[i][j] |= dp[i][j - 1];\n            }\n     \
    \       if (i > 0 && j > 0 && lst[0][i - 1] == '(' && lst[1][j - 1] == ')')\n\
    \            {\n                dp[i][j] |= dp[i - 1][j - 1];\n            }\n\
    \            if (i > 0 && j > 0 && lst[0][i - 1] == ')' && lst[1][j - 1] == '(')\n\
    \            {\n                dp[i][j] |= dp[i - 1][j - 1];\n            }\n\
    \        }\n    }\n    return dp[n][m] ? \"Yes\" : \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmjdb8wj5.d(23): Error: cannot implicitly convert expression `lst[0].length`
    of type `ulong` to `int`

    /tmp/tmpmjdb8wj5.d(24): Error: cannot implicitly convert expression `lst[1].length`
    of type `ulong` to `int`

    /tmp/tmpmjdb8wj5.d(25): Error: variable `n` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjdb8wj5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1\
    \ ~ s2;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n\
    \            count++;\n        else if(c == ')')\n            count--;\n     \
    \   if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n   \
    \     return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjxvax4xn.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpjxvax4xn.__unittest_L41_C1() [0x427e0a]

    ??:? void tmpjxvax4xn.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Your code here\n    string s = lst[0] ~ lst[1];\n    int count\
    \ = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptsykcwes.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmptsykcwes.__unittest_L37_C1() [0x427df6]

    ??:? void tmptsykcwes.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n  \
    \  int[] b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n\
    \    int[] e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n\
    \    int[] h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n\
    \    int[] k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n\
    \    int[] nn = new int[n];\n    int[] o = new int[n];\n    int[] p = new int[n];\n\
    \    int[] q = new int[n];\n    int[] r = new int[n];\n    int[] s = new int[n];\n\
    \    int[] t = new int[n];\n    int[] u = new int[n];\n    int[] v = new int[n];\n\
    \    int[] w = new int[n];\n    int[] x = new int[n];\n    int[] y = new int[n];\n\
    \    int[] z = new int[n];\n    int[] A = new int[n];\n    int[] B = new int[n];\n\
    \    int[] C = new int[n];\n    int[] D = new int[n];\n    int[] E = new int[n];\n\
    \    int[] F = new int[n];\n    int[] G = new int[n];\n    int[] H = new int[n];\n\
    \    int[] I = new int[n];\n    int[] J = new int[n];\n    int[] K = new int[n];\n\
    \    int[] L = new int[n];\n    int[] M = new int[n];\n    int[] N = new int[n];\n\
    \    int[] O = new int[n];\n    int\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpab_j446i.d(70): Error: no identifier for declarator `int`

    /tmp/tmpab_j446i.d(70): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpab_j446i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(i; 0..n1)\n\
    \    {\n        if(s1[i] == '(')\n            c1++;\n        else\n          \
    \  c1--;\n    }\n    foreach(i; 0..n2)\n    {\n        if(s2[i] == '(')\n    \
    \        c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 ==\
    \ 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\"\
    ;\n    if(c1 < 0 && c2 > 0)\n    {\n        if(c1 + c2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c1 > 0 &&\
    \ c2 < 0)\n    {\n        if(c1 + c2 == 0)\n            return \"Yes\";\n    \
    \    else\n            return \"No\";\n    }\n    if(c1 > 0 && c2 > 0)\n    {\n\
    \        if(c1 == c2)\n            return \"Yes\";\n        else\n           \
    \ return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo8d9xd17.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpo8d9xd17.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    /tmp/tmpo8d9xd17.d(21): Error: function `tmpo8d9xd17.match_parens` no `return
    exp;` or `assert(0);` at end of function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8d9xd17.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]

    ??:? void tmpnyosqxjb.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]

    ??:? void tmpj3bfejzp.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  count++;\n        else\n            count--;\n        if(count < 0)\n     \
    \       return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n \
    \   else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq6nlulyh.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpq6nlulyh.__unittest_L49_C1() [0x427e4a]

    ??:? void tmpq6nlulyh.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]

    ??:? void tmp_yuh_5m2.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    return\
    \ s.balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpydjdcrn8.d(26): Error: no property `balance` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpydjdcrn8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else\n        \
    \    cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return\
    \ cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4clo7h1x.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmp4clo7h1x.__unittest_L36_C1() [0x427dee]

    ??:? void tmp4clo7h1x.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n\
    \    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n           \
    \ open++;\n        else\n            close++;\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprpfk05xu.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmprpfk05xu.__unittest_L43_C1() [0x4280fa]

    ??:? void tmprpfk05xu.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n\
    \    int len2 = s2.length;\n    int count = 0;\n    foreach(c; s1)\n    {\n  \
    \      if(c == '(')\n            count++;\n        else\n            count--;\n\
    \    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n    }\n    if(count != 0)\n        return\
    \ \"No\";\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n\
    \        if(c == '(')\n            count1++;\n        else\n            count1--;\n\
    \        if(count1 < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n\
    \    {\n        if(c == '(')\n            count2++;\n        else\n          \
    \  count2--;\n        if(count2 < 0)\n            return \"No\";\n    }\n    return\
    \ \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp28eshcgq.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmp28eshcgq.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp28eshcgq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str1 = lst[0];\n    string str2 = lst[1];\n    int count1\
    \ = 0;\n    int count2 = 0;\n    foreach(c; str1)\n    {\n        if(c == '(')\n\
    \            count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ str2)\n    {\n        if(c == '(')\n            count2++;\n        else\n  \
    \          count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbl2s9jub.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpbl2s9jub.__unittest_L46_C1() [0x427c94]

    ??:? void tmpbl2s9jub.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpka8yz1m4.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmpka8yz1m4.__unittest_L37_C1() [0x4280a6]

    ??:? void tmpka8yz1m4.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]

    ??:? void tmpj3bfejzp.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuehkqee0.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmpuehkqee0.__unittest_L37_C1() [0x4280aa]

    ??:? void tmpuehkqee0.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n \
    \   foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n    \
    \    else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n\
    \    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"\
    Yes\";\n    else if(s1_open == s1_close && s2_open != s2_close)\n        return\
    \ \"No\";\n    else if(s1_open != s1_close && s2_open == s2_close)\n        return\
    \ \"No\";\n    else if(s1_open != s1_close && s2_open != s2_close)\n    {\n  \
    \      if(s1_open > s1_close)\n        {\n            if(s2_open > s2_close)\n\
    \                return \"No\";\n            else\n                return \"Yes\"\
    ;\n        }\n        else\n        {\n            if(s2_open > s2_close)\n  \
    \              return \"Yes\";\n            else\n                return \"No\"\
    ;\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate =\
    \ match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqox5drr3.d(74): unittest failure

    ----------------

    ??:? _d_unittestp [0x429115]

    ??:? void tmpqox5drr3.__unittest_L68_C1() [0x427e60]

    ??:? void tmpqox5drr3.__modtest() [0x428380]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da63]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a911]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9a0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a89d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e45]

    ??:? runModuleUnitTests [0x42d839]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ten80l.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmph7ten80l.__unittest_L45_C1() [0x427c94]

    ??:? void tmph7ten80l.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]

    ??:? void tmp4bm1qg_e.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]

    ??:? void tmp4bm1qg_e.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]

    ??:? void tmpkwtm4p5r.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]

    ??:? void tmpkwtm4p5r.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            left++;\n            else\n                right++;\n        }\n\
    \    }\n    return left == right ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbagkg_4r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmpbagkg_4r.__unittest_L37_C1() [0x4280a6]

    ??:? void tmpbagkg_4r.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n\
    \    int len2 = s2.length;\n    int open = 0;\n    int close = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            open++;\n        else\n      \
    \      close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n    \
    \        open++;\n        else\n            close++;\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnp37iw_2.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpnp37iw_2.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnp37iw_2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n \
    \   foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n    \
    \    else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n\
    \    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"\
    Yes\";\n    else if(s1_open == s1_close && s2_open != s2_close)\n        return\
    \ \"No\";\n    else if(s1_open != s1_close && s2_open == s2_close)\n        return\
    \ \"No\";\n    else\n    {\n        int s1_diff = abs(s1_open - s1_close);\n \
    \       int s2_diff = abs(s2_open - s2_close);\n        if(s1_diff == s2_diff)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp94by4967.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x42913d]

    ??:? void tmp94by4967.__unittest_L59_C1() [0x427df2]

    ??:? void tmp94by4967.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a939]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]

    ??:? runModuleUnitTests [0x42d861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429600]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int cnt = 0;\n    foreach(c; s1)\n    {\n      \
    \  if(c == '(')\n            cnt++;\n        else\n            cnt--;\n      \
    \  if(cnt < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            cnt++;\n        else\n            cnt--;\n\
    \        if(cnt < 0)\n            return \"No\";\n    }\n    if(cnt == 0)\n  \
    \      return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo6ws0df4.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpo6ws0df4.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo6ws0df4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if(count1 > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptgnbraz2.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmptgnbraz2.__unittest_L49_C1() [0x427ddc]

    ??:? void tmptgnbraz2.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n\
    \    auto count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n       \
    \     count++;\n        else\n            count--;\n        if(count < 0)\n  \
    \          return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbzxdvj_w.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429035]

    ??:? void tmpbzxdvj_w.__unittest_L38_C1() [0x427dfe]

    ??:? void tmpbzxdvj_w.__modtest() [0x4282a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d983]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a831]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7bd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d65]

    ??:? runModuleUnitTests [0x42d759]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]

    ??:? void tmpj3bfejzp.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // TODO: implement this function\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdzgy1eql.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f3d]

    ??:? void tmpdzgy1eql.__unittest_L26_C1() [0x427b7c]

    ??:? void tmpdzgy1eql.__modtest() [0x4281a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d817]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a754]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c6d]

    ??:? runModuleUnitTests [0x42d5ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42938c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2\
    \ != 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"\
    No\";\n    if(c1 > 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 && c2 >\
    \ 0)\n        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return \"Yes\"\
    ;\n    if(c1 < 0 && c2 < 0)\n        return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tjend0l.d(21): Error: function `tmp_tjend0l.match_parens` no `return
    exp;` or `assert(0);` at end of function

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tjend0l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else\n        \
    \    cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return\
    \ cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4clo7h1x.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmp4clo7h1x.__unittest_L36_C1() [0x427dee]

    ??:? void tmp4clo7h1x.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 + count2 == 0)\n        return \"Yes\"\
    ;\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxp73d4m3.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpxp73d4m3.__unittest_L46_C1() [0x428102]

    ??:? void tmpxp73d4m3.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2tivff1d.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmp2tivff1d.__unittest_L38_C1() [0x427e0a]

    ??:? void tmp2tivff1d.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(i; lst)\n        s ~= i;\n    return\
    \ s.balance ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnubileii.d(26): Error: no property `balance` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnubileii.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n\
    \    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n \
    \       else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return\
    \ \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0\
    \ && c2 == 0)\n        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return\
    \ \"No\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 &&\
    \ c2 > 0)\n    {\n        if(c1 == -c2)\n            return \"Yes\";\n       \
    \ else\n            return \"No\";\n    }\n    if(c1 > 0 && c2 < 0)\n    {\n \
    \       if(c1 == -c2)\n            return \"Yes\";\n        else\n           \
    \ return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoxizq49x.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpoxizq49x.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoxizq49x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int cnt = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                cnt++;\n       \
    \     else\n                cnt--;\n            if(cnt < 0)\n                return\
    \ \"No\";\n        }\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm27idn4m.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpm27idn4m.__unittest_L38_C1() [0x427dda]

    ??:? void tmpm27idn4m.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]

    ??:? void tmp_yuh_5m2.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]

    ??:? void tmpnyosqxjb.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int a = 0;\n    int b = 0;\n    foreach(c; lst[0])\n    {\n  \
    \      if(c == '(')\n            a++;\n        else\n            a--;\n    }\n\
    \    foreach(c; lst[1])\n    {\n        if(c == '(')\n            b++;\n     \
    \   else\n            b--;\n    }\n    if(a == 0 && b == 0)\n        return \"\
    Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsz3rpzn9.d(48): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpsz3rpzn9.__unittest_L44_C1() [0x427c8c]

    ??:? void tmpsz3rpzn9.__modtest() [0x4282b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(s; lst)\n    {\n\
    \        foreach(c; s)\n        {\n            if(c == '(')\n                open++;\n\
    \            else\n                close++;\n        }\n    }\n    return open\
    \ == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqz5l83g3.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmpqz5l83g3.__unittest_L37_C1() [0x4280a6]

    ??:? void tmpqz5l83g3.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n\
    \    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n       \
    \ if(c == '(')\n            count1++;\n        else\n            count1--;\n \
    \   }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n\
    \        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkpjdgb24.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkpjdgb24.__unittest_L47_C1() [0x427c94]

    ??:? void tmpkpjdgb24.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]

    ??:? void tmp_yuh_5m2.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]

    ??:? void tmpnyosqxjb.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuehkqee0.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmpuehkqee0.__unittest_L37_C1() [0x4280aa]

    ??:? void tmpuehkqee0.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2g7h0v0h.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmp2g7h0v0h.__unittest_L37_C1() [0x4280a6]

    ??:? void tmp2g7h0v0h.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // TODO: Implement your solution here\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4guq9wbn.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x428f3d]

    ??:? void tmp4guq9wbn.__unittest_L26_C1() [0x427b7c]

    ??:? void tmp4guq9wbn.__modtest() [0x4281a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d817]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428c96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a6c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a754]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a651]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c6d]

    ??:? runModuleUnitTests [0x42d5ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42938c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1\
    \ < 0 && count2 > 0)\n    {\n        if(count1 + count2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 > 0\
    \ && count2 < 0)\n    {\n        if(count1 + count2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdce_j4xw.d(74): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290e5]

    ??:? void tmpdce_j4xw.__unittest_L61_C1() [0x428192]

    ??:? void tmpdce_j4xw.__modtest() [0x42834c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a970]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a86d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e15]

    ??:? runModuleUnitTests [0x42d809]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if(count1 < 0 || count2 < 0)\n        return \"No\";\n    if(count1\
    \ == count2)\n        return \"Yes\";\n    if(count1 > count2)\n        return\
    \ \"No\";\n    if(count1 < count2)\n    {\n        if(count2 % 2 == 0)\n     \
    \       return \"Yes\";\n        else\n            return \"No\";\n    }\n   \
    \ return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl5v53f_q.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290e5]

    ??:? void tmpl5v53f_q.__unittest_L58_C1() [0x427d20]

    ??:? void tmpl5v53f_q.__modtest() [0x42834c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a970]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a86d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e15]

    ??:? runModuleUnitTests [0x42d809]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n        if(count1\
    \ < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            count2++;\n        else\n            count2--;\n \
    \       if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf1qtzcsm.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpf1qtzcsm.__unittest_L49_C1() [0x427cc0]

    ??:? void tmpf1qtzcsm.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open > close)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcntpiuvf.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmpcntpiuvf.__unittest_L40_C1() [0x427c38]

    ??:? void tmpcntpiuvf.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n   \
    \         s2_open--;\n    }\n    if(s1_open + s2_open == 0)\n        return \"\
    Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq0bopbdi.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpq0bopbdi.__unittest_L45_C1() [0x428102]

    ??:? void tmpq0bopbdi.__modtest() [0x4282bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n\
    \    int len2 = s2.length;\n    int count = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count++;\n        else\n     \
    \       count--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n   \
    \         count2++;\n        else\n            count2--;\n    }\n    if(count\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count == 0 && count2\
    \ != 0)\n    {\n        if(count2 < 0)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    else if(count != 0 && count2 == 0)\n \
    \   {\n        if(count > 0)\n            return \"Yes\";\n        else\n    \
    \        return \"No\";\n    }\n    else\n    {\n        if(count > 0 && count2\
    \ < 0)\n            return \"Yes\";\n        else\n            return \"No\";\n\
    \    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp0ib1oz4.d(25): Error: cannot implicitly convert expression `s1.length`
    of type `ulong` to `int`

    /tmp/tmpp0ib1oz4.d(26): Error: cannot implicitly convert expression `s2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp0ib1oz4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n \
    \   foreach(c; s1) {\n        if(c == '(') {\n            s1_open++;\n       \
    \ } else {\n            s1_close++;\n        }\n    }\n    foreach(c; s2) {\n\
    \        if(c == '(') {\n            s2_open++;\n        } else {\n          \
    \  s2_close++;\n        }\n    }\n    if(s1_open == s1_close && s2_open == s2_close)\
    \ {\n        return \"Yes\";\n    }\n    if(s1_open > s1_close && s2_open > s2_close)\
    \ {\n        return \"Yes\";\n    }\n    if(s1_open < s1_close && s2_open < s2_close)\
    \ {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdvo4ltxf.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290a5]

    ??:? void tmpdvo4ltxf.__unittest_L54_C1() [0x427ce4]

    ??:? void tmpdvo4ltxf.__modtest() [0x428310]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9f3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dfe]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8a1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a930]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a82d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dd5]

    ??:? runModuleUnitTests [0x42d7c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429568]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]

    ??:? void tmp4bm1qg_e.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int n = lst[0].length;\n    int m = lst[1].length;\n    int[][]\
    \ dp = new int[n + 1][m + 1];\n    for (int i = 0; i <= n; i++)\n    {\n     \
    \   for (int j = 0; j <= m; j++)\n        {\n            if (i == 0 && j == 0)\n\
    \            {\n                dp[i][j] = 1;\n            }\n            else\
    \ if (i == 0)\n            {\n                dp[i][j] = dp[i][j - 1] & (lst[1][j\
    \ - 1] == '(' ? 1 : -1);\n            }\n            else if (j == 0)\n      \
    \      {\n                dp[i][j] = dp[i - 1][j] & (lst[0][i - 1] == '(' ? 1\
    \ : -1);\n            }\n            else\n            {\n                dp[i][j]\
    \ = max(dp[i - 1][j] & (lst[0][i - 1] == '(' ? 1 : -1), dp[i][j - 1] & (lst[1][j\
    \ - 1] == '(' ? 1 : -1));\n            }\n        }\n    }\n    return dp[n][m]\
    \ == 1 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ibxm2ds.d(23): Error: cannot implicitly convert expression `lst[0].length`
    of type `ulong` to `int`

    /tmp/tmp2ibxm2ds.d(24): Error: cannot implicitly convert expression `lst[1].length`
    of type `ulong` to `int`

    /tmp/tmp2ibxm2ds.d(25): Error: variable `n` cannot be read at compile time

    /tmp/tmp2ibxm2ds.d(44): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ibxm2ds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(string i; lst)\n    {\n        s\
    \ ~= i;\n    }\n    int count = 0;\n    foreach(char i; s)\n    {\n        if(i\
    \ == '(')\n        {\n            count++;\n        }\n        else if(i == ')')\n\
    \        {\n            count--;\n        }\n        if(count < 0)\n        {\n\
    \            return \"No\";\n        }\n    }\n    if(count == 0)\n    {\n   \
    \     return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn50vhu8b.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpn50vhu8b.__unittest_L50_C1() [0x427e0e]

    ??:? void tmpn50vhu8b.__modtest() [0x4282b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n\
    \    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n       \
    \ if(c == '(')\n            count1++;\n        else\n            count1--;\n \
    \   }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n\
    \        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkpjdgb24.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkpjdgb24.__unittest_L47_C1() [0x427c94]

    ??:? void tmpkpjdgb24.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if(count1 > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptgnbraz2.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmptgnbraz2.__unittest_L49_C1() [0x427ddc]

    ??:? void tmptgnbraz2.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]

    ??:? void tmp4bm1qg_e.__modtest() [0x42827c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]

    ??:? void tmp_ugb1xs0.__modtest() [0x428268]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n   \
    \         s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return\
    \ \"Yes\";\n    if(s1_open == 0 && s2_open != 0)\n        return \"No\";\n   \
    \ if(s1_open != 0 && s2_open == 0)\n        return \"No\";\n    if(s1_open > 0\
    \ && s2_open < 0)\n        return \"No\";\n    if(s1_open < 0 && s2_open > 0)\n\
    \        return \"No\";\n    if(s1_open > 0 && s2_open > 0)\n        return \"\
    Yes\";\n    if(s1_open < 0 && s2_open < 0)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkdkn0zg4.d(61): unittest failure

    ----------------

    ??:? _d_unittestp [0x429105]

    ??:? void tmpkdkn0zg4.__unittest_L57_C1() [0x427d44]

    ??:? void tmpkdkn0zg4.__modtest() [0x428370]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e5e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a901]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a990]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a88d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e35]

    ??:? runModuleUnitTests [0x42d829]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  count++;\n        else\n            count--;\n        if(count < 0)\n     \
    \       return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n \
    \   else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq6nlulyh.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpq6nlulyh.__unittest_L49_C1() [0x427e4a]

    ??:? void tmpq6nlulyh.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ten80l.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmph7ten80l.__unittest_L45_C1() [0x427c94]

    ??:? void tmph7ten80l.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string a = lst[0];\n    string b = lst[1];\n    int a_open = 0;\n\
    \    int b_open = 0;\n    foreach(c; a)\n    {\n        if(c == '(')\n       \
    \     a_open++;\n        else\n            a_open--;\n    }\n    foreach(c; b)\n\
    \    {\n        if(c == '(')\n            b_open++;\n        else\n          \
    \  b_open--;\n    }\n    if(a_open == 0 && b_open == 0)\n        return \"Yes\"\
    ;\n    if(a_open > 0 && b_open < 0)\n        return \"Yes\";\n    if(a_open <\
    \ 0 && b_open > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp51ed_pyp.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmp51ed_pyp.__unittest_L49_C1() [0x427ddc]

    ??:? void tmp51ed_pyp.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n   \
    \         s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpe603cyil.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpe603cyil.__unittest_L45_C1() [0x427c94]

    ??:? void tmpe603cyil.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int l = lst[0].length;\n    int r = lst[1].length;\n    int lc\
    \ = 0;\n    int rc = 0;\n    foreach(c; lst[0])\n    {\n        if(c == '(')\n\
    \            lc++;\n        else\n            lc--;\n    }\n    foreach(c; lst[1])\n\
    \    {\n        if(c == '(')\n            rc++;\n        else\n            rc--;\n\
    \    }\n    if(lc == 0 && rc == 0)\n        return \"Yes\";\n    if(lc > 0 &&\
    \ rc < 0)\n        return \"No\";\n    if(lc < 0 && rc > 0)\n        return \"\
    No\";\n    if(lc == rc)\n        return \"Yes\";\n    if(abs(lc) > abs(rc))\n\
    \        return \"No\";\n    if(abs(lc) < abs(rc))\n        return \"No\";\n \
    \   return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwb6zgevb.d(23): Error: cannot implicitly convert expression `lst[0].length`
    of type `ulong` to `int`

    /tmp/tmpwb6zgevb.d(24): Error: cannot implicitly convert expression `lst[1].length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwb6zgevb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]

    ??:? void tmpkwtm4p5r.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  count++;\n        else\n            count--;\n        if(count < 0)\n     \
    \       return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n \
    \   else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq6nlulyh.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpq6nlulyh.__unittest_L49_C1() [0x427e4a]

    ??:? void tmpq6nlulyh.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]

    ??:? void tmpnhu6dv2q.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpka8yz1m4.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmpka8yz1m4.__unittest_L37_C1() [0x4280a6]

    ??:? void tmpka8yz1m4.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]

    ??:? void tmpkwtm4p5r.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n \
    \   foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n    \
    \    else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n\
    \    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"\
    Yes\";\n    else if(s1_open == s1_close && s2_open != s2_close)\n        return\
    \ \"No\";\n    else if(s1_open != s1_close && s2_open == s2_close)\n        return\
    \ \"No\";\n    else if(s1_open != s1_close && s2_open != s2_close)\n    {\n  \
    \      if(s1_open > s1_close)\n        {\n            if(s2_open > s2_close)\n\
    \            {\n                if(s1_open - s1_close == s2_open - s2_close)\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n            else\n            {\n         \
    \       if(s1_open - s1_close == s2_close - s2_open)\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n        }\n        else\n        {\n            if(s2_open > s2_close)\n\
    \            {\n                if(s1_close - s1_open == s2_open - s2_close)\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n            else\n            {\n         \
    \       if(s1_close - s1_open == s2_close - s2_open)\n                    return\
    \ \"Yes\";\n                else\n                    return \"No\";\n       \
    \     }\n        }\n\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7rckxnph.d(86): Error: found `unittest` instead of statement

    /tmp/tmp7rckxnph.d(103): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7rckxnph.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int open = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            open++;\n        else\n       \
    \     open--;\n        if(open < 0)\n            return \"No\";\n    }\n    return\
    \ open == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuzipmd19.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpuzipmd19.__unittest_L36_C1() [0x427dee]

    ??:? void tmpuzipmd19.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(char c; lst[0])\n    {\n        if(c\
    \ == '(')\n            count++;\n        else\n            count--;\n    }\n \
    \   foreach(char c; lst[1])\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n    }\n    return count == 0 ? \"Yes\" :\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpegldnr7z.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpegldnr7z.__unittest_L40_C1() [0x4280f2]

    ??:? void tmpegldnr7z.__modtest() [0x4282ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d993]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a841]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7cd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42d769]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429508]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpka8yz1m4.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmpka8yz1m4.__unittest_L37_C1() [0x4280a6]

    ??:? void tmpka8yz1m4.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n\
    \    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n       \
    \ if(c == '(')\n            count1++;\n        else if(c == ')')\n           \
    \ count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n        \
    \    count2++;\n        else if(c == ')')\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1 == 0 && count2\
    \ != 0)\n    {\n        if(count2 < 0)\n            return \"Yes\";\n        else\n\
    \            return \"No\";\n    }\n    else if(count1 != 0 && count2 == 0)\n\
    \    {\n        if(count1 > 0)\n            return \"Yes\";\n        else\n  \
    \          return \"No\";\n    }\n    else\n    {\n        if(count1 + count2\
    \ == 0)\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjmy96lab.d(75): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290e5]

    ??:? void tmpjmy96lab.__unittest_L66_C1() [0x427fad]

    ??:? void tmpjmy96lab.__modtest() [0x428350]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42da33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8e1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a970]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a86d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e15]

    ??:? runModuleUnitTests [0x42d809]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4295a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x429015]

    ??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]

    ??:? void tmpt7w5_6p8.__modtest() [0x428280]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a79d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a82c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]

    ??:? runModuleUnitTests [0x42d6c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429464]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x429025]

    ??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]

    ??:? void tmpnyosqxjb.__modtest() [0x428290]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d973]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a821]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7ad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]

    ??:? runModuleUnitTests [0x42d749]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(e; s)\n    {\n        if(e == '(')\n            count++;\n\
    \        else if(e == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcmd0rit1.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x429045]

    ??:? void tmpcmd0rit1.__unittest_L40_C1() [0x427e0e]

    ??:? void tmpcmd0rit1.__modtest() [0x4282b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e3bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d9e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b269]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b2f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b1f5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]

    ??:? runModuleUnitTests [0x42e191]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429494]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x429055]

    ??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]

    ??:? void tmpg7108nva.__modtest() [0x4282c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9a3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a851]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8e0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7dd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]

    ??:? runModuleUnitTests [0x42d779]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429518]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    return\
    \ (s.count(\"(\") == s.count(\")\")) ? \"Yes\" : \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_47c56r8.d(26): Error: no property `count` for type `string`

    /tmp/tmp_47c56r8.d(26): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_47c56r8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ffd]

    ??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]

    ??:? void tmp_yuh_5m2.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d56]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a785]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a711]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]

    ??:? runModuleUnitTests [0x42d6ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42944c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2g7h0v0h.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x428ff5]

    ??:? void tmp2g7h0v0h.__unittest_L37_C1() [0x4280a6]

    ??:? void tmp2g7h0v0h.__modtest() [0x428260]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d8cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a77d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a80c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a709]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]

    ??:? runModuleUnitTests [0x42d6a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429444]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 > 0 && c2\
    \ < 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 > 0)\n        return \"Yes\"\
    ;\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9b5zfkaf.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x429095]

    ??:? void tmp9b5zfkaf.__unittest_L49_C1() [0x427ddc]

    ??:? void tmp9b5zfkaf.__modtest() [0x4282fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9e3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a891]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a920]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a81d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]

    ??:? runModuleUnitTests [0x42d7b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429558]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]

    ??:? void tmpzfhuw0nm.__modtest() [0x4282b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n   \
    \         s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return\
    \ \"Yes\";\n    else if(s1_open == 0 && s2_open < 0)\n        return \"Yes\";\n\
    \    else if(s1_open > 0 && s2_open == 0)\n        return \"Yes\";\n    else if(s1_open\
    \ < 0 && s2_open == 0)\n        return \"Yes\";\n    else\n        return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuecpo1zb.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x4290ad]

    ??:? void tmpuecpo1zb.__unittest_L52_C1() [0x427cec]

    ??:? void tmpuecpo1zb.__modtest() [0x428318]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9fb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428e06]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a8a9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a938]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a835]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ddd]

    ??:? runModuleUnitTests [0x42d7d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429570]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n        if(count1\
    \ < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            count2++;\n        else\n            count2--;\n \
    \       if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf1qtzcsm.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x429085]

    ??:? void tmpf1qtzcsm.__unittest_L49_C1() [0x427cc0]

    ??:? void tmpf1qtzcsm.__modtest() [0x4282ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d9d3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428dde]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a881]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a910]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a80d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]

    ??:? runModuleUnitTests [0x42d7a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429548]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42902d]

    ??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]

    ??:? void tmpj3bfejzp.__modtest() [0x428298]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d86]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a829]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8b8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7b5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]

    ??:? runModuleUnitTests [0x42d751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4294f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161275
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1\
    \ ~ s2;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n\
    \            count++;\n        else\n            count--;\n        if(count <\
    \ 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"\
    Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbu1txzlf.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x42903d]

    ??:? void tmpbu1txzlf.__unittest_L40_C1() [0x427e02]

    ??:? void tmpbu1txzlf.__modtest() [0x4282a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d98b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428d96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a839]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8c8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7c5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]

    ??:? runModuleUnitTests [0x42d761]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429500]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    return (c1 + c2 == 0) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2tn6m0lx.d(56): unittest failure

    ----------------

    ??:? _d_unittestp [0x42904d]

    ??:? void tmp2tn6m0lx.__unittest_L43_C1() [0x4280fe]

    ??:? void tmp2tn6m0lx.__modtest() [0x4282b8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42d99b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428da6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a849]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a8d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a7d5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]

    ??:? runModuleUnitTests [0x42d771]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429510]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660161276
