language: d
name: HumanEval_70_strange_sort_list
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\n/*\n    Given a list of integers, return the list\
    \ of integers with the same length,\n    but with the elements in the reverse\
    \ order.\n    Examples:\n    >>> reverse_list([1L, 2L, 3L, 4L])\n    [4L, 3L,\
    \ 2L, 1L]\n    >>> reverse_list([1L])\n    [1L]\n    >>> reverse_list([])\n  \
    \  []\n*/\nlong[] reverse_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[lst.length\
    \ - i - 1];\n    }\n    return res;\n}\n/*\n    Given a list of integers, return\
    \ the list of integers with the same length,\n    but with the elements in the\
    \ reverse order.\n    Examples:\n    >>> reverse_list([1L, 2L, 3L, 4L])\n    [4L,\
    \ 3L, 2L, 1L]\n    >>> reverse_list([1L])\n    [1L]\n    >>> reverse_list([])\n\
    \    []\n*/\nlong[] reverse_list2(long[] lst) \n{\n    long[] res = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[lst.length\
    \ - i - 1];\n    }\n    return res;\n}\n/*\n    Given a list of\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa8orq1k2.d(82): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa8orq1k2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length == 0)\n            break;\n       \
    \ res[i] = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4zb2o_6o.d(27): Error: no property `min` for type `long[]`

    /tmp/tmp4zb2o_6o.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmp4zb2o_6o.d(32): Error: no property `max` for type `long[]`

    /tmp/tmp4zb2o_6o.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4zb2o_6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    int\
    \ i = 0;\n    while (sorted.length > 0)\n    {\n        result[i] = sorted[0];\n\
    \        sorted = sorted[1..$];\n        if (sorted.length > 0)\n        {\n \
    \           result[i+1] = sorted[$-1];\n            sorted = sorted[0..$-2];\n\
    \        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpojxvnwg4.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpojxvnwg4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    auto min = lst[0];\n    auto max = lst[0];\n    foreach\
    \ (i; lst)\n    {\n        min = min(min, i);\n        max = max(max, i);\n  \
    \  }\n    res[0] = min;\n    res[1] = max;\n    int j = 2;\n    foreach (i; lst)\n\
    \    {\n        if (i != min && i != max)\n        {\n            res[j] = i;\n\
    \            j++;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr6trywdn.d(27): Error: function expected before `()`, not `min`
    of type `long`

    /tmp/tmpr6trywdn.d(28): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr6trywdn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc\
    \ = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n          \
    \  res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n  \
    \          res[j] = lst[i];\n            j--;\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu4byattl.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu4byattl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    else\n    {\n \
    \       long min = lst[0];\n        long max = lst[0];\n        for (long i =\
    \ 0; i < lst.length; i++)\n        {\n            if (lst[i] < min)\n        \
    \        min = lst[i];\n            if (lst[i] > max)\n                max = lst[i];\n\
    \        }\n        long[] res = new long[lst.length];\n        long[] lst1 =\
    \ new long[lst.length];\n        long[] lst2 = new long[lst.length];\n       \
    \ long j = 0;\n        long k = 0;\n        for (long i = 0; i < lst.length; i++)\n\
    \        {\n            if (lst[i] != min && lst[i] != max)\n            {\n \
    \               lst1[j] = lst[i];\n                j++;\n            }\n     \
    \       else\n            {\n                lst2[k] = lst[i];\n             \
    \   k++;\n            }\n        }\n        lst1 = lst1[0..j];\n        lst2 =\
    \ lst2[0..k];\n        if (lst1.length == 0)\n            return lst2;\n     \
    \   if (lst2.length == 0)\n            return lst1;\n        long[] lst3 = strange_sort_list(lst1);\n\
    \        long[] lst4 = strange_sort_list(lst2);\n        long[] lst5 = new long[lst3.length\
    \ + lst4.length];\n        long i = 0;\n        j = 0;\n        k = 0;\n     \
    \   while (i < lst3.length && j < lst4.length)\n        {\n            lst5[k]\
    \ = lst3[i];\n            k++;\n            lst5[k] = lst4[j];\n            k++;\n\
    \            i++;\n            j++;\n        }\n        if (i < lst3.length)\n\
    \        {\n            while (i < lst3.length)\n            {\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8r9as3bm.d(76): Error: found `unittest` instead of statement

    /tmp/tmp8r9as3bm.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp8r9as3bm.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp8r9as3bm.d(90): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8r9as3bm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] sorted =\
    \ new long[lst.length];\n    long[] remaining = lst.dup;\n    int i = 0;\n   \
    \ while (remaining.length > 0)\n    {\n        long min = remaining[0];\n    \
    \    long max = remaining[0];\n        foreach (long x; remaining)\n        {\n\
    \            min = min(min, x);\n            max = max(max, x);\n        }\n \
    \       sorted[i] = min;\n        i++;\n        remaining = remaining.remove(min);\n\
    \        if (remaining.length > 0)\n        {\n            sorted[i] = max;\n\
    \            i++;\n            remaining = remaining.remove(max);\n        }\n\
    \    }\n    return sorted;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptlts4pt7.d(31): Error: function expected before `()`, not `min`
    of type `long`

    /tmp/tmptlts4pt7.d(32): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmptlts4pt7.d(36): Error: no property `remove` for type `long[]`

    /tmp/tmptlts4pt7.d(41): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptlts4pt7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    bool asc = true;\n    int i = 0;\n    while (lst.length\
    \ > 0)\n    {\n        long min = lst[0];\n        long max = lst[0];\n      \
    \  foreach (el; lst)\n        {\n            if (el < min)\n                min\
    \ = el;\n            if (el > max)\n                max = el;\n        }\n   \
    \     if (asc)\n        {\n            res[i] = min;\n            lst = lst.filter!(x\
    \ => x != min);\n        }\n        else\n        {\n            res[i] = max;\n\
    \            lst = lst.filter!(x => x != max);\n        }\n        asc = !asc;\n\
    \        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp46ljq39h.d(39): Error: no property `filter` for type `long[]`

    /tmp/tmp46ljq39h.d(44): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp46ljq39h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool flag = true;\n    while (i <= j)\n    {\n    \
    \    if (flag)\n        {\n            result[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            result[j] = lst[i];\n       \
    \     j--;\n        }\n        flag = !flag;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5ux1ou4p.d(22): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ux1ou4p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     long min = lst[0];\n            int min_idx = 0;\n            for (int k\
    \ = 1; k < lst.length; k++)\n            {\n                if (lst[k] < min)\n\
    \                {\n                    min = lst[k];\n                    min_idx\
    \ = k;\n                }\n            }\n            res[i] = min;\n        \
    \    lst[min_idx] = long.max;\n            i++;\n        }\n        else\n   \
    \     {\n            long max = lst[0];\n            int max_idx = 0;\n      \
    \      for (int k = 1; k < lst.length; k++)\n            {\n                if\
    \ (lst[k] > max)\n                {\n                    max = lst[k];\n     \
    \               max_idx = k;\n                }\n            }\n            res[j]\
    \ = max;\n            lst[max_idx] = long.min;\n            j--;\n        }\n\
    \        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp52yq79gs.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp52yq79gs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    auto\
    \ min_idx = 0;\n    auto max_idx = 0;\n    foreach (i; lst)\n    {\n        if\
    \ (lst[i] == min)\n            min_idx = i;\n        if (lst[i] == max)\n    \
    \        max_idx = i;\n    }\n    auto res = new long[](lst.length);\n    res[0]\
    \ = min;\n    res[1] = max;\n    auto idx = 2;\n    auto min_max = true;\n   \
    \ foreach (i; 2..lst.length)\n    {\n        if (min_max)\n        {\n       \
    \     res[idx] = lst[min_idx + i];\n            min_max = false;\n        }\n\
    \        else\n        {\n            res[idx] = lst[max_idx - i];\n         \
    \   min_max = true;\n        }\n        idx++;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7mbo0w7k.d(36): Error: cannot implicitly convert expression `i`
    of type `long` to `int`

    /tmp/tmp7mbo0w7k.d(38): Error: cannot implicitly convert expression `i` of type
    `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7mbo0w7k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = minElement(lst);\n\
    \    auto max = maxElement(lst);\n    long[] res = new long[lst.length];\n   \
    \ int i = 0;\n    while (i < lst.length) \n    {\n        if (i % 2 == 0) \n \
    \       {\n            res[i] = min;\n            min = minElement(lst[i + 1 ..\
    \ $]);\n        }\n        else \n        {\n            res[i] = max;\n     \
    \       max = maxElement(lst[i + 1 .. $]);\n        }\n        i++;\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiv206sey.d(22): Error: undefined identifier `minElement`

    /tmp/tmpiv206sey.d(23): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiv206sey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    int[] idx = new int[lst.length];\n    for (int i = 0; i < lst.length; i++)\
    \ idx[i] = i;\n    idx = idx.sort!((a, b) => lst[a] < lst[b]);\n    bool asc =\
    \ true;\n    for (int i = 0; i < lst.length; i++) {\n        res[i] = lst[idx[i]];\n\
    \        if (asc) idx[i] = idx[i] + 1;\n        else idx[i] = idx[i] - 1;\n  \
    \      if (idx[i] == lst.length) {\n            idx[i] = lst.length - 1;\n   \
    \         asc = false;\n        }\n        if (idx[i] == -1) {\n            idx[i]\
    \ = 0;\n            asc = true;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprsnaspo4.d(24): Error: no property `sort` for type `int[]`

    /tmp/tmprsnaspo4.d(31): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprsnaspo4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    bool\
    \ ascending = true;\n    int index = 0;\n    while (sorted.length > 0)\n    {\n\
    \        if (ascending)\n        {\n            result[index] = sorted[0];\n \
    \           sorted = sorted[1..$];\n        }\n        else\n        {\n     \
    \       result[index] = sorted[$-1];\n            sorted = sorted[0..$-1];\n \
    \       }\n        ascending = !ascending;\n        index++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdlaq2ytn.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdlaq2ytn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag\
    \ = true;\n    while (i <= j)\n    {\n        if (flag)\n        {\n         \
    \   res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n \
    \           res[j] = lst[i];\n            j--;\n        }\n        flag = !flag;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ba8h0fg.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ba8h0fg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    int i\
    \ = 0;\n    while (sorted.length > 0)\n    {\n        res[i] = sorted[0];\n  \
    \      sorted = sorted[1..$];\n        if (sorted.length > 0)\n        {\n   \
    \         res[i+1] = sorted[$-1];\n            sorted = sorted[0..$-2];\n    \
    \    }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk4_ym6c2.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk4_ym6c2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    for (auto i = 1; i < lst.length; i++)\n    {\n  \
    \      if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n\
    \            max = lst[i];\n    }\n    long[] res = new long[lst.length];\n  \
    \  int i = 0;\n    while (i < lst.length)\n    {\n        res[i] = min;\n    \
    \    i++;\n        if (i < lst.length)\n        {\n            res[i] = max;\n\
    \            i++;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcg35zg7v.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x42899d]

    ??:? void tmpcg35zg7v.__unittest_L45_C1() [0x4280ca]

    ??:? void tmpcg35zg7v.__modtest() [0x428720]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca7b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b90e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b99]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431048]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430b25]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8e5]

    ??:? runModuleUnitTests [0x42c851]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e60]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n\
    \    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n        if (el\
    \ < min)\n            min = el;\n        if (el > max)\n            max = el;\n\
    \    }\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        if (i\
    \ % 2 == 0)\n        {\n            res[i] = min;\n            lst_copy = lst_copy.filter!(a\
    \ => a != min);\n            if (lst_copy.length == 0)\n                break;\n\
    \            min = lst_copy[0];\n            foreach (el; lst_copy)\n        \
    \    {\n                if (el < min)\n                    min = el;\n       \
    \     }\n        }\n        else\n        {\n            res[i] = max;\n     \
    \       lst_copy = lst_copy.filter!(a => a != max);\n            if (lst_copy.length\
    \ == 0)\n                break;\n            max = lst_copy[0];\n            foreach\
    \ (el; lst_copy)\n            {\n                if (el > max)\n             \
    \       max = el;\n            }\n        }\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsfrcwc8e.d(39): Error: no property `filter` for type `long[]`

    /tmp/tmpsfrcwc8e.d(52): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsfrcwc8e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            result[i] = lst[lst.minIndex];\n            lst[lst.minIndex] = lst[lst.maxIndex];\n\
    \            lst[lst.maxIndex] = result[i];\n            i++;\n        }\n   \
    \     else\n        {\n            result[j] = lst[lst.maxIndex];\n          \
    \  lst[lst.maxIndex] = lst[lst.minIndex];\n            lst[lst.minIndex] = result[j];\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi86bf3z2.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpi86bf3z2.d(30): Error: no property `minIndex` for type `long[]`

    /tmp/tmpi86bf3z2.d(31): Error: no property `minIndex` for type `long[]`

    /tmp/tmpi86bf3z2.d(32): Error: no property `maxIndex` for type `long[]`

    /tmp/tmpi86bf3z2.d(37): Error: no property `maxIndex` for type `long[]`

    /tmp/tmpi86bf3z2.d(38): Error: no property `maxIndex` for type `long[]`

    /tmp/tmpi86bf3z2.d(39): Error: no property `minIndex` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi86bf3z2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy[0];\n        lst_copy\
    \ = lst_copy[1..$];\n        if (lst_copy.length > 0)\n        {\n           \
    \ res[i + 1] = lst_copy[$ - 1];\n            lst_copy = lst_copy[0..$ - 2];\n\
    \        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpb7gsk7wf.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ab1]

    ??:? void tmpb7gsk7wf.__unittest_L38_C1() [0x42825e]

    ??:? void tmpb7gsk7wf.__modtest() [0x428a28]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42973a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b479]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b508]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b405]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429711]

    ??:? runModuleUnitTests [0x42e4c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fc8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    while (i < lst.length)\n  \
    \  {\n        res[i] = min;\n        i++;\n        if (i < lst.length)\n     \
    \   {\n            res[i] = max;\n            i++;\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp_xqbzjz.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x42892d]

    ??:? void tmpp_xqbzjz.__unittest_L45_C1() [0x428056]

    ??:? void tmpp_xqbzjz.__modtest() [0x4286ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b89e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b875]

    ??:? runModuleUnitTests [0x42c7e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428df0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool inc\
    \ = true;\n    while (i <= j)\n    {\n        if (inc)\n        {\n          \
    \  res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n  \
    \          res[j] = lst[i];\n            j--;\n        }\n        inc = !inc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkbevbl0m.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkbevbl0m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool asc = true;\n  \
    \  foreach (i; 0 .. lst.length)\n    {\n        if (asc)\n        {\n        \
    \    res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n    \
    \    }\n        else\n        {\n            res[i] = lst_copy.max;\n        \
    \    lst_copy.remove(lst_copy.max);\n        }\n        asc = !asc;\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy7gri6rt.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpy7gri6rt.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpy7gri6rt.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpy7gri6rt.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy7gri6rt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    auto\
    \ result = new long[](lst.length);\n    auto step = 1;\n    auto index = 0;\n\
    \    while (index < lst.length)\n    {\n        if (step % 2 == 1)\n        {\n\
    \            auto min_index = 0;\n            foreach (i; lst)\n            {\n\
    \                if (lst[i] == min)\n                {\n                    min_index\
    \ = i;\n                    break;\n                }\n            }\n       \
    \     result[index] = min;\n            lst[min_index] = max + 1;\n        }\n\
    \        else\n        {\n            auto max_index = 0;\n            foreach\
    \ (i; lst)\n            {\n                if (lst[i] == max)\n              \
    \  {\n                    max_index = i;\n                    break;\n       \
    \         }\n            }\n            result[index] = max;\n            lst[max_index]\
    \ = min - 1;\n        }\n        index++;\n        step++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpalgx_wul.d(43): Error: cannot implicitly convert expression `i`
    of type `long` to `int`

    /tmp/tmpalgx_wul.d(57): Error: cannot implicitly convert expression `i` of type
    `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpalgx_wul.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag\
    \ = true;\n    foreach (el; lst)\n    {\n        if (flag)\n        {\n      \
    \      res[i] = el;\n            i++;\n        }\n        else\n        {\n  \
    \          res[j] = el;\n            j--;\n        }\n        flag = !flag;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpixmyvbty.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpixmyvbty.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int\
    \ k = 0;\n    while (i <= j)\n    {\n        if (k % 2 == 0)\n        {\n    \
    \        result[k] = lst[i];\n            i++;\n        }\n        else\n    \
    \    {\n            result[k] = lst[j];\n            j--;\n        }\n       \
    \ k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9c8mags_.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9c8mags_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v1yw48x.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v1yw48x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            result[i] = lst[i];\n            i++;\n        }\n        else\n\
    \        {\n            result[j] = lst[i];\n            j--;\n        }\n   \
    \     is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppys98p3l.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppys98p3l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n \
    \       long min = lst[0];\n        long max = lst[0];\n        foreach (el; lst)\n\
    \        {\n            if (el < min)\n                min = el;\n           \
    \ if (el > max)\n                max = el;\n        }\n        result[i] = min;\n\
    \        i++;\n        if (i == lst.length)\n            break;\n        result[i]\
    \ = max;\n        i++;\n        lst = lst.filter!(x => x != min && x != max);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurq0u5d8.d(41): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurq0u5d8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         res[i] = min(lst_copy);\n            lst_copy.remove(res[i]);\n    \
    \    }\n        else\n        {\n            res[i] = max(lst_copy);\n       \
    \     lst_copy.remove(res[i]);\n        }\n        is_min = !is_min;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpap1ybfh5.d(29): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpap1ybfh5.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpap1ybfh5.d(34): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpap1ybfh5.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpap1ybfh5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length > 0)\n        {\n            res[i]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwljge84z.d(27): Error: no property `min` for type `long[]`

    /tmp/tmpwljge84z.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpwljge84z.d(32): Error: no property `max` for type `long[]`

    /tmp/tmpwljge84z.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwljge84z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    auto minmax = minmaxElement(lst);\n    res[0] = minmax.min;\n\
    \    res[1] = minmax.max;\n    int i = 2;\n    int j = 0;\n    while (i < lst.length)\n\
    \    {\n        if (j % 2 == 0)\n        {\n            res[i] = lst[j];\n   \
    \         i++;\n        }\n        j++;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcdan783o.d(23): Error: undefined identifier `minmaxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcdan783o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        if (lst_copy.length > 0)\n        {\n            res[i+1] = lst_copy.max;\n\
    \            lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnem_is43.d(27): Error: no property `min` for type `long[]`

    /tmp/tmpnem_is43.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpnem_is43.d(31): Error: no property `max` for type `long[]`

    /tmp/tmpnem_is43.d(32): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnem_is43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    while (lst.length != 0)\n    {\n    \
    \    res[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length == 0)\n\
    \            break;\n        res[i + 1] = lst[$ - 1];\n        lst = lst[0..$\
    \ - 1];\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoum_6wuq.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmpoum_6wuq.__unittest_L36_C1() [0x4282bb]

    ??:? void tmpoum_6wuq.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    bool asc = true;\n    int i = 0;\n    while (lst.length\
    \ > 0)\n    {\n        if (asc)\n        {\n            res[i] = lst[0];\n   \
    \         lst = lst[1..$];\n        }\n        else\n        {\n            res[i]\
    \ = lst[$-1];\n            lst = lst[0..$-1];\n        }\n        i++;\n     \
    \   asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppej6r1o0.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmppej6r1o0.__unittest_L42_C1() [0x4282bf]

    ??:? void tmppej6r1o0.__modtest() [0x4286c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n\
    \        if (e < min) min = e;\n        if (e > max) max = e;\n    }\n    bool\
    \ is_min = true;\n    int i = 0;\n    while (i < lst.length)\n    {\n        if\
    \ (is_min)\n        {\n            res[i] = min;\n            lst = lst.filter!(x\
    \ => x != min);\n            min = lst[0];\n            foreach (e; lst)\n   \
    \         {\n                if (e < min) min = e;\n            }\n        }\n\
    \        else\n        {\n            res[i] = max;\n            lst = lst.filter!(x\
    \ => x != max);\n            max = lst[0];\n            foreach (e; lst)\n   \
    \         {\n                if (e > max) max = e;\n            }\n        }\n\
    \        is_min = !is_min;\n        i++;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc8k1axmd.d(36): Error: no property `filter` for type `long[]`

    /tmp/tmpc8k1axmd.d(46): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc8k1axmd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp_atkmes.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpp_atkmes.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpp_atkmes.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpp_atkmes.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp_atkmes.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            long min = lst[0];\n            int min_index = 0;\n            for\
    \ (int k = 0; k < lst.length; k++)\n            {\n                if (lst[k]\
    \ < min)\n                {\n                    min = lst[k];\n             \
    \       min_index = k;\n                }\n            }\n            result[i]\
    \ = min;\n            lst[min_index] = long.max;\n            i++;\n        }\n\
    \        else\n        {\n            long max = lst[0];\n            int max_index\
    \ = 0;\n            for (int k = 0; k < lst.length; k++)\n            {\n    \
    \            if (lst[k] > max)\n                {\n                    max = lst[k];\n\
    \                    max_index = k;\n                }\n            }\n      \
    \      result[j] = max;\n            lst[max_index] = long.min;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8p0uznrb.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8p0uznrb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag\
    \ = true;\n    while (i <= j)\n    {\n        if (flag)\n        {\n         \
    \   res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n \
    \           res[j] = lst[i];\n            j--;\n        }\n        flag = !flag;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ba8h0fg.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ba8h0fg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    bool\
    \ is_min = true;\n    foreach (i, e; lst)\n    {\n        if (is_min)\n      \
    \  {\n            result[i] = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            result[i] = sorted[$-1];\n  \
    \          sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_vm2f6u.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_vm2f6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         result[i] = min(copy);\n            copy.remove(result[i]);\n      \
    \  }\n        else\n        {\n            result[i] = max(copy);\n          \
    \  copy.remove(result[i]);\n        }\n        is_min = !is_min;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgt28lb7d.d(29): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpgt28lb7d.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpgt28lb7d.d(34): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpgt28lb7d.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgt28lb7d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    lst_copy.sort;\n    bool\
    \ asc = true;\n    foreach (i, ref elem; res)\n    {\n        if (asc)\n     \
    \   {\n            elem = lst_copy[0];\n            lst_copy = lst_copy[1..$];\n\
    \        }\n        else\n        {\n            elem = lst_copy[$-1];\n     \
    \       lst_copy = lst_copy[0..$-1];\n        }\n        asc = !asc;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxu_0morz.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxu_0morz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n \
    \       result[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length\
    \ == 0)\n            break;\n        result[i+1] = lst[$-1];\n        lst = lst[0..$-1];\n\
    \        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplyxxbdkc.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmplyxxbdkc.__unittest_L36_C1() [0x4282bb]

    ??:? void tmplyxxbdkc.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int[] idx = new int[lst.length];\n    for (int i = 0;\
    \ i < lst.length; i++)\n        idx[i] = i;\n    idx.sort!((a, b) => lst[a] <\
    \ lst[b]);\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while\
    \ (i <= j)\n    {\n        res[k++] = lst[idx[i++]];\n        if (i <= j)\n  \
    \          res[k++] = lst[idx[j--]];\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi98e27dr.d(26): Error: no property `sort` for type `int[]`

    /tmp/tmpi98e27dr.d(28): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi98e27dr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] tmp = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         result[i] = tmp.min;\n            tmp = tmp.filter!(a => a != tmp.min);\n\
    \        }\n        else\n        {\n            result[i] = tmp.max;\n      \
    \      tmp = tmp.filter!(a => a != tmp.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptqazlguv.d(29): Error: no property `min` for type `long[]`

    /tmp/tmptqazlguv.d(30): Error: no property `filter` for type `long[]`

    /tmp/tmptqazlguv.d(34): Error: no property `max` for type `long[]`

    /tmp/tmptqazlguv.d(35): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptqazlguv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = minElement(lst);\n\
    \    auto max = maxElement(lst);\n    long[] res = new long[lst.length];\n   \
    \ int i = 0;\n    while (i < lst.length)\n    {\n        res[i] = min;\n     \
    \   min = max;\n        max = minElement(lst);\n        i++;\n        if (i <\
    \ lst.length)\n        {\n            res[i] = max;\n            max = min;\n\
    \            min = minElement(lst);\n            i++;\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp97xs6ams.d(22): Error: undefined identifier `minElement`

    /tmp/tmp97xs6ams.d(23): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp97xs6ams.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst2 = lst.dup;\n    long min = lst2[0];\n   \
    \ long max = lst2[0];\n    foreach (i; lst2)\n    {\n        if (i < min)\n  \
    \          min = i;\n        if (i > max)\n            max = i;\n    }\n    res[0]\
    \ = min;\n    lst2.remove(min);\n    res[1] = max;\n    lst2.remove(max);\n  \
    \  int i = 2;\n    while (lst2.length != 0)\n    {\n        min = lst2[0];\n \
    \       max = lst2[0];\n        foreach (i; lst2)\n        {\n            if (i\
    \ < min)\n                min = i;\n            if (i > max)\n               \
    \ max = i;\n        }\n        res[i] = min;\n        lst2.remove(min);\n    \
    \    i++;\n        res[i] = max;\n        lst2.remove(max);\n        i++;\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa40_enby.d(34): Error: no property `remove` for type `long[]`

    /tmp/tmpa40_enby.d(36): Error: no property `remove` for type `long[]`

    /tmp/tmpa40_enby.d(42): Error: variable `i` is shadowing variable `tmpa40_enby.strange_sort_list.i`

    /tmp/tmpa40_enby.d(50): Error: no property `remove` for type `long[]`

    /tmp/tmpa40_enby.d(53): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa40_enby.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long min = min(lst);\n\
    \    long max = max(lst);\n    long[] result = new long[lst.length];\n    bool\
    \ is_min = true;\n    int i = 0;\n    while (i < lst.length)\n    {\n        if\
    \ (is_min)\n        {\n            result[i] = min;\n            lst = lst.filter!(x\
    \ => x != min);\n            is_min = false;\n        }\n        else\n      \
    \  {\n            result[i] = max;\n            lst = lst.filter!(x => x != max);\n\
    \            is_min = true;\n        }\n        i++;\n        if (lst.length ==\
    \ 0)\n            break;\n        min = min(lst);\n        max = max(lst);\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphsh0sjdc.d(22): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmphsh0sjdc.d(23): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmphsh0sjdc.d(32): Error: no property `filter` for type `long[]`

    /tmp/tmphsh0sjdc.d(38): Error: no property `filter` for type `long[]`

    /tmp/tmphsh0sjdc.d(44): Error: function expected before `()`, not `min` of type
    `long`

    /tmp/tmphsh0sjdc.d(45): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphsh0sjdc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = min(lst);\n            lst.remove(res[i]);\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = max(lst);\n        \
    \    lst.remove(res[j]);\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg58mad5g.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpg58mad5g.d(30): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpg58mad5g.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmpg58mad5g.d(36): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpg58mad5g.d(37): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg58mad5g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    int[] idx = new int[lst.length];\n    for (int i = 0; i < lst.length; i++)\n\
    \        idx[i] = i;\n    idx.sort!((a, b) => lst[a] < lst[b]);\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    while (i <= j)\n    {\n        res[idx[i]] =\
    \ lst[idx[i]];\n        if (i != j)\n            res[idx[j]] = lst[idx[j]];\n\
    \        i++;\n        j--;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1sd8ew8y.d(25): Error: no property `sort` for type `int[]`

    /tmp/tmp1sd8ew8y.d(27): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1sd8ew8y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k =\
    \ 0;\n    while (i <= j)\n    {\n        if (k % 2 == 0)\n        {\n        \
    \    res[k] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[k] = lst[j];\n            j--;\n        }\n        k++;\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcii1g_vo.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcii1g_vo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n     \
    \   res[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length == 0)\n\
    \            break;\n        res[i+1] = lst[$-1];\n        lst = lst[0..$-1];\n\
    \        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmfttf8ge.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmpmfttf8ge.__unittest_L36_C1() [0x4282bb]

    ??:? void tmpmfttf8ge.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc\
    \ = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n          \
    \  res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n  \
    \          res[j] = lst[i];\n            j--;\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu4byattl.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu4byattl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = min(lst);\n\
    \    auto max = max(lst);\n    long[] res = new long[lst.length];\n    bool is_min\
    \ = true;\n    int i = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = min;\n            lst = lst.filter!(x => x !=\
    \ min);\n        }\n        else\n        {\n            res[i] = max;\n     \
    \       lst = lst.filter!(x => x != max);\n        }\n        is_min = !is_min;\n\
    \        i++;\n        min = min(lst);\n        max = max(lst);\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1bf4zb50.d(22): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp1bf4zb50.d(23): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp1bf4zb50.d(32): Error: no property `filter` for type `long[]`

    /tmp/tmp1bf4zb50.d(37): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1bf4zb50.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long min = lst[0];\n\
    \    long max = lst[0];\n    foreach (e; lst)\n    {\n        if (e < min)\n \
    \           min = e;\n        if (e > max)\n            max = e;\n    }\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n    \
    \    {\n            res[i] = min;\n            is_min = false;\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = max;\n            is_min\
    \ = true;\n            j--;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfimi23l7.d(33): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfimi23l7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k =\
    \ 0;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n\
    \        {\n            res[k] = min(lst[i], lst[j]);\n            if (lst[i]\
    \ < lst[j])\n                i++;\n            else\n                j--;\n  \
    \      }\n        else\n        {\n            res[k] = max(lst[i], lst[j]);\n\
    \            if (lst[i] > lst[j])\n                i++;\n            else\n  \
    \              j--;\n        }\n        is_min = !is_min;\n        k++;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9_70cj5h.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp9_70cj5h.d(31): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp9_70cj5h.d(39): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_70cj5h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] remaining = lst.dup;\n    long min = remaining[0];\n\
    \    long max = remaining[0];\n    for (long i = 0; i < remaining.length; i++)\n\
    \    {\n        if (remaining[i] < min)\n            min = remaining[i];\n   \
    \     if (remaining[i] > max)\n            max = remaining[i];\n    }\n    int\
    \ j = 0;\n    while (remaining.length > 0)\n    {\n        result[j] = min;\n\
    \        remaining = remaining.remove(min);\n        if (remaining.length == 0)\n\
    \            break;\n        result[j + 1] = max;\n        remaining = remaining.remove(max);\n\
    \        j += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp891rhrsg.d(37): Error: no property `remove` for type `long[]`

    /tmp/tmp891rhrsg.d(41): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp891rhrsg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpazqhhkfp.d(28): Error: no property `min` for type `long[]`

    /tmp/tmpazqhhkfp.d(29): Error: no property `remove` for type `long[]`

    /tmp/tmpazqhhkfp.d(33): Error: no property `max` for type `long[]`

    /tmp/tmpazqhhkfp.d(34): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpazqhhkfp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    else\n    {\n \
    \       long min = min(lst);\n        long max = max(lst);\n        long[] result\
    \ = new long[lst.length];\n        int i = 0;\n        int j = lst.length - 1;\n\
    \        bool is_min = true;\n        foreach (e; lst)\n        {\n          \
    \  if (is_min)\n            {\n                if (e == min)\n               \
    \ {\n                    result[i] = e;\n                    i++;\n          \
    \          is_min = false;\n                }\n            }\n            else\n\
    \            {\n                if (e == max)\n                {\n           \
    \         result[j] = e;\n                    j--;\n                    is_min\
    \ = true;\n                }\n            }\n        }\n        return result;\n\
    \    }\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2zc1iiy4.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp2zc1iiy4.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp2zc1iiy4.d(28): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2zc1iiy4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    auto minmax = minmaxElement(lst);\n    bool is_min\
    \ = true;\n    int i = 0;\n    while (lst.length != 0)\n    {\n        if (is_min)\n\
    \        {\n            result[i] = minmax.min;\n            lst = lst.filter!(x\
    \ => x != minmax.min);\n        }\n        else\n        {\n            result[i]\
    \ = minmax.max;\n            lst = lst.filter!(x => x != minmax.max);\n      \
    \  }\n        minmax = minmaxElement(lst);\n        is_min = !is_min;\n      \
    \  i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprk3p3u7p.d(23): Error: undefined identifier `minmaxElement`

    /tmp/tmprk3p3u7p.d(31): Error: no property `filter` for type `long[]`

    /tmp/tmprk3p3u7p.d(36): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprk3p3u7p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool asc = true;\n  \
    \  size_t i = 0;\n    while (lst_copy.length > 0)\n    {\n        auto min_max\
    \ = asc ? lst_copy.min : lst_copy.max;\n        res[i] = min_max;\n        lst_copy.remove(min_max);\n\
    \        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp7zybc8z.d(28): Error: no property `min` for type `long[]`

    /tmp/tmpp7zybc8z.d(28): Error: no property `max` for type `long[]`

    /tmp/tmpp7zybc8z.d(30): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp7zybc8z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n    int\
    \ i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i <= j)\n\
    \    {\n        res[k++] = sorted[i++];\n        if (i <= j)\n            res[k++]\
    \ = sorted[j--];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqc1l9p0v.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmpqc1l9p0v.d(26): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqc1l9p0v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n   \
    \     if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n\
    \            max = lst[i];\n    }\n    long[] res = new long[lst.length];\n  \
    \  int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n\
    \    {\n        res[k++] = min;\n        if (i == j)\n            break;\n   \
    \     res[k++] = max;\n        i++;\n        j--;\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpipn4vk70.d(33): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpipn4vk70.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    bool is_min = true;\n    long min = lst[0];\n    long\
    \ max = lst[0];\n    for (long i = 0; i < lst.length; i++)\n    {\n        if\
    \ (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n     \
    \       max = lst[i];\n    }\n    long[] lst_copy = lst.dup;\n    int index =\
    \ 0;\n    while (lst_copy.length > 0)\n    {\n        if (is_min)\n        {\n\
    \            res[index] = min;\n            lst_copy = lst_copy.filter!(x => x\
    \ != min);\n            if (lst_copy.length > 0)\n                min = lst_copy[0];\n\
    \            for (long i = 0; i < lst_copy.length; i++)\n            {\n     \
    \           if (lst_copy[i] < min)\n                    min = lst_copy[i];\n \
    \           }\n        }\n        else\n        {\n            res[index] = max;\n\
    \            lst_copy = lst_copy.filter!(x => x != max);\n            if (lst_copy.length\
    \ > 0)\n                max = lst_copy[0];\n            for (long i = 0; i < lst_copy.length;\
    \ i++)\n            {\n                if (lst_copy[i] > max)\n              \
    \      max = lst_copy[i];\n            }\n        }\n        is_min = !is_min;\n\
    \        index++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpogvy7pxr.d(40): Error: no property `filter` for type `long[]`

    /tmp/tmpogvy7pxr.d(52): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogvy7pxr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    else\n    {\n \
    \       long min = min(lst);\n        long max = max(lst);\n        long[] result\
    \ = new long[lst.length];\n        int i = 0;\n        while (i < lst.length)\n\
    \        {\n            if (i % 2 == 0)\n            {\n                result[i]\
    \ = min;\n                lst = lst.filter!(x => x != min);\n            }\n \
    \           else\n            {\n                result[i] = max;\n          \
    \      lst = lst.filter!(x => x != max);\n            }\n            i++;\n  \
    \      }\n        return result;\n    }\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0zbnfi32.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmp0zbnfi32.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp0zbnfi32.d(33): Error: no property `filter` for type `long[]`

    /tmp/tmp0zbnfi32.d(38): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0zbnfi32.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i\
    \ <= j)\n    {\n        res[i] = lst[i];\n        if (i != j)\n            res[j]\
    \ = lst[j];\n        i++;\n        j--;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuapga_26.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuapga_26.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            result[i] = lst[lst.minIndex];\n            lst[lst.minIndex] = lst[j];\n\
    \            lst[j] = result[i];\n            i++;\n        }\n        else\n\
    \        {\n            result[j] = lst[lst.maxIndex];\n            lst[lst.maxIndex]\
    \ = lst[i];\n            lst[i] = result[j];\n            j--;\n        }\n  \
    \      is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9udmfc32.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp9udmfc32.d(30): Error: no property `minIndex` for type `long[]`

    /tmp/tmp9udmfc32.d(31): Error: no property `minIndex` for type `long[]`

    /tmp/tmp9udmfc32.d(37): Error: no property `maxIndex` for type `long[]`

    /tmp/tmp9udmfc32.d(38): Error: no property `maxIndex` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9udmfc32.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc\
    \ = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n          \
    \  res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n  \
    \          res[j] = lst[i];\n            j--;\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu4byattl.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu4byattl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (el; lst)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    res[i++] = min;\n  \
    \  if (lst.length == 1)\n        return res;\n    res[i++] = max;\n    if (lst.length\
    \ == 2)\n        return res;\n    long[] lst_ = lst.dup;\n    lst_.remove(min);\n\
    \    lst_.remove(max);\n    while (lst_.length > 0)\n    {\n        min = lst_[0];\n\
    \        max = lst_[0];\n        foreach (el; lst_)\n        {\n            if\
    \ (el < min)\n                min = el;\n            if (el > max)\n         \
    \       max = el;\n        }\n        res[i++] = min;\n        if (lst_.length\
    \ == 1)\n            break;\n        res[i++] = max;\n        if (lst_.length\
    \ == 2)\n            break;\n        lst_.remove(min);\n        lst_.remove(max);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkxfblgb2.d(40): Error: no property `remove` for type `long[]`

    /tmp/tmpkxfblgb2.d(41): Error: no property `remove` for type `long[]`

    /tmp/tmpkxfblgb2.d(59): Error: no property `remove` for type `long[]`

    /tmp/tmpkxfblgb2.d(60): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkxfblgb2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    int\
    \ i = 0;\n    int j = sorted.length - 1;\n    while (i < j)\n    {\n        result[i]\
    \ = sorted[i];\n        result[j] = sorted[j];\n        i++;\n        j--;\n \
    \   }\n    if (i == j)\n        result[i] = sorted[i];\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmli3jto8.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmpmli3jto8.d(26): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmli3jto8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v1yw48x.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v1yw48x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_sorted = lst.dup;\n    lst_sorted.sort;\n\
    \    long[] lst_sorted_rev = lst_sorted.dup;\n    lst_sorted_rev.reverse;\n  \
    \  bool flag = true;\n    foreach (i, e; lst)\n    {\n        if (flag)\n    \
    \    {\n            res[i] = lst_sorted[0];\n            lst_sorted = lst_sorted[1..$];\n\
    \        }\n        else\n        {\n            res[i] = lst_sorted_rev[0];\n\
    \            lst_sorted_rev = lst_sorted_rev[1..$];\n        }\n        flag =\
    \ !flag;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxk171q40.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmpxk171q40.d(26): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxk171q40.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    long[] res = new\
    \ long[lst.length];\n    long min = lst[0];\n    long max = lst[0];\n    foreach\
    \ (el; lst)\n    {\n        if (el < min)\n            min = el;\n        if (el\
    \ > max)\n            max = el;\n    }\n    long[] lst_sorted = lst.dup;\n   \
    \ lst_sorted.sort;\n    bool is_min = true;\n    int i = 0;\n    while (lst_sorted.length\
    \ > 0)\n    {\n        if (is_min)\n        {\n            res[i] = lst_sorted[0];\n\
    \            lst_sorted = lst_sorted[1..$];\n        }\n        else\n       \
    \ {\n            res[i] = lst_sorted[$-1];\n            lst_sorted = lst_sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp07eoh91e.d(33): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp07eoh91e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    auto min_max = minmax(lst);\n    long min = min_max[0];\n    long\
    \ max = min_max[1];\n    long[] res = new long[lst.length];\n    bool is_min =\
    \ true;\n    int i = 0;\n    while (lst.length > 0) \n    {\n        if (is_min)\
    \ \n        {\n            res[i] = min;\n            lst = lst.filter!(x => x\
    \ != min);\n            min_max = minmax(lst);\n            min = min_max[0];\n\
    \            max = min_max[1];\n        } \n        else \n        {\n       \
    \     res[i] = max;\n            lst = lst.filter!(x => x != max);\n         \
    \   min_max = minmax(lst);\n            min = min_max[0];\n            max = min_max[1];\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcps284ew.d(20): Error: undefined identifier `minmax`

    /tmp/tmpcps284ew.d(31): Error: no property `filter` for type `long[]`

    /tmp/tmpcps284ew.d(39): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcps284ew.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n \
    \       result[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length\
    \ > 0)\n        {\n            result[i + 1] = lst[$ - 1];\n            lst =\
    \ lst[0..$ - 1];\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8lnbcmhl.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmp8lnbcmhl.__unittest_L37_C1() [0x4282bb]

    ??:? void tmp8lnbcmhl.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428d87]

    ??:? _d_run_main [0x428cf2]

    ??:? main [0x4286cf]

    ??:? __libc_start_main [0x526cf554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int[] idx = new int[lst.length];\n    for (int i = 0;\
    \ i < lst.length; i++)\n        idx[i] = i;\n    idx.sort!((a, b) => lst[a] <\
    \ lst[b]);\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while\
    \ (i <= j)\n    {\n        res[k++] = lst[idx[i++]];\n        if (i <= j)\n  \
    \          res[k++] = lst[idx[j--]];\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi98e27dr.d(26): Error: no property `sort` for type `int[]`

    /tmp/tmpi98e27dr.d(28): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi98e27dr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    else\n    {\n \
    \       long[] result = new long[lst.length];\n        long[] sorted = lst.dup.sort;\n\
    \        bool is_min = true;\n        foreach (i, e; sorted)\n        {\n    \
    \        if (is_min)\n            {\n                result[i] = e;\n        \
    \        is_min = false;\n            }\n            else\n            {\n   \
    \             result[lst.length - i - 1] = e;\n                is_min = true;\n\
    \            }\n        }\n        return result;\n    }\n}\nunittest\n{\n   \
    \ alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L])\
    \ == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L,\
    \ 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L,\
    \ 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7hbr4r88.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7hbr4r88.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            result[i] = lst[i];\n            i++;\n        }\n        else\n\
    \        {\n            result[j] = lst[i];\n            j--;\n        }\n   \
    \     is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppys98p3l.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppys98p3l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n     \
    \   long min = min(lst);\n        long max = max(lst);\n        res[i] = min;\n\
    \        res[i + 1] = max;\n        lst = lst.filter!(x => x != min && x != max);\n\
    \        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj5jp_k0f.d(26): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpj5jp_k0f.d(27): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpj5jp_k0f.d(30): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj5jp_k0f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ min = true;\n    while (i <= j)\n    {\n        if (min)\n        {\n      \
    \      result[i] = min(lst);\n            lst = remove(lst, result[i]);\n    \
    \        i++;\n        }\n        else\n        {\n            result[j] = max(lst);\n\
    \            lst = remove(lst, result[j]);\n            j--;\n        }\n    \
    \    min = !min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc2rqmcjq.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpc2rqmcjq.d(30): Error: function expected before `()`, not `min` of type
    `bool`

    /tmp/tmpc2rqmcjq.d(31): Error: undefined identifier `remove`

    /tmp/tmpc2rqmcjq.d(36): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpc2rqmcjq.d(37): Error: undefined identifier `remove`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc2rqmcjq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    auto\
    \ min_lst = lst.filter!(a => a == min).array;\n    auto max_lst = lst.filter!(a\
    \ => a == max).array;\n    auto mid_lst = lst.filter!(a => a != min && a != max).array;\n\
    \    auto mid_lst_sorted = mid_lst.sort!((a, b) => a > b);\n    auto mid_lst_sorted_min\
    \ = mid_lst_sorted.filter!(a => a == mid_lst_sorted[0]).array;\n    auto mid_lst_sorted_max\
    \ = mid_lst_sorted.filter!(a => a == mid_lst_sorted[$ - 1]).array;\n    auto mid_lst_sorted_mid\
    \ = mid_lst_sorted.filter!(a => a != mid_lst_sorted[0] && a != mid_lst_sorted[$\
    \ - 1]).array;\n    auto mid_lst_sorted_mid_sorted = mid_lst_sorted_mid.sort!((a,\
    \ b) => a > b);\n    auto mid_lst_sorted_mid_sorted_min = mid_lst_sorted_mid_sorted.filter!(a\
    \ => a == mid_lst_sorted_mid_sorted[0]).array;\n    auto mid_lst_sorted_mid_sorted_max\
    \ = mid_lst_sorted_mid_sorted.filter!(a => a == mid_lst_sorted_mid_sorted[$ -\
    \ 1]).array;\n    auto mid_lst_sorted_mid_sorted_mid = mid_lst_sorted_mid_sorted.filter!(a\
    \ => a != mid_lst_s\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdd5yz5wt.d(42): Error: found `unittest` when expecting `)` following
    template argument list

    /tmp/tmpdd5yz5wt.d(43): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmpdd5yz5wt.d(56): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdd5yz5wt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_even = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_even)\n        {\n  \
    \          result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_even = !is_even;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpozf772ww.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpozf772ww.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpozf772ww.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpozf772ww.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozf772ww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ long[] result = new long[lst.length];\n    int i = 0;\n    bool is_min = true;\n\
    \    while (lst.length > 0) \n    {\n        if (is_min) \n        {\n       \
    \     result[i] = min(lst);\n        } \n        else \n        {\n          \
    \  result[i] = max(lst);\n        }\n        lst = remove(lst, result[i]);\n \
    \       i++;\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd8a7q7y4.d(31): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpd8a7q7y4.d(35): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpd8a7q7y4.d(37): Error: undefined identifier `remove`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd8a7q7y4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    auto minmax = minmaxElement(lst);\n    bool is_min\
    \ = true;\n    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n    \
    \    {\n            result[i] = minmax.min;\n            is_min = false;\n   \
    \     }\n        else\n        {\n            result[i] = minmax.max;\n      \
    \      is_min = true;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4geldka9.d(23): Error: undefined identifier `minmaxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4geldka9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[lst.minIndex];\n            lst[lst.minIndex] = lst[j];\n \
    \           lst[j] = res[i];\n            i++;\n        }\n        else\n    \
    \    {\n            res[j] = lst[lst.maxIndex];\n            lst[lst.maxIndex]\
    \ = lst[i];\n            lst[i] = res[j];\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjyevxoda.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpjyevxoda.d(30): Error: no property `minIndex` for type `long[]`

    /tmp/tmpjyevxoda.d(31): Error: no property `minIndex` for type `long[]`

    /tmp/tmpjyevxoda.d(37): Error: no property `maxIndex` for type `long[]`

    /tmp/tmpjyevxoda.d(38): Error: no property `maxIndex` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjyevxoda.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6j2m9qfq.d(29): Error: no property `min` for type `long[]`

    /tmp/tmp6j2m9qfq.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmp6j2m9qfq.d(34): Error: no property `max` for type `long[]`

    /tmp/tmp6j2m9qfq.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6j2m9qfq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int\
    \ k = 0;\n    while (i <= j)\n    {\n        result[k++] = lst[i++];\n       \
    \ if (i <= j)\n            result[k++] = lst[j--];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5alyqncf.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5alyqncf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag\
    \ = true;\n    foreach (e; lst)\n    {\n        if (flag)\n        {\n       \
    \     res[i] = e;\n            i++;\n        }\n        else\n        {\n    \
    \        res[j] = e;\n            j--;\n        }\n        flag = !flag;\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmc6ok09z.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmc6ok09z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    else\n    {\n \
    \       long min = lst[0];\n        long max = lst[0];\n        foreach (e; lst)\n\
    \        {\n            if (e < min)\n                min = e;\n            if\
    \ (e > max)\n                max = e;\n        }\n        long[] result = new\
    \ long[lst.length];\n        bool isMin = true;\n        long minIndex = 0;\n\
    \        long maxIndex = lst.length - 1;\n        foreach (e; lst)\n        {\n\
    \            if (isMin)\n            {\n                result[minIndex] = min;\n\
    \                minIndex++;\n            }\n            else\n            {\n\
    \                result[maxIndex] = max;\n                maxIndex--;\n      \
    \      }\n            isMin = !isMin;\n        }\n        return result;\n   \
    \ }\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfmxdtww4.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x4289a5]

    ??:? void tmpfmxdtww4.__unittest_L54_C1() [0x4280ce]

    ??:? void tmpfmxdtww4.__modtest() [0x428724]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430ba1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431050]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430b2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8ed]

    ??:? runModuleUnitTests [0x42c859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e68]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k =\
    \ 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n        if (i <=\
    \ j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpymx2bvfr.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymx2bvfr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] ret = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag\
    \ = true;\n    foreach (e; lst)\n    {\n        if (flag)\n        {\n       \
    \     ret[i] = e;\n            i++;\n        }\n        else\n        {\n    \
    \        ret[j] = e;\n            j--;\n        }\n        flag = !flag;\n   \
    \ }\n    return ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_wxjtvzb.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_wxjtvzb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        if (is_min)\n      \
    \  {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr07cxpi9.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpr07cxpi9.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpr07cxpi9.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpr07cxpi9.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr07cxpi9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    else\n    {\n \
    \       long min = lst[0];\n        long max = lst[0];\n        for (long i =\
    \ 0; i < lst.length; i++)\n        {\n            if (lst[i] < min)\n        \
    \        min = lst[i];\n            if (lst[i] > max)\n                max = lst[i];\n\
    \        }\n        long[] new_lst = new long[lst.length];\n        long[] lst_min\
    \ = new long[lst.length];\n        long[] lst_max = new long[lst.length];\n  \
    \      long j = 0;\n        long k = 0;\n        for (long i = 0; i < lst.length;\
    \ i++)\n        {\n            if (lst[i] != min && lst[i] != max)\n         \
    \   {\n                new_lst[i] = lst[i];\n            }\n            else if\
    \ (lst[i] == min)\n            {\n                lst_min[j] = lst[i];\n     \
    \           j++;\n            }\n            else if (lst[i] == max)\n       \
    \     {\n                lst_max[k] = lst[i];\n                k++;\n        \
    \    }\n        }\n        long[] lst_min_sorted = new long[j];\n        long[]\
    \ lst_max_sorted = new long[k];\n        for (long i = 0; i < j; i++)\n      \
    \  {\n            lst_min_sorted[i] = lst_min[i];\n        }\n        for (long\
    \ i = 0; i < k; i++)\n        {\n            lst_max_sorted[i] = lst_max[i];\n\
    \        }\n        lst_min_sorted.sort();\n        lst_max_sorted.sort();\n \
    \       long[] lst_min_sorted_reversed = new long[j];\n        long[] lst_max_sorted_reversed\
    \ = new long[k];\n        for (long i = 0; i < j;\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuzfu_6bt.d(70): Error: expression expected, not `unittest`

    /tmp/tmpuzfu_6bt.d(71): Error: found `{` when expecting `)`

    /tmp/tmpuzfu_6bt.d(84): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuzfu_6bt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    auto min = lst[0];\n    auto max = lst[0];\n    foreach\
    \ (i; lst)\n    {\n        if (i < min)\n            min = i;\n        if (i >\
    \ max)\n            max = i;\n    }\n    auto min_index = 0;\n    auto max_index\
    \ = lst.length - 1;\n    bool is_min = true;\n    foreach (i; lst)\n    {\n  \
    \      if (is_min)\n        {\n            res[min_index] = i;\n            min_index++;\n\
    \        }\n        else\n        {\n            res[max_index] = i;\n       \
    \     max_index--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbr_6yfy4.d(55): unittest failure

    ----------------

    ??:? _d_unittestp [0x4289a5]

    ??:? void tmpbr_6yfy4.__unittest_L51_C1() [0x4280d2]

    ??:? void tmpbr_6yfy4.__modtest() [0x428728]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430ba1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431050]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430b2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8ed]

    ??:? runModuleUnitTests [0x42c859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e68]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    long min_max;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if\
    \ (is_min)\n        {\n            min_max = lst_copy[0];\n            for (int\
    \ j = 0; j < lst_copy.length; j++)\n            {\n                if (lst_copy[j]\
    \ < min_max)\n                    min_max = lst_copy[j];\n            }\n    \
    \    }\n        else\n        {\n            min_max = lst_copy[0];\n        \
    \    for (int j = 0; j < lst_copy.length; j++)\n            {\n              \
    \  if (lst_copy[j] > min_max)\n                    min_max = lst_copy[j];\n  \
    \          }\n        }\n        result[i] = min_max;\n        lst_copy = lst_copy.filter!(x\
    \ => x != min_max);\n        is_min = !is_min;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzri_e1uc.d(47): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzri_e1uc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    int\
    \ i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i <= j)\n\
    \    {\n        result[k] = sorted[i];\n        i++;\n        k++;\n        if\
    \ (i <= j)\n        {\n            result[k] = sorted[j];\n            j--;\n\
    \            k++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxwvexn6e.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmpxwvexn6e.d(26): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxwvexn6e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k =\
    \ 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n        if (i <=\
    \ j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpymx2bvfr.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymx2bvfr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag\
    \ = true;\n    foreach (e; lst)\n    {\n        if (flag)\n        {\n       \
    \     res[i] = e;\n            i++;\n        }\n        else\n        {\n    \
    \        res[j] = e;\n            j--;\n        }\n        flag = !flag;\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmc6ok09z.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmc6ok09z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp_atkmes.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpp_atkmes.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpp_atkmes.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpp_atkmes.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp_atkmes.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n     \
    \   res[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length > 0)\n\
    \        {\n            res[i+1] = lst[$-1];\n            lst = lst[0..$-1];\n\
    \        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_x7is55b.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmp_x7is55b.__unittest_L37_C1() [0x4282bb]

    ??:? void tmp_x7is55b.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] sorted =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            sorted[i] = lst[lst.minIndex];\n            lst[lst.minIndex] = lst[lst.maxIndex];\n\
    \            i++;\n        }\n        else\n        {\n            sorted[j] =\
    \ lst[lst.maxIndex];\n            lst[lst.maxIndex] = lst[lst.minIndex];\n   \
    \         j--;\n        }\n        is_min = !is_min;\n    }\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv74v404o.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpv74v404o.d(30): Error: no property `minIndex` for type `long[]`

    /tmp/tmpv74v404o.d(31): Error: no property `minIndex` for type `long[]`

    /tmp/tmpv74v404o.d(36): Error: no property `maxIndex` for type `long[]`

    /tmp/tmpv74v404o.d(37): Error: no property `maxIndex` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv74v404o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpws_dj85l.d(30): Error: no property `min` for type `long[]`

    /tmp/tmpws_dj85l.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmpws_dj85l.d(35): Error: no property `max` for type `long[]`

    /tmp/tmpws_dj85l.d(36): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpws_dj85l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool inc\
    \ = true;\n    while (i <= j)\n    {\n        if (inc)\n        {\n          \
    \  res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n  \
    \          res[j] = lst[i];\n            j--;\n        }\n        inc = !inc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkbevbl0m.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkbevbl0m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length > 0)\n        {\n            res[i]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwljge84z.d(27): Error: no property `min` for type `long[]`

    /tmp/tmpwljge84z.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpwljge84z.d(32): Error: no property `max` for type `long[]`

    /tmp/tmpwljge84z.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwljge84z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    auto min = minElement(lst);\n\
    \    auto max = maxElement(lst);\n    long[] res = [];\n    bool is_min = true;\n\
    \    while (lst.length > 0)\n    {\n        if (is_min)\n        {\n         \
    \   res ~= min;\n            lst = lst.filter!(x => x != min);\n        }\n  \
    \      else\n        {\n            res ~= max;\n            lst = lst.filter!(x\
    \ => x != max);\n        }\n        min = minElement(lst);\n        max = maxElement(lst);\n\
    \        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsktokqd_.d(22): Error: undefined identifier `minElement`

    /tmp/tmpsktokqd_.d(23): Error: undefined identifier `maxElement`

    /tmp/tmpsktokqd_.d(31): Error: no property `filter` for type `long[]`

    /tmp/tmpsktokqd_.d(36): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsktokqd_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n\
    \    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n        if (el\
    \ < min)\n            min = el;\n        if (el > max)\n            max = el;\n\
    \    }\n    int i = 0;\n    while (lst_copy.length != 0)\n    {\n        if (i\
    \ % 2 == 0)\n        {\n            res[i] = min;\n            lst_copy = lst_copy.filter!(a\
    \ => a != min);\n            if (lst_copy.length == 0)\n                break;\n\
    \            min = lst_copy[0];\n            foreach (el; lst_copy)\n        \
    \    {\n                if (el < min)\n                    min = el;\n       \
    \     }\n        }\n        else\n        {\n            res[i] = max;\n     \
    \       lst_copy = lst_copy.filter!(a => a != max);\n            if (lst_copy.length\
    \ == 0)\n                break;\n            max = lst_copy[0];\n            foreach\
    \ (el; lst_copy)\n            {\n                if (el > max)\n             \
    \       max = el;\n            }\n        }\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmp_o0kqa.d(39): Error: no property `filter` for type `long[]`

    /tmp/tmpmp_o0kqa.d(52): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmp_o0kqa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n \
    \       result[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length\
    \ > 0)\n        {\n            result[i + 1] = lst[$ - 1];\n            lst =\
    \ lst[0..$ - 1];\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8lnbcmhl.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmp8lnbcmhl.__unittest_L37_C1() [0x4282bb]

    ??:? void tmp8lnbcmhl.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428d87]

    ??:? _d_run_main [0x428cf2]

    ??:? main [0x4286cf]

    ??:? __libc_start_main [0x526cf554]

    1/1 unittests FAILED

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = minElement(lst);\n\
    \    auto max = maxElement(lst);\n    long[] res = new long[lst.length];\n   \
    \ int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    foreach\
    \ (e; lst) \n    {\n        if (is_min) \n        {\n            res[i] = e;\n\
    \            i++;\n        } \n        else \n        {\n            res[j] =\
    \ e;\n            j--;\n        }\n        is_min = !is_min;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_dq6sen.d(22): Error: undefined identifier `minElement`

    /tmp/tmpo_dq6sen.d(23): Error: undefined identifier `maxElement`

    /tmp/tmpo_dq6sen.d(26): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_dq6sen.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst2 = lst.dup;\n    int i = 0;\n    while (lst2.length\
    \ > 0)\n    {\n        res[i] = lst2.min;\n        lst2.remove(lst2.min);\n  \
    \      i++;\n        if (lst2.length == 0)\n            break;\n        res[i]\
    \ = lst2.max;\n        lst2.remove(lst2.max);\n        i++;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm3a6pbmo.d(27): Error: no property `min` for type `long[]`

    /tmp/tmpm3a6pbmo.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpm3a6pbmo.d(32): Error: no property `max` for type `long[]`

    /tmp/tmpm3a6pbmo.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm3a6pbmo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    bool\
    \ asc = true;\n    foreach (i, x; lst)\n    {\n        if (asc)\n        {\n \
    \           res[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n\
    \        else\n        {\n            res[i] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-1];\n        }\n        asc = !asc;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpswjebm80.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswjebm80.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    bool is_min = true;\n    while\
    \ (lst.length > 0)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = min;\n            lst = lst.filter!(x => x != min);\n            min = lst[0];\n\
    \            foreach (i; lst)\n            {\n                if (i < min)\n \
    \                   min = i;\n            }\n        }\n        else\n       \
    \ {\n            res[i] = max;\n            lst = lst.filter!(x => x != max);\n\
    \            max = lst[0];\n            foreach (i; lst)\n            {\n    \
    \            if (i > max)\n                    max = i;\n            }\n     \
    \   }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp41dmoru5.d(39): Error: no property `filter` for type `long[]`

    /tmp/tmp41dmoru5.d(41): Error: variable `i` is shadowing variable `tmp41dmoru5.strange_sort_list.i`

    /tmp/tmp41dmoru5.d(50): Error: no property `filter` for type `long[]`

    /tmp/tmp41dmoru5.d(52): Error: variable `i` is shadowing variable `tmp41dmoru5.strange_sort_list.i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp41dmoru5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] result = new long[lst.length];\n\
    \    bool is_min = true;\n    long min_val = lst[0];\n    long max_val = lst[0];\n\
    \    long min_index = 0;\n    long max_index = 0;\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min_val)\n        {\n            min_val =\
    \ lst[i];\n            min_index = i;\n        }\n        if (lst[i] > max_val)\n\
    \        {\n            max_val = lst[i];\n            max_index = i;\n      \
    \  }\n    }\n    long[] temp_lst = lst[0..min_index] ~ lst[min_index+1..$];\n\
    \    result[0] = min_val;\n    long result_index = 1;\n    while (temp_lst.length\
    \ > 0)\n    {\n        if (is_min)\n        {\n            min_val = temp_lst[0];\n\
    \            min_index = 0;\n            for (long i = 0; i < temp_lst.length;\
    \ i++)\n            {\n                if (temp_lst[i] < min_val)\n          \
    \      {\n                    min_val = temp_lst[i];\n                    min_index\
    \ = i;\n                }\n            }\n            result[result_index] = min_val;\n\
    \            temp_lst = temp_lst[0..min_index] ~ temp_lst[min_index+1..$];\n \
    \           result_index++;\n            is_min = false;\n        }\n        else\n\
    \        {\n            max_val = temp_lst[0];\n            max_index = 0;\n \
    \           for (long i = 0; i < temp_lst.length; i++)\n            {\n      \
    \          if (temp_lst[i] > max_val)\n                {\n                   \
    \ max_val = temp_lst[i];\n                    max_index = i;\n               \
    \ }\n            }\n            result\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkahfv68v.d(75): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpkahfv68v.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpkahfv68v.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpkahfv68v.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkahfv68v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp_atkmes.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpp_atkmes.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpp_atkmes.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpp_atkmes.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp_atkmes.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] tmp = lst.dup;\n    bool asc = true;\n    int\
    \ i = 0;\n    while (tmp.length > 0)\n    {\n        if (asc)\n        {\n   \
    \         res[i] = tmp.min;\n            tmp.remove(tmp.min);\n        }\n   \
    \     else\n        {\n            res[i] = tmp.max;\n            tmp.remove(tmp.max);\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6s2febex.d(30): Error: no property `min` for type `long[]`

    /tmp/tmp6s2febex.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmp6s2febex.d(35): Error: no property `max` for type `long[]`

    /tmp/tmp6s2febex.d(36): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6s2febex.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length == 0)\n            break;\n       \
    \ res[i] = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4zb2o_6o.d(27): Error: no property `min` for type `long[]`

    /tmp/tmp4zb2o_6o.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmp4zb2o_6o.d(32): Error: no property `max` for type `long[]`

    /tmp/tmp4zb2o_6o.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4zb2o_6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min_max =\
    \ minmax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n    long[]\
    \ res = new long[lst.length];\n    bool is_min = true;\n    int i = 0;\n    while\
    \ (i < lst.length)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = min;\n            is_min = false;\n        }\n        else\n        {\n  \
    \          res[i] = max;\n            is_min = true;\n        }\n        i +=\
    \ 1;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpii7voxnz.d(22): Error: undefined identifier `minmax`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpii7voxnz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    auto minmax = minmaxElement(lst);\n    res[0] = minmax.min;\n\
    \    res[1] = minmax.max;\n    int i = 2;\n    int j = 0;\n    while (i < lst.length)\n\
    \    {\n        if (j % 2 == 0)\n        {\n            auto minmax = minmaxElement(lst);\n\
    \            res[i] = minmax.min;\n            res[i + 1] = minmax.max;\n    \
    \    }\n        else\n        {\n            auto minmax = minmaxElement(lst);\n\
    \            res[i] = minmax.max;\n            res[i + 1] = minmax.min;\n    \
    \    }\n        i += 2;\n        j++;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpko7__axt.d(23): Error: undefined identifier `minmaxElement`

    /tmp/tmpko7__axt.d(32): Error: undefined identifier `minmaxElement`

    /tmp/tmpko7__axt.d(32): Error: variable `minmax` is shadowing variable `tmpko7__axt.strange_sort_list.minmax`

    /tmp/tmpko7__axt.d(38): Error: undefined identifier `minmaxElement`

    /tmp/tmpko7__axt.d(38): Error: variable `minmax` is shadowing variable `tmpko7__axt.strange_sort_list.minmax`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpko7__axt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool asc = true;\n  \
    \  for (int i = 0; i < lst.length; i++)\n    {\n        if (asc)\n        {\n\
    \            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        asc = !asc;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_1drfspg.d(29): Error: no property `min` for type `long[]`

    /tmp/tmp_1drfspg.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmp_1drfspg.d(34): Error: no property `max` for type `long[]`

    /tmp/tmp_1drfspg.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_1drfspg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = min(lst_copy);\n\
    \    long max = max(lst_copy);\n    bool is_min = true;\n    foreach (i; 0 ..\
    \ lst.length)\n    {\n        if (is_min)\n        {\n            res[i] = min;\n\
    \            lst_copy.remove(min);\n            min = min(lst_copy);\n       \
    \ }\n        else\n        {\n            res[i] = max;\n            lst_copy.remove(max);\n\
    \            max = max(lst_copy);\n        }\n        is_min = !is_min;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph7iwsrno.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmph7iwsrno.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmph7iwsrno.d(32): Error: no property `remove` for type `long[]`

    /tmp/tmph7iwsrno.d(33): Error: function expected before `()`, not `min` of type
    `long`

    /tmp/tmph7iwsrno.d(38): Error: no property `remove` for type `long[]`

    /tmp/tmph7iwsrno.d(39): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph7iwsrno.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool asc\
    \ = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n          \
    \  res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n  \
    \          res[j] = lst[i];\n            j--;\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu4byattl.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu4byattl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   while (i <= j)\n    {\n        res[i] = min;\n        res[j] = max;\n    \
    \    i++;\n        j--;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp91ipie5w.d(33): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp91ipie5w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    auto\
    \ min_lst = lst.filter!(a => a == min);\n    auto max_lst = lst.filter!(a => a\
    \ == max);\n    auto mid_lst = lst.filter!(a => a != min && a != max);\n    auto\
    \ mid_lst_sorted = mid_lst.sort!((a, b) => a > b);\n    auto mid_lst_sorted_strange\
    \ = mid_lst_sorted.chunks(2).map!(a => a[0]).array;\n    if (mid_lst_sorted.length\
    \ % 2 == 1)\n        mid_lst_sorted_strange ~= mid_lst_sorted[$ - 1];\n    return\
    \ min_lst ~ max_lst ~ mid_lst_sorted_strange;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg_52qh1u.d(31): Error: no property `filter` for type `long[]`

    /tmp/tmpg_52qh1u.d(32): Error: no property `filter` for type `long[]`

    /tmp/tmpg_52qh1u.d(33): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_52qh1u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    long[]\
    \ res = new long[lst.length];\n    res[0] = min;\n    res[1] = max;\n    int i\
    \ = 2;\n    while (i < lst.length)\n    {\n        auto min = lst[0];\n      \
    \  auto max = lst[0];\n        foreach (j; lst)\n        {\n            if (j\
    \ < min && j != res[i - 2])\n                min = j;\n            if (j > max\
    \ && j != res[i - 1])\n                max = j;\n        }\n        res[i] = min;\n\
    \        res[i + 1] = max;\n        i += 2;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl3dsnhz8.d(37): Error: variable `min` is shadowing variable `tmpl3dsnhz8.strange_sort_list.min`

    /tmp/tmpl3dsnhz8.d(38): Error: variable `max` is shadowing variable `tmpl3dsnhz8.strange_sort_list.max`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl3dsnhz8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ auto min_max = minMax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n\
    \    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool is_min = true;\n    foreach (el; lst) \n    {\n        if (is_min)\
    \ \n        {\n            if (el == min) \n            {\n                result[i]\
    \ = el;\n                i++;\n                is_min = false;\n            }\n\
    \        } \n        else \n        {\n            if (el == max) \n         \
    \   {\n                result[j] = el;\n                j--;\n               \
    \ is_min = true;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7t1__a97.d(24): Error: undefined identifier `minMax`

    /tmp/tmp7t1__a97.d(29): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7t1__a97.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool flag\
    \ = true;\n    foreach (x; lst)\n    {\n        if (flag)\n        {\n       \
    \     res[i] = x;\n            i++;\n        }\n        else\n        {\n    \
    \        res[j] = x;\n            j--;\n        }\n        flag = !flag;\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfoj2nl0p.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfoj2nl0p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n     \
    \   res[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length > 0)\n\
    \        {\n            res[i+1] = lst[$-1];\n            lst = lst[0..$-1];\n\
    \        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_x7is55b.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmp_x7is55b.__unittest_L37_C1() [0x4282bb]

    ??:? void tmp_x7is55b.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n     \
    \   res[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length > 0)\n\
    \        {\n            res[i + 1] = lst[$ - 1];\n            lst = lst[0..$ -\
    \ 1];\n        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L])\
    \ == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L,\
    \ 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L,\
    \ 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcqyegbed.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmpcqyegbed.__unittest_L37_C1() [0x4282bb]

    ??:? void tmpcqyegbed.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length == 0)\n            break;\n       \
    \ res[i] = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4zb2o_6o.d(27): Error: no property `min` for type `long[]`

    /tmp/tmp4zb2o_6o.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmp4zb2o_6o.d(32): Error: no property `max` for type `long[]`

    /tmp/tmp4zb2o_6o.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4zb2o_6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[lst.minIndex];\n            lst[lst.minIndex] = lst[lst.maxIndex];\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = lst[lst.maxIndex];\n\
    \            lst[lst.maxIndex] = lst[lst.minIndex];\n            j--;\n      \
    \  }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5z5qjmyg.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp5z5qjmyg.d(30): Error: no property `minIndex` for type `long[]`

    /tmp/tmp5z5qjmyg.d(31): Error: no property `minIndex` for type `long[]`

    /tmp/tmp5z5qjmyg.d(36): Error: no property `maxIndex` for type `long[]`

    /tmp/tmp5z5qjmyg.d(37): Error: no property `maxIndex` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5z5qjmyg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        if (is_min)\n      \
    \  {\n            long min = lst_copy[0];\n            int min_index = 0;\n  \
    \          for (int j = 0; j < lst_copy.length; j++)\n            {\n        \
    \        if (lst_copy[j] < min)\n                {\n                    min =\
    \ lst_copy[j];\n                    min_index = j;\n                }\n      \
    \      }\n            result[i] = min;\n            lst_copy = lst_copy[0..min_index]\
    \ ~ lst_copy[min_index+1..$];\n            is_min = false;\n        }\n      \
    \  else\n        {\n            long max = lst_copy[0];\n            int max_index\
    \ = 0;\n            for (int j = 0; j < lst_copy.length; j++)\n            {\n\
    \                if (lst_copy[j] > max)\n                {\n                 \
    \   max = lst_copy[j];\n                    max_index = j;\n                }\n\
    \            }\n            result[i] = max;\n            lst_copy = lst_copy[0..max_index]\
    \ ~ lst_copy[max_index+1..$];\n            is_min = true;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n \
    \       long min = lst[0];\n        long max = lst[0];\n        foreach (elem;\
    \ lst)\n        {\n            if (elem < min)\n                min = elem;\n\
    \            if (elem > max)\n                max = elem;\n        }\n       \
    \ result[i] = min;\n        result[i + 1] = max;\n        i += 2;\n        lst\
    \ = lst.filter!(e => e != min && e != max);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppft2g4qt.d(38): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppft2g4qt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        long min = lst_copy[0];\n  \
    \      long max = lst_copy[0];\n        long min_index = 0;\n        long max_index\
    \ = 0;\n        foreach (j; 0 .. lst_copy.length)\n        {\n            if (lst_copy[j]\
    \ < min)\n            {\n                min = lst_copy[j];\n                min_index\
    \ = j;\n            }\n            if (lst_copy[j] > max)\n            {\n   \
    \             max = lst_copy[j];\n                max_index = j;\n           \
    \ }\n        }\n        if (is_min)\n        {\n            result[i] = min;\n\
    \            lst_copy[min_index] = max;\n        }\n        else\n        {\n\
    \            result[i] = max;\n            lst_copy[max_index] = min;\n      \
    \  }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph4f5zq8x.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x429be1]

    ??:? void tmph4f5zq8x.__unittest_L58_C1() [0x42838e]

    ??:? void tmph4f5zq8x.__modtest() [0x428b58]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e81f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42986a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b5a9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b638]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b535]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429841]

    ??:? runModuleUnitTests [0x42e5f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42a0f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v1yw48x.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v1yw48x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    int\
    \ i = 0;\n    int j = sorted.length - 1;\n    bool is_min = true;\n    foreach\
    \ (e; lst)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[i];\n\
    \            i++;\n        }\n        else\n        {\n            result[j] =\
    \ sorted[j];\n            j--;\n        }\n        is_min = !is_min;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvdl5r5f0.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmpvdl5r5f0.d(26): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvdl5r5f0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (i; lst_copy)\n    {\n        if (i < min) min = i;\n        if (i\
    \ > max) max = i;\n    }\n    int index = 0;\n    while (lst_copy.length > 0)\n\
    \    {\n        if (index % 2 == 0)\n        {\n            result[index] = min;\n\
    \            lst_copy = lst_copy.filter!(i => i != min);\n            if (lst_copy.length\
    \ > 0)\n            {\n                min = lst_copy[0];\n                foreach\
    \ (i; lst_copy)\n                {\n                    if (i < min) min = i;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      result[index] = max;\n            lst_copy = lst_copy.filter!(i => i !=\
    \ max);\n            if (lst_copy.length > 0)\n            {\n               \
    \ max = lst_copy[0];\n                foreach (i; lst_copy)\n                {\n\
    \                    if (i > max) max = i;\n                }\n            }\n\
    \        }\n        index++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9mug_qeh.d(36): Error: no property `filter` for type `long[]`

    /tmp/tmp9mug_qeh.d(49): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9mug_qeh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] copy = lst.dup;\n    int i = 0;\n    while\
    \ (copy.length > 0)\n    {\n        result[i] = copy.min;\n        copy.remove(result[i]);\n\
    \        i += 1;\n        if (copy.length == 0)\n            break;\n        result[i]\
    \ = copy.max;\n        copy.remove(result[i]);\n        i += 1;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1pahhpn7.d(27): Error: no property `min` for type `long[]`

    /tmp/tmp1pahhpn7.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmp1pahhpn7.d(32): Error: no property `max` for type `long[]`

    /tmp/tmp1pahhpn7.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1pahhpn7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_ = lst.dup;\n    bool asc = true;\n    int\
    \ i = 0;\n    while(lst_.length > 0)\n    {\n        if (asc)\n        {\n   \
    \         res[i] = lst_.min();\n            lst_.remove(lst_.min());\n       \
    \ }\n        else\n        {\n            res[i] = lst_.max();\n            lst_.remove(lst_.max());\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj1ewsb7f.d(30): Error: no property `min` for type `long[]`

    /tmp/tmpj1ewsb7f.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmpj1ewsb7f.d(35): Error: no property `max` for type `long[]`

    /tmp/tmpj1ewsb7f.d(36): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj1ewsb7f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         res[i] = min(lst_copy);\n            lst_copy.remove(res[i]);\n    \
    \    }\n        else\n        {\n            res[i] = max(lst_copy);\n       \
    \     lst_copy.remove(res[i]);\n        }\n        is_min = !is_min;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpap1ybfh5.d(29): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpap1ybfh5.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpap1ybfh5.d(34): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpap1ybfh5.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpap1ybfh5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int index = 0;\n  \
    \  bool is_min = true;\n    while (lst.length > 0)\n    {\n        long min_max\
    \ = is_min ? lst.min : lst.max;\n        result[index] = min_max;\n        index++;\n\
    \        lst = lst.filter!(a => a != min_max);\n        is_min = !is_min;\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqcowsirc.d(25): Error: no property `min` for type `long[]`

    /tmp/tmpqcowsirc.d(25): Error: no property `max` for type `long[]`

    /tmp/tmpqcowsirc.d(28): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqcowsirc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long min_val = lst_copy[0];\n    long max_val\
    \ = lst_copy[0];\n    foreach (i; lst_copy)\n    {\n        if (i < min_val) min_val\
    \ = i;\n        if (i > max_val) max_val = i;\n    }\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        if (i % 2 == 0)\n        {\n         \
    \   res[i] = min_val;\n            lst_copy = lst_copy.filter!(a => a != min_val);\n\
    \            if (lst_copy.length > 0)\n            {\n                min_val\
    \ = lst_copy[0];\n                foreach (i; lst_copy)\n                {\n \
    \                   if (i < min_val) min_val = i;\n                }\n       \
    \     }\n        }\n        else\n        {\n            res[i] = max_val;\n \
    \           lst_copy = lst_copy.filter!(a => a != max_val);\n            if (lst_copy.length\
    \ > 0)\n            {\n                max_val = lst_copy[0];\n              \
    \  foreach (i; lst_copy)\n                {\n                    if (i > max_val)\
    \ max_val = i;\n                }\n            }\n        }\n        i++;\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnvhjq3e4.d(36): Error: no property `filter` for type `long[]`

    /tmp/tmpnvhjq3e4.d(40): Error: variable `i` is shadowing variable `tmpnvhjq3e4.strange_sort_list.i`

    /tmp/tmpnvhjq3e4.d(49): Error: no property `filter` for type `long[]`

    /tmp/tmpnvhjq3e4.d(53): Error: variable `i` is shadowing variable `tmpnvhjq3e4.strange_sort_list.i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnvhjq3e4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool asc = true;\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        if (asc)\n        {\n\
    \            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        asc = !asc;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuwxydpr_.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpuwxydpr_.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpuwxydpr_.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpuwxydpr_.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwxydpr_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v1yw48x.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v1yw48x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (e; lst)\n    {\n        if (e < min)\n            min = e;\n   \
    \     if (e > max)\n            max = e;\n    }\n    res[i++] = min;\n    res[i++]\
    \ = max;\n    lst = lst.filter!(e => e != min && e != max);\n    while (lst.length\
    \ > 0)\n    {\n        min = lst[0];\n        max = lst[0];\n        foreach (e;\
    \ lst)\n        {\n            if (e < min)\n                min = e;\n      \
    \      if (e > max)\n                max = e;\n        }\n        res[i++] = min;\n\
    \        res[i++] = max;\n        lst = lst.filter!(e => e != min && e != max);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr5gwn20z.d(35): Error: no property `filter` for type `long[]`

    /tmp/tmpr5gwn20z.d(49): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr5gwn20z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n\
    \    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n        if (el\
    \ < min)\n            min = el;\n        if (el > max)\n            max = el;\n\
    \    }\n    int i = 0;\n    while (lst_copy.length != 0)\n    {\n        if (i\
    \ % 2 == 0)\n        {\n            res[i] = min;\n            lst_copy = lst_copy.filter!(a\
    \ => a != min);\n            if (lst_copy.length == 0)\n                break;\n\
    \            min = lst_copy[0];\n            foreach (el; lst_copy)\n        \
    \    {\n                if (el < min)\n                    min = el;\n       \
    \     }\n        }\n        else\n        {\n            res[i] = max;\n     \
    \       lst_copy = lst_copy.filter!(a => a != max);\n            if (lst_copy.length\
    \ == 0)\n                break;\n            max = lst_copy[0];\n            foreach\
    \ (el; lst_copy)\n            {\n                if (el > max)\n             \
    \       max = el;\n            }\n        }\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmp_o0kqa.d(39): Error: no property `filter` for type `long[]`

    /tmp/tmpmp_o0kqa.d(52): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmp_o0kqa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (e; lst)\n    {\n        if (e < min)\n \
    \           min = e;\n        if (e > max)\n            max = e;\n    }\n    auto\
    \ min_index = 0;\n    auto max_index = 0;\n    foreach (i, e; lst)\n    {\n  \
    \      if (e == min)\n            min_index = i;\n        if (e == max)\n    \
    \        max_index = i;\n    }\n    lst[min_index] = max;\n    lst[max_index]\
    \ = min;\n    return lst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwn2ghgk4.d(36): Error: cannot implicitly convert expression `i`
    of type `ulong` to `int`

    /tmp/tmpwn2ghgk4.d(38): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwn2ghgk4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = minElement(lst);\n\
    \    auto max = maxElement(lst);\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    while (i < lst.length)\n    {\n        if (i % 2 == 0)\n\
    \        {\n            result[i] = min;\n            min = minElement(lst[min..$]);\n\
    \        }\n        else\n        {\n            result[i] = max;\n          \
    \  max = maxElement(lst[0..max]);\n        }\n        i++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbcsc6v1p.d(22): Error: undefined identifier `minElement`

    /tmp/tmpbcsc6v1p.d(23): Error: undefined identifier `maxElement`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbcsc6v1p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length > 0)\n        {\n            res[i]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwljge84z.d(27): Error: no property `min` for type `long[]`

    /tmp/tmpwljge84z.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpwljge84z.d(32): Error: no property `max` for type `long[]`

    /tmp/tmpwljge84z.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwljge84z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    auto\
    \ min_lst = new long[];\n    auto max_lst = new long[];\n    foreach (i; lst)\n\
    \    {\n        if (i == min)\n            continue;\n        if (i == max)\n\
    \            continue;\n        if (i < (min + max) / 2)\n            min_lst\
    \ ~= i;\n        else\n            max_lst ~= i;\n    }\n    auto min_lst_sorted\
    \ = min_lst.sort();\n    auto max_lst_sorted = max_lst.sort();\n    auto result\
    \ = new long[];\n    bool min_flag = true;\n    while (min_lst_sorted.length >\
    \ 0 || max_lst_sorted.length > 0)\n    {\n        if (min_flag)\n        {\n \
    \           if (min_lst_sorted.length > 0)\n            {\n                result\
    \ ~= min_lst_sorted[0];\n                min_lst_sorted = min_lst_sorted[1..$];\n\
    \            }\n            else\n            {\n                result ~= max;\n\
    \            }\n        }\n        else\n        {\n            if (max_lst_sorted.length\
    \ > 0)\n            {\n                result ~= max_lst_sorted[$-1];\n      \
    \          max_lst_sorted = max_lst_sorted[0..$-1];\n            }\n         \
    \   else\n            {\n                result ~= min;\n            }\n     \
    \   }\n        min_flag = !min_flag;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl0wt3xfl.d(31): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpl0wt3xfl.d(32): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    /tmp/tmpl0wt3xfl.d(46): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0wt3xfl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        long min = lst[0];\n        long\
    \ max = lst[0];\n        int min_idx = 0;\n        int max_idx = 0;\n        for\
    \ (int k = 0; k < lst.length; k++)\n        {\n            if (lst[k] < min)\n\
    \            {\n                min = lst[k];\n                min_idx = k;\n\
    \            }\n            if (lst[k] > max)\n            {\n               \
    \ max = lst[k];\n                max_idx = k;\n            }\n        }\n    \
    \    if (is_min)\n        {\n            res[i] = min;\n            lst[min_idx]\
    \ = max;\n            i++;\n        }\n        else\n        {\n            res[j]\
    \ = max;\n            lst[max_idx] = min;\n            j--;\n        }\n     \
    \   is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr8iit5r5.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr8iit5r5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    auto min_max = minmax(lst);\n    long min = min_max[0];\n\
    \    long max = min_max[1];\n    int i = 0;\n    int j = lst.length - 1;\n   \
    \ bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n      \
    \  {\n            res[i] = min;\n            i++;\n        }\n        else\n \
    \       {\n            res[j] = max;\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv916zsr4.d(23): Error: undefined identifier `minmax`

    /tmp/tmpv916zsr4.d(27): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv916zsr4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup.sort;\n    bool is_even = true;\n    foreach (i,\
    \ e; sorted)\n    {\n        if (is_even)\n        {\n            result[i] =\
    \ e;\n            is_even = false;\n        }\n        else\n        {\n     \
    \       result[lst.length - i - 1] = e;\n            is_even = true;\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1saqgt13.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1saqgt13.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    int i = 0;\n    while (lst_copy.length != 0)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5gohzf82.d(30): Error: no property `min` for type `long[]`

    /tmp/tmp5gohzf82.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmp5gohzf82.d(35): Error: no property `max` for type `long[]`

    /tmp/tmp5gohzf82.d(36): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5gohzf82.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp_atkmes.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpp_atkmes.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpp_atkmes.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpp_atkmes.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp_atkmes.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n  \
    \  int i = 0;\n    int j = 0;\n    int k = sorted.length - 1;\n    while (i <\
    \ sorted.length)\n    {\n        if (j % 2 == 0)\n        {\n            result[i]\
    \ = sorted[j];\n            j++;\n        }\n        else\n        {\n       \
    \     result[i] = sorted[k];\n            k--;\n        }\n        i++;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpya324zwq.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmpya324zwq.d(27): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpya324zwq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min_max =\
    \ minmax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   bool is_min = true;\n    foreach (e; lst)\n    {\n        if (is_min)\n  \
    \      {\n            res[i] = e;\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = e;\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvupdjp37.d(22): Error: undefined identifier `minmax`

    /tmp/tmpvupdjp37.d(27): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvupdjp37.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k =\
    \ 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n        if (i <=\
    \ j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpymx2bvfr.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymx2bvfr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup.sort;\n    bool is_even = true;\n    int i = 0;\n\
    \    while (sorted.length > 0)\n    {\n        if (is_even)\n        {\n     \
    \       res[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n \
    \       else\n        {\n            res[i] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-1];\n        }\n        is_even = !is_even;\n        i++;\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyq80eik_.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyq80eik_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) \n    {\n        return lst;\n    }\n   \
    \ long[] sorted = new long[lst.length];\n    long[] remaining = lst.dup;\n   \
    \ long min = remaining[0];\n    long max = remaining[0];\n    foreach (el; remaining)\
    \ \n    {\n        min = min(min, el);\n        max = max(max, el);\n    }\n \
    \   int i = 0;\n    while (remaining.length > 0) \n    {\n        sorted[i] =\
    \ min;\n        remaining = remaining.filter!(el => el != min);\n        if (remaining.length\
    \ == 0) \n        {\n            break;\n        }\n        sorted[i + 1] = max;\n\
    \        remaining = remaining.filter!(el => el != max);\n        i += 2;\n  \
    \  }\n    return sorted;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1w7w2r1g.d(30): Error: function expected before `()`, not `min`
    of type `long`

    /tmp/tmp1w7w2r1g.d(31): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmp1w7w2r1g.d(37): Error: no property `filter` for type `long[]`

    /tmp/tmp1w7w2r1g.d(43): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1w7w2r1g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v1yw48x.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v1yw48x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int\
    \ k = 0;\n    while (i <= j)\n    {\n        result[k++] = lst[i++];\n       \
    \ if (i <= j)\n            result[k++] = lst[j--];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5alyqncf.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5alyqncf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] remaining = lst[1..$];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    result[0]\
    \ = min;\n    result[$-1] = max;\n    remaining.remove(min);\n    remaining.remove(max);\n\
    \    int index = 1;\n    while (remaining.length > 0)\n    {\n        min = remaining[0];\n\
    \        max = remaining[0];\n        foreach (i; remaining)\n        {\n    \
    \        if (i < min)\n                min = i;\n            if (i > max)\n  \
    \              max = i;\n        }\n        result[index] = min;\n        result[$-index-1]\
    \ = max;\n        remaining.remove(min);\n        remaining.remove(max);\n   \
    \     index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgn5wydcw.d(35): Error: no property `remove` for type `long[]`

    /tmp/tmpgn5wydcw.d(36): Error: no property `remove` for type `long[]`

    /tmp/tmpgn5wydcw.d(51): Error: no property `remove` for type `long[]`

    /tmp/tmpgn5wydcw.d(52): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgn5wydcw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    bool asc = true;\n    int i = 0;\n    while (lst.length\
    \ > 0)\n    {\n        auto minmax = minmaxElement(lst);\n        if (asc)\n \
    \       {\n            res[i] = minmax[0];\n            lst = lst.remove(minmax[0]);\n\
    \        }\n        else\n        {\n            res[i] = minmax[1];\n       \
    \     lst = lst.remove(minmax[1]);\n        }\n        i++;\n        asc = !asc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgwjp_yzf.d(27): Error: undefined identifier `minmaxElement`

    /tmp/tmpgwjp_yzf.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmpgwjp_yzf.d(36): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgwjp_yzf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst) {\n    \
    \    min = min(min, e);\n        max = max(max, e);\n    }\n    long[] lst_ =\
    \ lst.dup;\n    lst_.remove(min);\n    lst_.remove(max);\n    res[0] = min;\n\
    \    res[1] = max;\n    int i = 2;\n    while (lst_.length > 0) {\n        min\
    \ = lst_[0];\n        max = lst_[0];\n        foreach (e; lst_) {\n          \
    \  min = min(min, e);\n            max = max(max, e);\n        }\n        lst_.remove(min);\n\
    \        lst_.remove(max);\n        res[i] = min;\n        res[i+1] = max;\n \
    \       i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg8wv711s.d(25): Error: function expected before `()`, not `min`
    of type `long`

    /tmp/tmpg8wv711s.d(26): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmpg8wv711s.d(29): Error: no property `remove` for type `long[]`

    /tmp/tmpg8wv711s.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpg8wv711s.d(38): Error: function expected before `()`, not `min` of type
    `long`

    /tmp/tmpg8wv711s.d(39): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmpg8wv711s.d(41): Error: no property `remove` for type `long[]`

    /tmp/tmpg8wv711s.d(42): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8wv711s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[lst.minIndex];\n            lst[lst.minIndex] = long.max;\n\
    \        }\n        else\n        {\n            res[i] = lst[lst.maxIndex];\n\
    \            lst[lst.maxIndex] = long.min;\n        }\n        is_min = !is_min;\n\
    \        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdbig8kgn.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpdbig8kgn.d(30): Error: no property `minIndex` for type `long[]`

    /tmp/tmpdbig8kgn.d(31): Error: no property `minIndex` for type `long[]`

    /tmp/tmpdbig8kgn.d(35): Error: no property `maxIndex` for type `long[]`

    /tmp/tmpdbig8kgn.d(36): Error: no property `maxIndex` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdbig8kgn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n\
    \    auto max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n \
    \           min = i;\n        if (i > max)\n            max = i;\n    }\n    long[]\
    \ res = new long[lst.length];\n    int j = 0;\n    int k = lst.length - 1;\n \
    \   for (int i = 0; i < lst.length; i++)\n    {\n        if (i % 2 == 0)\n   \
    \     {\n            res[i] = min;\n            j++;\n        }\n        else\n\
    \        {\n            res[i] = max;\n            k--;\n        }\n    }\n  \
    \  return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n \
    \   assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7md1y04j.d(33): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7md1y04j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n  \
    \  int index = 0;\n    int min = 0;\n    int max = sorted.length - 1;\n    while\
    \ (min <= max)\n    {\n        result[index] = sorted[min];\n        index++;\n\
    \        if (min == max)\n            break;\n        result[index] = sorted[max];\n\
    \        index++;\n        min++;\n        max--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4bdr37o4.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmp4bdr37o4.d(27): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4bdr37o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n\
    \    long max = lst_copy[0];\n    foreach (i; lst_copy)\n    {\n        if (i\
    \ < min)\n            min = i;\n        if (i > max)\n            max = i;\n \
    \   }\n    bool is_min = true;\n    foreach (i; 0..lst.length)\n    {\n      \
    \  if (is_min)\n        {\n            res[i] = min;\n            lst_copy.remove(min);\n\
    \            min = lst_copy[0];\n            foreach (j; lst_copy)\n         \
    \   {\n                if (j < min)\n                    min = j;\n          \
    \  }\n            is_min = false;\n        }\n        else\n        {\n      \
    \      res[i] = max;\n            lst_copy.remove(max);\n            max = lst_copy[0];\n\
    \            foreach (j; lst_copy)\n            {\n                if (j > max)\n\
    \                    max = j;\n            }\n            is_min = true;\n   \
    \     }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp184h1182.d(39): Error: no property `remove` for type `long[]`

    /tmp/tmp184h1182.d(51): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp184h1182.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool asc = true;\n\
    \    size_t i = 0;\n    while (lst_copy.length > 0)\n    {\n        if (asc)\n\
    \        {\n            result[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            result[i] = lst_copy.max;\n \
    \           lst_copy.remove(lst_copy.max);\n        }\n        i++;\n        asc\
    \ = !asc;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcpzqyswh.d(30): Error: no property `min` for type `long[]`

    /tmp/tmpcpzqyswh.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmpcpzqyswh.d(35): Error: no property `max` for type `long[]`

    /tmp/tmpcpzqyswh.d(36): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcpzqyswh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] sorted =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i < lst.length)\n    {\n        if (is_min)\n   \
    \     {\n            sorted[i] = lst[0];\n            lst = lst[1..$];\n     \
    \   }\n        else\n        {\n            sorted[i] = lst[$-1];\n          \
    \  lst = lst[0..$-1];\n        }\n        is_min = !is_min;\n        i++;\n  \
    \  }\n    return sorted;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwqe1okiw.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwqe1okiw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length == 0)\n            break;\n       \
    \ res[i] = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4zb2o_6o.d(27): Error: no property `min` for type `long[]`

    /tmp/tmp4zb2o_6o.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmp4zb2o_6o.d(32): Error: no property `max` for type `long[]`

    /tmp/tmp4zb2o_6o.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4zb2o_6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    auto min_max = minmax(lst);\n    long min = min_max[0];\n\
    \    long max = min_max[1];\n    bool is_min = true;\n    int i = 0;\n    while\
    \ (i < lst.length)\n    {\n        if (is_min)\n        {\n            if (lst[i]\
    \ == min)\n            {\n                result[i] = lst[i];\n              \
    \  is_min = false;\n                i++;\n            }\n        }\n        else\n\
    \        {\n            if (lst[i] == max)\n            {\n                result[i]\
    \ = lst[i];\n                is_min = true;\n                i++;\n          \
    \  }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpike3von9.d(23): Error: undefined identifier `minmax`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpike3von9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n\
    \    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n        if (el\
    \ < min)\n            min = el;\n        if (el > max)\n            max = el;\n\
    \    }\n    int i = 0;\n    int j = lst_copy.length - 1;\n    bool is_min = true;\n\
    \    while (i <= j)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = min;\n            lst_copy.remove(min);\n            min = lst_copy[0];\n\
    \            foreach (el; lst_copy)\n            {\n                if (el < min)\n\
    \                    min = el;\n            }\n            is_min = false;\n \
    \           i++;\n        }\n        else\n        {\n            res[j] = max;\n\
    \            lst_copy.remove(max);\n            max = lst_copy[0];\n         \
    \   foreach (el; lst_copy)\n            {\n                if (el > max)\n   \
    \                 max = el;\n            }\n            is_min = true;\n     \
    \       j--;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps2sdic_6.d(34): Error: cannot implicitly convert expression `lst_copy.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmps2sdic_6.d(41): Error: no property `remove` for type `long[]`

    /tmp/tmps2sdic_6.d(54): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps2sdic_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    auto minmax = minmaxElement(lst);\n    result[0]\
    \ = minmax.min;\n    result[1] = minmax.max;\n    lst.remove(minmax.min);\n  \
    \  lst.remove(minmax.max);\n    int i = 2;\n    while (lst.length != 0)\n    {\n\
    \        minmax = minmaxElement(lst);\n        result[i] = minmax.min;\n     \
    \   result[i + 1] = minmax.max;\n        lst.remove(minmax.min);\n        lst.remove(minmax.max);\n\
    \        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz50x0vyt.d(23): Error: undefined identifier `minmaxElement`

    /tmp/tmpz50x0vyt.d(26): Error: no property `remove` for type `long[]`

    /tmp/tmpz50x0vyt.d(27): Error: no property `remove` for type `long[]`

    /tmp/tmpz50x0vyt.d(34): Error: no property `remove` for type `long[]`

    /tmp/tmpz50x0vyt.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz50x0vyt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long min = lst[0];\n   \
    \ long max = lst[0];\n    foreach (el; lst)\n    {\n        min = min(min, el);\n\
    \        max = max(max, el);\n    }\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 ..\
    \ lst.length)\n    {\n        if (is_min)\n        {\n            res[i] = min;\n\
    \            lst_copy.remove(min);\n            if (lst_copy.length == 0) break;\n\
    \            min = lst_copy[0];\n            foreach (el; lst_copy)\n        \
    \    {\n                min = min(min, el);\n            }\n        }\n      \
    \  else\n        {\n            res[i] = max;\n            lst_copy.remove(max);\n\
    \            if (lst_copy.length == 0) break;\n            max = lst_copy[0];\n\
    \            foreach (el; lst_copy)\n            {\n                max = max(max,\
    \ el);\n            }\n        }\n        is_min = !is_min;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hj4y4ki.d(25): Error: function expected before `()`, not `min`
    of type `long`

    /tmp/tmp5hj4y4ki.d(26): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmp5hj4y4ki.d(36): Error: no property `remove` for type `long[]`

    /tmp/tmp5hj4y4ki.d(41): Error: function expected before `()`, not `min` of type
    `long`

    /tmp/tmp5hj4y4ki.d(47): Error: no property `remove` for type `long[]`

    /tmp/tmp5hj4y4ki.d(52): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hj4y4ki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length\
    \ > 0)\n    {\n        result[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n\
    \        if (lst_copy.length > 0)\n        {\n            result[i+1] = lst_copy[$-1];\n\
    \            lst_copy = lst_copy[0..$-2];\n        }\n        i += 2;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4yz4i_d3.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ab1]

    ??:? void tmp4yz4i_d3.__unittest_L38_C1() [0x42825e]

    ??:? void tmp4yz4i_d3.__modtest() [0x428a28]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42973a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b479]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b508]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b405]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429711]

    ??:? runModuleUnitTests [0x42e4c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fc8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    // TODO: implement strange sorting algorithm\n    long[] result\
    \ = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    long[] reversed\
    \ = sorted.dup.reverse;\n    int i = 0;\n    int j = 0;\n    foreach(e; lst)\n\
    \    {\n        if(i % 2 == 0)\n        {\n            result[i] = sorted[j];\n\
    \        }\n        else\n        {\n            result[i] = reversed[j];\n  \
    \          j++;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ndqd6_z.d(22): Error: no property `sort` for type `long[]`

    /tmp/tmp8ndqd6_z.d(23): Error: template `std.typecons.reverse` cannot deduce function
    from argument types `!()(long[])`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(1486):        `std.typecons.reverse(T)(T
    t) if (isTuple!T)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ndqd6_z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy\
    \ = lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length\
    \ == 0)\n            break;\n        res[i] = lst_copy.max;\n        lst_copy\
    \ = lst_copy.remove(lst_copy.max);\n        i++;\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm11wopk3.d(27): Error: no property `min` for type `long[]`

    /tmp/tmpm11wopk3.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpm11wopk3.d(32): Error: no property `max` for type `long[]`

    /tmp/tmpm11wopk3.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm11wopk3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return [];\n    auto sorted = lst.dup;\n\
    \    sorted.sort;\n    long[] result = new long[lst.length];\n    bool is_min\
    \ = true;\n    foreach (i, e; sorted)\n    {\n        if (is_min)\n        {\n\
    \            result[i] = e;\n            is_min = false;\n        }\n        else\n\
    \        {\n            result[lst.length - i - 1] = e;\n            is_min =\
    \ true;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wsn82zn.d(23): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wsn82zn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    int\
    \ i = 0;\n    int j = sorted.length - 1;\n    bool flag = true;\n    foreach (el;\
    \ lst)\n    {\n        if (flag)\n        {\n            result[i] = sorted[i];\n\
    \            i++;\n        }\n        else\n        {\n            result[j] =\
    \ sorted[j];\n            j--;\n        }\n        flag = !flag;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm49krare.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmpm49krare.d(26): Error: cannot implicitly convert expression `sorted.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm49krare.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     long min = lst[0];\n            int min_index = 0;\n            for (int\
    \ k = 0; k < lst.length; k++)\n            {\n                if (lst[k] < min)\n\
    \                {\n                    min = lst[k];\n                    min_index\
    \ = k;\n                }\n            }\n            res[i] = min;\n        \
    \    lst[min_index] = long.max;\n            i++;\n        }\n        else\n \
    \       {\n            long max = lst[0];\n            int max_index = 0;\n  \
    \          for (int k = 0; k < lst.length; k++)\n            {\n             \
    \   if (lst[k] > max)\n                {\n                    max = lst[k];\n\
    \                    max_index = k;\n                }\n            }\n      \
    \      res[j] = max;\n            lst[max_index] = long.min;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp89bxip1f.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp89bxip1f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        long min = lst_copy[0];\n        long\
    \ max = lst_copy[0];\n        foreach (el; lst_copy)\n        {\n            min\
    \ = min(min, el);\n            max = max(max, el);\n        }\n        res[i]\
    \ = min;\n        i++;\n        res[i] = max;\n        i++;\n        lst_copy\
    \ = lst_copy.filter!(x => x != min && x != max);\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpisa8hw08.d(31): Error: function expected before `()`, not `min`
    of type `long`

    /tmp/tmpisa8hw08.d(32): Error: function expected before `()`, not `max` of type
    `long`

    /tmp/tmpisa8hw08.d(38): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpisa8hw08.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n\
    \    long max = lst_copy[0];\n    foreach (el; lst_copy)\n    {\n        if (el\
    \ < min)\n            min = el;\n        if (el > max)\n            max = el;\n\
    \    }\n    int i = 0;\n    while (i < lst.length)\n    {\n        res[i] = min;\n\
    \        lst_copy.remove(min);\n        if (i + 1 < lst.length)\n        {\n \
    \           res[i + 1] = max;\n            lst_copy.remove(max);\n        }\n\
    \        if (lst_copy.length == 0)\n            break;\n        min = lst_copy[0];\n\
    \        max = lst_copy[0];\n        foreach (el; lst_copy)\n        {\n     \
    \       if (el < min)\n                min = el;\n            if (el > max)\n\
    \                max = el;\n        }\n        i += 2;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa08gsi5a.d(37): Error: no property `remove` for type `long[]`

    /tmp/tmpa08gsi5a.d(41): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa08gsi5a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        result[i] = lst_copy[0];\n        lst_copy\
    \ = lst_copy[1..$];\n        if (lst_copy.length > 0)\n        {\n           \
    \ result[i+1] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-2];\n   \
    \     }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6tzz7ouh.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x429ab1]

    ??:? void tmp6tzz7ouh.__unittest_L38_C1() [0x42825e]

    ??:? void tmp6tzz7ouh.__modtest() [0x428a28]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e6ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42973a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42b479]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42b508]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42b405]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429711]

    ??:? runModuleUnitTests [0x42e4c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429fc8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[lst.minIndex];\n            lst[lst.minIndex] = lst[lst.maxIndex]\
    \ + 1;\n            i++;\n        }\n        else\n        {\n            res[j]\
    \ = lst[lst.maxIndex];\n            lst[lst.maxIndex] = lst[lst.minIndex] - 1;\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8yu4il8x.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8yu4il8x.d(30): Error: no property `minIndex` for type `long[]`

    /tmp/tmp8yu4il8x.d(31): Error: no property `minIndex` for type `long[]`

    /tmp/tmp8yu4il8x.d(36): Error: no property `maxIndex` for type `long[]`

    /tmp/tmp8yu4il8x.d(37): Error: no property `maxIndex` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8yu4il8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n  \
    \  bool is_min = true;\n    foreach (idx, _; sorted)\n    {\n        if (is_min)\n\
    \        {\n            result[idx] = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            result[idx] = sorted[$-1];\n\
    \            sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0kb10x_.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0kb10x_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] result = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n\
    \        if (i < min) min = i;\n        if (i > max) max = i;\n    }\n    long[]\
    \ temp = lst.dup;\n    temp.remove(min);\n    temp.remove(max);\n    int i = 0;\n\
    \    while (temp.length > 0)\n    {\n        result[i] = min;\n        i++;\n\
    \        result[i] = max;\n        i++;\n        min = temp[0];\n        max =\
    \ temp[0];\n        foreach (j; temp)\n        {\n            if (j < min) min\
    \ = j;\n            if (j > max) max = j;\n        }\n        temp.remove(min);\n\
    \        temp.remove(max);\n    }\n    if (lst.length % 2 == 1)\n    {\n     \
    \   result[i] = min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeptytrxr.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpeptytrxr.d(31): Error: no property `remove` for type `long[]`

    /tmp/tmpeptytrxr.d(46): Error: no property `remove` for type `long[]`

    /tmp/tmpeptytrxr.d(47): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeptytrxr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0) return lst;\n    long[] result = new long[lst.length];\n\
    \    long min = lst[0];\n    long max = lst[0];\n    foreach (i; lst) {\n    \
    \    if (i < min) min = i;\n        if (i > max) max = i;\n    }\n    bool is_min\
    \ = true;\n    long min_idx = 0;\n    long max_idx = lst.length - 1;\n    foreach\
    \ (i; lst) {\n        if (is_min) {\n            result[min_idx] = min;\n    \
    \        min_idx++;\n        } else {\n            result[max_idx] = max;\n  \
    \          max_idx--;\n        }\n        is_min = !is_min;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcbxvitv8.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x4289a5]

    ??:? void tmpcbxvitv8.__unittest_L43_C1() [0x4280d2]

    ??:? void tmpcbxvitv8.__modtest() [0x428728]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430ba1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x431050]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430b2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8ed]

    ??:? runModuleUnitTests [0x42c859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e68]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    bool\
    \ is_min = true;\n    foreach (i, ref val; result)\n    {\n        if (is_min)\n\
    \        {\n            val = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            val = sorted[$-1];\n        \
    \    sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3n95kokf.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3n95kokf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min_max =\
    \ minmax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n    long[]\
    \ res = new long[lst.length];\n    bool is_min = true;\n    int i = 0;\n    while\
    \ (i < lst.length)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = min;\n            is_min = false;\n        }\n        else\n        {\n  \
    \          res[i] = max;\n            is_min = true;\n        }\n        i++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hbvngra.d(22): Error: undefined identifier `minmax`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hbvngra.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v1yw48x.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v1yw48x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    auto min_max =\
    \ minmax(lst);\n    long[] res = new long[lst.length];\n    res[0] = min_max[0];\n\
    \    res[1] = min_max[1];\n    long[] lst_copy = lst.dup;\n    lst_copy.remove(min_max[0]);\n\
    \    lst_copy.remove(min_max[1]);\n    bool is_min = true;\n    for (int i = 2;\
    \ i < lst.length; i++)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = min(lst_copy);\n            lst_copy.remove(res[i]);\n        }\n        else\n\
    \        {\n            res[i] = max(lst_copy);\n            lst_copy.remove(res[i]);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvylsmm1y.d(22): Error: undefined identifier `minmax`

    /tmp/tmpvylsmm1y.d(27): Error: no property `remove` for type `long[]`

    /tmp/tmpvylsmm1y.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmpvylsmm1y.d(34): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpvylsmm1y.d(35): Error: no property `remove` for type `long[]`

    /tmp/tmpvylsmm1y.d(39): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpvylsmm1y.d(40): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvylsmm1y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        if (is_min)\n      \
    \  {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr07cxpi9.d(29): Error: no property `min` for type `long[]`

    /tmp/tmpr07cxpi9.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmpr07cxpi9.d(34): Error: no property `max` for type `long[]`

    /tmp/tmpr07cxpi9.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr07cxpi9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    while\
    \ (lst.length > 0)\n    {\n        auto min = lst.min;\n        auto max = lst.max;\n\
    \        result[i] = min;\n        result[i+1] = max;\n        lst = lst.filter!(x\
    \ => x != min && x != max);\n        i += 2;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwfp8de07.d(24): Error: no property `min` for type `long[]`

    /tmp/tmpwfp8de07.d(25): Error: no property `max` for type `long[]`

    /tmp/tmpwfp8de07.d(28): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfp8de07.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    auto min_max = minMax(lst);\n    long min = min_max[0];\n\
    \    long max = min_max[1];\n    bool is_min = true;\n    int index = 0;\n   \
    \ while (lst.length != 0)\n    {\n        if (is_min)\n        {\n           \
    \ result[index] = min;\n            lst = lst.filter!(a => a != min);\n      \
    \      if (lst.length != 0)\n            {\n                min_max = minMax(lst);\n\
    \                min = min_max[0];\n                max = min_max[1];\n      \
    \      }\n        }\n        else\n        {\n            result[index] = max;\n\
    \            lst = lst.filter!(a => a != max);\n            if (lst.length !=\
    \ 0)\n            {\n                min_max = minMax(lst);\n                min\
    \ = min_max[0];\n                max = min_max[1];\n            }\n        }\n\
    \        is_min = !is_min;\n        index++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps9aj5uqr.d(23): Error: undefined identifier `minMax`

    /tmp/tmps9aj5uqr.d(33): Error: no property `filter` for type `long[]`

    /tmp/tmps9aj5uqr.d(44): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps9aj5uqr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool is_min = true;\n\
    \    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n   \
    \         res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6j2m9qfq.d(29): Error: no property `min` for type `long[]`

    /tmp/tmp6j2m9qfq.d(30): Error: no property `remove` for type `long[]`

    /tmp/tmp6j2m9qfq.d(34): Error: no property `max` for type `long[]`

    /tmp/tmp6j2m9qfq.d(35): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6j2m9qfq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    while (lst.length > 0)\n    {\n     \
    \   res[i] = lst[0];\n        lst = lst[1..$];\n        if (lst.length == 0)\n\
    \            break;\n        res[i+1] = lst[$-1];\n        lst = lst[0..$-1];\n\
    \        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmfttf8ge.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42893d]

    ??:? void tmpmfttf8ge.__unittest_L36_C1() [0x4282bb]

    ??:? void tmpmfttf8ge.__modtest() [0x4286bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ca1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b8ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430b39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430fe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430ac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b885]

    ??:? runModuleUnitTests [0x42c7f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e00]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    long min = min(lst_copy);\n\
    \    long max = max(lst_copy);\n    bool is_min = true;\n    for (int i = 0; i\
    \ < lst.length; i++)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = min;\n            lst_copy.remove(min);\n            is_min = false;\n   \
    \     }\n        else\n        {\n            res[i] = max;\n            lst_copy.remove(max);\n\
    \            is_min = true;\n        }\n        min = min(lst_copy);\n       \
    \ max = max(lst_copy);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpos5iwxvh.d(24): Error: undefined identifier `min`, did you mean
    function `main`?

    /tmp/tmpos5iwxvh.d(25): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpos5iwxvh.d(32): Error: no property `remove` for type `long[]`

    /tmp/tmpos5iwxvh.d(38): Error: no property `remove` for type `long[]`

    /tmp/tmpos5iwxvh.d(41): Error: function expected before `()`, not `min` of type
    `long`

    /tmp/tmpos5iwxvh.d(42): Error: function expected before `()`, not `max` of type
    `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpos5iwxvh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v1yw48x.d(24): Error: cannot implicitly convert expression `lst.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v1yw48x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length == 0)\n            break;\n       \
    \ res[i] = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4zb2o_6o.d(27): Error: no property `min` for type `long[]`

    /tmp/tmp4zb2o_6o.d(28): Error: no property `remove` for type `long[]`

    /tmp/tmp4zb2o_6o.d(32): Error: no property `max` for type `long[]`

    /tmp/tmp4zb2o_6o.d(33): Error: no property `remove` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4zb2o_6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L,\
    \ 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n\
    \    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
    \ lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n  \
    \  int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        result[k++] = sorted[i++];\n        if (i <= j)\n       \
    \     result[k++] = sorted[j--];\n    }\n    return result;\n}\n/*\n    Given\
    \ a list of integers, return list of integers that are\n    not in the list.\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1gofgk1l.d(36): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1gofgk1l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
