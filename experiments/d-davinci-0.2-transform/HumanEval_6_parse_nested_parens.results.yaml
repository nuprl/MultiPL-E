language: d
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_level = 0;\n    long level = 0;\n \
    \   foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n       \
    \     stack ~= 1;\n            level++;\n            max_level = max(max_level,\
    \ level);\n        }\n        else if(c == ')')\n        {\n            stack\
    \ ~= -1;\n            level--;\n        }\n        else if(c == ' ')\n       \
    \ {\n            if(stack.length > 0)\n            {\n                result ~=\
    \ max_level;\n                stack = [];\n                max_level = 0;\n  \
    \              level = 0;\n            }\n        }\n    }\n    if(stack.length\
    \ > 0)\n    {\n        result ~= max_level;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8k0qdrlc.d(24): Error: undefined identifier `max`, did you mean
    function `fmax`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8k0qdrlc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_level = 0;\n    long current_level = 0;\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            current_level++;\n\
    \            max_level = max(max_level, current_level);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_level--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_level;\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn54b4_bz.d(22): Error: undefined identifier `max`, did you mean
    function `fmax`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn54b4_bz.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    string[] paren_groups = paren_string.split(\" \");\n\
    \    foreach(paren_group; paren_groups) \n    {\n        long max_nesting = 0;\n\
    \        long current_nesting = 0;\n        foreach(paren; paren_group) \n   \
    \     {\n            if(paren == '(') \n            {\n                current_nesting++;\n\
    \                max_nesting = max(max_nesting, current_nesting);\n          \
    \  }\n            else if(paren == ')') \n            {\n                current_nesting--;\n\
    \            }\n        }\n        result ~= max_nesting;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqwlanvbu.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpqwlanvbu.d(15): Error: no property
    `split` for type `string`\n/tmp/tmpqwlanvbu.d(25): Error: undefined identifier
    `max`, did you mean function `fmax`?\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpqwlanvbu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long count = 0;\n    long max = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            count++;\n            max\
    \ = max(max, count);\n        }\n        else if(c == ')')\n        {\n      \
    \      count--;\n        }\n        else if(c == ' ')\n        {\n           \
    \ result ~= max;\n            max = 0;\n            count = 0;\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcc_xd8qq.d(22): Error: function expected before `()`, not `max`
    of type `long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcc_xd8qq.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_nesting = 0;\n    long current_nesting = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            current_nesting++;\n\
    \            max_nesting = max(max_nesting, current_nesting);\n        } \n  \
    \      else if(c == ')') \n        {\n            current_nesting--;\n       \
    \ } \n        else if(c == ' ') \n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            current_nesting = 0;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplprckudf.d(22): Error: undefined identifier `max`, did you mean
    function `fmax`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplprckudf.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n\
    \    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n\
    \    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long\
    \ ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n\
    \    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long\
    \ ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n\
    \    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long\
    \ bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n\
    \    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long\
    \ bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n\
    \    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long\
    \ by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n\
    \    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long\
    \ cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n\
    \    long cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long\
    \ cu;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcbq_rjiu.d(109): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbq_rjiu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int[] stack;\n    int i;\n    int len;\n    int max_depth;\n  \
    \  int depth;\n    int paren_count;\n    int paren_index;\n    int paren_start;\n\
    \    int paren_end;\n    int paren_start_index;\n    int paren_end_index;\n  \
    \  int paren_start_index_prev;\n    int paren_end_index_prev;\n    int paren_start_index_next;\n\
    \    int paren_end_index_next;\n    int paren_start_index_next_next;\n    int\
    \ paren_end_index_next_next;\n    int paren_start_index_prev_prev;\n    int paren_end_index_prev_prev;\n\
    \    int paren_start_index_prev_prev_prev;\n    int paren_end_index_prev_prev_prev;\n\
    \    int paren_start_index_next_next_next;\n    int paren_end_index_next_next_next;\n\
    \    int paren_start_index_next_next_next_next;\n    int paren_end_index_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next;\n    int paren_end_index_next_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next_next;\n    int paren_end_index_next_next_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next_next_next;\n    int paren_end_index_next_next_next_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next_next_next_next;\n    int paren_end_index_next_next_next_next_next_next_next_next;\n\
    \    int paren_start_index_next_next_next_next_next_next_next_next_next;\n   \
    \ int paren_end_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuk0qaq7b.d(50): Error: semicolon expected, not `unittest`\n/tmp/tmpuk0qaq7b.d(50):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpuk0qaq7b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    long[] stack = new long[];\n    foreach(paren; paren_string.split(\"\
    \ \"))\n    {\n        foreach(c; paren)\n        {\n            if(c == '(')\n\
    \            {\n                stack ~= 1;\n            }\n            else if(c\
    \ == ')')\n            {\n                stack ~= -1;\n            }\n      \
    \  }\n        long max_depth = 0;\n        long depth = 0;\n        foreach(c;\
    \ stack)\n        {\n            depth += c;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n        stack = new long[];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv9gjeq0j.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpv9gjeq0j.d(15): Error: new
    can only create structs, dynamic arrays or class objects, not `long[]`\''s\n/tmp/tmpv9gjeq0j.d(16):
    Error: no property `split` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpv9gjeq0j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        stack = [];\n        max_depth = 0;\n        foreach (paren;\
    \ paren_group) \n        {\n            if (paren == '(') \n            {\n  \
    \              stack ~= 1;\n                max_depth = max(max_depth, stack.length);\n\
    \            }\n            else if (paren == ')') \n            {\n         \
    \       stack.pop;\n            }\n        }\n        result ~= max_depth;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw46ysduq.d(17): Error: no property `split` for type `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw46ysduq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long current_level;\n    long max_level;\n \
    \   long i;\n    long j;\n    long len;\n    long len2;\n    char c;\n    char\
    \ c2;\n    string s;\n    string[] paren_groups;\n    paren_groups = split(paren_string,\
    \ \" \");\n    len = paren_groups.length;\n    result = new long[len];\n    for\
    \ (i = 0; i < len; i++) {\n        s = paren_groups[i];\n        stack = new long[s.length];\n\
    \        current_level = 0;\n        max_level = 0;\n        len2 = s.length;\n\
    \        for (j = 0; j < len2; j++) {\n            c = s[j];\n            if (c\
    \ == '(') {\n                current_level++;\n                stack[current_level]\
    \ = j;\n            } else if (c == ')') {\n                if (current_level\
    \ > 0) {\n                    current_level--;\n                } else {\n   \
    \                 throw new Exception(\"Invalid input\");\n                }\n\
    \            } else {\n                throw new Exception(\"Invalid input\");\n\
    \            }\n            max_level = max(max_level, current_level);\n     \
    \   }\n        if (current_level != 0) {\n            throw new Exception(\"Invalid\
    \ input\");\n        }\n        result[i] = max_level;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyts2oye2.d(26): Error: undefined identifier `split`\n/tmp/tmpyts2oye2.d(49):
    Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpyts2oye2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long[] stack_temp;\n    long[] stack_temp2;\n\
    \    long[] stack_temp3;\n    long[] stack_temp4;\n    long[] stack_temp5;\n \
    \   long[] stack_temp6;\n    long[] stack_temp7;\n    long[] stack_temp8;\n  \
    \  long[] stack_temp9;\n    long[] stack_temp10;\n    long[] stack_temp11;\n \
    \   long[] stack_temp12;\n    long[] stack_temp13;\n    long[] stack_temp14;\n\
    \    long[] stack_temp15;\n    long[] stack_temp16;\n    long[] stack_temp17;\n\
    \    long[] stack_temp18;\n    long[] stack_temp19;\n    long[] stack_temp20;\n\
    \    long[] stack_temp21;\n    long[] stack_temp22;\n    long[] stack_temp23;\n\
    \    long[] stack_temp24;\n    long[] stack_temp25;\n    long[] stack_temp26;\n\
    \    long[] stack_temp27;\n    long[] stack_temp28;\n    long[] stack_temp29;\n\
    \    long[] stack_temp30;\n    long[] stack_temp31;\n    long[] stack_temp32;\n\
    \    long[] stack_temp33;\n    long[] stack_temp34;\n    long[] stack_temp35;\n\
    \    long[] stack_temp36;\n    long[] stack_temp37;\n    long[] stack_temp38;\n\
    \    long[] stack_temp39;\n    long[] stack_temp40;\n    long[] stack_temp41;\n\
    \    long[] stack_temp42;\n    long[] stack_temp43;\n    long[] stack_temp44;\n\
    \    long[] stack_temp45;\n    long[] stack_temp46;\n    long[] stack_temp47;\n\
    \    long[] stack_temp48;\n    long[] stack_temp49;\n    long[] stack_temp50;\n\
    \    long[] stack_temp51;\n    long[] stack_temp52;\n    long[] stack_temp53;\n\
    \    long[] stack_temp54;\n    long[] stack_temp55;\n    long[]\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1unr7uim.d(72): Error: no identifier for declarator `long[]`\n/tmp/tmp1unr7uim.d(72):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp1unr7uim.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            depth++;\n         \
    \   max_depth = max(max_depth, depth);\n        } \n        else if (c == ')')\
    \ \n        {\n            depth--;\n        } \n        else if (c == ' ') \n\
    \        {\n            result ~= max_depth;\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3kgg7y_i.d(22): Error: undefined identifier `max`, did you mean
    function `fmax`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3kgg7y_i.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_string; paren_string.length > 0)\n\
    \    {\n        auto paren_group = paren_string.split(\" \")[0];\n        paren_string\
    \ = paren_string.split(\" \")[1];\n        int max_depth = 0;\n        int depth\
    \ = 0;\n        foreach(paren_group; paren_group.length > 0)\n        {\n    \
    \        auto paren = paren_group.split(\"\")[0];\n            paren_group = paren_group.split(\"\
    \")[1];\n            if(paren == \"(\")\n            {\n                depth\
    \ += 1;\n                max_depth = max(max_depth, depth);\n            }\n \
    \           else if(paren == \")\")\n            {\n                depth -= 1;\n\
    \            }\n        }\n        result[i] = max_depth;\n        i += 1;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp526e_7m0.d(16): Error: invalid `foreach` aggregate `paren_string.length
    > 0LU`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp526e_7m0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_nesting = 0;\n    int nesting = 0;\n    bool in_parens\
    \ = false;\n    foreach (c; paren_string)\n    {\n        if (c == '(')\n    \
    \    {\n            in_parens = true;\n            nesting++;\n            max_nesting\
    \ = max(max_nesting, nesting);\n        }\n        else if (c == ')')\n      \
    \  {\n            nesting--;\n        }\n        else if (c == ' ' && in_parens)\n\
    \        {\n            result ~= max_nesting;\n            max_nesting = 0;\n\
    \            nesting = 0;\n            in_parens = false;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkj63zcbt.d(24): Error: undefined identifier `max`, did you mean
    function `fmax`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkj63zcbt.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int max_nesting = 0;\n    int nesting = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            nesting++;\n\
    \            max_nesting = max(max_nesting, nesting);\n        }\n        else\
    \ if(c == ')')\n        {\n            nesting--;\n        }\n        else if(c\
    \ == ' ')\n        {\n            result ~= max_nesting;\n            max_nesting\
    \ = 0;\n            nesting = 0;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2xwbqbaj.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp2xwbqbaj.d(22): Error: undefined
    identifier `max`, did you mean function `fmax`?\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2xwbqbaj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long[] max_stack;\n    long max_stack_size;\n\
    \    long stack_size;\n    long max_depth;\n    long depth;\n    long i;\n   \
    \ long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n \
    \   long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n\
    \    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long\
    \ ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n\
    \    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long\
    \ ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n\
    \    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long\
    \ bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n\
    \    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long\
    \ bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n\
    \    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long\
    \ by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n\
    \    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long\
    \ cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n\
    \    long cp;\n    long\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwps8ax4k.d(108): Error: no identifier for declarator `long`\n/tmp/tmpwps8ax4k.d(108):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpwps8ax4k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren_group; paren_string.split(\" \")) \n\
    \    {\n        long max_nesting = 0;\n        long nesting = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             nesting++;\n                max_nesting = max(max_nesting, nesting);\n\
    \            } \n            else if(paren == ')') \n            {\n         \
    \       nesting--;\n            }\n        }\n        result ~= max_nesting;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdiy6zo1b.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpdiy6zo1b.d(15): Error: no property
    `split` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdiy6zo1b.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] paren_count;\n    long[] max_paren_count;\n    long[] max_paren_count_index;\n\
    \    long[] max_paren_count_index_temp;\n    long[] max_paren_count_index_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp;\n    long[] max_paren_count_index_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp;\n    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp;\n    long[]\
    \ max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp;\n    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    long[] max_paren_count\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuhwp1g0z.d(35): Error: semicolon expected, not `unittest`\n/tmp/tmpuhwp1g0z.d(35):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpuhwp1g0z.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_level = 0;\n        long level = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n            {\n                level++;\n\
    \                max_level = max(max_level, level);\n            }\n         \
    \   else if(paren == ')')\n            {\n                level--;\n         \
    \   }\n        }\n        result ~= max_level;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa_wpm6we.d(15): Error: no property `split` for type `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa_wpm6we.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int count = 0;\n    int max = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            count++;\n            if(count\
    \ > max)\n                max = count;\n        }\n        else if(c == ')')\n\
    \        {\n            count--;\n        }\n        else if(c == ' ')\n     \
    \   {\n            result ~= max;\n            max = 0;\n            count = 0;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph83h80zg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n\
    \    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n\
    \    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long\
    \ ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n\
    \    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long\
    \ ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n\
    \    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long\
    \ bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n\
    \    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long\
    \ bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n\
    \    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long\
    \ by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n\
    \    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long\
    \ cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n\
    \    long cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long\
    \ cu;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcbq_rjiu.d(109): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbq_rjiu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_depth++;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppa3txi9p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    foreach(paren_group;\
    \ paren_string.split(\" \"))\n    {\n        max_depth = 0;\n        depth = 0;\n\
    \        stack = [];\n        foreach(paren; paren_group)\n        {\n       \
    \     if(paren == '(')\n            {\n                stack ~= 1;\n         \
    \       depth++;\n                max_depth = max(max_depth, depth);\n       \
    \     }\n            else if(paren == ')')\n            {\n                stack.pop();\n\
    \                depth--;\n            }\n        }\n        assert(stack.empty);\n\
    \        result ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1jdwe03h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    long[] stack = new long[];\n    foreach(paren; paren_string.split(\"\
    \ \"))\n    {\n        foreach(c; paren)\n        {\n            if(c == '(')\n\
    \            {\n                stack ~= 1;\n            }\n            else if(c\
    \ == ')')\n            {\n                stack ~= -1;\n            }\n      \
    \  }\n        long sum = 0;\n        long max = 0;\n        foreach(i; stack)\n\
    \        {\n            sum += i;\n            max = max(max, sum);\n        }\n\
    \        result ~= max;\n        stack = new long[];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp53ksa01e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long[] max_stack;\n    long max_depth;\n   \
    \ long depth;\n    long i;\n    long j;\n    long k;\n    long len;\n    long\
    \ len2;\n    long len3;\n    long len4;\n    long len5;\n    long len6;\n    long\
    \ len7;\n    long len8;\n    long len9;\n    long len10;\n    long len11;\n  \
    \  long len12;\n    long len13;\n    long len14;\n    long len15;\n    long len16;\n\
    \    long len17;\n    long len18;\n    long len19;\n    long len20;\n    long\
    \ len21;\n    long len22;\n    long len23;\n    long len24;\n    long len25;\n\
    \    long len26;\n    long len27;\n    long len28;\n    long len29;\n    long\
    \ len30;\n    long len31;\n    long len32;\n    long len33;\n    long len34;\n\
    \    long len35;\n    long len36;\n    long len37;\n    long len38;\n    long\
    \ len39;\n    long len40;\n    long len41;\n    long len42;\n    long len43;\n\
    \    long len44;\n    long len45;\n    long len46;\n    long len47;\n    long\
    \ len48;\n    long len49;\n    long len50;\n    long len51;\n    long len52;\n\
    \    long len53;\n    long len54;\n    long len55;\n    long len56;\n    long\
    \ len57;\n    long len58;\n    long len59;\n    long len60;\n    long len61;\n\
    \    long len62;\n    long len63;\n    long len64;\n    long len65;\n    long\
    \ len66;\n    long len67;\n    long len68;\n    long len69;\n    long len70;\n\
    \    long len71;\n    long len72;\n    long len73;\n    long len74;\n    long\
    \ len75;\n    long len76;\n    long len77;\n   \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsao9pl2x.d(100): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsao9pl2x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbp2r2x6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_nesting = 0;\n    int nesting = 0;\n    foreach(ch; paren_string)\n\
    \    {\n        if(ch == '(')\n        {\n            nesting++;\n           \
    \ max_nesting = max(max_nesting, nesting);\n        }\n        else if(ch == ')')\n\
    \        {\n            nesting--;\n        }\n        else if(ch == ' ')\n  \
    \      {\n            result ~= max_nesting;\n            max_nesting = 0;\n \
    \           nesting = 0;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp640jle8p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\
    \ \n    {\n        int max_depth = 0;\n        int current_depth = 0;\n      \
    \  foreach(paren; paren_group) \n        {\n            if(paren == '(') \n  \
    \          {\n                current_depth++;\n                max_depth = max(max_depth,\
    \ current_depth);\n            }\n            else if(paren == ')') \n       \
    \     {\n                current_depth--;\n            }\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpishj80iw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int[] paren_count;\n    int[] paren_level;\n    int[] paren_level_max;\n\
    \    int[] paren_level_max_index;\n    int[] paren_level_max_index_count;\n  \
    \  int[] paren_level_max_index_count_max;\n    int[] paren_level_max_index_count_max_index;\n\
    \    int[] paren_level_max_index_count_max_index_count;\n    int[] paren_level_max_index_count_max_index_count_max;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index;\n    int[] paren_level_max_index_count_max_index_count_max_index_count;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_max;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_max_index;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_max_index_count;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_max_index_count_max;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_max_index_count_max_index;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_max_index_count_max_index_count;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_max_index_count_max_index_count_max;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_max_index_count_max_index_count_max_index;\n\
    \    int[] paren_level_max_index_count_max_index_count_max_index_count_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp40f43sji.d(35): Error: semicolon expected, not \''unittest\''\n/tmp/tmp40f43sji.d(35):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp40f43sji.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split)\n    {\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n       \
    \ {\n            if(paren == '(')\n                depth++;\n            else\
    \ if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8zs851a.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(char c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppuwqs2c8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int current_level = 0;\n    int max_level = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_level++;\n\
    \            max_level = max(max_level, current_level);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_level--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_level;\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl4v1s23q.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    auto paren_groups = paren_string.split(\" \");\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long max_nesting = 0;\n        long current_nesting\
    \ = 0;\n        foreach(paren; paren_group)\n        {\n            if(paren ==\
    \ '(')\n            {\n                current_nesting++;\n                max_nesting\
    \ = max(max_nesting, current_nesting);\n            }\n            else if(paren\
    \ == ')')\n            {\n                current_nesting--;\n            }\n\
    \        }\n        result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoqm9p7i7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvggybk_1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if(c == '(') \n        {\n            depth++;\n          \
    \  max_depth = max(max_depth, depth);\n        }\n        else if(c == ')') \n\
    \        {\n            depth--;\n        }\n        else if(c == ' ') \n    \
    \    {\n            result ~= max_depth;\n            max_depth = 0;\n       \
    \     depth = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjrt4ekwx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocz90hec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_nesting_level = 0;\n    long nesting_level = 0;\n    foreach(paren;\
    \ paren_string)\n    {\n        if(paren == '(')\n        {\n            nesting_level++;\n\
    \            max_nesting_level = max(max_nesting_level, nesting_level);\n    \
    \    }\n        else if(paren == ')')\n        {\n            nesting_level--;\n\
    \        }\n        else if(paren == ' ')\n        {\n            result ~= max_nesting_level;\n\
    \            max_nesting_level = 0;\n            nesting_level = 0;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx6o2r8zy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int paren_count = 0;\n    int max_paren_count = 0;\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      paren_count++;\n            max_paren_count = max(max_paren_count, paren_count);\n\
    \        }\n        else if(c == ')')\n        {\n            paren_count--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_paren_count;\n\
    \            max_paren_count = 0;\n            paren_count = 0;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp86ezlm3e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocz90hec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(char c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            depth++;\n         \
    \   max_depth = max(max_depth, depth);\n        } \n        else if (c == ')')\
    \ \n        {\n            depth--;\n        } \n        else if (c == ' ') \n\
    \        {\n            result ~= max_depth;\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpspsranv4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int[] paren_stack;\n    int paren_stack_top;\n    int paren_stack_size;\n\
    \    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int\
    \ o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n\
    \    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int aa;\n   \
    \ int ab;\n    int ac;\n    int ad;\n    int ae;\n    int af;\n    int ag;\n \
    \   int ah;\n    int ai;\n    int aj;\n    int ak;\n    int al;\n    int am;\n\
    \    int an;\n    int ao;\n    int ap;\n    int aq;\n    int ar;\n    int as;\n\
    \    int at;\n    int au;\n    int av;\n    int aw;\n    int ax;\n    int ay;\n\
    \    int az;\n    int ba;\n    int bb;\n    int bc;\n    int bd;\n    int be;\n\
    \    int bf;\n    int bg;\n    int bh;\n    int bi;\n    int bj;\n    int bk;\n\
    \    int bl;\n    int bm;\n    int bn;\n    int bo;\n    int bp;\n    int bq;\n\
    \    int br;\n    int bs;\n    int bt;\n    int bu;\n    int bv;\n    int bw;\n\
    \    int bx;\n    int by;\n    int bz;\n    int ca;\n    int cb;\n    int cc;\n\
    \    int cd;\n    int ce;\n    int cf;\n    int cg;\n    int ch;\n    int ci;\n\
    \    int cj;\n    int ck;\n    int cl;\n    int cm;\n    int cn;\n    int co;\n\
    \    int cp;\n    int cq;\n    int cr;\n    int cs;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwntobmm0.d(107): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwntobmm0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res = new long[];\n    auto paren_groups = paren_string.split(\" \");\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long max_nesting = 0;\n        long curr_nesting\
    \ = 0;\n        foreach(paren; paren_group)\n        {\n            if(paren ==\
    \ '(')\n            {\n                curr_nesting++;\n                max_nesting\
    \ = max(max_nesting, curr_nesting);\n            }\n            else if(paren\
    \ == ')')\n            {\n                curr_nesting--;\n            }\n   \
    \     }\n        res ~= max_nesting;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyq7rkoxw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             current_depth++;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else if(paren == ')') \n            {\n          \
    \      current_depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp60vhi8m0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_nesting_level;\n    long current_nesting_level;\n    long\
    \ current_group_start;\n    long current_group_end;\n    long current_group_length;\n\
    \    long current_group_index;\n    long current_group_nesting_level;\n    long\
    \ current_group_nesting_level_start;\n    long current_group_nesting_level_end;\n\
    \    long current_group_nesting_level_length;\n    long current_group_nesting_level_index;\n\
    \    long current_group_nesting_level_nesting_level;\n    long current_group_nesting_level_nesting_level_start;\n\
    \    long current_group_nesting_level_nesting_level_end;\n    long current_group_nesting_level_nesting_level_length;\n\
    \    long current_group_nesting_level_nesting_level_index;\n    long current_group_nesting_level_nesting_level_nesting_level;\n\
    \    long current_group_nesting_level_nesting_level_nesting_level_start;\n   \
    \ long current_group_nesting_level_nesting_level_nesting_level_end;\n    long\
    \ current_group_nesting_level_nesting_level_nesting_level_length;\n    long current_group_nesting_level_nesting_level_nesting_level_index;\n\
    \    long current_group_nesting_level_nesting_level_nesting_level_nesting_level;\n\
    \    long current_group_nesting_level_nesting_level_nesting_level_nesting_level_start;\n\
    \    long current_group_nesting_level_nesting_level_nesting_level_nesting_level_end;\n\
    \    long current_group_nesting_level_nesting_level_nesting_level_nesting_level_length;\n\
    \    long current_group_nesting_level_nesting_level_nesting_level_nesting_level_index;\n\
    \    long current_group_nesting_level_nesting_level_nesting_level_nesting_level\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp91w4a_d.d(42): Error: semicolon expected, not \''unittest\''\n/tmp/tmpp91w4a_d.d(42):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpp91w4a_d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_nesting = 0;\n        long current_nesting = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             current_nesting++;\n                max_nesting = max(max_nesting,\
    \ current_nesting);\n            }\n            else if(paren == ')') \n     \
    \       {\n                current_nesting--;\n            }\n        }\n    \
    \    result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ghcj3sf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_level = 0;\n    int level = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            level++;\n            max_level\
    \ = max(max_level, level);\n        }\n        else if(c == ')')\n        {\n\
    \            level--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_level;\n            max_level = 0;\n            level =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph65fxxti.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int i = 0;\n    while (i < paren_string.length) \n\
    \    {\n        if (paren_string[i] == '(') \n        {\n            int j = i\
    \ + 1;\n            int count = 1;\n            while (j < paren_string.length)\
    \ \n            {\n                if (paren_string[j] == '(') \n            \
    \    {\n                    count++;\n                } \n                else\
    \ if (paren_string[j] == ')') \n                {\n                    count--;\n\
    \                }\n                if (count == 0) \n                {\n    \
    \                break;\n                }\n                j++;\n           \
    \ }\n            result ~= count;\n            i = j + 1;\n        } \n      \
    \  else \n        {\n            i++;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplj68hugu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0L;\n        long depth = 0L;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2x84z6xi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int n = paren_string.length;\n    while (i < n)\
    \ \n    {\n        if (paren_string[i] == '(') \n        {\n            int j\
    \ = i + 1;\n            int count = 1;\n            while (j < n) \n         \
    \   {\n                if (paren_string[j] == '(') \n                {\n     \
    \               count++;\n                } \n                else if (paren_string[j]\
    \ == ')') \n                {\n                    count--;\n                }\n\
    \                if (count == 0) \n                {\n                    break;\n\
    \                }\n                j++;\n            }\n            if (j ==\
    \ n) \n            {\n                throw new Exception(\"Unbalanced parentheses\"\
    );\n            }\n            result ~= count;\n            i = j + 1;\n    \
    \    } \n        else if (paren_string[i] == ' ') \n        {\n            i++;\n\
    \        } \n        else \n        {\n            throw new Exception(\"Invalid\
    \ character\");\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmw8ycvb2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        long max_nesting = 0;\n        long nesting = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           nesting++;\n                max_nesting = max(max_nesting, nesting);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     nesting--;\n            }\n        }\n        result ~= max_nesting;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7rwxg8dl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_depth\
    \ += 1;\n            max_depth = max(max_depth, current_depth);\n        }\n \
    \       else if(c == ')')\n        {\n            current_depth -= 1;\n      \
    \  }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppjcvie9x.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split())\n    {\n        long\
    \ max_level = 0;\n        long level = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                level++;\n         \
    \   else if(paren == ')')\n                level--;\n            max_level = max(max_level,\
    \ level);\n        }\n        result ~= max_level;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp62mdgnth.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocz90hec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if(c == '(') \n        {\n            depth++;\n          \
    \  max_depth = max(max_depth, depth);\n        } \n        else if(c == ')') \n\
    \        {\n            depth--;\n        } \n        else if(c == ' ') \n   \
    \     {\n            result ~= max_depth;\n            max_depth = 0;\n      \
    \      depth = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps__rhfgp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbp2r2x6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long depth = 0;\n        long max_depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeu4wnvh7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int[] paren_count = new int[];\n    int[] paren_max\
    \ = new int[];\n    int[] paren_min = new int[];\n    int[] paren_level = new\
    \ int[];\n    int[] paren_level_max = new int[];\n    int[] paren_level_min =\
    \ new int[];\n    int[] paren_level_count = new int[];\n    int[] paren_level_count_max\
    \ = new int[];\n    int[] paren_level_count_min = new int[];\n    int[] paren_level_count_max_index\
    \ = new int[];\n    int[] paren_level_count_min_index = new int[];\n    int[]\
    \ paren_level_count_max_index_max = new int[];\n    int[] paren_level_count_min_index_min\
    \ = new int[];\n    int[] paren_level_count_max_index_max_max = new int[];\n \
    \   int[] paren_level_count_min_index_min_min = new int[];\n    int[] paren_level_count_max_index_max_max_max\
    \ = new int[];\n    int[] paren_level_count_min_index_min_min_min = new int[];\n\
    \    int[] paren_level_count_max_index_max_max_max_max = new int[];\n    int[]\
    \ paren_level_count_min_index_min_min_min_min = new int[];\n    int[] paren_level_count_max_index_max_max_max_max_max\
    \ = new int[];\n    int[] paren_level_count_min_index_min_min_min_min_min = new\
    \ int[];\n    int[] paren_level_count_max_index_max_max_max_max_max_max = new\
    \ int[];\n    int[] paren_level_count_min_index_min_min_min_min_min_min = new\
    \ int[];\n    int[] paren_level_count_max_index_max_max_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa2tgke9v.d(39): Error: semicolon expected, not \''unittest\''\n/tmp/tmpa2tgke9v.d(39):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpa2tgke9v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_level = 0;\n    long current_level = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            current_level++;\n\
    \            max_level = max(max_level, current_level);\n        }\n        else\
    \ if(c == ')') \n        {\n            current_level--;\n        }\n        else\
    \ if(c == ' ') \n        {\n            result ~= max_level;\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpykgrpdvl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int level = 0;\n    int max_level = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            level++;\n\
    \            max_level = max(max_level, level);\n        }\n        else if(c\
    \ == ')')\n        {\n            level--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_level;\n            max_level = 0;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg0m__jo5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ugeukux.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')')\n            {\n                depth--;\n         \
    \   }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmploerjdf0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i;\n    int j;\n    int k;\n    int n;\n    int m;\n    int\
    \ p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n    int v;\n\
    \    int w;\n    int x;\n    int y;\n    int z;\n    int aa;\n    int bb;\n  \
    \  int cc;\n    int dd;\n    int ee;\n    int ff;\n    int gg;\n    int hh;\n\
    \    int ii;\n    int jj;\n    int kk;\n    int ll;\n    int mm;\n    int nn;\n\
    \    int oo;\n    int pp;\n    int qq;\n    int rr;\n    int ss;\n    int tt;\n\
    \    int uu;\n    int vv;\n    int ww;\n    int xx;\n    int yy;\n    int zz;\n\
    \    int aaa;\n    int bbb;\n    int ccc;\n    int ddd;\n    int eee;\n    int\
    \ fff;\n    int ggg;\n    int hhh;\n    int iii;\n    int jjj;\n    int kkk;\n\
    \    int lll;\n    int mmm;\n    int nnn;\n    int ooo;\n    int ppp;\n    int\
    \ qqq;\n    int rrr;\n    int sss;\n    int ttt;\n    int uuu;\n    int vvv;\n\
    \    int www;\n    int xxx;\n    int yyy;\n    int zzz;\n    int aaaa;\n    int\
    \ bbbb;\n    int cccc;\n    int dddd;\n    int eeee;\n    int ffff;\n    int gggg;\n\
    \    int hhhh;\n    int iiii;\n    int jjjj;\n    int kkkk;\n    int llll;\n \
    \   int mmmm;\n    int nnnn;\n    int oooo;\n    int pppp;\n    int qqqq;\n  \
    \  int rrrr;\n    int s\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn4_0_ohg.d(102): Error: semicolon expected, not \''unittest\''\n/tmp/tmpn4_0_ohg.d(102):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpn4_0_ohg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_nesting = 0;\n        long current_nesting = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             current_nesting++;\n                max_nesting = max(max_nesting,\
    \ current_nesting);\n            }\n            else if(paren == ')') \n     \
    \       {\n                current_nesting--;\n            }\n        }\n    \
    \    result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ghcj3sf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    string[] paren_groups = paren_string.split(\" \");\n    foreach(paren_group;\
    \ paren_groups) \n    {\n        long max_depth = 0;\n        long depth = 0;\n\
    \        foreach(paren; paren_group) \n        {\n            if(paren == '(')\
    \ \n            {\n                depth++;\n            }\n            else \n\
    \            {\n                depth--;\n            }\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwci6fo9b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split) \n    {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             current_nesting++;\n                max_nesting = max(max_nesting,\
    \ current_nesting);\n            } \n            else if(paren == ')') \n    \
    \        {\n                current_nesting--;\n            }\n        }\n   \
    \     result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkk58r01h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int start = 0;\n    int end = 0;\n    int count = 0;\n    int max_count\
    \ = 0;\n    int max_index = 0;\n    int index = 0;\n    int i = 0;\n    int j\
    \ = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int\
    \ o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n   \
    \ int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n\
    \    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int bb = 0;\n    int cc\
    \ = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n    int gg = 0;\n \
    \   int hh = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll\
    \ = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n \
    \   int qq = 0;\n    int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu\
    \ = 0;\n    int vv = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy = 0;\n \
    \   int zz = 0;\n    int aaa = 0;\n    int bbb = 0;\n    int ccc = 0;\n    int\
    \ ddd = 0;\n    int eee = 0;\n    int fff = 0;\n    int ggg = 0;\n    int hhh\
    \ = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk = 0;\n    int lll = 0;\n\
    \    int mmm = 0;\n    int nnn = 0;\n    int ooo = 0;\n    int ppp = 0;\n    int\
    \ qqq =\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpol3al5ga.d(82): Error: expression expected, not \''unittest\''\n/tmp/tmpol3al5ga.d(83):
    Error: semicolon expected, not \''{\''\n/tmp/tmpol3al5ga.d(90): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpol3al5ga.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        int max_depth = 0;\n        int depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n                depth++;\n\
    \            else if(paren == ')')\n                depth--;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpst_3wgbn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] paren_counts;\n    long[] paren_counts_max;\n    long[]\
    \ paren_counts_min;\n    long[] paren_counts_max_min;\n    long[] paren_counts_max_min_max;\n\
    \    long[] paren_counts_max_min_max_min;\n    long[] paren_counts_max_min_max_min_max;\n\
    \    long[] paren_counts_max_min_max_min_max_min;\n    long[] paren_counts_max_min_max_min_max_min_max;\n\
    \    long[] paren_counts_max_min_max_min_max_min_max_min;\n    long[] paren_counts_max_min_max_min_max_min_max_min_max;\n\
    \    long[] paren_counts_max_min_max_min_max_min_max_min_max_min;\n    long[]\
    \ paren_counts_max_min_max_min_max_min_max_min_max_min_max;\n    long[] paren_counts_max_min_max_min_max_min_max_min_max_min_max_min;\n\
    \    long[] paren_counts_max_min_max_min_max_min_max_min_max_min_max_min_max;\n\
    \    long[] paren_counts_max_min_max_min_max_min_max_min_max_min_max_min_max_min;\n\
    \    long[] paren_counts_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max;\n\
    \    long[] paren_counts_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min;\n\
    \    long[] paren_counts_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max;\n\
    \    long[] paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1um13z4v.d(35): Error: semicolon expected, not \''unittest\''\n/tmp/tmp1um13z4v.d(35):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp1um13z4v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split) \n    {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            } \n        \
    \    else if(paren == ')') \n            {\n                depth--;\n       \
    \     }\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwsr00ods.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = paren_string.split(\" \");\n    long[] result;\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long max_nesting = 0;\n        long current_nesting\
    \ = 0;\n        foreach(paren; paren_group)\n        {\n            if(paren ==\
    \ '(')\n            {\n                current_nesting++;\n                max_nesting\
    \ = max(max_nesting, current_nesting);\n            }\n            else if(paren\
    \ == ')')\n            {\n                current_nesting--;\n            }\n\
    \        }\n        result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk13u78np.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(c; paren_group)\
    \ \n        {\n            if(c == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(c == ')') \n            {\n                depth--;\n            }\n\
    \        }\n        result ~= max_depth;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp44qk8gk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int count = 0;\n    int max = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            count++;\n            if(count\
    \ > max)\n                max = count;\n        }\n        else if(c == ')')\n\
    \        {\n            count--;\n        }\n        else if(c == ' ')\n     \
    \   {\n            result ~= max;\n            max = 0;\n            count = 0;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph83h80zg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        stack = [];\n        max_depth = 0;\n        foreach (paren;\
    \ paren_group) \n        {\n            if (paren == '(') \n            {\n  \
    \              stack ~= 1;\n                max_depth = max(max_depth, stack.length);\n\
    \            } \n            else if (paren == ')') \n            {\n        \
    \        stack.pop;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv32rjm15.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n\
    \    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n\
    \    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long\
    \ ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n\
    \    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long\
    \ ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n\
    \    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long\
    \ bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n\
    \    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long\
    \ bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n\
    \    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long\
    \ by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n\
    \    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long\
    \ cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n\
    \    long cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long\
    \ cu;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcbq_rjiu.d(109): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbq_rjiu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_nesting = 0;\n        long current_nesting = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_nesting++;\n                max_nesting = max(max_nesting,\
    \ current_nesting);\n            }\n            else if(paren == ')')\n      \
    \      {\n                current_nesting--;\n            }\n        }\n     \
    \   result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ktyos30.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        long max_depth = 0;\n        long current_depth = 0;\n       \
    \ foreach(paren; paren_group)\n        {\n            if(paren == '(')\n     \
    \       {\n                current_depth++;\n                max_depth = max(max_depth,\
    \ current_depth);\n            }\n            else if(paren == ')')\n        \
    \    {\n                current_depth--;\n            }\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx1fc9p9y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth;\n    long depth;\n    foreach(paren_group; paren_string.split)\
    \ \n    {\n        max_depth = 0;\n        depth = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             depth++;\n                max_depth = max(max_depth, depth);\n \
    \           }\n            else if(paren == ')') \n            {\n           \
    \     depth--;\n            }\n        }\n        result ~= max_depth;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnf5vyy49.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_level = 0;\n        long level = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n            {\n                level++;\n\
    \                max_level = max(max_level, level);\n            }\n         \
    \   else if(paren == ')')\n            {\n                level--;\n         \
    \   }\n        }\n        result ~= max_level;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa_wpm6we.d(15): Error: no property `split` for type `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa_wpm6we.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvggybk_1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')') \n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ') \n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpysbs_vdf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long paren_count;\n    long paren_index;\n    long paren_start;\n    long\
    \ paren_end;\n    long paren_length;\n    long paren_depth;\n    long paren_depth_index;\n\
    \    long paren_depth_start;\n    long paren_depth_end;\n    long paren_depth_length;\n\
    \    long paren_depth_depth;\n    long paren_depth_depth_index;\n    long paren_depth_depth_start;\n\
    \    long paren_depth_depth_end;\n    long paren_depth_depth_length;\n    long\
    \ paren_depth_depth_depth;\n    long paren_depth_depth_depth_index;\n    long\
    \ paren_depth_depth_depth_start;\n    long paren_depth_depth_depth_end;\n    long\
    \ paren_depth_depth_depth_length;\n    long paren_depth_depth_depth_depth;\n \
    \   long paren_depth_depth_depth_depth_index;\n    long paren_depth_depth_depth_depth_start;\n\
    \    long paren_depth_depth_depth_depth_end;\n    long paren_depth_depth_depth_depth_length;\n\
    \    long paren_depth_depth_depth_depth_depth;\n    long paren_depth_depth_depth_depth_depth_index;\n\
    \    long paren_depth_depth_depth_depth_depth_start;\n    long paren_depth_depth_depth_depth_depth_end;\n\
    \    long paren_depth_depth_depth_depth_depth_length;\n    long paren_depth_depth_depth_depth_depth_depth;\n\
    \    long paren_depth_depth_depth_depth_depth_depth_index;\n    long paren_depth_depth_depth_depth_depth_depth_start;\n\
    \    long paren_depth_depth_depth_depth_depth_depth_end;\n    long paren_depth_depth_depth_depth_depth_depth_length;\n\
    \    long\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_yotiri7.d(55): Error: no identifier for declarator long\n/tmp/tmp_yotiri7.d(55):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_yotiri7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] paren_count;\n    int current_count;\n    int max_count;\n\
    \    int i;\n    int j;\n    int k;\n    int len;\n    int len2;\n    int len3;\n\
    \    int len4;\n    int len5;\n    int len6;\n    int len7;\n    int len8;\n \
    \   int len9;\n    int len10;\n    int len11;\n    int len12;\n    int len13;\n\
    \    int len14;\n    int len15;\n    int len16;\n    int len17;\n    int len18;\n\
    \    int len19;\n    int len20;\n    int len21;\n    int len22;\n    int len23;\n\
    \    int len24;\n    int len25;\n    int len26;\n    int len27;\n    int len28;\n\
    \    int len29;\n    int len30;\n    int len31;\n    int len32;\n    int len33;\n\
    \    int len34;\n    int len35;\n    int len36;\n    int len37;\n    int len38;\n\
    \    int len39;\n    int len40;\n    int len41;\n    int len42;\n    int len43;\n\
    \    int len44;\n    int len45;\n    int len46;\n    int len47;\n    int len48;\n\
    \    int len49;\n    int len50;\n    int len51;\n    int len52;\n    int len53;\n\
    \    int len54;\n    int len55;\n    int len56;\n    int len57;\n    int len58;\n\
    \    int len59;\n    int len60;\n    int len61;\n    int len62;\n    int len63;\n\
    \    int len64;\n    int len65;\n    int len66;\n    int len67;\n    int len68;\n\
    \    int len69;\n    int len70;\n    int len71;\n    int len72;\n    int len73;\n\
    \    int len74;\n    int len75;\n    int len76;\n    int len77;\n    int len78\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy9grsdh5.d(99): Error: semicolon expected, not \''unittest\''\n/tmp/tmpy9grsdh5.d(99):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy9grsdh5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_level = 0;\n        long level = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                level++;\n\
    \                max_level = max(max_level, level);\n            } \n        \
    \    else if(paren == ')') \n            {\n                level--;\n       \
    \     }\n        }\n        result ~= max_level;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1a7o6kt1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocz90hec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren_group; paren_string.split(\" \")) \n\
    \    {\n        long max_depth = 0;\n        long depth = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             depth++;\n                max_depth = max(max_depth, depth);\n \
    \           } \n            else if(paren == ')') \n            {\n          \
    \      depth--;\n            }\n        }\n        result ~= max_depth;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmporll64qd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int\
    \ n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n\
    \    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int\
    \ aa;\n    int ab;\n    int ac;\n    int ad;\n    int ae;\n    int af;\n    int\
    \ ag;\n    int ah;\n    int ai;\n    int aj;\n    int ak;\n    int al;\n    int\
    \ am;\n    int an;\n    int ao;\n    int ap;\n    int aq;\n    int ar;\n    int\
    \ as;\n    int at;\n    int au;\n    int av;\n    int aw;\n    int ax;\n    int\
    \ ay;\n    int az;\n    int ba;\n    int bb;\n    int bc;\n    int bd;\n    int\
    \ be;\n    int bf;\n    int bg;\n    int bh;\n    int bi;\n    int bj;\n    int\
    \ bk;\n    int bl;\n    int bm;\n    int bn;\n    int bo;\n    int bp;\n    int\
    \ bq;\n    int br;\n    int bs;\n    int bt;\n    int bu;\n    int bv;\n    int\
    \ bw;\n    int bx;\n    int by;\n    int bz;\n    int ca;\n    int cb;\n    int\
    \ cc;\n    int cd;\n    int ce;\n    int cf;\n    int cg;\n    int ch;\n    int\
    \ ci;\n    int cj;\n    int ck;\n    int cl;\n    int cm;\n    int cn;\n    int\
    \ co;\n    int cp;\n    int cq;\n    int cr;\n    int cs;\n    int ct;\n    int\
    \ cu;\n    int cv;\n    int cw;\n    int cx;\n\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi7889ubt.d(110): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi7889ubt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = paren_string.split(\" \");\n    long[] result;\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long max_nesting = 0;\n        long current_nesting\
    \ = 0;\n        foreach(paren; paren_group)\n        {\n            if(paren ==\
    \ '(')\n            {\n                current_nesting += 1;\n               \
    \ max_nesting = max(max_nesting, current_nesting);\n            }\n          \
    \  else if(paren == ')')\n            {\n                current_nesting -= 1;\n\
    \            }\n        }\n        result ~= max_nesting;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1u_9e15y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    long[] stack = new long[];\n    foreach(paren_group;\
    \ paren_string.split(\" \")) \n    {\n        foreach(paren; paren_group) \n \
    \       {\n            if(paren == '(')\n                stack ~= 1;\n       \
    \     else if(paren == ')') \n            {\n                if(stack.length >\
    \ 0)\n                    stack[$-1]++;\n            }\n        }\n        result\
    \ ~= stack.length > 0 ? max(stack) : 0;\n        stack = new long[];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyd47s0s.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocz90hec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        stack = [];\n        max_depth = 0;\n        foreach (paren;\
    \ paren_group) \n        {\n            if (paren == '(') \n            {\n  \
    \              stack ~= 1;\n                max_depth = max(max_depth, stack.length);\n\
    \            } \n            else if (paren == ')') \n            {\n        \
    \        stack.pop;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv32rjm15.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long len;\n    char ch;\n    // split the string into groups\n    string[]\
    \ groups = paren_string.split(\" \");\n    foreach(string group; groups) {\n \
    \       // initialize the stack and max_depth\n        stack = new long[];\n \
    \       max_depth = 0L;\n        depth = 0L;\n        // iterate over each character\
    \ in the group\n        len = group.length;\n        for(i = 0L; i < len; i++)\
    \ {\n            ch = group[i];\n            // if the character is '(' then push\
    \ the current depth to the stack\n            if(ch == '(') {\n              \
    \  stack ~= depth;\n                depth++;\n                // update the max_depth\
    \ if the current depth is greater than the max_depth\n                if(depth\
    \ > max_depth) {\n                    max_depth = depth;\n                }\n\
    \            }\n            // if the character is ')' then pop the depth from\
    \ the stack\n            else if(ch == ')') {\n                depth = stack.pop;\n\
    \            }\n        }\n        // push the max_depth to the result\n     \
    \   result ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmr1nk1xl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int current_level = 0;\n    int max_level = 0;\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            current_level++;\n\
    \            max_level = max(max_level, current_level);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_level--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_level;\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx86f3lsm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int paren_count = 0;\n    int max_paren_count = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            paren_count++;\n\
    \            max_paren_count = max(max_paren_count, paren_count);\n        }\n\
    \        else if(c == ')')\n        {\n            paren_count--;\n        }\n\
    \        else if(c == ' ')\n        {\n            result ~= max_paren_count;\n\
    \            max_paren_count = 0;\n            paren_count = 0;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkz8isi53.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        int max_depth = 0;\n        int depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n                depth++;\n\
    \            else if(paren == ')')\n                depth--;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpst_3wgbn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int[] paren_count;\n    int[] paren_count_max;\n    int[] paren_count_min;\n\
    \    int[] paren_count_max_index;\n    int[] paren_count_min_index;\n    int[]\
    \ paren_count_max_index_diff;\n    int[] paren_count_min_index_diff;\n    int[]\
    \ paren_count_max_index_diff_max;\n    int[] paren_count_min_index_diff_max;\n\
    \    int[] paren_count_max_index_diff_min;\n    int[] paren_count_min_index_diff_min;\n\
    \    int[] paren_count_max_index_diff_max_index;\n    int[] paren_count_min_index_diff_max_index;\n\
    \    int[] paren_count_max_index_diff_min_index;\n    int[] paren_count_min_index_diff_min_index;\n\
    \    int[] paren_count_max_index_diff_max_index_diff;\n    int[] paren_count_min_index_diff_max_index_diff;\n\
    \    int[] paren_count_max_index_diff_min_index_diff;\n    int[] paren_count_min_index_diff_min_index_diff;\n\
    \    int[] paren_count_max_index_diff_max_index_diff_max;\n    int[] paren_count_min_index_diff_max_index_diff_max;\n\
    \    int[] paren_count_max_index_diff_min_index_diff_max;\n    int[] paren_count_min_index_diff_min_index_diff_max;\n\
    \    int[] paren_count_max_index_diff_max_index_diff_min;\n    int[] paren_count_min_index_diff_max_index_diff_min;\n\
    \    int[] paren_count_max_index_diff_min_index_diff_min;\n    int[] paren_count_min_index_diff_min_index_diff_min;\n\
    \    int[] p\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkmw3ty2d.d(43): Error: semicolon expected, not \''unittest\''\n/tmp/tmpkmw3ty2d.d(43):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkmw3ty2d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_depth++;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppa3txi9p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int level = 0;\n    foreach(paren; paren_string)\n    {\n     \
    \   if(paren == '(')\n            level++;\n        else if(paren == ')')\n  \
    \          level--;\n        else\n        {\n            result ~= level;\n \
    \           level = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt9rdxlje.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocz90hec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_level;\n    int level;\n    int i;\n    int j;\n    int\
    \ k;\n    int n;\n    int m;\n    int p;\n    int q;\n    int r;\n    int s;\n\
    \    int t;\n    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n    int\
    \ z;\n    int aa;\n    int bb;\n    int cc;\n    int dd;\n    int ee;\n    int\
    \ ff;\n    int gg;\n    int hh;\n    int ii;\n    int jj;\n    int kk;\n    int\
    \ ll;\n    int mm;\n    int nn;\n    int oo;\n    int pp;\n    int qq;\n    int\
    \ rr;\n    int ss;\n    int tt;\n    int uu;\n    int vv;\n    int ww;\n    int\
    \ xx;\n    int yy;\n    int zz;\n    int aaa;\n    int bbb;\n    int ccc;\n  \
    \  int ddd;\n    int eee;\n    int fff;\n    int ggg;\n    int hhh;\n    int iii;\n\
    \    int jjj;\n    int kkk;\n    int lll;\n    int mmm;\n    int nnn;\n    int\
    \ ooo;\n    int ppp;\n    int qqq;\n    int rrr;\n    int sss;\n    int ttt;\n\
    \    int uuu;\n    int vvv;\n    int www;\n    int xxx;\n    int yyy;\n    int\
    \ zzz;\n    int aaaa;\n    int bbbb;\n    int cccc;\n    int dddd;\n    int eeee;\n\
    \    int ffff;\n    int gggg;\n    int hhhh;\n    int iiii;\n    int jjjj;\n \
    \   int kkkk;\n    int llll;\n    int mmmm;\n    int nnnn;\n    int oooo;\n  \
    \  int pppp;\n    int qqqq\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbvc0vu52.d(102): Error: semicolon expected, not \''unittest\''\n/tmp/tmpbvc0vu52.d(102):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpbvc0vu52.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')') \n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ') \n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpysbs_vdf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int[] paren_count;\n    int paren_count_index = 0;\n    int paren_count_max\
    \ = 0;\n    int paren_count_max_index = 0;\n    int paren_count_max_index_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev = 0;\n    int paren_count_max_index_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev = 0;\n   \
    \ int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count_max_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_count\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6zvda5u4.d(35): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6zvda5u4.d(35):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6zvda5u4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        max_depth = 0;\n        stack = [];\n        foreach (paren;\
    \ paren_group) \n        {\n            if (paren == '(') \n            {\n  \
    \              stack ~= 1;\n                max_depth = max(max_depth, stack.length);\n\
    \            } \n            else if (paren == ')') \n            {\n        \
    \        stack.pop;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp09jbcinj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_nesting = 0;\n    long nesting = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            nesting++;\n       \
    \     max_nesting = max(max_nesting, nesting);\n        } \n        else if (c\
    \ == ')') \n        {\n            nesting--;\n        } \n        else if (c\
    \ == ' ') \n        {\n            result ~= max_nesting;\n            max_nesting\
    \ = 0;\n            nesting = 0;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3q1d0lo9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ugeukux.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = paren_string.split(\" \");\n    long[] result;\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long max_nesting = 0;\n        long current_nesting\
    \ = 0;\n        foreach(paren; paren_group)\n        {\n            if(paren ==\
    \ '(')\n            {\n                current_nesting++;\n                max_nesting\
    \ = max(max_nesting, current_nesting);\n            }\n            else if(paren\
    \ == ')')\n            {\n                current_nesting--;\n            }\n\
    \        }\n        result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk13u78np.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_level = 0;\n        long current_level = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_level++;\n                max_level = max(max_level, current_level);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_level--;\n            }\n        }\n        result ~= max_level;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpod0fb3bk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if(c == '(') \n        {\n            depth++;\n          \
    \  max_depth = max(max_depth, depth);\n        }\n        else if(c == ')') \n\
    \        {\n            depth--;\n        }\n        else if(c == ' ') \n    \
    \    {\n            result ~= max_depth;\n            max_depth = 0;\n       \
    \     depth = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjrt4ekwx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_depth = 0;\n    int depth = 0;\n    foreach(ch; paren_string)\n\
    \    {\n        if(ch == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(ch == ')')\n        {\n\
    \            depth--;\n        }\n        else if(ch == ' ')\n        {\n    \
    \        result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdqvcl1xq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int paren_count = 0;\n    int max_paren_count = 0;\n    foreach(paren;\
    \ paren_string)\n    {\n        if(paren == '(')\n        {\n            paren_count++;\n\
    \            max_paren_count = max(max_paren_count, paren_count);\n        }\n\
    \        else if(paren == ')')\n        {\n            paren_count--;\n      \
    \  }\n        else if(paren == ' ')\n        {\n            result ~= max_paren_count;\n\
    \            max_paren_count = 0;\n            paren_count = 0;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvtixuv6k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] temp;\n    long[] temp2;\n    long[] temp3;\n    long[]\
    \ temp4;\n    long[] temp5;\n    long[] temp6;\n    long[] temp7;\n    long[]\
    \ temp8;\n    long[] temp9;\n    long[] temp10;\n    long[] temp11;\n    long[]\
    \ temp12;\n    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n    long[]\
    \ temp16;\n    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n    long[]\
    \ temp20;\n    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n    long[]\
    \ temp24;\n    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n    long[]\
    \ temp28;\n    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n    long[]\
    \ temp32;\n    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n    long[]\
    \ temp36;\n    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n    long[]\
    \ temp40;\n    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n    long[]\
    \ temp44;\n    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n    long[]\
    \ temp48;\n    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n    long[]\
    \ temp52;\n    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n    long[]\
    \ temp56;\n    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n    long[]\
    \ temp60;\n    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n    long[]\
    \ temp64;\n    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n    long[]\
    \ temp68;\n    long[] temp69;\n    long[] temp70;\n    long[] temp71;\n    long[]\
    \ temp72;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpudhw6zyg.d(88): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpudhw6zyg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int len = paren_string.length;\n    while (i <\
    \ len)\n    {\n        int j = i;\n        int count = 0;\n        while (j <\
    \ len && paren_string[j] != ' ')\n        {\n            if (paren_string[j] ==\
    \ '(')\n                count++;\n            else if (paren_string[j] == ')')\n\
    \                count--;\n            j++;\n        }\n        result ~= count;\n\
    \        i = j + 1;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp57x0kc87.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_level = 0;\n        long current_level = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_level++;\n                max_level = max(max_level, current_level);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_level--;\n            }\n        }\n        result ~= max_level;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpod0fb3bk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Split\
    \ the string into groups of parentheses\n    auto paren_groups = paren_string.split(\"\
    \ \");\n    // Initialize the result array\n    long[] result;\n    // For each\
    \ group of parentheses\n    foreach (paren_group; paren_groups) \n    {\n    \
    \    // Initialize the stack\n        Stack!(char[]) stack;\n        // Initialize\
    \ the current level of nesting\n        long curr_level = 0;\n        // Initialize\
    \ the maximum level of nesting\n        long max_level = 0;\n        // For each\
    \ character in the group\n        foreach (paren; paren_group) \n        {\n \
    \           // If the character is an opening parenthesis\n            if (paren\
    \ == '(') \n            {\n                // Push the character to the stack\n\
    \                stack.push(paren);\n                // Increment the current\
    \ level of nesting\n                curr_level++;\n                // Update the\
    \ maximum level of nesting\n                max_level = max(max_level, curr_level);\n\
    \            } \n            // If the character is a closing parenthesis\n  \
    \          else if (paren == ')') \n            {\n                // Pop the\
    \ stack\n                stack.pop();\n                // Decrement the current\
    \ level of nesting\n                curr_level--;\n            }\n        }\n\
    \        // Append the maximum level of nesting to the result array\n        result\
    \ ~= max_level;\n    }\n    // Return the result array\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpebh32apu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        int max_depth = 0;\n        int depth = 0;\n        foreach(c;\
    \ paren_group)\n        {\n            if(c == '(')\n                depth++;\n\
    \            else if(c == ')')\n                depth--;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprpd7rslp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_nesting = 0;\n        long current_nesting = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_nesting++;\n                max_nesting = max(max_nesting,\
    \ current_nesting);\n            }\n            else if(paren == ')')\n      \
    \      {\n                current_nesting--;\n            }\n        }\n     \
    \   result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ktyos30.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    auto paren_groups = paren_string.split(\" \");\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long max_depth = 0;\n        long depth = 0;\n\
    \        foreach(paren; paren_group)\n        {\n            if(paren == '(')\n\
    \                depth++;\n            else if(paren == ')')\n               \
    \ depth--;\n            max_depth = max(max_depth, depth);\n        }\n      \
    \  result ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvtkdqjl2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int max_nesting = 0;\n    int cur_nesting = 0;\n \
    \   foreach(c; paren_string) \n    {\n        if(c == '(') \n        {\n     \
    \       cur_nesting++;\n            max_nesting = max(max_nesting, cur_nesting);\n\
    \        }\n        else if(c == ')') \n        {\n            cur_nesting--;\n\
    \        }\n        else if(c == ' ') \n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            cur_nesting = 0;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbgi0dgg8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_depth = 0;\n    int current_depth = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')') \n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ') \n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4pv8hu2i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    string[] groups = paren_string.split(\" \");\n   \
    \ foreach(string group; groups)\n    {\n        long max_level = 0;\n        long\
    \ level = 0;\n        foreach(char c; group)\n        {\n            if(c == '(')\n\
    \            {\n                level++;\n                max_level = max(max_level,\
    \ level);\n            }\n            else if(c == ')')\n            {\n     \
    \           level--;\n            }\n        }\n        result ~= max_level;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfxxpbccm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int[] paren_stack;\n    int paren_stack_top = 0;\n    int paren_stack_max\
    \ = 0;\n    int paren_stack_min = 0;\n    int paren_stack_min_idx = 0;\n    int\
    \ paren_stack_max_idx = 0;\n    int paren_stack_min_idx_prev = 0;\n    int paren_stack_max_idx_prev\
    \ = 0;\n    int paren_stack_min_idx_prev_prev = 0;\n    int paren_stack_max_idx_prev_prev\
    \ = 0;\n    int paren_stack_min_idx_prev_prev_prev = 0;\n    int paren_stack_max_idx_prev_prev_prev\
    \ = 0;\n    int paren_stack_min_idx_prev_prev_prev_prev = 0;\n    int paren_stack_max_idx_prev_prev_prev_prev\
    \ = 0;\n    int paren_stack_min_idx_prev_prev_prev_prev_prev = 0;\n    int paren_stack_max_idx_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_stack_min_idx_prev_prev_prev_prev_prev_prev = 0;\n    int\
    \ paren_stack_max_idx_prev_prev_prev_prev_prev_prev = 0;\n    int paren_stack_min_idx_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    int paren_stack_max_idx_prev_prev_prev_prev_prev_prev_prev = 0;\n\
    \    int paren_stack_min_idx_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  \
    \  int paren_stack_max_idx_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    int\
    \ paren_stack_min_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    int\
    \ paren_stack_max_idx\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpizb5skgs.d(39): Error: semicolon expected, not \''unittest\''\n/tmp/tmpizb5skgs.d(39):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpizb5skgs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_nesting = 0;\n    int nesting = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            nesting++;\n            max_nesting\
    \ = max(max_nesting, nesting);\n        }\n        else if(c == ')')\n       \
    \ {\n            nesting--;\n        }\n        else if(c == ' ')\n        {\n\
    \            result ~= max_nesting;\n            max_nesting = 0;\n          \
    \  nesting = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpos8wlvda.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long len;\n    long c;\n    long paren_count;\n    long[] paren_counts;\n\
    \    len = paren_string.length;\n    stack = new long[];\n    max_depth = 0L;\n\
    \    depth = 0L;\n    paren_count = 0L;\n    paren_counts = new long[];\n    for\
    \ (i = 0L; i < len; i++)\n    {\n        c = paren_string[i];\n        if (c ==\
    \ '(')\n        {\n            stack ~= c;\n            depth++;\n           \
    \ if (depth > max_depth)\n            {\n                max_depth = depth;\n\
    \            }\n        }\n        else if (c == ')')\n        {\n           \
    \ if (stack.length > 0L)\n            {\n                stack.pop();\n      \
    \          depth--;\n            }\n            else\n            {\n        \
    \        throw new Exception(\"Invalid input\");\n            }\n        }\n \
    \       else if (c == ' ')\n        {\n            if (stack.length == 0L)\n \
    \           {\n                paren_counts ~= max_depth;\n                max_depth\
    \ = 0L;\n                depth = 0L;\n            }\n        }\n        else\n\
    \        {\n            throw new Exception(\"Invalid input\");\n        }\n \
    \   }\n    if (stack.length > 0L)\n    {\n        throw new Exception(\"Invalid\
    \ input\");\n    }\n    paren_counts ~= max_depth;\n    return paren_counts;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1vdj_cna.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbp2r2x6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        long max_nesting = 0;\n        long current_nesting = 0;\n   \
    \     foreach(paren; paren_group)\n        {\n            if(paren == '(')\n \
    \           {\n                current_nesting++;\n                max_nesting\
    \ = max(max_nesting, current_nesting);\n            }\n            else if(paren\
    \ == ')')\n            {\n                current_nesting--;\n            }\n\
    \        }\n        result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphn8iwy1r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    foreach\
    \ (paren_group; paren_string.split)\n    {\n        stack = [];\n        max_depth\
    \ = 0;\n        depth = 0;\n        foreach (paren; paren_group)\n        {\n\
    \            if (paren == '(')\n            {\n                stack ~= 1;\n \
    \               depth += 1;\n                max_depth = max(max_depth, depth);\n\
    \            }\n            else if (paren == ')')\n            {\n          \
    \      stack.pop;\n                depth -= 1;\n            }\n        }\n   \
    \     if (stack.length == 0)\n        {\n            result ~= max_depth;\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnzj3kfi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        long max_depth = 0;\n        long depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           depth++;\n                max_depth = max(max_depth, depth);\n   \
    \         }\n            else if(paren == ')')\n            {\n              \
    \  depth--;\n            }\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8885vx_0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_nesting = 0;\n        long current_nesting = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_nesting++;\n                max_nesting = max(max_nesting,\
    \ current_nesting);\n            }\n            else if(paren == ')')\n      \
    \      {\n                current_nesting--;\n            }\n        }\n     \
    \   result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ktyos30.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    foreach(paren_group; paren_string.split)\n    {\n\
    \        long max_depth = 0;\n        long depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n                depth++;\n\
    \            else if(paren == ')')\n                depth--;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3bxecjx1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    foreach\
    \ (paren_group; paren_string.split(\" \"))\n    {\n        stack = [];\n     \
    \   max_depth = 0;\n        depth = 0;\n        foreach (paren; paren_group)\n\
    \        {\n            if (paren == '(')\n            {\n                stack\
    \ ~= '(';\n                depth++;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if (paren == ')')\n            {\n\
    \                stack.pop;\n                depth--;\n            }\n       \
    \ }\n        result ~= max_depth;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwlacz3mt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_nesting = 0;\n    int nesting = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            nesting++;\n            max_nesting\
    \ = max(max_nesting, nesting);\n        }\n        else if(c == ')')\n       \
    \ {\n            nesting--;\n        }\n        else if(c == ' ')\n        {\n\
    \            result ~= max_nesting;\n            max_nesting = 0;\n          \
    \  nesting = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpos8wlvda.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        int max_depth = 0;\n        int depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           depth++;\n                max_depth = max(max_depth, depth);\n   \
    \         }\n            else if(paren == ')')\n            {\n              \
    \  depth--;\n            }\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6cku96wl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long[] max_stack;\n    long max_depth;\n   \
    \ long current_depth;\n    long i;\n    long j;\n    long k;\n    long len;\n\
    \    long len2;\n    long len3;\n    long len4;\n    long len5;\n    long len6;\n\
    \    long len7;\n    long len8;\n    long len9;\n    long len10;\n    long len11;\n\
    \    long len12;\n    long len13;\n    long len14;\n    long len15;\n    long\
    \ len16;\n    long len17;\n    long len18;\n    long len19;\n    long len20;\n\
    \    long len21;\n    long len22;\n    long len23;\n    long len24;\n    long\
    \ len25;\n    long len26;\n    long len27;\n    long len28;\n    long len29;\n\
    \    long len30;\n    long len31;\n    long len32;\n    long len33;\n    long\
    \ len34;\n    long len35;\n    long len36;\n    long len37;\n    long len38;\n\
    \    long len39;\n    long len40;\n    long len41;\n    long len42;\n    long\
    \ len43;\n    long len44;\n    long len45;\n    long len46;\n    long len47;\n\
    \    long len48;\n    long len49;\n    long len50;\n    long len51;\n    long\
    \ len52;\n    long len53;\n    long len54;\n    long len55;\n    long len56;\n\
    \    long len57;\n    long len58;\n    long len59;\n    long len60;\n    long\
    \ len61;\n    long len62;\n    long len63;\n    long len64;\n    long len65;\n\
    \    long len66;\n    long len67;\n    long len68;\n    long len69;\n    long\
    \ len70;\n    long len71;\n    long len72;\n    long len73;\n    long len74;\n\
    \    long len75;\n    long len76;\n    long len77;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsxpn8ijl.d(99): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsxpn8ijl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long j;\n    long k;\n    long n;\n    long m;\n    long p;\n    long q;\n\
    \    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n\
    \    long x;\n    long y;\n    long z;\n    long aa;\n    long ab;\n    long ac;\n\
    \    long ad;\n    long ae;\n    long af;\n    long ag;\n    long ah;\n    long\
    \ ai;\n    long aj;\n    long ak;\n    long al;\n    long am;\n    long an;\n\
    \    long ao;\n    long ap;\n    long aq;\n    long ar;\n    long as;\n    long\
    \ at;\n    long au;\n    long av;\n    long aw;\n    long ax;\n    long ay;\n\
    \    long az;\n    long ba;\n    long bb;\n    long bc;\n    long bd;\n    long\
    \ be;\n    long bf;\n    long bg;\n    long bh;\n    long bi;\n    long bj;\n\
    \    long bk;\n    long bl;\n    long bm;\n    long bn;\n    long bo;\n    long\
    \ bp;\n    long bq;\n    long br;\n    long bs;\n    long bt;\n    long bu;\n\
    \    long bv;\n    long bw;\n    long bx;\n    long by;\n    long bz;\n    long\
    \ ca;\n    long cb;\n    long cc;\n    long cd;\n    long ce;\n    long cf;\n\
    \    long cg;\n    long ch;\n    long ci;\n    long cj;\n    long ck;\n    long\
    \ cl;\n    long cm;\n    long cn;\n    long co;\n    long cp;\n    long cq;\n\
    \    long cr;\n    long cs;\n    long ct;\n    long cu;\n    long cv;\n    long\
    \ c\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiqrwvron.d(109): Error: semicolon expected, not \''unittest\''\n/tmp/tmpiqrwvron.d(109):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpiqrwvron.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long current_level = 0;\n    long max_level = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_level++;\n\
    \            max_level = max(max_level, current_level);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_level--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_level;\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeu0tx_qh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    foreach\
    \ (paren_group; paren_string.split(\" \")) \n    {\n        max_depth = 0;\n \
    \       depth = 0;\n        stack = [];\n        foreach (paren; paren_group)\
    \ \n        {\n            if (paren == '(') \n            {\n               \
    \ stack ~= 1;\n                depth++;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else \n            {\n                stack.pop();\n\
    \                depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtt8w5iy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // TODO:\
    \ implement this function\n    return [2L, 3L, 1L, 3L];\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6x33l4nq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    int i;\n\
    \    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int o;\n    int\
    \ p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n    int v;\n\
    \    int w;\n    int x;\n    int y;\n    int z;\n    int aa;\n    int ab;\n  \
    \  int ac;\n    int ad;\n    int ae;\n    int af;\n    int ag;\n    int ah;\n\
    \    int ai;\n    int aj;\n    int ak;\n    int al;\n    int am;\n    int an;\n\
    \    int ao;\n    int ap;\n    int aq;\n    int ar;\n    int as;\n    int at;\n\
    \    int au;\n    int av;\n    int aw;\n    int ax;\n    int ay;\n    int az;\n\
    \    int ba;\n    int bb;\n    int bc;\n    int bd;\n    int be;\n    int bf;\n\
    \    int bg;\n    int bh;\n    int bi;\n    int bj;\n    int bk;\n    int bl;\n\
    \    int bm;\n    int bn;\n    int bo;\n    int bp;\n    int bq;\n    int br;\n\
    \    int bs;\n    int bt;\n    int bu;\n    int bv;\n    int bw;\n    int bx;\n\
    \    int by;\n    int bz;\n    int ca;\n    int cb;\n    int cc;\n    int cd;\n\
    \    int ce;\n    int cf;\n    int cg;\n    int ch;\n    int ci;\n    int cj;\n\
    \    int ck;\n    int cl;\n    int cm;\n    int cn;\n    int co;\n    int cp;\n\
    \    int cq;\n    int cr;\n    int cs;\n    int ct;\n    int cu;\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2kd1dcuz.d(109): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2kd1dcuz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long paren_count;\n    long paren_start;\n    long paren_end;\n    long paren_length;\n\
    \    string paren_group;\n    string[] paren_groups;\n    paren_groups = paren_string.split(\"\
    \ \");\n    result = new long[paren_groups.length];\n    foreach (i, paren_group;\
    \ paren_groups)\n    {\n        stack = new long[];\n        max_depth = 0L;\n\
    \        depth = 0L;\n        paren_count = 0L;\n        paren_start = 0L;\n \
    \       paren_end = 0L;\n        paren_length = paren_group.length;\n        while\
    \ (paren_count < paren_length)\n        {\n            if (paren_group[paren_count]\
    \ == '(')\n            {\n                stack ~= paren_count;\n            \
    \    depth += 1L;\n                if (depth > max_depth)\n                {\n\
    \                    max_depth = depth;\n                }\n            }\n  \
    \          else if (paren_group[paren_count] == ')')\n            {\n        \
    \        paren_start = stack[$ - 1L];\n                paren_end = paren_count;\n\
    \                stack = stack[0 .. $ - 1L];\n                depth -= 1L;\n \
    \           }\n            paren_count += 1L;\n        }\n        result[i] =\
    \ max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilusb27_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int start = 0;\n    int end = 0;\n    while (end <\
    \ paren_string.length) \n    {\n        if (paren_string[end] == ' ') \n     \
    \   {\n            result ~= parse_nested_parens_helper(paren_string[start..end]);\n\
    \            start = end + 1;\n        }\n        end++;\n    }\n    result ~=\
    \ parse_nested_parens_helper(paren_string[start..end]);\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdiai7z9q.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_depth++;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppa3txi9p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = paren_string.split(\" \");\n    long[] result;\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long max_nesting = 0;\n        long nesting =\
    \ 0;\n        foreach(paren; paren_group)\n        {\n            if(paren ==\
    \ '(')\n            {\n                nesting++;\n                max_nesting\
    \ = max(max_nesting, nesting);\n            }\n            else if(paren == ')')\n\
    \            {\n                nesting--;\n            }\n        }\n       \
    \ result ~= max_nesting;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9flslglv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_level = 0;\n    long level = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            level++;\n            max_level\
    \ = max(max_level, level);\n        }\n        else if(c == ')')\n        {\n\
    \            level--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_level;\n            max_level = 0;\n            level =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk6v6xszo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long len;\n    long c;\n    long group_start;\n    long group_end;\n    long\
    \ group_len;\n    string group;\n    len = paren_string.length;\n    stack = new\
    \ long[];\n    result = new long[];\n    group_start = 0;\n    group_end = 0;\n\
    \    for (i = 0; i < len; i++) \n    {\n        c = paren_string[i];\n       \
    \ if (c == '(') \n        {\n            stack ~= 1;\n        }\n        else\
    \ if (c == ')') \n        {\n            stack ~= -1;\n        }\n        else\
    \ if (c == ' ') \n        {\n            group_end = i;\n            group_len\
    \ = group_end - group_start;\n            group = paren_string[group_start ..\
    \ group_end];\n            max_depth = 0;\n            depth = 0;\n          \
    \  foreach (paren; stack) \n            {\n                depth += paren;\n \
    \               max_depth = max(max_depth, depth);\n            }\n          \
    \  result ~= max_depth;\n            stack = new long[];\n            group_start\
    \ = i + 1;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk7qqrwzn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int level = 0;\n    int max_level = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            level++;\n            max_level\
    \ = max(max_level, level);\n        }\n        else if(c == ')')\n        {\n\
    \            level--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_level;\n            max_level = 0;\n            level =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwm5afe4q.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int paren_count = 0;\n    int max_paren_count = 0;\n    foreach(paren;\
    \ paren_string)\n    {\n        if(paren == '(')\n        {\n            paren_count++;\n\
    \            max_paren_count = max(max_paren_count, paren_count);\n        }\n\
    \        else if(paren == ')')\n        {\n            paren_count--;\n      \
    \  }\n        else if(paren == ' ')\n        {\n            result ~= max_paren_count;\n\
    \            max_paren_count = 0;\n            paren_count = 0;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvtixuv6k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max;\n    long current;\n    long i;\n\
    \    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n\
    \    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n\
    \    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long\
    \ ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n\
    \    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long\
    \ ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n\
    \    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long\
    \ bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n\
    \    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long\
    \ bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n\
    \    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long\
    \ by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n\
    \    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long\
    \ cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n\
    \    long cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long\
    \ cu;\n   \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph8y_l3_2.d(110): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph8y_l3_2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int start = 0;\n    foreach(i; 0 .. paren_string.length)\n\
    \    {\n        if(paren_string[i] == ' ')\n        {\n            result ~= parse_nested_parens_helper(paren_string[start\
    \ .. i]);\n            start = i + 1;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp31f45h_1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvggybk_1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] paren_count;\n    long[] paren_max;\n    long[] paren_level;\n\
    \    long[] paren_level_max;\n    long[] paren_level_max_idx;\n    long[] paren_level_max_idx_count;\n\
    \    long[] paren_level_max_idx_count_max;\n    long[] paren_level_max_idx_count_max_idx;\n\
    \    long[] paren_level_max_idx_count_max_idx_count;\n    long[] paren_level_max_idx_count_max_idx_count_max;\n\
    \    long[] paren_level_max_idx_count_max_idx_count_max_idx;\n    long[] paren_level_max_idx_count_max_idx_count_max_idx_count;\n\
    \    long[] paren_level_max_idx_count_max_idx_count_max_idx_count_max;\n    long[]\
    \ paren_level_max_idx_count_max_idx_count_max_idx_count_max_idx;\n    long[] paren_level_max_idx_count_max_idx_count_max_idx_count_max_idx_count;\n\
    \    long[] paren_level_max_idx_count_max_idx_count_max_idx_count_max_idx_count_max;\n\
    \    long[] paren_level_max_idx_count_max_idx_count_max_idx_count_max_idx_count_max_idx;\n\
    \    long[] paren_level_max_idx_count_max_idx_count_max_idx_count_max_idx_count_max_idx_count;\n\
    \    long[] paren_level_max_idx_count_max_idx_count_max_idx_count_max_idx_count_max_idx_count_max;\n\
    \    long[] paren_level_max_idx_count_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp88c9sj80.d(35): Error: semicolon expected, not \''unittest\''\n/tmp/tmp88c9sj80.d(35):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp88c9sj80.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int current_level = 0;\n    int max_level = 0;\n \
    \   foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n       \
    \     current_level++;\n            max_level = max(max_level, current_level);\n\
    \        }\n        else if(c == ')')\n        {\n            current_level--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_level;\n\
    \            max_level = 0;\n            current_level = 0;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp08wr0pnr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_depth += 1;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_depth -= 1;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzqp9f9qt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int i = 0;\n    while (i < paren_string.length) \n\
    \    {\n        int start = i;\n        while (i < paren_string.length && paren_string[i]\
    \ != ' ') \n        {\n            i++;\n        }\n        string paren_group\
    \ = paren_string[start..i];\n        int max_depth = 0;\n        int depth = 0;\n\
    \        foreach (c; paren_group) \n        {\n            if (c == '(') \n  \
    \          {\n                depth++;\n                max_depth = max(max_depth,\
    \ depth);\n            } \n            else if (c == ')') \n            {\n  \
    \              depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc9qiwp4d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long current_depth;\n \
    \   long i;\n    long j;\n    long k;\n    long len;\n    long len2;\n    long\
    \ len3;\n    long len4;\n    long len5;\n    long len6;\n    long len7;\n    long\
    \ len8;\n    long len9;\n    long len10;\n    long len11;\n    long len12;\n \
    \   long len13;\n    long len14;\n    long len15;\n    long len16;\n    long len17;\n\
    \    long len18;\n    long len19;\n    long len20;\n    long len21;\n    long\
    \ len22;\n    long len23;\n    long len24;\n    long len25;\n    long len26;\n\
    \    long len27;\n    long len28;\n    long len29;\n    long len30;\n    long\
    \ len31;\n    long len32;\n    long len33;\n    long len34;\n    long len35;\n\
    \    long len36;\n    long len37;\n    long len38;\n    long len39;\n    long\
    \ len40;\n    long len41;\n    long len42;\n    long len43;\n    long len44;\n\
    \    long len45;\n    long len46;\n    long len47;\n    long len48;\n    long\
    \ len49;\n    long len50;\n    long len51;\n    long len52;\n    long len53;\n\
    \    long len54;\n    long len55;\n    long len56;\n    long len57;\n    long\
    \ len58;\n    long len59;\n    long len60;\n    long len61;\n    long len62;\n\
    \    long len63;\n    long len64;\n    long len65;\n    long len66;\n    long\
    \ len67;\n    long len68;\n    long len69;\n    long len70;\n    long len71;\n\
    \    long len72;\n    long len73;\n    long len74;\n    long len75;\n    long\
    \ len76;\n    long len77;\n    long len78;\n   \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1vaiv80_.d(100): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1vaiv80_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocz90hec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            } \n        \
    \    else if(paren == ')') \n            {\n                depth--;\n       \
    \     }\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvmngqlf4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfa97e0e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth = 0;\n    long depth = 0;\n \
    \   foreach (c; paren_string)\n    {\n        if (c == '(')\n        {\n     \
    \       depth++;\n            if (depth > max_depth)\n                max_depth\
    \ = depth;\n        }\n        else if (c == ')')\n        {\n            depth--;\n\
    \        }\n        else if (c == ' ')\n        {\n            if (depth != 0)\n\
    \                throw new Exception(\"Unbalanced parentheses\");\n          \
    \  result ~= max_depth;\n            max_depth = 0;\n        }\n        else\n\
    \        {\n            throw new Exception(\"Invalid character\");\n        }\n\
    \    }\n    if (depth != 0)\n        throw new Exception(\"Unbalanced parentheses\"\
    );\n    result ~= max_depth;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmqzjz3uy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long paren_count;\n    long paren_index;\n    long paren_start;\n    long\
    \ paren_end;\n    long paren_len;\n    string paren_group;\n    string paren_group_trimmed;\n\
    \    string[] paren_groups;\n    paren_groups = split(paren_string, \" \");\n\
    \    result = new long[paren_groups.length];\n    foreach (paren_group; paren_groups)\
    \ \n    {\n        paren_group_trimmed = paren_group.trim();\n        paren_len\
    \ = paren_group_trimmed.length;\n        paren_count = 0;\n        paren_index\
    \ = 0;\n        stack = new long[paren_len];\n        max_depth = 0;\n       \
    \ depth = 0;\n        foreach (i; 0 .. paren_len) \n        {\n            if\
    \ (paren_group_trimmed[i] == '(') \n            {\n                stack[paren_count]\
    \ = i;\n                paren_count++;\n                depth++;\n           \
    \     max_depth = max(max_depth, depth);\n            }\n            else if (paren_group_trimmed[i]\
    \ == ')') \n            {\n                paren_count--;\n                depth--;\n\
    \            }\n        }\n        result[paren_index] = max_depth;\n        paren_index++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqk7fiw9g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ugeukux.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\n\
    \    {\n        int max_depth = 0;\n        int depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n                depth++;\n\
    \            else if(paren == ')')\n                depth--;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpst_3wgbn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if(c == '(') \n        {\n            depth++;\n          \
    \  max_depth = max(max_depth, depth);\n        } \n        else if(c == ')') \n\
    \        {\n            depth--;\n        } \n        else if(c == ' ') \n   \
    \     {\n            result ~= max_depth;\n            max_depth = 0;\n      \
    \      depth = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps__rhfgp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_nesting = 0;\n    long nesting = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            nesting++;\n            max_nesting\
    \ = max(max_nesting, nesting);\n        }\n        else if(c == ')')\n       \
    \ {\n            nesting--;\n        }\n        else if(c == ' ')\n        {\n\
    \            result ~= max_nesting;\n            max_nesting = 0;\n          \
    \  nesting = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoj5k0jex.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int[] paren_count;\n    int paren_count_len;\n    int paren_count_idx;\n\
    \    int paren_count_max;\n    int paren_count_max_idx;\n    int paren_count_max_len;\n\
    \    int paren_count_max_len_idx;\n    int paren_count_max_len_idx_max;\n    int\
    \ paren_count_max_len_idx_max_idx;\n    int paren_count_max_len_idx_max_idx_max;\n\
    \    int paren_count_max_len_idx_max_idx_max_idx;\n    int paren_count_max_len_idx_max_idx_max_idx_max;\n\
    \    int paren_count_max_len_idx_max_idx_max_idx_max_idx;\n    int paren_count_max_len_idx_max_idx_max_idx_max_idx_max;\n\
    \    int paren_count_max_len_idx_max_idx_max_idx_max_idx_max_idx;\n    int paren_count_max_len_idx_max_idx_max_idx_max_idx_max_idx_max;\n\
    \    int paren_count_max_len_idx_max_idx_max_idx_max_idx_max_idx_max_idx;\n  \
    \  int paren_count_max_len_idx_max_idx_max_idx_max_idx_max_idx_max_idx_max;\n\
    \    int paren_count_max_len_idx_max_idx_max_idx_max_idx_max_idx_max_idx_max_idx;\n\
    \    int paren_count_max_len_idx_max_idx_max_idx_max_idx_max_idx_max_idx_max_idx_max;\n\
    \    int paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptlw_avgn.d(36): Error: semicolon expected, not \''unittest\''\n/tmp/tmptlw_avgn.d(36):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmptlw_avgn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocz90hec.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n\
    \    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n\
    \    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long\
    \ ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n\
    \    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long\
    \ ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n\
    \    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long\
    \ bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n\
    \    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long\
    \ bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n\
    \    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long\
    \ by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n\
    \    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long\
    \ cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n\
    \    long cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long\
    \ cu;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcbq_rjiu.d(109): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbq_rjiu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long j;\n    long k;\n    long n;\n    long m;\n    long p;\n    long q;\n\
    \    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n\
    \    long x;\n    long y;\n    long z;\n    long a;\n    long b;\n    long c;\n\
    \    long d;\n    long e;\n    long f;\n    long g;\n    long h;\n    long ii;\n\
    \    long jj;\n    long kk;\n    long ll;\n    long mm;\n    long nn;\n    long\
    \ oo;\n    long pp;\n    long qq;\n    long rr;\n    long ss;\n    long tt;\n\
    \    long uu;\n    long vv;\n    long ww;\n    long xx;\n    long yy;\n    long\
    \ zz;\n    long aa;\n    long bb;\n    long cc;\n    long dd;\n    long ee;\n\
    \    long ff;\n    long gg;\n    long hh;\n    long iii;\n    long jjj;\n    long\
    \ kkk;\n    long lll;\n    long mmm;\n    long nnn;\n    long ooo;\n    long ppp;\n\
    \    long qqq;\n    long rrr;\n    long sss;\n    long ttt;\n    long uuu;\n \
    \   long vvv;\n    long www;\n    long xxx;\n    long yyy;\n    long zzz;\n  \
    \  long aaaa;\n    long bbbb;\n    long cccc;\n    long dddd;\n    long eeee;\n\
    \    long ffff;\n    long gggg;\n    long hhhh;\n    long iiii;\n    long jjjj;\n\
    \    long kkkk;\n    long llll;\n    long mmmm;\n    long nnnn;\n    long oooo;\n\
    \    long pppp;\n    long qqqq;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbl6g52q4.d(104): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbl6g52q4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // TODO:\
    \ Implement me\n    return null;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjws5rut.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    int start = 0;\n    int end = 0;\n    int i = 0;\n\
    \    while (i < paren_string.length) \n    {\n        if (paren_string[i] == '(')\
    \ \n        {\n            start = i;\n            while (i < paren_string.length\
    \ && paren_string[i] != ')') \n            {\n                i++;\n         \
    \   }\n            end = i;\n            if (i == paren_string.length) \n    \
    \        {\n                break;\n            }\n            result ~= parse_nested_parens(paren_string[start..end]);\n\
    \        }\n        i++;\n    }\n    return result.length == 0 ? 1 : max(result);\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy9w6gktm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    long[] stack = new long[];\n    foreach(paren; paren_string.split(\"\
    \ \"))\n    {\n        foreach(c; paren)\n        {\n            if(c == '(')\n\
    \            {\n                stack ~= 1;\n            }\n            else if(c\
    \ == ')')\n            {\n                stack ~= -1;\n            }\n      \
    \  }\n        long max_level = 0;\n        long cur_level = 0;\n        foreach(level;\
    \ stack)\n        {\n            cur_level += level;\n            max_level =\
    \ max(max_level, cur_level);\n        }\n        result ~= max_level;\n      \
    \  stack = new long[];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp45nx5kea.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split) \n    {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        foreach(c; paren_group) \n\
    \        {\n            if(c == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            } \n        \
    \    else if(c == ')') \n            {\n                depth--;\n           \
    \ }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy2koj9gu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    auto paren_groups = paren_string.split(\" \");\n    foreach(paren_group;\
    \ paren_groups) \n    {\n        long max_depth = 0;\n        long depth = 0;\n\
    \        foreach(paren; paren_group) \n        {\n            if(paren == '(')\
    \ \n            {\n                depth++;\n            } \n            else\
    \ if(paren == ')') \n            {\n                depth--;\n            }\n\
    \            max_depth = max(max_depth, depth);\n        }\n        result ~=\
    \ max_depth;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpplb21pre.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797793
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    foreach (paren_group; paren_string.split)\
    \ \n    {\n        stack = [];\n        max_depth = 0;\n        foreach (paren;\
    \ paren_group) \n        {\n            if (paren == '(') \n            {\n  \
    \              stack ~= 1;\n                max_depth = max(max_depth, stack.length);\n\
    \            } \n            else if (paren == ')') \n            {\n        \
    \        stack.pop;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt4v6yzmi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_nesting = 0;\n    int current_nesting = 0;\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            current_nesting++;\n\
    \            max_nesting = max(max_nesting, current_nesting);\n        }\n   \
    \     else if(c == ')')\n        {\n            current_nesting--;\n        }\n\
    \        else if(c == ' ')\n        {\n            result ~= max_nesting;\n  \
    \          max_nesting = 0;\n            current_nesting = 0;\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk9fiinyc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split)\n    {\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\n       \
    \ {\n            if(paren == '(')\n                depth++;\n            else\
    \ if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8zs851a.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int\
    \ n;\n    int o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n\
    \    int u;\n    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int\
    \ aa;\n    int ab;\n    int ac;\n    int ad;\n    int ae;\n    int af;\n    int\
    \ ag;\n    int ah;\n    int ai;\n    int aj;\n    int ak;\n    int al;\n    int\
    \ am;\n    int an;\n    int ao;\n    int ap;\n    int aq;\n    int ar;\n    int\
    \ as;\n    int at;\n    int au;\n    int av;\n    int aw;\n    int ax;\n    int\
    \ ay;\n    int az;\n    int ba;\n    int bb;\n    int bc;\n    int bd;\n    int\
    \ be;\n    int bf;\n    int bg;\n    int bh;\n    int bi;\n    int bj;\n    int\
    \ bk;\n    int bl;\n    int bm;\n    int bn;\n    int bo;\n    int bp;\n    int\
    \ bq;\n    int br;\n    int bs;\n    int bt;\n    int bu;\n    int bv;\n    int\
    \ bw;\n    int bx;\n    int by;\n    int bz;\n    int ca;\n    int cb;\n    int\
    \ cc;\n    int cd;\n    int ce;\n    int cf;\n    int cg;\n    int ch;\n    int\
    \ ci;\n    int cj;\n    int ck;\n    int cl;\n    int cm;\n    int cn;\n    int\
    \ co;\n    int cp;\n    int cq;\n    int cr;\n    int cs;\n    int ct;\n    int\
    \ cu;\n    int cv;\n    int cw;\n    int cx;\n\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi7889ubt.d(110): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi7889ubt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long depth = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphrqltlem.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res = new long[];\n    foreach(paren_group; paren_string.split(\" \"))\n   \
    \ {\n        long max_nesting = 0;\n        long nesting = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n                nesting++;\n\
    \            else if(paren == ')')\n                nesting--;\n            max_nesting\
    \ = max(max_nesting, nesting);\n        }\n        res ~= max_nesting;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzieyumic.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ugeukux.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbp2r2x6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_groups = paren_string.split(\" \");\n    long[] result;\n    foreach(paren_group;\
    \ paren_groups)\n    {\n        long max_level = 0;\n        long level = 0;\n\
    \        foreach(paren; paren_group)\n        {\n            if(paren == '(')\n\
    \            {\n                level++;\n                max_level = max(max_level,\
    \ level);\n            }\n            else if(paren == ')')\n            {\n \
    \               level--;\n            }\n        }\n        result ~= max_level;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz9sizz71.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[];\n    long[] stack = new long[];\n    long max_depth = 0;\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      stack ~= 1;\n            max_depth = max(max_depth, stack.length);\n  \
    \      }\n        else if(c == ')')\n        {\n            stack.popBack();\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_cp2efw3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')') \n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ') \n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpysbs_vdf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int max_depth = 0;\n    int depth = 0;\n    foreach(ch; paren_string)\n\
    \    {\n        if(ch == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(ch == ')')\n        {\n\
    \            depth--;\n        }\n        else if(ch == ' ')\n        {\n    \
    \        result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdqvcl1xq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659797792
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n  \
    \  int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa =\
    \ 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n   \
    \ int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj =\
    \ 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n   \
    \ int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as =\
    \ 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n   \
    \ int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb =\
    \ 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n   \
    \ int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk =\
    \ 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n   \
    \ int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt =\
    \ 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx = 0;\n   \
    \ int by = 0\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq_3qu5q1.d(84): Error: semicolon expected, not `unittest`\n/tmp/tmpq_3qu5q1.d(84):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq_3qu5q1.d", "-I/tmp"]\n'''
  stdout: b''
