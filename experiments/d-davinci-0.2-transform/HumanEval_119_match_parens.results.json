{
  "language": "d",
  "name": "HumanEval_119_match_parens",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n    {\n        if(abs(c1) == abs(c2))\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c1 < 0 && c2 > 0)\n    {\n        if(abs(c1) == abs(c2))\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpag398bg4.d(80): unittest failure\n----------------\n??:? _d_unittestp [0x4291ed]\n??:? void tmpag398bg4.__unittest_L67_C1() [0x428286]\n??:? void tmpag398bg4.__modtest() [0x428454]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42db3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428f46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a9e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a975]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f1d]\n??:? runModuleUnitTests [0x42d911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprpfk05xu.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmprpfk05xu.__unittest_L43_C1() [0x4280fa]\n??:? void tmprpfk05xu.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    return count1 == count2 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1xjl7klg.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmp1xjl7klg.__unittest_L43_C1() [0x427c8c]\n??:? void tmp1xjl7klg.__modtest() [0x4282b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]\n??:? void tmpkwtm4p5r.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]\n??:? void tmpnyosqxjb.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]\n??:? void tmpj3bfejzp.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2tivff1d.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmp2tivff1d.__unittest_L38_C1() [0x427e0a]\n??:? void tmp2tivff1d.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(e; s)\n    {\n        if(e == '(')\n            count++;\n        else if(e == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcmd0rit1.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpcmd0rit1.__unittest_L40_C1() [0x427e0e]\n??:? void tmpcmd0rit1.__modtest() [0x4282b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(string str; lst)\n        s ~= str;\n    return s.balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph47lkzlz.d(26): Error: no property `balance` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph47lkzlz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n        if(count1 < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n        if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpf1qtzcsm.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpf1qtzcsm.__unittest_L49_C1() [0x427cc0]\n??:? void tmpf1qtzcsm.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == count2 && count1 >= 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm50lws27.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpm50lws27.__unittest_L46_C1() [0x427c94]\n??:? void tmpm50lws27.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n    int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < len1; i++)\n    {\n        if (s1[i] == '(')\n            count1++;\n        else\n            count1--;\n    }\n    for (int i = 0; i < len2; i++)\n    {\n        if (s2[i] == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if (count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjfnzy__1.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpjfnzy__1.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjfnzy__1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(el; lst)\n        s ~= el;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpk8182_te.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpk8182_te.__unittest_L38_C1() [0x427e0a]\n??:? void tmpk8182_te.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2tivff1d.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmp2tivff1d.__unittest_L38_C1() [0x427e0a]\n??:? void tmp2tivff1d.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return \"Yes\";\n    else if(s1_open < 0 && s2_open > 0)\n        return \"Yes\";\n    else if(s1_open > 0 && s2_open < 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptge4ijeo.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmptge4ijeo.__unittest_L50_C1() [0x427ddc]\n??:? void tmptge4ijeo.__modtest() [0x4282fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a891]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]\n??:? runModuleUnitTests [0x42d7b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n    int s2_len = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open == s1_close && s2_open != s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open == s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open != s2_close)\n    {\n        if(s1_open > s1_close)\n        {\n            if(s2_open > s2_close)\n            {\n                if(s1_open - s1_close == s2_open - s2_close)\n                    return \"Yes\";\n                else\n                    return \"No\";\n            }\n            else\n            {\n                if(s1_open - s1_close == s2_close - s2_open)\n                    return \"Yes\";\n                else\n                    return \"No\";\n            }\n        }\n        else\n        {\n            if(s2_open > s2_close)\n            {\n                if(s1_close - s1_open == s2_open - s2_close)\n                    return \"Yes\";\n                else\n                    return \"No\";\n            }\n            else\n            {\n                if(s1_close - s1_open == s2_close - s\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppz2zznfz.d(82): Error: found `unittest` when expecting `)`\n/tmp/tmppz2zznfz.d(99): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppz2zznfz.d(99): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppz2zznfz.d(99): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppz2zznfz.d(99): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppz2zznfz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2g7h0v0h.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmp2g7h0v0h.__unittest_L37_C1() [0x4280a6]\n??:? void tmp2g7h0v0h.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]\n??:? void tmp_yuh_5m2.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]\n??:? void tmpkwtm4p5r.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int cnt1 = 0;\n    int cnt2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            cnt1++;\n        else\n            cnt1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            cnt2++;\n        else\n            cnt2--;\n    }\n    if(cnt1 == 0 && cnt2 == 0)\n        return \"Yes\";\n    if(cnt1 == 0 && cnt2 < 0)\n        return \"No\";\n    if(cnt1 > 0 && cnt2 == 0)\n        return \"No\";\n    if(cnt1 > 0 && cnt2 < 0)\n    {\n        if(cnt1 == abs(cnt2))\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(cnt1 < 0 && cnt2 == 0)\n        return \"No\";\n    if(cnt1 < 0 && cnt2 > 0)\n    {\n        if(abs(cnt1) == cnt2)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpl5mmhy5z.d(78): unittest failure\n----------------\n??:? _d_unittestp [0x42918d]\n??:? void tmpl5mmhy5z.__unittest_L65_C1() [0x428226]\n??:? void tmpl5mmhy5z.__modtest() [0x4283f4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42dadb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428ee6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a989]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa18]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a915]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ebd]\n??:? runModuleUnitTests [0x42d8b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429650]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n    int[] b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n    int[] e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n    int[] h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n    int[] k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n    int[] o = new int[n];\n    int[] p = new int[n];\n    int[] q = new int[n];\n    int[] r = new int[n];\n    int[] t = new int[n];\n    int[] u = new int[n];\n    int[] v = new int[n];\n    int[] w = new int[n];\n    int[] x = new int[n];\n    int[] y = new int[n];\n    int[] z = new int[n];\n    int[] aa = new int[n];\n    int[] bb = new int[n];\n    int[] cc = new int[n];\n    int[] dd = new int[n];\n    int[] ee = new int[n];\n    int[] ff = new int[n];\n    int[] gg = new int[n];\n    int[] hh = new int[n];\n    int[] ii = new int[n];\n    int[] jj = new int[n];\n    int[] kk = new int[n];\n    int[] ll = new int[n];\n    int[] mm = new int[n];\n    int[] oo = new int[n];\n    int[] pp = new int[n];\n    int[] qq = new int[n];\n    int[] rr\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9qmihhzn.d(69): Error: semicolon expected, not `unittest`\n/tmp/tmp9qmihhzn.d(69): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9qmihhzn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 == 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 == 0)\n        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return \"No\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1 > 0 && count2 < 0)\n    {\n        if(abs(count1) == abs(count2))\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 < 0 && count2 > 0)\n    {\n        if(abs(count1) == abs(count2))\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp15db9irr.d(80): unittest failure\n----------------\n??:? _d_unittestp [0x4291ed]\n??:? void tmp15db9irr.__unittest_L67_C1() [0x428286]\n??:? void tmp15db9irr.__modtest() [0x428454]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42db3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428f46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a9e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a975]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f1d]\n??:? runModuleUnitTests [0x42d911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n    int len2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    for (int i = 0; i < len1; i++)\n    {\n        if (s1[i] == '(')\n            count1++;\n        else\n            count1--;\n    }\n    for (int i = 0; i < len2; i++)\n    {\n        if (s2[i] == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if (count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjfnzy__1.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpjfnzy__1.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjfnzy__1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161274
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpsv99zlg5.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpsv99zlg5.__unittest_L41_C1() [0x4280f6]\n??:? void tmpsv99zlg5.__modtest() [0x4282b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d993]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a841]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42d769]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429508]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]\n??:? void tmpkwtm4p5r.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2tivff1d.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmp2tivff1d.__unittest_L38_C1() [0x427e0a]\n??:? void tmp2tivff1d.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    return s.balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpydjdcrn8.d(26): Error: no property `balance` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpydjdcrn8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n    int cnt = 0;\n    int i = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            cnt++;\n        else\n            cnt--;\n        a[i++] = cnt;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            cnt++;\n        else\n            cnt--;\n        a[i++] = cnt;\n    }\n    if(cnt != 0)\n        return \"No\";\n    int min = a[0];\n    foreach(x; a)\n        min = min(min, x);\n    if(min < 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi40xu3gj.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpi40xu3gj.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\n/tmp/tmpi40xu3gj.d(51): Error: function expected before `()`, not `min` of type `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi40xu3gj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]\n??:? void tmpnyosqxjb.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpq6nlulyh.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpq6nlulyh.__unittest_L49_C1() [0x427e4a]\n??:? void tmpq6nlulyh.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]\n??:? void tmp_yuh_5m2.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpka8yz1m4.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmpka8yz1m4.__unittest_L37_C1() [0x4280a6]\n??:? void tmpka8yz1m4.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    // your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s3 = s1 ~ s2;\n    int count = 0;\n    foreach(char c; s3)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyw01dcjp.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpyw01dcjp.__unittest_L42_C1() [0x427e0a]\n??:? void tmpyw01dcjp.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d993]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a841]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42d769]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429508]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]\n??:? void tmpj3bfejzp.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        if (dp[i] == 0)\n            continue;\n        if (i < n1 && s1[i] == '(')\n            dp[i + 1] = 1;\n        if (i < n2 && s2[i] == '(')\n            dp[i + 1] = 1;\n        if (i < n1 && s1[i] == ')')\n            dp[i + 1] = dp[i - 1];\n        if (i < n2 && s2[i] == ')')\n            dp[i + 1] = dp[i - 1];\n    }\n    return dp[n] == 1 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgiif9oy6.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpgiif9oy6.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgiif9oy6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    int i = 0;\n    int j = 0;\n    while (i < n1)\n    {\n        if (s1[i] == '(')\n            c1++;\n        else\n            c1--;\n        i++;\n    }\n    while (j < n2)\n    {\n        if (s2[j] == '(')\n            c2++;\n        else\n            c2--;\n        j++;\n    }\n    if (c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5hmqba_8.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmp5hmqba_8.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5hmqba_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]\n??:? void tmpj3bfejzp.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2g7h0v0h.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmp2g7h0v0h.__unittest_L37_C1() [0x4280a6]\n??:? void tmp2g7h0v0h.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int l1 = s1.length;\n    int l2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    for (int i = 0; i < l1; i++)\n    {\n        if (s1[i] == '(')\n            c1++;\n        else\n            c1--;\n    }\n    for (int i = 0; i < l2; i++)\n    {\n        if (s2[i] == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if (c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if (c1 == 0 && c2 > 0)\n        return \"No\";\n    if (c1 < 0 && c2 == 0)\n        return \"No\";\n    if (c1 < 0 && c2 > 0)\n    {\n        if (c1 + c2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if (c1 > 0 && c2 == 0)\n    {\n        if (c1 + c2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if (c1 > 0 && c2 > 0)\n    {\n        if (c1 + c2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5_51pyom.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmp5_51pyom.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5_51pyom.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n        if(count1 < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n        if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpf1qtzcsm.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpf1qtzcsm.__unittest_L49_C1() [0x427cc0]\n??:? void tmpf1qtzcsm.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n    int len2 = s2.length;\n    int count = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpri_rvon2.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpri_rvon2.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpri_rvon2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]\n??:? void tmp4bm1qg_e.__modtest() [0x42827c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]\n??:? void tmpkwtm4p5r.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(i; lst)\n        s ~= i;\n    int count = 0;\n    foreach(i; s)\n    {\n        if(i == '(')\n            count++;\n        else if(i == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpmfbiecl3.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpmfbiecl3.__unittest_L40_C1() [0x427e0e]\n??:? void tmpmfbiecl3.__modtest() [0x4282b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return \"Yes\";\n    if(s1_open == 0 && s2_open < 0)\n        return \"No\";\n    if(s1_open > 0 && s2_open == 0)\n        return \"No\";\n    if(s1_open > 0 && s2_open < 0)\n    {\n        if(s1_open == abs(s2_open))\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpw4ofb4z3.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x429135]\n??:? void tmpw4ofb4z3.__unittest_L56_C1() [0x427ee6]\n??:? void tmpw4ofb4z3.__modtest() [0x42839c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42da83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428e8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a931]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a8bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e65]\n??:? runModuleUnitTests [0x42d859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295f8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string str = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; str)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpexenojmg.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpexenojmg.__unittest_L36_C1() [0x427df6]\n??:? void tmpexenojmg.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst[0].length;\n    int m = lst[1].length;\n    int[][] dp = new int[n + 1][m + 1];\n    dp[0][0] = 1;\n    foreach (i; 0 .. n + 1)\n    {\n        foreach (j; 0 .. m + 1)\n        {\n            if (i > 0 && lst[0][i - 1] == '(')\n            {\n                dp[i][j] |= dp[i - 1][j];\n            }\n            if (j > 0 && lst[1][j - 1] == '(')\n            {\n                dp[i][j] |= dp[i][j - 1];\n            }\n            if (i > 0 && lst[0][i - 1] == ')')\n            {\n                dp[i][j] |= dp[i - 1][j];\n            }\n            if (j > 0 && lst[1][j - 1] == ')')\n            {\n                dp[i][j] |= dp[i][j - 1];\n            }\n            if (i > 0 && j > 0 && lst[0][i - 1] == '(' && lst[1][j - 1] == ')')\n            {\n                dp[i][j] |= dp[i - 1][j - 1];\n            }\n            if (i > 0 && j > 0 && lst[0][i - 1] == ')' && lst[1][j - 1] == '(')\n            {\n                dp[i][j] |= dp[i - 1][j - 1];\n            }\n        }\n    }\n    return dp[n][m] ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmjdb8wj5.d(23): Error: cannot implicitly convert expression `lst[0].length` of type `ulong` to `int`\n/tmp/tmpmjdb8wj5.d(24): Error: cannot implicitly convert expression `lst[1].length` of type `ulong` to `int`\n/tmp/tmpmjdb8wj5.d(25): Error: variable `n` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmjdb8wj5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 ~ s2;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpjxvax4xn.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpjxvax4xn.__unittest_L41_C1() [0x427e0a]\n??:? void tmpjxvax4xn.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d993]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a841]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42d769]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429508]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    // Your code here\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptsykcwes.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmptsykcwes.__unittest_L37_C1() [0x427df6]\n??:? void tmptsykcwes.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n    int[] b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n    int[] e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n    int[] h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n    int[] k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n    int[] nn = new int[n];\n    int[] o = new int[n];\n    int[] p = new int[n];\n    int[] q = new int[n];\n    int[] r = new int[n];\n    int[] s = new int[n];\n    int[] t = new int[n];\n    int[] u = new int[n];\n    int[] v = new int[n];\n    int[] w = new int[n];\n    int[] x = new int[n];\n    int[] y = new int[n];\n    int[] z = new int[n];\n    int[] A = new int[n];\n    int[] B = new int[n];\n    int[] C = new int[n];\n    int[] D = new int[n];\n    int[] E = new int[n];\n    int[] F = new int[n];\n    int[] G = new int[n];\n    int[] H = new int[n];\n    int[] I = new int[n];\n    int[] J = new int[n];\n    int[] K = new int[n];\n    int[] L = new int[n];\n    int[] M = new int[n];\n    int[] N = new int[n];\n    int[] O = new int[n];\n    int\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpab_j446i.d(70): Error: no identifier for declarator `int`\n/tmp/tmpab_j446i.d(70): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpab_j446i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(i; 0..n1)\n    {\n        if(s1[i] == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(i; 0..n2)\n    {\n        if(s2[i] == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 && c2 > 0)\n    {\n        if(c1 + c2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c1 > 0 && c2 < 0)\n    {\n        if(c1 + c2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c1 > 0 && c2 > 0)\n    {\n        if(c1 == c2)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo8d9xd17.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpo8d9xd17.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\n/tmp/tmpo8d9xd17.d(21): Error: function `tmpo8d9xd17.match_parens` no `return exp;` or `assert(0);` at end of function\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo8d9xd17.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]\n??:? void tmpnyosqxjb.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]\n??:? void tmpj3bfejzp.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpq6nlulyh.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpq6nlulyh.__unittest_L49_C1() [0x427e4a]\n??:? void tmpq6nlulyh.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]\n??:? void tmp_yuh_5m2.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    return s.balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpydjdcrn8.d(26): Error: no property `balance` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpydjdcrn8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4clo7h1x.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmp4clo7h1x.__unittest_L36_C1() [0x427dee]\n??:? void tmp4clo7h1x.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprpfk05xu.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmprpfk05xu.__unittest_L43_C1() [0x4280fa]\n??:? void tmprpfk05xu.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n    int len2 = s2.length;\n    int count = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n    }\n    if(count != 0)\n        return \"No\";\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n        if(count1 < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n        if(count2 < 0)\n            return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp28eshcgq.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmp28eshcgq.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp28eshcgq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string str1 = lst[0];\n    string str2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; str1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; str2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbl2s9jub.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpbl2s9jub.__unittest_L46_C1() [0x427c94]\n??:? void tmpbl2s9jub.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpka8yz1m4.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmpka8yz1m4.__unittest_L37_C1() [0x4280a6]\n??:? void tmpka8yz1m4.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]\n??:? void tmpj3bfejzp.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuehkqee0.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmpuehkqee0.__unittest_L37_C1() [0x4280aa]\n??:? void tmpuehkqee0.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open == s1_close && s2_open != s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open == s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open != s2_close)\n    {\n        if(s1_open > s1_close)\n        {\n            if(s2_open > s2_close)\n                return \"No\";\n            else\n                return \"Yes\";\n        }\n        else\n        {\n            if(s2_open > s2_close)\n                return \"Yes\";\n            else\n                return \"No\";\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqox5drr3.d(74): unittest failure\n----------------\n??:? _d_unittestp [0x429115]\n??:? void tmpqox5drr3.__unittest_L68_C1() [0x427e60]\n??:? void tmpqox5drr3.__modtest() [0x428380]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42da63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428e6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a911]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9a0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a89d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e45]\n??:? runModuleUnitTests [0x42d839]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmph7ten80l.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmph7ten80l.__unittest_L45_C1() [0x427c94]\n??:? void tmph7ten80l.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]\n??:? void tmp4bm1qg_e.__modtest() [0x42827c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]\n??:? void tmp4bm1qg_e.__modtest() [0x42827c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]\n??:? void tmpkwtm4p5r.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]\n??:? void tmpkwtm4p5r.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                left++;\n            else\n                right++;\n        }\n    }\n    return left == right ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbagkg_4r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmpbagkg_4r.__unittest_L37_C1() [0x4280a6]\n??:? void tmpbagkg_4r.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n    int len2 = s2.length;\n    int open = 0;\n    int close = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnp37iw_2.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpnp37iw_2.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnp37iw_2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open == s1_close && s2_open != s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open == s2_close)\n        return \"No\";\n    else\n    {\n        int s1_diff = abs(s1_open - s1_close);\n        int s2_diff = abs(s2_open - s2_close);\n        if(s1_diff == s2_diff)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp94by4967.d(64): unittest failure\n----------------\n??:? _d_unittestp [0x42913d]\n??:? void tmp94by4967.__unittest_L59_C1() [0x427df2]\n??:? void tmp94by4967.__modtest() [0x4283a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42da8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428e96]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a939]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a8c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e6d]\n??:? runModuleUnitTests [0x42d861]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429600]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n    int cnt = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            cnt++;\n        else\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            cnt++;\n        else\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    if(cnt == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo6ws0df4.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpo6ws0df4.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo6ws0df4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1 < 0 && count2 > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptgnbraz2.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmptgnbraz2.__unittest_L49_C1() [0x427ddc]\n??:? void tmptgnbraz2.__modtest() [0x4282fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a891]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]\n??:? runModuleUnitTests [0x42d7b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    auto count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbzxdvj_w.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429035]\n??:? void tmpbzxdvj_w.__unittest_L38_C1() [0x427dfe]\n??:? void tmpbzxdvj_w.__modtest() [0x4282a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d983]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a831]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d65]\n??:? runModuleUnitTests [0x42d759]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]\n??:? void tmpj3bfejzp.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    // TODO: implement this function\n    return \"\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdzgy1eql.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428f3d]\n??:? void tmpdzgy1eql.__unittest_L26_C1() [0x427b7c]\n??:? void tmpdzgy1eql.__modtest() [0x4281a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d817]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428c96]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a6c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a754]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c6d]\n??:? runModuleUnitTests [0x42d5ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42938c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\";\n    if(c1 > 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 && c2 > 0)\n        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 < 0)\n        return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tjend0l.d(21): Error: function `tmp_tjend0l.match_parens` no `return exp;` or `assert(0);` at end of function\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tjend0l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4clo7h1x.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmp4clo7h1x.__unittest_L36_C1() [0x427dee]\n??:? void tmp4clo7h1x.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 + count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpxp73d4m3.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpxp73d4m3.__unittest_L46_C1() [0x428102]\n??:? void tmpxp73d4m3.__modtest() [0x4282bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2tivff1d.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmp2tivff1d.__unittest_L38_C1() [0x427e0a]\n??:? void tmp2tivff1d.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(i; lst)\n        s ~= i;\n    return s.balance ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnubileii.d(26): Error: no property `balance` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnubileii.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 != 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return \"No\";\n    if(c1 < 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 && c2 > 0)\n    {\n        if(c1 == -c2)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(c1 > 0 && c2 < 0)\n    {\n        if(c1 == -c2)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoxizq49x.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpoxizq49x.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoxizq49x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int cnt = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                cnt++;\n            else\n                cnt--;\n            if(cnt < 0)\n                return \"No\";\n        }\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpm27idn4m.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpm27idn4m.__unittest_L38_C1() [0x427dda]\n??:? void tmpm27idn4m.__modtest() [0x42827c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]\n??:? void tmp_yuh_5m2.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]\n??:? void tmpnyosqxjb.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int a = 0;\n    int b = 0;\n    foreach(c; lst[0])\n    {\n        if(c == '(')\n            a++;\n        else\n            a--;\n    }\n    foreach(c; lst[1])\n    {\n        if(c == '(')\n            b++;\n        else\n            b--;\n    }\n    if(a == 0 && b == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpsz3rpzn9.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpsz3rpzn9.__unittest_L44_C1() [0x427c8c]\n??:? void tmpsz3rpzn9.__modtest() [0x4282b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(s; lst)\n    {\n        foreach(c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqz5l83g3.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmpqz5l83g3.__unittest_L37_C1() [0x4280a6]\n??:? void tmpqz5l83g3.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    // your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkpjdgb24.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkpjdgb24.__unittest_L47_C1() [0x427c94]\n??:? void tmpkpjdgb24.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]\n??:? void tmp_yuh_5m2.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]\n??:? void tmpnyosqxjb.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuehkqee0.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmpuehkqee0.__unittest_L37_C1() [0x4280aa]\n??:? void tmpuehkqee0.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2g7h0v0h.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmp2g7h0v0h.__unittest_L37_C1() [0x4280a6]\n??:? void tmp2g7h0v0h.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    // TODO: Implement your solution here\n    return \"\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4guq9wbn.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428f3d]\n??:? void tmp4guq9wbn.__unittest_L26_C1() [0x427b7c]\n??:? void tmp4guq9wbn.__modtest() [0x4281a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d817]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428c96]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a6c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a754]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428c6d]\n??:? runModuleUnitTests [0x42d5ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42938c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1 < 0 && count2 > 0)\n    {\n        if(count1 + count2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 > 0 && count2 < 0)\n    {\n        if(count1 + count2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdce_j4xw.d(74): unittest failure\n----------------\n??:? _d_unittestp [0x4290e5]\n??:? void tmpdce_j4xw.__unittest_L61_C1() [0x428192]\n??:? void tmpdce_j4xw.__modtest() [0x42834c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42da33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428e3e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a8e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a970]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a86d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e15]\n??:? runModuleUnitTests [0x42d809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295a8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 < 0 || count2 < 0)\n        return \"No\";\n    if(count1 == count2)\n        return \"Yes\";\n    if(count1 > count2)\n        return \"No\";\n    if(count1 < count2)\n    {\n        if(count2 % 2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpl5v53f_q.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x4290e5]\n??:? void tmpl5v53f_q.__unittest_L58_C1() [0x427d20]\n??:? void tmpl5v53f_q.__modtest() [0x42834c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42da33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428e3e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a8e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a970]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a86d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e15]\n??:? runModuleUnitTests [0x42d809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295a8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n        if(count1 < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n        if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpf1qtzcsm.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpf1qtzcsm.__unittest_L49_C1() [0x427cc0]\n??:? void tmpf1qtzcsm.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    if(open > close)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcntpiuvf.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmpcntpiuvf.__unittest_L40_C1() [0x427c38]\n??:? void tmpcntpiuvf.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_open--;\n    }\n    if(s1_open + s2_open == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpq0bopbdi.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpq0bopbdi.__unittest_L45_C1() [0x428102]\n??:? void tmpq0bopbdi.__modtest() [0x4282bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int len1 = s1.length;\n    int len2 = s2.length;\n    int count = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count == 0 && count2 != 0)\n    {\n        if(count2 < 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    else if(count != 0 && count2 == 0)\n    {\n        if(count > 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    else\n    {\n        if(count > 0 && count2 < 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp0ib1oz4.d(25): Error: cannot implicitly convert expression `s1.length` of type `ulong` to `int`\n/tmp/tmpp0ib1oz4.d(26): Error: cannot implicitly convert expression `s2.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp0ib1oz4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1) {\n        if(c == '(') {\n            s1_open++;\n        } else {\n            s1_close++;\n        }\n    }\n    foreach(c; s2) {\n        if(c == '(') {\n            s2_open++;\n        } else {\n            s2_close++;\n        }\n    }\n    if(s1_open == s1_close && s2_open == s2_close) {\n        return \"Yes\";\n    }\n    if(s1_open > s1_close && s2_open > s2_close) {\n        return \"Yes\";\n    }\n    if(s1_open < s1_close && s2_open < s2_close) {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdvo4ltxf.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4290a5]\n??:? void tmpdvo4ltxf.__unittest_L54_C1() [0x427ce4]\n??:? void tmpdvo4ltxf.__modtest() [0x428310]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9f3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dfe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a8a1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a930]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a82d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dd5]\n??:? runModuleUnitTests [0x42d7c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429568]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]\n??:? void tmp4bm1qg_e.__modtest() [0x42827c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int n = lst[0].length;\n    int m = lst[1].length;\n    int[][] dp = new int[n + 1][m + 1];\n    for (int i = 0; i <= n; i++)\n    {\n        for (int j = 0; j <= m; j++)\n        {\n            if (i == 0 && j == 0)\n            {\n                dp[i][j] = 1;\n            }\n            else if (i == 0)\n            {\n                dp[i][j] = dp[i][j - 1] & (lst[1][j - 1] == '(' ? 1 : -1);\n            }\n            else if (j == 0)\n            {\n                dp[i][j] = dp[i - 1][j] & (lst[0][i - 1] == '(' ? 1 : -1);\n            }\n            else\n            {\n                dp[i][j] = max(dp[i - 1][j] & (lst[0][i - 1] == '(' ? 1 : -1), dp[i][j - 1] & (lst[1][j - 1] == '(' ? 1 : -1));\n            }\n        }\n    }\n    return dp[n][m] == 1 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2ibxm2ds.d(23): Error: cannot implicitly convert expression `lst[0].length` of type `ulong` to `int`\n/tmp/tmp2ibxm2ds.d(24): Error: cannot implicitly convert expression `lst[1].length` of type `ulong` to `int`\n/tmp/tmp2ibxm2ds.d(25): Error: variable `n` cannot be read at compile time\n/tmp/tmp2ibxm2ds.d(44): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ibxm2ds.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(string i; lst)\n    {\n        s ~= i;\n    }\n    int count = 0;\n    foreach(char i; s)\n    {\n        if(i == '(')\n        {\n            count++;\n        }\n        else if(i == ')')\n        {\n            count--;\n        }\n        if(count < 0)\n        {\n            return \"No\";\n        }\n    }\n    if(count == 0)\n    {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpn50vhu8b.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpn50vhu8b.__unittest_L50_C1() [0x427e0e]\n??:? void tmpn50vhu8b.__modtest() [0x4282b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    // your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkpjdgb24.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkpjdgb24.__unittest_L47_C1() [0x427c94]\n??:? void tmpkpjdgb24.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1 < 0 && count2 > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptgnbraz2.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmptgnbraz2.__unittest_L49_C1() [0x427ddc]\n??:? void tmptgnbraz2.__modtest() [0x4282fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a891]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]\n??:? runModuleUnitTests [0x42d7b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4bm1qg_e.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmp4bm1qg_e.__unittest_L38_C1() [0x427dda]\n??:? void tmp4bm1qg_e.__modtest() [0x42827c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else if(c == ')')\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_ugb1xs0.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_ugb1xs0.__unittest_L39_C1() [0x4280ae]\n??:? void tmp_ugb1xs0.__modtest() [0x428268]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return \"Yes\";\n    if(s1_open == 0 && s2_open != 0)\n        return \"No\";\n    if(s1_open != 0 && s2_open == 0)\n        return \"No\";\n    if(s1_open > 0 && s2_open < 0)\n        return \"No\";\n    if(s1_open < 0 && s2_open > 0)\n        return \"No\";\n    if(s1_open > 0 && s2_open > 0)\n        return \"Yes\";\n    if(s1_open < 0 && s2_open < 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkdkn0zg4.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x429105]\n??:? void tmpkdkn0zg4.__unittest_L57_C1() [0x427d44]\n??:? void tmpkdkn0zg4.__modtest() [0x428370]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42da53]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428e5e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a901]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a990]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a88d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e35]\n??:? runModuleUnitTests [0x42d829]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpq6nlulyh.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpq6nlulyh.__unittest_L49_C1() [0x427e4a]\n??:? void tmpq6nlulyh.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmph7ten80l.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmph7ten80l.__unittest_L45_C1() [0x427c94]\n??:? void tmph7ten80l.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string a = lst[0];\n    string b = lst[1];\n    int a_open = 0;\n    int b_open = 0;\n    foreach(c; a)\n    {\n        if(c == '(')\n            a_open++;\n        else\n            a_open--;\n    }\n    foreach(c; b)\n    {\n        if(c == '(')\n            b_open++;\n        else\n            b_open--;\n    }\n    if(a_open == 0 && b_open == 0)\n        return \"Yes\";\n    if(a_open > 0 && b_open < 0)\n        return \"Yes\";\n    if(a_open < 0 && b_open > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp51ed_pyp.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmp51ed_pyp.__unittest_L49_C1() [0x427ddc]\n??:? void tmp51ed_pyp.__modtest() [0x4282fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a891]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]\n??:? runModuleUnitTests [0x42d7b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpe603cyil.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpe603cyil.__unittest_L45_C1() [0x427c94]\n??:? void tmpe603cyil.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int l = lst[0].length;\n    int r = lst[1].length;\n    int lc = 0;\n    int rc = 0;\n    foreach(c; lst[0])\n    {\n        if(c == '(')\n            lc++;\n        else\n            lc--;\n    }\n    foreach(c; lst[1])\n    {\n        if(c == '(')\n            rc++;\n        else\n            rc--;\n    }\n    if(lc == 0 && rc == 0)\n        return \"Yes\";\n    if(lc > 0 && rc < 0)\n        return \"No\";\n    if(lc < 0 && rc > 0)\n        return \"No\";\n    if(lc == rc)\n        return \"Yes\";\n    if(abs(lc) > abs(rc))\n        return \"No\";\n    if(abs(lc) < abs(rc))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwb6zgevb.d(23): Error: cannot implicitly convert expression `lst[0].length` of type `ulong` to `int`\n/tmp/tmpwb6zgevb.d(24): Error: cannot implicitly convert expression `lst[1].length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwb6zgevb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]\n??:? void tmpkwtm4p5r.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpq6nlulyh.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpq6nlulyh.__unittest_L49_C1() [0x427e4a]\n??:? void tmpq6nlulyh.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnhu6dv2q.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpnhu6dv2q.__unittest_L36_C1() [0x427df6]\n??:? void tmpnhu6dv2q.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpka8yz1m4.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmpka8yz1m4.__unittest_L37_C1() [0x4280a6]\n??:? void tmpka8yz1m4.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkwtm4p5r.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpkwtm4p5r.__unittest_L46_C1() [0x427c94]\n??:? void tmpkwtm4p5r.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"Yes\";\n    else if(s1_open == s1_close && s2_open != s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open == s2_close)\n        return \"No\";\n    else if(s1_open != s1_close && s2_open != s2_close)\n    {\n        if(s1_open > s1_close)\n        {\n            if(s2_open > s2_close)\n            {\n                if(s1_open - s1_close == s2_open - s2_close)\n                    return \"Yes\";\n                else\n                    return \"No\";\n            }\n            else\n            {\n                if(s1_open - s1_close == s2_close - s2_open)\n                    return \"Yes\";\n                else\n                    return \"No\";\n            }\n        }\n        else\n        {\n            if(s2_open > s2_close)\n            {\n                if(s1_close - s1_open == s2_open - s2_close)\n                    return \"Yes\";\n                else\n                    return \"No\";\n            }\n            else\n            {\n                if(s1_close - s1_open == s2_close - s2_open)\n                    return \"Yes\";\n                else\n                    return \"No\";\n            }\n        }\n\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7rckxnph.d(86): Error: found `unittest` instead of statement\n/tmp/tmp7rckxnph.d(103): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7rckxnph.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int open = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            open++;\n        else\n            open--;\n        if(open < 0)\n            return \"No\";\n    }\n    return open == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuzipmd19.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmpuzipmd19.__unittest_L36_C1() [0x427dee]\n??:? void tmpuzipmd19.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n    }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpegldnr7z.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpegldnr7z.__unittest_L40_C1() [0x4280f2]\n??:? void tmpegldnr7z.__modtest() [0x4282ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d993]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a841]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42d769]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429508]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpka8yz1m4.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmpka8yz1m4.__unittest_L37_C1() [0x4280a6]\n??:? void tmpka8yz1m4.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    // Your code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else if(c == ')')\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else if(c == ')')\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1 == 0 && count2 != 0)\n    {\n        if(count2 < 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    else if(count1 != 0 && count2 == 0)\n    {\n        if(count1 > 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n    else\n    {\n        if(count1 + count2 == 0)\n            return \"Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpjmy96lab.d(75): unittest failure\n----------------\n??:? _d_unittestp [0x4290e5]\n??:? void tmpjmy96lab.__unittest_L66_C1() [0x427fad]\n??:? void tmpjmy96lab.__modtest() [0x428350]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42da33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428e3e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a8e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a970]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a86d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428e15]\n??:? runModuleUnitTests [0x42d809]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4295a8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                count++;\n            else if(c == ')')\n                count--;\n            if(count < 0)\n                return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt7w5_6p8.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429015]\n??:? void tmpt7w5_6p8.__unittest_L38_C1() [0x427dde]\n??:? void tmpt7w5_6p8.__modtest() [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a79d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a729]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d45]\n??:? runModuleUnitTests [0x42d6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429464]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnyosqxjb.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x429025]\n??:? void tmpnyosqxjb.__unittest_L36_C1() [0x427dee]\n??:? void tmpnyosqxjb.__modtest() [0x428290]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d973]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a821]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d55]\n??:? runModuleUnitTests [0x42d749]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(e; s)\n    {\n        if(e == '(')\n            count++;\n        else if(e == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcmd0rit1.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x429045]\n??:? void tmpcmd0rit1.__unittest_L40_C1() [0x427e0e]\n??:? void tmpcmd0rit1.__modtest() [0x4282b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e3bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b269]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d75]\n??:? runModuleUnitTests [0x42e191]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429494]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg7108nva.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x429055]\n??:? void tmpg7108nva.__unittest_L46_C1() [0x427c94]\n??:? void tmpg7108nva.__modtest() [0x4282c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a851]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d85]\n??:? runModuleUnitTests [0x42d779]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429518]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    return (s.count(\"(\") == s.count(\")\")) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_47c56r8.d(26): Error: no property `count` for type `string`\n/tmp/tmp_47c56r8.d(26): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_47c56r8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_yuh_5m2.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ffd]\n??:? void tmp_yuh_5m2.__unittest_L39_C1() [0x4280aa]\n??:? void tmp_yuh_5m2.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a785]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a711]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d2d]\n??:? runModuleUnitTests [0x42d6ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42944c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n                open++;\n            else\n                close++;\n        }\n    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2g7h0v0h.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428ff5]\n??:? void tmp2g7h0v0h.__unittest_L37_C1() [0x4280a6]\n??:? void tmp2g7h0v0h.__modtest() [0x428260]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d8cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a77d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d25]\n??:? runModuleUnitTests [0x42d6a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429444]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 > 0 && c2 < 0)\n        return \"Yes\";\n    if(c1 < 0 && c2 > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9b5zfkaf.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x429095]\n??:? void tmp9b5zfkaf.__unittest_L49_C1() [0x427ddc]\n??:? void tmp9b5zfkaf.__modtest() [0x4282fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9e3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a891]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428dc5]\n??:? runModuleUnitTests [0x42d7b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429558]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzfhuw0nm.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmpzfhuw0nm.__unittest_L43_C1() [0x4280fa]\n??:? void tmpzfhuw0nm.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n            s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return \"Yes\";\n    else if(s1_open == 0 && s2_open < 0)\n        return \"Yes\";\n    else if(s1_open > 0 && s2_open == 0)\n        return \"Yes\";\n    else if(s1_open < 0 && s2_open == 0)\n        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpuecpo1zb.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4290ad]\n??:? void tmpuecpo1zb.__unittest_L52_C1() [0x427cec]\n??:? void tmpuecpo1zb.__modtest() [0x428318]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428e06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a8a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a938]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a835]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428ddd]\n??:? runModuleUnitTests [0x42d7d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429570]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n            count1--;\n        if(count1 < 0)\n            return \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n            count2--;\n        if(count2 < 0)\n            return \"No\";\n    }\n    if(count1 == count2)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpf1qtzcsm.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x429085]\n??:? void tmpf1qtzcsm.__unittest_L49_C1() [0x427cc0]\n??:? void tmpf1qtzcsm.__modtest() [0x4282ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d9d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428dde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a881]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428db5]\n??:? runModuleUnitTests [0x42d7a9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429548]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else if(c == ')')\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj3bfejzp.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42902d]\n??:? void tmpj3bfejzp.__unittest_L36_C1() [0x427df6]\n??:? void tmpj3bfejzp.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d97b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a829]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d5d]\n??:? runModuleUnitTests [0x42d751]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4294f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161275
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1 ~ s2;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n        else\n            count--;\n        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbu1txzlf.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42903d]\n??:? void tmpbu1txzlf.__unittest_L40_C1() [0x427e02]\n??:? void tmpbu1txzlf.__modtest() [0x4282a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d98b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428d96]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a839]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d6d]\n??:? runModuleUnitTests [0x42d761]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429500]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n            c2--;\n    }\n    return (c1 + c2 == 0) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2tn6m0lx.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x42904d]\n??:? void tmp2tn6m0lx.__unittest_L43_C1() [0x4280fe]\n??:? void tmp2tn6m0lx.__modtest() [0x4282b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d99b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428da6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42a849]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428d7d]\n??:? runModuleUnitTests [0x42d771]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429510]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660161276
    }
  ]
}