name: HumanEval_70_strange_sort_list
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
  \ return list in strange order.\n    Strange sorting, is when you start with the\
  \ minimum value,\n    then maximum of the remaining integers, then minimum and so\
  \ on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L,\
  \ 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n \
  \   >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
  \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
  \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
  \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
  \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
  \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
  \ == [111111L]);\n}\nvoid main(){}"
completions: ["{\n    if (lst.length == 0)\n        return lst;\n    long[] res =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            res[i] = lst[i];\n            i++;\n        }\n        else\n   \
    \     {\n            res[j] = lst[i];\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}\n/*\n    Given a list of integers, return\
    \ the list of integers with the same length,\n    but with the elements in the\
    \ reverse order.\n    Examples:\n    >>> reverse_list([1L, 2L, 3L, 4L])\n    [4L,\
    \ 3L, 2L, 1L]\n    >>> reverse_list([1L])\n    [1L]\n    >>> reverse_list([])\n\
    \    []\n*/\nlong[] reverse_list(long[] lst) \n{\n    long[] res = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[lst.length\
    \ - i - 1];\n    }\n    return res;\n}\n/*\n    Given a list of integers, return\
    \ the list of integers with the same length,\n    but with the elements in the\
    \ reverse order.\n    Examples:\n    >>> reverse_list([1L, 2L, 3L, 4L])\n    [4L,\
    \ 3L, 2L, 1L]\n    >>> reverse_list([1L])\n    [1L]\n    >>> reverse_list([])\n\
    \    []\n*/\nlong[] reverse_list2(long[] lst) \n{\n    long[] res = new long[lst.length];\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[lst.length\
    \ - i - 1];\n    }\n    return res;\n}\n/*\n    Given a list of", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n    \
    \    i++;\n        if (lst_copy.length == 0)\n            break;\n        res[i]\
    \ = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ result = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n\
    \    int i = 0;\n    while (sorted.length > 0)\n    {\n        result[i] = sorted[0];\n\
    \        sorted = sorted[1..$];\n        if (sorted.length > 0)\n        {\n \
    \           result[i+1] = sorted[$-1];\n            sorted = sorted[0..$-2];\n\
    \        }\n        i += 2;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    auto\
    \ min = lst[0];\n    auto max = lst[0];\n    foreach (i; lst)\n    {\n       \
    \ min = min(min, i);\n        max = max(max, i);\n    }\n    res[0] = min;\n \
    \   res[1] = max;\n    int j = 2;\n    foreach (i; lst)\n    {\n        if (i\
    \ != min && i != max)\n        {\n            res[j] = i;\n            j++;\n\
    \        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n     \
    \   if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n    \
    \    }\n        else\n        {\n            res[j] = lst[i];\n            j--;\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    else\n    {\n        long min = lst[0];\n  \
    \      long max = lst[0];\n        for (long i = 0; i < lst.length; i++)\n   \
    \     {\n            if (lst[i] < min)\n                min = lst[i];\n      \
    \      if (lst[i] > max)\n                max = lst[i];\n        }\n        long[]\
    \ res = new long[lst.length];\n        long[] lst1 = new long[lst.length];\n \
    \       long[] lst2 = new long[lst.length];\n        long j = 0;\n        long\
    \ k = 0;\n        for (long i = 0; i < lst.length; i++)\n        {\n         \
    \   if (lst[i] != min && lst[i] != max)\n            {\n                lst1[j]\
    \ = lst[i];\n                j++;\n            }\n            else\n         \
    \   {\n                lst2[k] = lst[i];\n                k++;\n            }\n\
    \        }\n        lst1 = lst1[0..j];\n        lst2 = lst2[0..k];\n        if\
    \ (lst1.length == 0)\n            return lst2;\n        if (lst2.length == 0)\n\
    \            return lst1;\n        long[] lst3 = strange_sort_list(lst1);\n  \
    \      long[] lst4 = strange_sort_list(lst2);\n        long[] lst5 = new long[lst3.length\
    \ + lst4.length];\n        long i = 0;\n        j = 0;\n        k = 0;\n     \
    \   while (i < lst3.length && j < lst4.length)\n        {\n            lst5[k]\
    \ = lst3[i];\n            k++;\n            lst5[k] = lst4[j];\n            k++;\n\
    \            i++;\n            j++;\n        }\n        if (i < lst3.length)\n\
    \        {\n            while (i < lst3.length)\n            {", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] sorted = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    int i = 0;\n    while (remaining.length > 0)\n   \
    \ {\n        long min = remaining[0];\n        long max = remaining[0];\n    \
    \    foreach (long x; remaining)\n        {\n            min = min(min, x);\n\
    \            max = max(max, x);\n        }\n        sorted[i] = min;\n       \
    \ i++;\n        remaining = remaining.remove(min);\n        if (remaining.length\
    \ > 0)\n        {\n            sorted[i] = max;\n            i++;\n          \
    \  remaining = remaining.remove(max);\n        }\n    }\n    return sorted;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    bool asc = true;\n    int i = 0;\n    while (lst.length > 0)\n    {\n   \
    \     long min = lst[0];\n        long max = lst[0];\n        foreach (el; lst)\n\
    \        {\n            if (el < min)\n                min = el;\n           \
    \ if (el > max)\n                max = el;\n        }\n        if (asc)\n    \
    \    {\n            res[i] = min;\n            lst = lst.filter!(x => x != min);\n\
    \        }\n        else\n        {\n            res[i] = max;\n            lst\
    \ = lst.filter!(x => x != max);\n        }\n        asc = !asc;\n        i++;\n\
    \    }\n    return res;\n}", "{\n    long[] result = new long[lst.length];\n \
    \   int i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while\
    \ (i <= j)\n    {\n        if (flag)\n        {\n            result[i] = lst[i];\n\
    \            i++;\n        }\n        else\n        {\n            result[j] =\
    \ lst[i];\n            j--;\n        }\n        flag = !flag;\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            long min = lst[0];\n            int min_idx = 0;\n            for\
    \ (int k = 1; k < lst.length; k++)\n            {\n                if (lst[k]\
    \ < min)\n                {\n                    min = lst[k];\n             \
    \       min_idx = k;\n                }\n            }\n            res[i] = min;\n\
    \            lst[min_idx] = long.max;\n            i++;\n        }\n        else\n\
    \        {\n            long max = lst[0];\n            int max_idx = 0;\n   \
    \         for (int k = 1; k < lst.length; k++)\n            {\n              \
    \  if (lst[k] > max)\n                {\n                    max = lst[k];\n \
    \                   max_idx = k;\n                }\n            }\n         \
    \   res[j] = max;\n            lst[max_idx] = long.min;\n            j--;\n  \
    \      }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto min_idx = 0;\n    auto\
    \ max_idx = 0;\n    foreach (i; lst)\n    {\n        if (lst[i] == min)\n    \
    \        min_idx = i;\n        if (lst[i] == max)\n            max_idx = i;\n\
    \    }\n    auto res = new long[](lst.length);\n    res[0] = min;\n    res[1]\
    \ = max;\n    auto idx = 2;\n    auto min_max = true;\n    foreach (i; 2..lst.length)\n\
    \    {\n        if (min_max)\n        {\n            res[idx] = lst[min_idx +\
    \ i];\n            min_max = false;\n        }\n        else\n        {\n    \
    \        res[idx] = lst[max_idx - i];\n            min_max = true;\n        }\n\
    \        idx++;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n  \
    \      return lst;\n    auto min = minElement(lst);\n    auto max = maxElement(lst);\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    while (i < lst.length)\
    \ \n    {\n        if (i % 2 == 0) \n        {\n            res[i] = min;\n  \
    \          min = minElement(lst[i + 1 .. $]);\n        }\n        else \n    \
    \    {\n            res[i] = max;\n            max = maxElement(lst[i + 1 .. $]);\n\
    \        }\n        i++;\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0) return lst;\n    long[] res = new long[lst.length];\n    int[] idx = new\
    \ int[lst.length];\n    for (int i = 0; i < lst.length; i++) idx[i] = i;\n   \
    \ idx = idx.sort!((a, b) => lst[a] < lst[b]);\n    bool asc = true;\n    for (int\
    \ i = 0; i < lst.length; i++) {\n        res[i] = lst[idx[i]];\n        if (asc)\
    \ idx[i] = idx[i] + 1;\n        else idx[i] = idx[i] - 1;\n        if (idx[i]\
    \ == lst.length) {\n            idx[i] = lst.length - 1;\n            asc = false;\n\
    \        }\n        if (idx[i] == -1) {\n            idx[i] = 0;\n           \
    \ asc = true;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool ascending = true;\n    int index\
    \ = 0;\n    while (sorted.length > 0)\n    {\n        if (ascending)\n       \
    \ {\n            result[index] = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            result[index] = sorted[$-1];\n\
    \            sorted = sorted[0..$-1];\n        }\n        ascending = !ascending;\n\
    \        index++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    bool flag = true;\n    while (i <= j)\n    {\n\
    \        if (flag)\n        {\n            res[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = lst[i];\n          \
    \  j--;\n        }\n        flag = !flag;\n    }\n    return res;\n}", "{\n  \
    \  if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    while (sorted.length\
    \ > 0)\n    {\n        res[i] = sorted[0];\n        sorted = sorted[1..$];\n \
    \       if (sorted.length > 0)\n        {\n            res[i+1] = sorted[$-1];\n\
    \            sorted = sorted[0..$-2];\n        }\n        i += 2;\n    }\n   \
    \ return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    auto\
    \ min = lst[0];\n    auto max = lst[0];\n    for (auto i = 1; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    while (i < lst.length)\n    {\n        res[i] = min;\n  \
    \      i++;\n        if (i < lst.length)\n        {\n            res[i] = max;\n\
    \            i++;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        if (i % 2 == 0)\n        {\n         \
    \   res[i] = min;\n            lst_copy = lst_copy.filter!(a => a != min);\n \
    \           if (lst_copy.length == 0)\n                break;\n            min\
    \ = lst_copy[0];\n            foreach (el; lst_copy)\n            {\n        \
    \        if (el < min)\n                    min = el;\n            }\n       \
    \ }\n        else\n        {\n            res[i] = max;\n            lst_copy\
    \ = lst_copy.filter!(a => a != max);\n            if (lst_copy.length == 0)\n\
    \                break;\n            max = lst_copy[0];\n            foreach (el;\
    \ lst_copy)\n            {\n                if (el > max)\n                  \
    \  max = el;\n            }\n        }\n        i++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return [];\n    long[] result = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     result[i] = lst[lst.minIndex];\n            lst[lst.minIndex] = lst[lst.maxIndex];\n\
    \            lst[lst.maxIndex] = result[i];\n            i++;\n        }\n   \
    \     else\n        {\n            result[j] = lst[lst.maxIndex];\n          \
    \  lst[lst.maxIndex] = lst[lst.minIndex];\n            lst[lst.minIndex] = result[j];\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length >\
    \ 0)\n    {\n        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n\
    \        if (lst_copy.length > 0)\n        {\n            res[i + 1] = lst_copy[$\
    \ - 1];\n            lst_copy = lst_copy[0..$ - 2];\n        }\n        i += 2;\n\
    \    }\n    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
