language: d
name: HumanEval_132_is_nested
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string) {\n  \
    \      if(c == '[') {\n            stack.push(c);\n        } else if(c == ']')\
    \ {\n            if(stack.empty) {\n                return false;\n          \
    \  } else {\n                stack.pop();\n            }\n        }\n    }\n \
    \   return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprg34fwyp.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg34fwyp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate through the string\n    foreach(char c; string)\n    {\n     \
    \   // If the character is an opening bracket, push it onto the stack\n      \
    \  if(c == '[')\n            stack.push(c);\n        // If the character is a\
    \ closing bracket, pop the stack\n        else if(c == ']')\n        {\n     \
    \       // If the stack is empty, return false\n            if(stack.empty)\n\
    \                return false;\n            stack.pop();\n        }\n    }\n \
    \   // If the stack is empty, return true\n    return stack.empty;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpobkod5fj.d(26): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobkod5fj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate over the string\n    foreach(char c; string)\n    {\n        //\
    \ If the character is an opening bracket, push it to the stack\n        if(c ==\
    \ '[')\n            stack.push(c);\n        // If the character is a closing bracket,\
    \ pop the stack\n        else if(c == ']')\n        {\n            // If the stack\
    \ is empty, return false\n            if(stack.empty)\n                return\
    \ false;\n            // If the stack is not empty, pop the stack\n          \
    \  else\n                stack.pop();\n        }\n    }\n    // If the stack is\
    \ empty, return true\n    if(stack.empty)\n        return true;\n    // If the\
    \ stack is not empty, return false\n    else\n        return false;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3_y91m6d.d(26): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_y91m6d.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // TODO\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8l5m5qsy.d(32): unittest failure\n----------------\n??:?
    _d_unittestp [0x427ecd]\n??:? void tmp8l5m5qsy.__unittest_L28_C1() [0x427a26]\n??:?
    void tmp8l5m5qsy.__modtest() [0x427c4c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300c8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fba5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa5d]\n??:? runModuleUnitTests [0x42b9c9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42831c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4282a3]\n??:? _d_run_main [0x42820e]\n??:? main [0x427c5f]\n??:?
    __libc_start_main [0x664f3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool result = false;\n    int count = 0;\n    foreach(char\
    \ c; string)\n    {\n        if(c == '[')\n        {\n            count++;\n \
    \       }\n        else if(c == ']')\n        {\n            count--;\n      \
    \  }\n        if(count < 0)\n        {\n            return false;\n        }\n\
    \    }\n    if(count > 0)\n    {\n        return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6dvy01w2.d(54): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f55]\n??:? void tmp6dvy01w2.__unittest_L48_C1() [0x427b00]\n??:?
    void tmp6dvy01w2.__modtest() [0x427cd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aae5]\n??:? runModuleUnitTests [0x42ba51]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42832b]\n??:? _d_run_main [0x428296]\n??:? main [0x427ce7]\n??:?
    __libc_start_main [0xd59a3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
