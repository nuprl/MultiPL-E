language: d
name: HumanEval_132_is_nested
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string) {\n  \
    \      if(c == '[') {\n            stack.push(c);\n        } else if(c == ']')\
    \ {\n            if(stack.empty) {\n                return false;\n          \
    \  } else {\n                stack.pop();\n            }\n        }\n    }\n \
    \   return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprg34fwyp.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg34fwyp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate through the string\n    foreach(char c; string)\n    {\n     \
    \   // If the character is an opening bracket, push it onto the stack\n      \
    \  if(c == '[')\n            stack.push(c);\n        // If the character is a\
    \ closing bracket, pop the stack\n        else if(c == ']')\n        {\n     \
    \       // If the stack is empty, return false\n            if(stack.empty)\n\
    \                return false;\n            stack.pop();\n        }\n    }\n \
    \   // If the stack is empty, return true\n    return stack.empty;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpobkod5fj.d(26): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobkod5fj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate over the string\n    foreach(char c; string)\n    {\n        //\
    \ If the character is an opening bracket, push it to the stack\n        if(c ==\
    \ '[')\n            stack.push(c);\n        // If the character is a closing bracket,\
    \ pop the stack\n        else if(c == ']')\n        {\n            // If the stack\
    \ is empty, return false\n            if(stack.empty)\n                return\
    \ false;\n            // If the stack is not empty, pop the stack\n          \
    \  else\n                stack.pop();\n        }\n    }\n    // If the stack is\
    \ empty, return true\n    if(stack.empty)\n        return true;\n    // If the\
    \ stack is not empty, return false\n    else\n        return false;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3_y91m6d.d(26): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_y91m6d.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // TODO\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8l5m5qsy.d(32): unittest failure\n----------------\n??:?
    _d_unittestp [0x427ecd]\n??:? void tmp8l5m5qsy.__unittest_L28_C1() [0x427a26]\n??:?
    void tmp8l5m5qsy.__modtest() [0x427c4c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300c8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fba5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa5d]\n??:? runModuleUnitTests [0x42b9c9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42831c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4282a3]\n??:? _d_run_main [0x42820e]\n??:? main [0x427c5f]\n??:?
    __libc_start_main [0x664f3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool result = false;\n    int count = 0;\n    foreach(char\
    \ c; string)\n    {\n        if(c == '[')\n        {\n            count++;\n \
    \       }\n        else if(c == ']')\n        {\n            count--;\n      \
    \  }\n        if(count < 0)\n        {\n            return false;\n        }\n\
    \    }\n    if(count > 0)\n    {\n        return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6dvy01w2.d(54): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f55]\n??:? void tmp6dvy01w2.__unittest_L48_C1() [0x427b00]\n??:?
    void tmp6dvy01w2.__modtest() [0x427cd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fca1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430150]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aae5]\n??:? runModuleUnitTests [0x42ba51]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4283a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42832b]\n??:? _d_run_main [0x428296]\n??:? main [0x427ce7]\n??:?
    __libc_start_main [0xd59a3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz59jmgq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0alpc5_v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy1y_ifu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool result = false;\n    int count = 0;\n    foreach(char\
    \ c; string)\n    {\n        if(c == '[')\n        {\n            count++;\n \
    \       }\n        else if(c == ']')\n        {\n            count--;\n      \
    \  }\n        if(count < 0)\n        {\n            break;\n        }\n    }\n\
    \    if(count == 0)\n    {\n        result = true;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpumfpd1tl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // TODO\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8l5m5qsy.d(32): unittest failure\n----------------\n??:?
    _d_unittestp [0x427ecd]\n??:? void tmp8l5m5qsy.__unittest_L28_C1() [0x427a26]\n??:?
    void tmp8l5m5qsy.__modtest() [0x427c4c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300c8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fba5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa5d]\n??:? runModuleUnitTests [0x42b9c9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42831c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4282a3]\n??:? _d_run_main [0x42820e]\n??:? main [0x427c5f]\n??:?
    __libc_start_main [0x664f3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    import std.algorithm;\n    import std.array;\n    import std.range;\n\
    \    import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.conv;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.conv;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.conv;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.conv;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.conv;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.conv;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.range;\n   \
    \ import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.conv;\n    import std.stdio;\n    import std.typecons\nunittest\n{\n   \
    \ alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n \
    \   assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\"\
    ) == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwa1nfmmt.d(94): Error: \'';\'' expected\n/tmp/tmpwa1nfmmt.d(113):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwa1nfmmt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!int;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(1);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxkyc__g6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack of char\n    Stack!char stack;\n    // Iterate\
    \ through the string\n    foreach(char c; string)\n    {\n        // If the char\
    \ is a opening bracket, push it to the stack\n        if(c == '[')\n         \
    \   stack.push(c);\n        // If the char is a closing bracket, pop it from the\
    \ stack\n        else if(c == ']')\n        {\n            // If the stack is\
    \ empty, return false\n            if(stack.empty)\n                return false;\n\
    \            // Else, pop the stack\n            else\n                stack.pop();\n\
    \        }\n    }\n    // If the stack is empty, return true\n    if(stack.empty)\n\
    \        return true;\n    // Else, return false\n    else\n        return false;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatodm9sx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps4u9rcci.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz59jmgq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy1y_ifu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool result = false;\n    int count = 0;\n    foreach(ch; string)\n\
    \    {\n        if(ch == '[')\n        {\n            count++;\n        }\n  \
    \      else if(ch == ']')\n        {\n            count--;\n        }\n      \
    \  if(count < 0)\n        {\n            break;\n        }\n    }\n    if(count\
    \ == 0)\n    {\n        result = true;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjrvamn8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // TODO: Implement this function\n    return false;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6auwkag0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int open = 0;\n    int close = 0;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            open++;\n        }\n    \
    \    else if(c == ']')\n        {\n            close++;\n        }\n        if(close\
    \ > open)\n        {\n            return false;\n        }\n    }\n    return\
    \ open == close;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpegio8k1b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool result = false;\n    int count = 0;\n    foreach(char\
    \ c; string)\n    {\n        if(c == '[')\n        {\n            count++;\n \
    \       }\n        else if(c == ']')\n        {\n            count--;\n      \
    \  }\n        if(count < 0)\n        {\n            break;\n        }\n    }\n\
    \    if(count == 0)\n    {\n        result = true;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpumfpd1tl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char();\n    foreach(c; string)\n  \
    \  {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaqlyqqqw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps4u9rcci.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqhegxu6d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(ch; string)\n    {\n        if(ch\
    \ == '[')\n            count++;\n        else if(ch == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gglixur.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int open_brackets = 0;\n    int close_brackets = 0;\n    int\
    \ nested_brackets = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n\
    \        {\n            open_brackets++;\n        }\n        else if(c == ']')\n\
    \        {\n            close_brackets++;\n            if(open_brackets > 0)\n\
    \            {\n                open_brackets--;\n                nested_brackets++;\n\
    \            }\n        }\n    }\n    return open_brackets == 0 && close_brackets\
    \ == nested_brackets;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n  \
    \  assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj3yjajf5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else\n        {\n            if(stack.empty)\n            {\n           \
    \     return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprj4fiqvm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate through the string\n    foreach(char c; string)\n    {\n     \
    \   // If the character is an opening bracket, push it onto the stack\n      \
    \  if(c == '[')\n            stack.push(c);\n        // If the character is a\
    \ closing bracket, pop the stack\n        else if(c == ']')\n        {\n     \
    \       // If the stack is empty, return false\n            if(stack.empty)\n\
    \                return false;\n            // Otherwise, pop the stack\n    \
    \        else\n                stack.pop();\n        }\n    }\n    // If the stack\
    \ is empty, return true\n    if(stack.empty)\n        return true;\n    // Otherwise,\
    \ return false\n    else\n        return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4cersjz8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!int;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(1);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhiwyao2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2zsq35_b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqhegxu6d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int[] stack;\n    foreach(char c; string)\n    {\n        if(c\
    \ == '[')\n            stack ~= 1;\n        else if(c == ']')\n        {\n   \
    \         if(stack.length == 0)\n                return false;\n            stack.length--;\n\
    \        }\n    }\n    return stack.length == 0;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuub_j3i3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(ch; string)\n    {\n        if(ch\
    \ == '[')\n            count++;\n        else if(ch == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gglixur.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz59jmgq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // TODO: implement\n    return false;\n}\nunittest\n{\n   \
    \ alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n \
    \   assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\"\
    ) == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg10xvzs8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = Stack!char();\n    foreach(char c; string)\n \
    \   {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwzr4xx2f.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz59jmgq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy5737gbm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        \n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbnx6sn8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // TODO: implement\n    return false;\n}\nunittest\n{\n   \
    \ alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n \
    \   assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\"\
    ) == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg10xvzs8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(ch; string)\n   \
    \ {\n        if(ch == '[')\n        {\n            stack.push(ch);\n        }\n\
    \        else if(ch == ']')\n        {\n            if(stack.empty)\n        \
    \    {\n                return false;\n            }\n            else\n     \
    \       {\n                stack.pop();\n            }\n        }\n    }\n   \
    \ return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n  \
    \  assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptdsfh6c7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int n = string.length;\n    int[] stack = new int[n];\n   \
    \ int top = 0;\n    foreach(i, c; string)\n    {\n        if (c == '[')\n    \
    \    {\n            stack[top++] = i;\n        }\n        else\n        {\n  \
    \          if (top == 0)\n            {\n                return false;\n     \
    \       }\n            else\n            {\n                top--;\n         \
    \   }\n        }\n    }\n    return top == 0;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptsa_m6df.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!int;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(1);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxkyc__g6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(ch; string)\n    {\n        if(ch\
    \ == '[')\n            count++;\n        else if(ch == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gglixur.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool is_nested = false;\n    int open_brackets = 0;\n    int\
    \ closed_brackets = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n\
    \        {\n            open_brackets++;\n        }\n        else if(c == ']')\n\
    \        {\n            closed_brackets++;\n        }\n    }\n    if(open_brackets\
    \ > closed_brackets)\n    {\n        is_nested = true;\n    }\n    return is_nested;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz97i437.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[') stack.push(c);\n        else if(c == ']')\n     \
    \   {\n            if(stack.empty) return false;\n            else stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbkq4h5uv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool result = false;\n    int count = 0;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            count++;\n        }\n   \
    \     else if(c == ']')\n        {\n            count--;\n        }\n        if(count\
    \ < 0)\n        {\n            break;\n        }\n    }\n    if(count == 0)\n\
    \    {\n        result = true;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1m_up0ne.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnj6xuep7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int[] stack;\n    foreach(c; string)\n    {\n        if(c ==\
    \ '[')\n            stack ~= 1;\n        else if(c == ']')\n        {\n      \
    \      if(stack.length == 0)\n                return false;\n            stack.popBack();\n\
    \        }\n    }\n    return stack.length == 0;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7s7jh48x.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    enum bracket_type {\n        left,\n        right\n    }\n\
    \    struct bracket\n    {\n        bracket_type type;\n        int index;\n \
    \   }\n    auto brackets = string.map!(c => bracket(c == '[' ? bracket_type.left\
    \ : bracket_type.right, c.indexOf)).array;\n    auto stack = new Stack!bracket;\n\
    \    foreach(bracket; brackets)\n    {\n        if(bracket.type == bracket_type.left)\n\
    \        {\n            stack.push(bracket);\n        }\n        else\n      \
    \  {\n            if(stack.empty)\n            {\n                return false;\n\
    \            }\n            else\n            {\n                auto top = stack.pop;\n\
    \                if(top.type == bracket_type.right)\n                {\n     \
    \               return false;\n                }\n                else\n     \
    \           {\n                    if(abs(top.index - bracket.index) == 1)\n \
    \                   {\n                        return true;\n                \
    \    }\n                }\n            }\n        }\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpusqokrfs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // create a stack to store the brackets\n    Stack!char stack;\n\
    \    // iterate over the string\n    foreach(char c; string)\n    {\n        //\
    \ if the character is a left bracket, push it onto the stack\n        if(c ==\
    \ '[')\n            stack.push(c);\n        // if the character is a right bracket,\
    \ pop a left bracket off the stack\n        else if(c == ']')\n        {\n   \
    \         // if the stack is empty, return false\n            if(stack.empty)\n\
    \                return false;\n            stack.pop();\n        }\n    }\n \
    \   // if the stack is empty, return true\n    return stack.empty;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr5ke8q73.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate over the string\n    foreach(char c; string)\n    {\n        //\
    \ If the character is an opening bracket, push it onto the stack\n        if(c\
    \ == '[')\n            stack.push(c);\n        // If the character is a closing\
    \ bracket, pop the stack\n        else if(c == ']')\n        {\n            //\
    \ If the stack is empty, return false\n            if(stack.empty)\n         \
    \       return false;\n            // Otherwise, pop the stack\n            else\n\
    \                stack.pop();\n        }\n    }\n    // If the stack is empty,\
    \ return true\n    if(stack.empty)\n        return true;\n    // Otherwise, return\
    \ false\n    else\n        return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpex8ewxu5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int counter = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            counter++;\n        else if(c == ']')\n            counter--;\n\
    \        if(counter < 0)\n            return false;\n    }\n    return counter\
    \ == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd40d4n_w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack of ints\n    Stack!int stack;\n    // Iterate\
    \ over the string\n    foreach(char c; string)\n    {\n        // If the char\
    \ is a [ push a 1 on the stack\n        if(c == '[')\n            stack.push(1);\n\
    \        // If the char is a ] pop a 1 off the stack\n        else if(c == ']')\n\
    \            stack.pop();\n        // If the stack is empty return false\n   \
    \     if(stack.empty)\n            return false;\n    }\n    // If the stack is\
    \ empty return true\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymhy4p0t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string) \n    {\n     \
    \   if (c == '[') \n        {\n            count++;\n        }\n        else if\
    \ (c == ']') \n        {\n            count--;\n        }\n        if (count <\
    \ 0) \n        {\n            return false;\n        }\n    }\n    return count\
    \ == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6oaw2pu0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps4u9rcci.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate through the string\n    foreach(char c; string)\n    {\n     \
    \   // If the character is an opening bracket, push it to the stack\n        if(c\
    \ == '[')\n            stack.push(c);\n        // If the character is a closing\
    \ bracket, pop the stack\n        else if(c == ']')\n        {\n            //\
    \ If the stack is empty, return false\n            if(stack.empty)\n         \
    \       return false;\n            // Otherwise, pop the stack\n            else\n\
    \                stack.pop();\n        }\n    }\n    // If the stack is empty,\
    \ return true\n    if(stack.empty)\n        return true;\n    // Otherwise, return\
    \ false\n    else\n        return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp54c9mwdx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy1y_ifu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool is_nested = false;\n    int count = 0;\n    foreach(char\
    \ c; string)\n    {\n        if(c == '[')\n        {\n            count++;\n \
    \       }\n        else if(c == ']')\n        {\n            count--;\n      \
    \  }\n        if(count < 0)\n        {\n            return false;\n        }\n\
    \        if(count > 0)\n        {\n            is_nested = true;\n        }\n\
    \    }\n    return is_nested;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprxba0ou1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4chz9w7m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    for (int i = 0; i < string.length; i++)\n\
    \    {\n        if (string[i] == '[')\n        {\n            count++;\n     \
    \   }\n        else if (string[i] == ']')\n        {\n            count--;\n \
    \       }\n        if (count < 0)\n        {\n            return false;\n    \
    \    }\n    }\n    return count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpprewmvoj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int n = string.length;\n    int[int] count = [0 : 0];\n   \
    \ foreach(i; 0 .. n) \n    {\n        if(string[i] == '[') \n        {\n     \
    \       count[i] = count[i - 1] + 1;\n        } \n        else \n        {\n \
    \           count[i] = count[i - 1] - 1;\n        }\n    }\n    return count[n\
    \ - 1] == 0 && min(count) >= 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2ixniow.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int[] stack = new int[];\n    foreach(char c; string)\n   \
    \ {\n        if(c == '[')\n        {\n            stack ~= 1;\n        }\n   \
    \     else if(c == ']')\n        {\n            if(stack.length == 0)\n      \
    \      {\n                return false;\n            }\n            stack.length--;\n\
    \        }\n    }\n    return stack.length == 0;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpikmqo63j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(char c; string)\
    \ {\n        if (c == '[') {\n            stack.push(c);\n        } else if (c\
    \ == ']') {\n            if (stack.empty) {\n                return false;\n \
    \           }\n            stack.pop();\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpslz5kbc5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprpozjwof.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnj6xuep7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprpozjwof.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = Stack!char();\n    foreach(char c; string)\n \
    \   {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwzr4xx2f.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy1y_ifu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string) \n    {\n     \
    \   if(c == '[') \n        {\n            count++;\n        }\n        else if(c\
    \ == ']') \n        {\n            count--;\n        }\n        if(count < 0)\
    \ \n        {\n            return false;\n        }\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp99j6elp4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string) {\n  \
    \      if(c == '[') {\n            stack.push(c);\n        } else if(c == ']')\
    \ {\n            if(stack.empty) {\n                return false;\n          \
    \  } else {\n                stack.pop();\n            }\n        }\n    }\n \
    \   return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n\
    \    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprg34fwyp.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg34fwyp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy1y_ifu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string) \n    {\n     \
    \   if(c == '[') \n        {\n            count++;\n        }\n        else if(c\
    \ == ']') \n        {\n            count--;\n        }\n        if(count < 0)\
    \ \n        {\n            return false;\n        }\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp99j6elp4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy1y_ifu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int open = 0;\n    int close = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            open++;\n        else if(c == ']')\n\
    \            close++;\n        if(close > open)\n            return false;\n \
    \   }\n    return open == close;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_p4yke7v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(c; string)\n    {\n        if(c\
    \ == '[')\n            count++;\n        else if(c == ']')\n            count--;\n\
    \        if(count < 0)\n            return false;\n    }\n    return count ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpboxqd1zv.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmpboxqd1zv.__unittest_L37_C1() [0x427af8]\n??:?
    void tmpboxqd1zv.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x3f002554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate over the string\n    foreach(char c; string)\n    {\n        //\
    \ If the character is a left bracket, push it to the stack\n        if(c == '[')\n\
    \            stack.push(c);\n        // If the character is a right bracket, pop\
    \ the last bracket from the stack\n        else if(c == ']')\n        {\n    \
    \        // If the stack is empty, return false\n            if(stack.empty)\n\
    \                return false;\n            stack.pop();\n        }\n    }\n \
    \   // If the stack is empty, return true\n    return stack.empty;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdwj_gx5n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char();\n    foreach(c; string)\n  \
    \  {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaqlyqqqw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa53dbgka.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz59jmgq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int length = string.length;\n    if (length == 0) return false;\n\
    \    if (length == 1) return false;\n    if (length == 2) return true;\n    if\
    \ (length == 3) return false;\n    if (length == 4) return true;\n    if (length\
    \ == 5) return false;\n    if (length == 6) return true;\n    if (length == 7)\
    \ return false;\n    if (length == 8) return true;\n    if (length == 9) return\
    \ false;\n    if (length == 10) return true;\n    if (length == 11) return false;\n\
    \    if (length == 12) return true;\n    if (length == 13) return false;\n   \
    \ if (length == 14) return true;\n    if (length == 15) return false;\n    if\
    \ (length == 16) return true;\n    if (length == 17) return false;\n    if (length\
    \ == 18) return true;\n    if (length == 19) return false;\n    if (length ==\
    \ 20) return true;\n    if (length == 21) return false;\n    if (length == 22)\
    \ return true;\n    if (length == 23) return false;\n    if (length == 24) return\
    \ true;\n    if (length == 25) return false;\n    if (length == 26) return true;\n\
    \    if (length == 27) return false;\n    if (length == 28) return true;\n   \
    \ if (length == 29) return false;\n    if (length == 30) return true;\n    if\
    \ (length == 31) return false;\n    if (length == 32) return true;\n    if (length\
    \ == 33) return false;\n    if (length == 34) return true;\n    if (length ==\
    \ 35) return false;\n    if (length == 36) return true;\n    if (length == 37)\
    \ return false;\n    if (length == 38) return true;\n    if (length == 39) return\
    \ false;\n    if (length == 40) return true;\n    if (length == 41) return false;\n\
    \    if (length == 42) return true;\n    if (length == 43) return false;\n   \
    \ if (length == 44) return true;\n    if (length ==\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv3geusrk.d(72): Error: expression expected, not \''unittest\''\n/tmp/tmpv3geusrk.d(73):
    Error: found \''{\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpv3geusrk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz59jmgq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz59jmgq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // create a stack to store the brackets\n    Stack!char stack;\n\
    \    // iterate over the string\n    foreach(char c; string)\n    {\n        //\
    \ if the character is a left bracket, push it onto the stack\n        if(c ==\
    \ '[')\n            stack.push(c);\n        // if the character is a right bracket,\
    \ pop the stack\n        else if(c == ']')\n        {\n            // if the stack\
    \ is empty, return false\n            if(stack.empty)\n                return\
    \ false;\n            // if the stack is not empty, pop the stack\n          \
    \  else\n                stack.pop();\n        }\n    }\n    // if the stack is\
    \ empty, return true\n    if(stack.empty)\n        return true;\n    // if the\
    \ stack is not empty, return false\n    else\n        return false;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvn025e2q.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to hold the brackets\n    Stack!char brackets;\n\
    \    // Iterate over the string\n    foreach(char c; string)\n    {\n        //\
    \ If the character is an opening bracket, push it onto the stack\n        if(c\
    \ == '[')\n            brackets.push(c);\n        // If the character is a closing\
    \ bracket, pop the stack\n        else if(c == ']')\n        {\n            //\
    \ If the stack is empty, there is no opening bracket to match the closing bracket\n\
    \            if(brackets.empty)\n                return false;\n            //\
    \ Otherwise, pop the stack\n            brackets.pop();\n        }\n    }\n  \
    \  // If the stack is empty, there is a valid subsequence of brackets\n    return\
    \ brackets.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2osqj4qk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char();\n    foreach(c; string)\n  \
    \  {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2xbodhrx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to store the brackets\n    Stack!char stack;\n\
    \    // Iterate through the string\n    foreach(char c; string)\n    {\n     \
    \   // If the character is an opening bracket, push it onto the stack\n      \
    \  if(c == '[')\n            stack.push(c);\n        // If the character is a\
    \ closing bracket, pop the stack\n        else if(c == ']')\n        {\n     \
    \       // If the stack is empty, return false\n            if(stack.empty)\n\
    \                return false;\n            // Otherwise, pop the stack\n    \
    \        else\n                stack.pop();\n        }\n    }\n    // If the stack\
    \ is empty, return true\n    if(stack.empty)\n        return true;\n    // Otherwise,\
    \ return false\n    else\n        return false;\n}\n/*\n    Create a function\
    \ that takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\nunittest\n{\n \
    \   alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfewmiis4.d(51): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfewmiis4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char)();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps4u9rcci.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int open_count = 0;\n    int close_count = 0;\n    foreach(char\
    \ c; string)\n    {\n        if(c == '[')\n        {\n            open_count++;\n\
    \        }\n        else if(c == ']')\n        {\n            close_count++;\n\
    \        }\n        if(close_count > open_count)\n        {\n            return\
    \ false;\n        }\n    }\n    return open_count == close_count;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphof8rqt6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    bool result = false;\n    int count = 0;\n    foreach(char\
    \ c; string) {\n        if (c == '[') {\n            count++;\n        } else\
    \ if (c == ']') {\n            count--;\n        }\n        if (count < 0) {\n\
    \            break;\n        }\n    }\n    if (count == 0) {\n        result =\
    \ true;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_wqocqc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0alpc5_v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char);\n    foreach(c; string)\n  \
    \  {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8stpgpd_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa53dbgka.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppd_62jlx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int open = 0;\n    int close = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            open++;\n        else if(c == ']')\n\
    \            close++;\n        if(close > open)\n            return false;\n \
    \   }\n    return open == close;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_p4yke7v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // TODO: Implement me\n    return false;\n}\nunittest\n{\n\
    \    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3c64c0oa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int left = 0;\n    int right = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            left++;\n        else if(c == ']')\n\
    \            right++;\n        if(right > left)\n            return false;\n \
    \   }\n    return left == right;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbwt35uvt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!(char[])();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            else\n      \
    \      {\n                stack.pop();\n            }\n        }\n    }\n    return\
    \ stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy5737gbm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            else\n            {\n\
    \                stack.pop();\n            }\n        }\n    }\n    return stack.empty;\n\
    }\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
    ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwjhfrab.d(25): Error: template instance `Stack!char` template
    `Stack` is not defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwjhfrab.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy1y_ifu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char();\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n        {\n            stack.push(c);\n        }\n\
    \        else if(c == ']')\n        {\n            if(stack.empty)\n         \
    \   {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate\
    \ = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplc_bg_vj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // Create a stack to keep track of the brackets\n    Stack!char\
    \ stack;\n    // Iterate over the string\n    foreach(char c; string)\n    {\n\
    \        // If the character is an opening bracket, push it to the stack\n   \
    \     if(c == '[')\n            stack.push(c);\n        // If the character is\
    \ a closing bracket, pop the stack\n        else if(c == ']')\n        {\n   \
    \         // If the stack is empty, return false\n            if(stack.empty)\n\
    \                return false;\n            // Otherwise, pop the stack\n    \
    \        stack.pop();\n        }\n    }\n    // If the stack is empty, return\
    \ true\n    return stack.empty;\n}\nunittest\n{\n    alias candidate = is_nested;\n\
    \n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\"\
    ) == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphmb2xxpm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    int count = 0;\n    foreach(char c; string)\n    {\n      \
    \  if(c == '[')\n            count++;\n        else if(c == ']')\n           \
    \ count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}\nunittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"\
    [[]]\") == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3j65sbh_.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427f4d]\n??:? void tmp3j65sbh_.__unittest_L37_C1() [0x427af8]\n??:?
    void tmp3j65sbh_.__modtest() [0x427ccc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42ab06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430148]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fc25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aadd]\n??:? runModuleUnitTests [0x42ba49]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42839c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428323]\n??:? _d_run_main [0x42828e]\n??:? main [0x427cdf]\n??:?
    __libc_start_main [0x71568554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    auto stack = new Stack!char;\n    foreach(c; string)\n    {\n\
    \        if(c == '[')\n        {\n            stack.push(c);\n        }\n    \
    \    else if(c == ']')\n        {\n            if(stack.empty)\n            {\n\
    \                return false;\n            }\n            stack.pop();\n    \
    \    }\n    }\n    return stack.empty;\n}\nunittest\n{\n    alias candidate =\
    \ is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n    assert(candidate(\"\
    []]]]]]][[[[[]\") == false);\n    assert(candidate(\"[][]\") == false);\n    assert(candidate(\"\
    []\") == false);\n    assert(candidate(\"[[[[]]]]\") == true);\n    assert(candidate(\"\
    []]]]]]]]]]\") == false);\n    assert(candidate(\"[][][[]]\") == true);\n    assert(candidate(\"\
    [[]\") == false);\n    assert(candidate(\"[]]\") == false);\n    assert(candidate(\"\
    [[]][[\") == true);\n    assert(candidate(\"[[][]]\") == true);\n    assert(candidate(\"\
    \") == false);\n    assert(candidate(\"[[[[[[[[\") == false);\n    assert(candidate(\"\
    ]]]]]]]]\") == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmy1y_ifu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ takes a string as input which contains only square brackets.\n    The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
    [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
    [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"\
    [[][]]\")\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
    \ string) \n{\n    // TODO: Implement this function\n    return false;\n}\nunittest\n\
    {\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\") == true);\n\
    \    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
    [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
    [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
    [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
    []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
    [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
    [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6auwkag0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659798819
