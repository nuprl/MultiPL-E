name: HumanEval_159_eat
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit,\
  \ and you already have eaten a certain number of carrots,\n    but now you need\
  \ to eat more carrots to complete the day's meals.\n    you should return an array\
  \ of [ total number of eaten carrots after your meals,\n                       \
  \             the number of carrots left after your meals ]\n    if there are not\
  \ enough remaining carrots, you will eat all remaining carrots, but will still be\
  \ hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>>\
  \ eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n   \
  \ >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n\
  \        the number of carrots that you have eaten.\n    @need : integer\n     \
  \   the number of carrots that you need to eat.\n    @remaining : integer\n    \
  \    the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
  \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
  \n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining)\
  \ \n"
tests: "unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L)\
  \ == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L,\
  \ 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n  \
  \  assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L)\
  \ == [5L, 0L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[2];\n    result[0] = number + need;\n\
    \    result[1] = max(0L, remaining - need);\n    return result;\n}", "{\n    long[]\
    \ result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining\
    \ - need;\n    if(result[1] < 0)\n    {\n        result[0] = result[0] + result[1];\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[2];\n    result[0] = number + need;\n    result[1] = remaining -\
    \ need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n\
    \        result[1] = 0;\n    }\n    return result;\n}", "{\n    return [min(number\
    \ + need, remaining), max(remaining - need, 0L)];\n}", "{\n    long[] result =\
    \ new long[2];\n    if (remaining < need)\n    {\n        result[0] = number +\
    \ remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0]\
    \ = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n \
    \       result[0] = number + need;\n        result[1] = remaining - need;\n  \
    \  }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    return [min(number + need, remaining),\
    \ max(remaining - need, 0L)];\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000\
    \ || remaining < 0 || remaining > 1000)\n        return result;\n    result[0]\
    \ = number + need;\n    result[1] = max(0L, remaining - need);\n    return result;\n\
    }", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n \
    \       result[0] = number + need;\n        result[1] = remaining - need;\n  \
    \  }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}", "{\n    long[] result = new long[2];\n\
    \    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1]\
    \ < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    result[0] =\
    \ number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n \
    \   {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[2];\n    if(remaining\
    \ >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining\
    \ - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n \
    \       result[1] = 0;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n\
    \    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[2];\n    if (need > remaining)\n    {\n \
    \       result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[2];\n    result[0]\
    \ = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n\
    \    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n\
    \    return result;\n}", "{\n    if(number > 1000 || need > 1000 || remaining\
    \ > 1000)\n        return [0L, 0L];\n    if(number < 0 || need < 0 || remaining\
    \ < 0)\n        return [0L, 0L];\n    if(number + need > remaining)\n        return\
    \ [remaining, 0L];\n    return [number + need, remaining - (number + need)];\n\
    }", "{\n    return [min(number + need, remaining), max(remaining - (number + need),\
    \ 0L)];\n}", "{\n    long[] result = new long[2];\n    if(remaining >= need)\n\
    \    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n\
    \    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1]\
    \ = 0;\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
