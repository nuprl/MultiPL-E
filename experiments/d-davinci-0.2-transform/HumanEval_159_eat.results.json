{
  "language": "d",
  "name": "HumanEval_159_eat",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = max(0L, remaining - need);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8std5acb.d(41): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8std5acb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = result[0] + result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - need, 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gnmjscn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - need, 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gnmjscn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    result[0] = number + need;\n    result[1] = max(0L, remaining - need);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn7j5uxpl.d(43): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn7j5uxpl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplrt2m72r.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284ed]\n??:? void tmplrt2m72r.__unittest_L52_C1() [0x427f98]\n??:? void tmplrt2m72r.__modtest() [0x42826c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]\n??:? runModuleUnitTests [0x42c37d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (need > remaining)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    if(number > 1000 || need > 1000 || remaining > 1000)\n        return [0L, 0L];\n    if(number < 0 || need < 0 || remaining < 0)\n        return [0L, 0L];\n    if(number + need > remaining)\n        return [remaining, 0L];\n    return [number + need, remaining - (number + need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptr1mubvy.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmptr1mubvy.__unittest_L47_C1() [0x427f60]\n??:? void tmptr1mubvy.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c49f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b332]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430974]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430451]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b309]\n??:? runModuleUnitTests [0x42c275]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428904]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number >= need)\n    {\n        result[0] = number;\n        result[1] = remaining;\n    }\n    else\n    {\n        if(remaining >= need - number)\n        {\n            result[0] = need;\n            result[1] = remaining - (need - number);\n        }\n        else\n        {\n            result[0] = number + remaining;\n            result[1] = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpjfu_5wqi.d(64): unittest failure\n----------------\n??:? _d_unittestp [0x42851d]\n??:? void tmpjfu_5wqi.__unittest_L60_C1() [0x427fcc]\n??:? void tmpjfu_5wqi.__modtest() [0x4282a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b46a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430681]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b441]\n??:? runModuleUnitTests [0x42c3ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - need, 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gnmjscn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - need, 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gnmjscn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplrt2m72r.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284ed]\n??:? void tmplrt2m72r.__unittest_L52_C1() [0x427f98]\n??:? void tmplrt2m72r.__modtest() [0x42826c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]\n??:? runModuleUnitTests [0x42c37d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto result = tuple(number + need, remaining - need);\n    if (result[1] < 0)\n        result = tuple(result[0] + result[1], 0);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpihvwor1g.d(42): Error: cannot implicitly convert expression `result` of type `Tuple!(long, long)` to `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpihvwor1g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8qvbz4f0.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp8qvbz4f0.__unittest_L52_C1() [0x427f6c]\n??:? void tmp8qvbz4f0.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpd5f7j4r_.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmpd5f7j4r_.__unittest_L52_C1() [0x427f6c]\n??:? void tmpd5f7j4r_.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(0L, remaining - need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rz9ssnx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(need > remaining)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplrt2m72r.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284ed]\n??:? void tmplrt2m72r.__unittest_L52_C1() [0x427f98]\n??:? void tmplrt2m72r.__modtest() [0x42826c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]\n??:? runModuleUnitTests [0x42c37d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    if(need > remaining)\n        return [number + remaining, 0L];\n    else\n        return [number + need, remaining - need];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(need, remaining) + number, max(0L, remaining - need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0vflbppk.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp0vflbppk.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0vflbppk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return [0L, 0L];\n    if(remaining < need)\n        return [number + remaining, 0L];\n    return [number + need, remaining - need];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - need, 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gnmjscn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplrt2m72r.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284ed]\n??:? void tmplrt2m72r.__unittest_L52_C1() [0x427f98]\n??:? void tmplrt2m72r.__modtest() [0x42826c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]\n??:? runModuleUnitTests [0x42c37d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = max(0L, remaining - need);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8std5acb.d(41): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8std5acb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(0L, remaining - (number + need))];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdzjbtv6s.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpdzjbtv6s.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdzjbtv6s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpd5f7j4r_.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmpd5f7j4r_.__unittest_L52_C1() [0x427f6c]\n??:? void tmpd5f7j4r_.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (need > remaining)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8qvbz4f0.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp8qvbz4f0.__unittest_L52_C1() [0x427f6c]\n??:? void tmp8qvbz4f0.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(0L, remaining - need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rz9ssnx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpjvjn6yk0.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmpjvjn6yk0.__unittest_L52_C1() [0x427f6c]\n??:? void tmpjvjn6yk0.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = max(0L, remaining - need);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8std5acb.d(41): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8std5acb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number >= 0 && number <= 1000 && need >= 0 && need <= 1000 && remaining >= 0 && remaining <= 1000)\n    {\n        if(remaining >= need)\n        {\n            result[0] = number + need;\n            result[1] = remaining - need;\n        }\n        else\n        {\n            result[0] = number + remaining;\n            result[1] = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] res = new long[2];\n    if(remaining >= need)\n    {\n        res[0] = number + need;\n        res[1] = remaining - need;\n    }\n    else\n    {\n        res[0] = number + remaining;\n        res[1] = 0;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8qvbz4f0.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp8qvbz4f0.__unittest_L52_C1() [0x427f6c]\n??:? void tmp8qvbz4f0.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8qvbz4f0.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp8qvbz4f0.__unittest_L52_C1() [0x427f6c]\n??:? void tmp8qvbz4f0.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(need > remaining)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - need, 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gnmjscn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + min(need, remaining);\n    result[1] = max(0L, remaining - need);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn_fgpfim.d(40): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpn_fgpfim.d(41): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn_fgpfim.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplrt2m72r.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284ed]\n??:? void tmplrt2m72r.__unittest_L52_C1() [0x427f98]\n??:? void tmplrt2m72r.__modtest() [0x42826c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]\n??:? runModuleUnitTests [0x42c37d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto result = tuple(number, remaining);\n    if(result[1] < result[0] + need)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] += need;\n        result[1] -= need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2qyxb344.d(50): Error: cannot implicitly convert expression `result` of type `Tuple!(long, long)` to `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2qyxb344.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9a1px2ko.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp9a1px2ko.__unittest_L52_C1() [0x427f68]\n??:? void tmp9a1px2ko.__modtest() [0x42823c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto result = [number, need, remaining];\n    return [result[0] + result[1], result[2] - result[1]];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpys1iwl7r.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmpys1iwl7r.__unittest_L42_C1() [0x4280b1]\n??:? void tmpys1iwl7r.__modtest() [0x42823c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c51b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430541]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4309f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4304cd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b385]\n??:? runModuleUnitTests [0x42c2f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = 0;\n    result[1] = 0;\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplrt2m72r.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284ed]\n??:? void tmplrt2m72r.__unittest_L52_C1() [0x427f98]\n??:? void tmplrt2m72r.__modtest() [0x42826c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]\n??:? runModuleUnitTests [0x42c37d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8qvbz4f0.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp8qvbz4f0.__unittest_L52_C1() [0x427f6c]\n??:? void tmp8qvbz4f0.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(need > remaining)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9a1px2ko.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp9a1px2ko.__unittest_L52_C1() [0x427f68]\n??:? void tmp9a1px2ko.__modtest() [0x42823c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number;\n    result[1] = remaining;\n    if(remaining > 0)\n    {\n        if(need > remaining)\n        {\n            result[0] += remaining;\n            result[1] = 0;\n        }\n        else\n        {\n            result[0] += need;\n            result[1] -= need;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    if(number > 1000 || need > 1000 || remaining > 1000)\n        return [0L, 0L];\n    if(number < 0 || need < 0 || remaining < 0)\n        return [0L, 0L];\n    if(number + need > remaining)\n        return [remaining, 0L];\n    return [number + need, remaining - (number + need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptr1mubvy.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmptr1mubvy.__unittest_L47_C1() [0x427f60]\n??:? void tmptr1mubvy.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c49f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b332]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430974]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430451]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b309]\n??:? runModuleUnitTests [0x42c275]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428904]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    long total = number + need;\n    if(total > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = total;\n        result[1] = remaining - total;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_srvjdw6.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp_srvjdw6.__unittest_L53_C1() [0x427f68]\n??:? void tmp_srvjdw6.__modtest() [0x42823c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number >= 0 && number <= 1000 && need >= 0 && need <= 1000 && remaining >= 0 && remaining <= 1000)\n    {\n        if(remaining >= need)\n        {\n            result[0] = number + need;\n            result[1] = remaining - need;\n        }\n        else\n        {\n            result[0] = number + remaining;\n            result[1] = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(0L, remaining - need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rz9ssnx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(0L, remaining - need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rz9ssnx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number + need <= remaining)\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8qvbz4f0.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmp8qvbz4f0.__unittest_L52_C1() [0x427f6c]\n??:? void tmp8qvbz4f0.__modtest() [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - need, 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gnmjscn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = result[0] + result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = max(0L, remaining - need);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8std5acb.d(41): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8std5acb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(0L, remaining - number - need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgeltg__q.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpgeltg__q.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgeltg__q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(0L, remaining - number - need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgeltg__q.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpgeltg__q.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgeltg__q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number > 1000 || need > 1000 || remaining > 1000)\n        return result;\n    if(number < 0 || need < 0 || remaining < 0)\n        return result;\n    if(remaining == 0)\n    {\n        result[0] = number;\n        result[1] = 0;\n        return result;\n    }\n    if(need == 0)\n    {\n        result[0] = number;\n        result[1] = remaining;\n        return result;\n    }\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n        return result;\n    }\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + min(need, remaining);\n    result[1] = max(0L, remaining - need);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn_fgpfim.d(40): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmpn_fgpfim.d(41): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn_fgpfim.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long total = number + need;\n    long left = 0;\n    if(total > remaining)\n    {\n        total = remaining;\n        left = 0;\n    }\n    else\n    {\n        left = remaining - total;\n    }\n    return [total, left];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptxsjlz10.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428425]\n??:? void tmptxsjlz10.__unittest_L52_C1() [0x427ed0]\n??:? void tmptxsjlz10.__modtest() [0x4281a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c40f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430435]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]\n??:? runModuleUnitTests [0x42c1e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428874]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto total = number + need;\n    if (total > remaining)\n    {\n        return [remaining, 0];\n    }\n    else\n    {\n        return [total, remaining - total];\n    }\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_qtdh57s.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x428435]\n??:? void tmp_qtdh57s.__unittest_L49_C1() [0x427ee0]\n??:? void tmp_qtdh57s.__modtest() [0x4281b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428884]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto total = number + need;\n    auto left = remaining - total;\n    if (left < 0)\n    {\n        total += left;\n        left = 0;\n    }\n    return [total, left];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzgoj6pxp.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x42841d]\n??:? void tmpzgoj6pxp.__unittest_L48_C1() [0x427ec8]\n??:? void tmpzgoj6pxp.__modtest() [0x42819c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x42886c]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(need > remaining)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(0L, remaining - need)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp0rz9ssnx.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rz9ssnx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(number + need > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - (number + need);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbukx3dwk.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x4284fd]\n??:? void tmpbukx3dwk.__unittest_L54_C1() [0x427fa8]\n??:? void tmpbukx3dwk.__modtest() [0x42827c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5b7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b44a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b84]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430661]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b421]\n??:? runModuleUnitTests [0x42c38d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    if(result[0] > remaining)\n    {\n        result[0] = remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[1] = remaining - result[0];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplrt2m72r.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x4284ed]\n??:? void tmplrt2m72r.__unittest_L52_C1() [0x427f98]\n??:? void tmplrt2m72r.__modtest() [0x42826c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430651]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b411]\n??:? runModuleUnitTests [0x42c37d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(need > remaining)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        throw new Exception(\"Invalid input\");\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(remaining >= need)\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    else\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - (number + need), 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppdso2rbr.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmppdso2rbr.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppdso2rbr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = max(0L, remaining - need);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8std5acb.d(41): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8std5acb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    auto result = tuple(number + need, remaining - need);\n    if (result[1] < 0)\n        result = tuple(result[0] + result[1], 0);\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpihvwor1g.d(42): Error: cannot implicitly convert expression `result` of type `Tuple!(long, long)` to `long[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpihvwor1g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    return [min(number + need, remaining), max(remaining - need, 0L)];\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp8gnmjscn.d(39): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gnmjscn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (need > remaining)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    // your code here\n    long[] result = new long[2];\n    if(remaining < need)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    else\n    {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if(number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000)\n        return result;\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164416
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] += result[1];\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if(result[1] < 0)\n    {\n        result[0] = number + remaining;\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164415
    }
  ]
}