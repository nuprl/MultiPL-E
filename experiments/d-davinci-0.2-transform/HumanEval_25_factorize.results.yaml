language: d
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors;\n    long[] primes = [2L, 3L, 5L, 7L, 11L, 13L, 17L,\
    \ 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L,\
    \ 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L, 149L, 151L,\
    \ 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L, 223L, 227L,\
    \ 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L, 283L, 293L,\
    \ 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L, 373L, 379L,\
    \ 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L, 449L, 457L,\
    \ 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L, 541L, 547L,\
    \ 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L, 617L, 619L,\
    \ 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L, 701L, 709L,\
    \ 719L, 727L, 733L, 739L, 743L, 751L, 757L, 761L, 769L, 773L, 787L, 797L, 809L,\
    \ 811L, 821L, 823L, 827L, 829L, 839L,\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaohbu2q9.d(19): Error: expression expected, not `unittest`\n/tmp/tmpaohbu2q9.d(20):
    Error: comma expected separating array initializers, not `{`\n/tmp/tmpaohbu2q9.d(32):
    Error: comma expected separating array initializers, not `void`\n/tmp/tmpaohbu2q9.d(32):
    Error: semicolon expected, not `main`\n/tmp/tmpaohbu2q9.d(32): Error: found `{`
    when expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpaohbu2q9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = new long[];\n    long i = 2;\n    while (n > 1) \n   \
    \ {\n        if (n % i == 0) \n        {\n            res ~= i;\n            n\
    \ /= i;\n        } \n        else \n        {\n            i++;\n        }\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcpq4ztcj.d(17): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpcpq4ztcj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long i = 2;\n    while (i <= n) \n    {\n\
    \        if (n % i == 0) \n        {\n            result ~= i;\n            n\
    \ /= i;\n        } \n        else \n        {\n            i++;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long d = 2;\n    while (n > 1) \n    {\n \
    \       while (n % d == 0) \n        {\n            result ~= d;\n           \
    \ n /= d;\n        }\n        d += 1;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long d = 2;\n    while (n > 1) \n    {\n \
    \       while (n % d == 0) \n        {\n            result ~= d;\n           \
    \ n /= d;\n        }\n        d += 1;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long d = 2;\n    while (n > 1) \n    {\n \
    \       while (n % d == 0) \n        {\n            result ~= d;\n           \
    \ n /= d;\n        }\n        d += 1;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[0];\n    long[] primes = new long[0];\n  \
    \  long[] powers = new long[0];\n    long[] factors = new long[0];\n    long[]\
    \ factors_powers = new long[0];\n    long[] factors_powers_sorted = new long[0];\n\
    \    long[] factors_sorted = new long[0];\n    long[] factors_powers_sorted_unique\
    \ = new long[0];\n    long[] factors_sorted_unique = new long[0];\n    long[]\
    \ factors_sorted_unique_powers = new long[0];\n    long[] factors_sorted_unique_powers_sorted\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_sorted_unique = new\
    \ long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers = new\
    \ long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers_sorted\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers_sorted_unique\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers_sorted\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers_sorted_unique\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers_sorted\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers_sorted_unique_powers_sorted_unique\
    \ = new long[0];\n    long[] factors_sorted_unique_powers_s\nunittest\n{\n   \
    \ alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpljbo1aif.d(39): Error: semicolon expected, not `unittest`\n/tmp/tmpljbo1aif.d(39):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpljbo1aif.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long[] primes = [2L, 3L, 5L, 7L, 11L, 13L,\
    \ 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L,\
    \ 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L, 149L, 151L,\
    \ 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L, 223L, 227L,\
    \ 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L, 283L, 293L,\
    \ 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L, 373L, 379L,\
    \ 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L, 449L, 457L,\
    \ 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L, 541L, 547L,\
    \ 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L, 617L, 619L,\
    \ 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L, 701L, 709L,\
    \ 719L, 727L, 733L, 739L, 743L, 751L, 757L, 761L, 769L, 773L, 787L, 797L, 809L,\
    \ 811L, 821L, 823L, 827L, 829L, 839L\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsee_qaqf.d(19): Error: comma expected separating array initializers,
    not `unittest`\n/tmp/tmpsee_qaqf.d(20): Error: semicolon expected, not `{`\n/tmp/tmpsee_qaqf.d(32):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsee_qaqf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    long i = 2;\n    while (i <= n) \n    {\n\
    \        if (n % i == 0) \n        {\n            factors ~= i;\n            n\
    \ /= i;\n        } \n        else \n        {\n            i++;\n        }\n \
    \   }\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[];\n    long[] primes = getPrimes(n);\n \
    \   foreach(prime; primes)\n    {\n        while(n % prime == 0)\n        {\n\
    \            n /= prime;\n            factors ~= prime;\n        }\n    }\n  \
    \  return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa1nw87j8.d(17): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpa1nw87j8.d(18): Error: undefined
    identifier `getPrimes`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa1nw87j8.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long i = 2;\n    while (n > 1) \n    {\n \
    \       if (n % i == 0) \n        {\n            result ~= i;\n            n /=\
    \ i;\n        }\n        else \n        {\n            i++;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long i = 2;\n    while (n > 1) \n    {\n \
    \       if (n % i == 0) \n        {\n            result ~= i;\n            n /=\
    \ i;\n        } \n        else \n        {\n            i++;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = new long[];\n    long i = 2;\n    while (n > 1) \n\
    \    {\n        if (n % i == 0) \n        {\n            result ~= i;\n      \
    \      n /= i;\n        } \n        else \n        {\n            i++;\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjv5uuxmh.d(17): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpjv5uuxmh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[];\n    long i = 2;\n    while (i <= n) \n\
    \    {\n        if (n % i == 0) \n        {\n            factors ~= i;\n     \
    \       n /= i;\n        } \n        else \n        {\n            i++;\n    \
    \    }\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprubfs1jv.d(17): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprubfs1jv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    long i = 2;\n    while (n > 1) \n    {\n\
    \        while (n % i == 0) \n        {\n            factors ~= i;\n         \
    \   n /= i;\n        }\n        i++;\n    }\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] result = [];\n    long i = 2;\n    while (n > 1) \n    {\n \
    \       while (n % i == 0) \n        {\n            result ~= i;\n           \
    \ n /= i;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[];\n    long[] primes = primes(n);\n    foreach(prime;\
    \ primes)\n    {\n        while(n % prime == 0)\n        {\n            n /= prime;\n\
    \            factors ~= prime;\n        }\n    }\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0_twpplo.d(17): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp0_twpplo.d(18): Error: undefined
    identifier `primes`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0_twpplo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] ret = new long[];\n    long i = 2;\n    while (n > 1) \n   \
    \ {\n        if (n % i == 0) \n        {\n            ret ~= i;\n            n\
    \ /= i;\n        } \n        else \n        {\n            i++;\n        }\n \
    \   }\n    return ret;\n}\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyis5f1sf.d(17): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpyis5f1sf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = [];\n    long[] primes = [2L, 3L, 5L, 7L, 11L, 13L,\
    \ 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L,\
    \ 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L, 149L, 151L,\
    \ 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L, 223L, 227L,\
    \ 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L, 283L, 293L,\
    \ 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L, 373L, 379L,\
    \ 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L, 449L, 457L,\
    \ 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L, 541L, 547L,\
    \ 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L, 617L, 619L,\
    \ 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L, 701L, 709L,\
    \ 719L, 727L, 733L, 739L, 743L, 751L, 757L, 761L, 769L, 773L, 787L, 797L, 809L,\
    \ 811L, 821L, 823L, 827L, 829L, 839L\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa9ccz0zu.d(19): Error: comma expected separating array initializers,
    not `unittest`\n/tmp/tmpa9ccz0zu.d(20): Error: semicolon expected, not `{`\n/tmp/tmpa9ccz0zu.d(32):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa9ccz0zu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n Return list of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be listed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] res = [];\n    long i = 2;\n    while (i <= n) \n    {\n   \
    \     if (n % i == 0) \n        {\n            res ~= i;\n            n /= i;\n\
    \        } \n        else \n        {\n            i++;\n        }\n    }\n  \
    \  return res;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
