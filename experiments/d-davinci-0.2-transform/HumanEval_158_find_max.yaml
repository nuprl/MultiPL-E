name: HumanEval_158_find_max
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
  \ a list of strings.\n    The list contains different words. Return the word with\
  \ maximum number\n    of unique characters. If multiple strings have maximum number\
  \ of unique\n    characters, return the one which comes first in lexicographical\
  \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n \
  \   >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
  aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
  \ words) \n"
tests: "unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
  , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
  , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"])\
  \ == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
  we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
  this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) ==\
  \ \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n\
  }\nvoid main(){}"
completions: ["{\n    string max = words[0];\n    foreach(string word; words)\n  \
    \  {\n        if(word.length > max.length)\n        {\n            max = word;\n\
    \        }\n    }\n    return max;\n}", "{\n    string max_word = \"\";\n    int\
    \ max_unique = 0;\n    foreach(word; words)\n    {\n        int unique = 0;\n\
    \        foreach(char c; word)\n        {\n            if(!max_word.canFind(c))\n\
    \            {\n                unique++;\n            }\n        }\n        if(unique\
    \ > max_unique)\n        {\n            max_unique = unique;\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}", "{\n    string max_word\
    \ = \"\";\n    int max_unique = 0;\n    foreach(string word; words)\n    {\n \
    \       int unique = 0;\n        foreach(char c; word)\n        {\n          \
    \  if(word.count(c) == 1)\n                unique++;\n        }\n        if(unique\
    \ > max_unique)\n        {\n            max_unique = unique;\n            max_word\
    \ = word;\n        }\n        else if(unique == max_unique)\n        {\n     \
    \       if(word < max_word)\n                max_word = word;\n        }\n   \
    \ }\n    return max_word;\n}", "{\n    int max_count = 0;\n    string max_word\
    \ = \"\";\n    foreach(word; words)\n    {\n        int count = 0;\n        foreach(c;\
    \ word)\n        {\n            if(!max_word.canFind(c))\n            {\n    \
    \            count++;\n            }\n        }\n        if(count > max_count)\n\
    \        {\n            max_count = count;\n            max_word = word;\n   \
    \     }\n    }\n    return max_word;\n}", "{\n    string result = \"\";\n    int\
    \ max_unique = 0;\n    foreach(string word; words)\n    {\n        int unique\
    \ = 0;\n        foreach(char c; word)\n        {\n            if(!result.canFind(c))\n\
    \            {\n                unique++;\n            }\n        }\n        if(unique\
    \ > max_unique)\n        {\n            max_unique = unique;\n            result\
    \ = word;\n        }\n    }\n    return result;\n}", "{\n    string result = \"\
    \";\n    int max_unique = 0;\n    foreach(word; words)\n    {\n        int unique\
    \ = 0;\n        foreach(c; word)\n        {\n            if(word.count(c) == 1)\n\
    \            {\n                unique++;\n            }\n        }\n        if(unique\
    \ > max_unique)\n        {\n            max_unique = unique;\n            result\
    \ = word;\n        }\n    }\n    return result;\n}", "{\n    string max_word =\
    \ \"\";\n    int max_count = 0;\n    foreach(string word; words)\n    {\n    \
    \    int count = 0;\n        foreach(char c; word)\n        {\n            if(!max_word.canFind(c))\n\
    \            {\n                count++;\n            }\n        }\n        if(count\
    \ > max_count)\n        {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}", "{\n    string max = words[0];\n\
    \    foreach(string word; words)\n    {\n        if(word.length > max.length)\n\
    \        {\n            max = word;\n        }\n    }\n    return max;\n}", "{\n\
    \    string max_word = \"\";\n    int max_unique = 0;\n    foreach(word; words)\n\
    \    {\n        int unique = 0;\n        foreach(char c; word)\n        {\n  \
    \          if(!max_word.canFind(c))\n            {\n                unique++;\n\
    \            }\n        }\n        if(unique > max_unique)\n        {\n      \
    \      max_unique = unique;\n            max_word = word;\n        }\n    }\n\
    \    return max_word;\n}", "{\n    string max_word = \"\";\n    int max_unique\
    \ = 0;\n    foreach(string word; words) \n    {\n        int unique = 0;\n   \
    \     foreach(char c; word) \n        {\n            if(c !in max_word) \n   \
    \         {\n                max_word ~= c;\n                unique++;\n     \
    \       }\n        }\n        if(unique > max_unique) \n        {\n          \
    \  max_unique = unique;\n            max_word = word;\n        }\n    }\n    return\
    \ max_word;\n}", "{\n    string max_word = \"\";\n    int max_unique = 0;\n  \
    \  foreach(word; words) \n    {\n        int unique = 0;\n        foreach(c; word)\
    \ \n        {\n            if(word.count(c) == 1) \n            {\n          \
    \      unique++;\n            }\n        }\n        if(unique > max_unique) \n\
    \        {\n            max_unique = unique;\n            max_word = word;\n \
    \       }\n        else if(unique == max_unique) \n        {\n            if(word\
    \ < max_word) \n            {\n                max_word = word;\n            }\n\
    \        }\n    }\n    return max_word;\n}", "{\n    string max_word = \"\";\n\
    \    int max_unique = 0;\n    foreach(string word; words)\n    {\n        int\
    \ unique = 0;\n        foreach(char c; word)\n        {\n            if(!max_word.canFind(c))\n\
    \            {\n                unique++;\n            }\n        }\n        if(unique\
    \ > max_unique)\n        {\n            max_unique = unique;\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}", "{\n    string max_word;\n\
    \    int max_count = 0;\n    foreach(word; words)\n    {\n        int count =\
    \ 0;\n        foreach(c; word)\n        {\n            if(count == 0)\n      \
    \      {\n                count = 1;\n            }\n            else\n      \
    \      {\n                if(word[0..count].count(c) == 0)\n                {\n\
    \                    count++;\n                }\n            }\n        }\n \
    \       if(count > max_count)\n        {\n            max_count = count;\n   \
    \         max_word = word;\n        }\n    }\n    return max_word;\n}", "{\n \
    \   string max_word = \"\";\n    int max_unique = 0;\n    foreach(word; words)\n\
    \    {\n        int unique = 0;\n        foreach(c; word)\n        {\n       \
    \     if(!max_word.canFind(c))\n            {\n                unique++;\n   \
    \         }\n        }\n        if(unique > max_unique)\n        {\n         \
    \   max_unique = unique;\n            max_word = word;\n        }\n    }\n   \
    \ return max_word;\n}", "{\n    string max_word = \"\";\n    int max_unique =\
    \ 0;\n    foreach(word; words)\n    {\n        int unique = 0;\n        foreach(char\
    \ c; word)\n        {\n            if(!max_word.canFind(c))\n            {\n \
    \               unique++;\n            }\n        }\n        if(unique > max_unique)\n\
    \        {\n            max_unique = unique;\n            max_word = word;\n \
    \       }\n    }\n    return max_word;\n}", "{\n    string max_word = \"\";\n\
    \    int max_count = 0;\n    foreach(word; words)\n    {\n        int count =\
    \ 0;\n        foreach(c; word)\n        {\n            if(!max_word.canFind(c))\n\
    \            {\n                count++;\n            }\n        }\n        if(count\
    \ > max_count)\n        {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}", "{\n    string max_word;\n\
    \    int max_unique = 0;\n    foreach(word; words)\n    {\n        int unique\
    \ = 0;\n        foreach(c; word)\n        {\n            if(word.count(c) == 1)\n\
    \            {\n                unique++;\n            }\n        }\n        if(unique\
    \ > max_unique)\n        {\n            max_unique = unique;\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;\n}", "{\n    string result =\
    \ \"\";\n    int max_unique = 0;\n    foreach(word; words)\n    {\n        int\
    \ unique = 0;\n        foreach(char c; word)\n        {\n            if(!result.canFind(c))\n\
    \            {\n                unique++;\n            }\n        }\n        if(unique\
    \ > max_unique)\n        {\n            max_unique = unique;\n            result\
    \ = word;\n        }\n    }\n    return result;\n}", "{\n    string max_word =\
    \ \"\";\n    int max_unique = 0;\n    foreach(word; words)\n    {\n        int\
    \ unique = 0;\n        foreach(c; word)\n        {\n            if(count(word,\
    \ c) == 1)\n            {\n                unique++;\n            }\n        }\n\
    \        if(unique > max_unique)\n        {\n            max_unique = unique;\n\
    \            max_word = word;\n        }\n    }\n    return max_word;\n}", "{\n\
    \    string max = words[0];\n    foreach(string word; words)\n    {\n        if(word.length\
    \ > max.length)\n        {\n            max = word;\n        }\n    }\n    return\
    \ max;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
