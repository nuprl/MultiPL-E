language: d
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, numeral; roman_numerals)\n    {\n    \
    \    while(number >= decimal_numerals[i])\n        {\n            result ~= numeral;\n\
    \            number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdn9f7btr.d(31): Error: expression expected, not `unittest`

    /tmp/tmpdn9f7btr.d(32): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpdn9f7btr.d(50): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpdn9f7btr.d(50): Error: semicolon expected, not `main`

    /tmp/tmpdn9f7btr.d(50): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdn9f7btr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, numeral; roman_numerals)\n    {\n    \
    \    while(number >= decimal_numerals[i])\n        {\n            result ~= numeral;\n\
    \            number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] decimal_values = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ long[] decimal_values_reversed = decimal_values.dup.reverse;\n    static long[]\
    \ decimal_values_reversed_without_last = decimal_values_reversed[0..$-1];\n  \
    \  static string[] roman_numerals_reversed = roman_numerals.dup.reverse;\n   \
    \ static string[] roman_numerals_reversed_without_last = roman_numerals_reversed[0..$-1];\n\
    \    static long[] decimal_values_reversed_without_last_and_last_two = decimal_values_reversed[0..$-2];\n\
    \    static string[] roman_numerals_reversed_without_last_and_last_two = roman_numerals_reversed[0..$-2];\n\
    \    static long[] decimal_values_reversed_without_last_and_last_three = decimal_values_reversed[0..$-3];\n\
    \    static string[] roman_numerals_reversed_without_last_and_last_three = roman_numerals_reversed[0..$-3];\n\
    \    static long[] decimal_values_reversed_without_last_and_last_four = decimal_values_reversed[0..$-4];\n\
    \    static string[] roman_numerals_reversed_without_last_and_last_four = roman_numerals_reversed[0..$-4];\n\
    \    static long[] decimal_values_reversed_without_last_and_last_five = decimal_values_reversed[0..$-5];\n\
    \    static string[] roman_numerals_reversed_without_last_and_last_five = roman_numerals_reversed[0..$-5];\n\
    \    static long[] decimal_values_reversed_without\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr2pimlf_.d(35): Error: semicolon expected, not `unittest`

    /tmp/tmpr2pimlf_.d(35): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr2pimlf_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    string result = \"\";\n\
    \    while (number > 0) {\n        result ~= roman_digits[number % 10];\n    \
    \    number /= 10;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzr23wy37.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x42823d]

    ??:? void tmpzr23wy37.__unittest_L30_C1() [0x427bc4]

    ??:? void tmpzr23wy37.__modtest() [0x427fc0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9f7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b906]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43022d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4306dc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4301b9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8dd]

    ??:? runModuleUnitTests [0x42c7cd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428700]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens_of_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundreds_of_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_tens_of_millions = [\n  \
    \      \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    , \"c\"\n    ];\n    static string[10] roman_hundreds_of_millions = [\n      \
    \  \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"\
    m\"\n    ];\n    static string[10] roman_billions = [\n       \nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmperho8ebc.d(49): Error: expression expected, not `unittest`

    /tmp/tmperho8ebc.d(50): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmperho8ebc.d(68): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmperho8ebc.d(68): Error: semicolon expected, not `main`

    /tmp/tmperho8ebc.d(68): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmperho8ebc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ struct RomanNumeral {\n        long value;\n        string symbol;\n    }\n\
    \    romanNumerals[] = [\n        RomanNumeral(1L, \"i\"),\n        RomanNumeral(4L,\
    \ \"iv\"),\n        RomanNumeral(5L, \"v\"),\n        RomanNumeral(9L, \"ix\"\
    ),\n        RomanNumeral(10L, \"x\"),\n        RomanNumeral(40L, \"xl\"),\n  \
    \      RomanNumeral(50L, \"l\"),\n        RomanNumeral(90L, \"xc\"),\n       \
    \ RomanNumeral(100L, \"c\"),\n        RomanNumeral(400L, \"cd\"),\n        RomanNumeral(500L,\
    \ \"d\"),\n        RomanNumeral(900L, \"cm\"),\n        RomanNumeral(1000L, \"\
    m\")\n    ];\n    string result = \"\";\n    foreach(i, romanNumeral; romanNumerals)\
    \ {\n        while(number >= romanNumeral.value) {\n            result ~= romanNumeral.symbol;\n\
    \            number -= romanNumeral.value;\n        }\n    }\n    return result;\n\
    }\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuxrdquta.d(48): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuxrdquta.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[int] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[int] roman_hundreds = [\n        \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[int] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n  \
    \  static string[int] roman_tenthousands = [\n        \"xm\", \"xxm\", \"xxxm\"\
    \n    ];\n    static string[int] roman_hundredthousands = [\n        \"cm\", \"\
    ccm\", \"cccm\"\n    ];\n    static string[int] roman_millions = [\n        \"\
    m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_tenmillions = [\n \
    \       \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundredmillions\
    \ = [\n        \"cm\", \"ccm\", \"cccm\"\n    ];\n    static string[int] roman_billions\
    \ = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_tenbillions\
    \ = [\n        \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundredbillions\
    \ = [\n        \"cm\", \"ccm\", \"cccm\"\n    ];\n    static string[int] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_tentrillions\
    \ = [\n        \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundredtrillions\
    \ = [\n        \"cm\", \"ccm\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps_klaltj.d(62): Error: unterminated string constant starting at
    /tmp/tmps_klaltj.d(81)

    /tmp/tmps_klaltj.d(68): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmps_klaltj.d(68): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmps_klaltj.d(69): Error: found `lii` when expecting `;` following statement

    /tmp/tmps_klaltj.d(70): Error: found `cli` when expecting `;` following statement

    /tmp/tmps_klaltj.d(71): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmps_klaltj.d(72): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmps_klaltj.d(73): Error: found `i` when expecting `;` following statement

    /tmp/tmps_klaltj.d(74): Error: found `iv` when expecting `;` following statement

    /tmp/tmps_klaltj.d(75): Error: found `xliii` when expecting `;` following statement

    /tmp/tmps_klaltj.d(76): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    string result = \"\";\n    while (number\
    \ > 0) \n    {\n        auto digit = number % 10;\n        result = roman_numerals[digit]\
    \ ~ result;\n        number /= 10;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcvjfystm.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x42825d]

    ??:? void tmpcvjfystm.__unittest_L30_C1() [0x427be4]

    ??:? void tmpcvjfystm.__modtest() [0x427fe0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c0c3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42afd2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ffa1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430450]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ff2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42afa9]

    ??:? runModuleUnitTests [0x42be99]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428720]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] roman_values = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ long[] roman_values_reversed = roman_values.dup.reverse;\n    static string[]\
    \ roman_numerals_reversed = roman_numerals.dup.reverse;\n    static long[] roman_values_reversed_sorted\
    \ = roman_values_reversed.dup.sort;\n    static string[] roman_numerals_reversed_sorted\
    \ = roman_numerals_reversed.dup.sort;\n    static long[] roman_values_sorted =\
    \ roman_values_reversed_sorted.dup.reverse;\n    static string[] roman_numerals_sorted\
    \ = roman_numerals_reversed_sorted.dup.reverse;\n    static long[] roman_values_sorted_reversed\
    \ = roman_values_sorted.dup.reverse;\n    static string[] roman_numerals_sorted_reversed\
    \ = roman_numerals_sorted.dup.reverse;\n    static long[] roman_values_reversed_sorted_reversed\
    \ = roman_values_sorted_reversed.dup.reverse;\n    static string[] roman_numerals_reversed_sorted_reversed\
    \ = roman_numerals_sorted_reversed.dup.reverse;\n    static long[] roman_values_sorted_reversed_reversed\
    \ = roman_values_reversed_sorted_reversed.dup.reverse;\n    static string[] roman_numerals_sorted_reversed_reversed\
    \ = roman_numerals_reversed_sorted_reversed.dup.reverse;\n    static long[] roman_values_sorted_reversed_reversed_reversed\
    \ = roman_values_sorted_reversed_\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps7yq7gfg.d(35): Error: semicolon expected, not `unittest`

    /tmp/tmps7yq7gfg.d(35): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps7yq7gfg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] romans = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] romans_tens = [\"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static\
    \ string[10] romans_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] romans_thousands = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tenthousands = [\"\"\
    , \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] romans_hundredthousands =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] romans_millions = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tenmillions = [\"\"\
    , \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] romans_hundredmillions = [\"\
    \", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] romans_billions = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tenbillions = [\"\", \"\
    xm\", \"xxm\", \"xxxm\"];\n    static string[4] romans_hundredbillions = [\"\"\
    , \"cm\", \"ccm\", \"cccm\"];\n    static string[4] romans_trillions = [\"\",\
    \ \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tentrillions = [\"\",\
    \ \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] romans_hundredtrillions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] romans_quadrillions\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tenquadrillions\
    \ =\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphfhq3anp.d(37): Error: expression expected, not `unittest`

    /tmp/tmphfhq3anp.d(38): Error: semicolon expected, not `{`

    /tmp/tmphfhq3anp.d(56): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphfhq3anp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\n        \"i\", \"ii\", \"\
    iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[10] roman_thousands = [\n        \"\
    m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n\
    \    ];\n    if (number > 0) {\n        if (number < 10) {\n            result\
    \ = roman_numerals[number - 1];\n        } else if (number < 100) {\n        \
    \    result = roman_tens[number / 10 - 1] ~ roman_numerals[number % 10 - 1];\n\
    \        } else if (number < 1000) {\n            result = roman_hundreds[number\
    \ / 100 - 1] ~ roman_tens[(number % 100) / 10 - 1] ~ roman_numerals[number % 10\
    \ - 1];\n        } else if (number < 10000) {\n            result = roman_thousands[number\
    \ / 1000 - 1] ~ roman_hundreds[(number % 1000) / 100 - 1] ~ roman_tens[(number\
    \ % 100) / 10 - 1] ~ roman_numerals[number % 10 - 1];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp40a24qrv.d(39): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428826]

    ??:? immutable(char)[] tmp40a24qrv.int_to_mini_roman(long) [0x427e39]

    ??:? void tmp40a24qrv.__unittest_L46_C1() [0x4281c5]

    ??:? void tmp40a24qrv.__modtest() [0x4284f4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5db]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304b9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430968]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430445]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4c1]

    ??:? runModuleUnitTests [0x42c3b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    auto numeral = tuple(\"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\");\n    auto value\
    \ = tuple(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1);\n    foreach(i,\
    \ v; value)\n    {\n        while(number >= v)\n        {\n            result\
    \ ~= numeral[i];\n            number -= v;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number >= 1 && number <= 1000);\n    string result\
    \ = \"\";\n    result ~= roman_thousands[number / 1000];\n    number %= 1000;\n\
    \    result ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~=\
    \ roman_tens[number / 10];\n    number %= 10;\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzyzefngt.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzyzefngt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] decimal_values = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400,\
    \ 500, 600, 700, 800, 900, 1000];\n    static const string[] roman_values = [\"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n   \
    \ static const string[] roman_values_upper = [\"I\", \"II\", \"III\", \"IV\",\
    \ \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XX\", \"XXX\", \"XL\", \"\
    L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\"\
    , \"DC\", \"DCC\", \"DCCC\", \"CM\", \"M\"];\n    static const string[] roman_values_lower\
    \ = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\
    , \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\
    ];\n    static const string[] roman_values_lower_mini = [\"i\", \"i\", \"i\",\
    \ \"i\", \"v\", \"v\", \"v\", \"v\", \"x\", \"x\", \"x\", \"x\", \"l\", \"l\"\
    , \"l\", \"l\", \"c\", \"c\", \"c\", \"c\", \"d\", \"d\", \"\nunittest\n{\n  \
    \  alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmputw2qljq.d(26): Error: unterminated string constant starting at
    /tmp/tmputw2qljq.d(44)

    /tmp/tmputw2qljq.d(31): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmputw2qljq.d(31): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmputw2qljq.d(32): Error: found `lii` when expecting `;` following statement

    /tmp/tmputw2qljq.d(33): Error: found `cli` when expecting `;` following statement

    /tmp/tmputw2qljq.d(34): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmputw2qljq.d(35): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmputw2qljq.d(36): Error: found `i` when expecting `;` following statement

    /tmp/tmputw2qljq.d(37): Error: found `iv` when expecting `;` following statement

    /tmp/tmputw2qljq.d(38): Error: found `xliii` when expecting `;` following statement

    /tmp/tmputw2qljq.d(39): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_thousands\
    \ = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_thousands\
    \ = [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_millions =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_millions = [\"\
    \", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_millions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_billions = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_billions = [\"\"\
    , \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_billions = [\"\
    \", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_trillions = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_trillions = [\"\",\
    \ \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_trillions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_quadrillion =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    static string\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjsjpw5l4.d(37): Error: no identifier for declarator `string`

    /tmp/tmpjsjpw5l4.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjsjpw5l4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ decimal_numerals = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L,\
    \ 10L, 9L, 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, numeral;\
    \ roman_numerals)\n    {\n        while(number >= decimal_numerals[i])\n     \
    \   {\n            result ~= numeral;\n            number -= decimal_numerals[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_subtractors\
    \ = [1, 10, 100];\n    static const string[] roman_subtraction_strings = [\"i\"\
    , \"x\", \"c\"];\n    static const string[] roman_subtraction_strings_5 = [\"\
    v\", \"l\", \"d\"];\n    static const string[] roman_subtraction_strings_10 =\
    \ [\"x\", \"c\", \"m\"];\n    static const string[] roman_subtraction_strings_15\
    \ = [\"xv\", \"lc\", \"dm\"];\n    static const string[] roman_subtraction_strings_20\
    \ = [\"xx\", \"cc\", \"mm\"];\n    static const string[] roman_subtraction_strings_25\
    \ = [\"xxv\", \"ccl\", \"dmm\"];\n    static const string[] roman_subtraction_strings_30\
    \ = [\"xxx\", \"ccc\", \"mmm\"];\n    static const string[] roman_subtraction_strings_35\
    \ = [\"xxxv\", \"cccl\", \"dmmm\"];\n    static const string[] roman_subtraction_strings_40\
    \ = [\"xl\", \"cd\", \"mv\"];\n    static const string[] roman_subtraction_strings_45\
    \ = [\"xlv\", \"cdl\", \"mvd\"];\n    static const string[] roman_subtraction_strings_50\
    \ = [\"l\", \"d\", \"m\"];\n    static const string[] roman_subtraction_strings_55\
    \ = [\"lv\", \"dl\", \"md\"];\n    static const string[] roman_subtraction_strings_60\
    \ = [\"lx\", \"dc\", \"mc\"];\n    static const string[] roman_subtraction_strings_65\
    \ = [\"lxv\", \"dcl\", \"mcd\"];\n    static const string[] roman_subtraction_strings_70\
    \ = [\"lxx\", \"dcc\", \"mcc\"];\n    static const string[] roman_subtraction_strings_75\
    \ = [\"lxx\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpovgsq42t.d(38): Error: unterminated string constant starting at
    /tmp/tmpovgsq42t.d(56)

    /tmp/tmpovgsq42t.d(43): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpovgsq42t.d(43): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpovgsq42t.d(44): Error: found `lii` when expecting `;` following statement

    /tmp/tmpovgsq42t.d(45): Error: found `cli` when expecting `;` following statement

    /tmp/tmpovgsq42t.d(46): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpovgsq42t.d(47): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpovgsq42t.d(48): Error: found `i` when expecting `;` following statement

    /tmp/tmpovgsq42t.d(49): Error: found `iv` when expecting `;` following statement

    /tmp/tmpovgsq42t.d(50): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpovgsq42t.d(51): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    string result = \"\";\n    result ~= thousands[number / 1000];\n    result\
    \ ~= hundreds[(number % 1000) / 100];\n    result ~= tens[(number % 100) / 10];\n\
    \    result ~= digits[number % 10];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdn9f7btr.d(31): Error: expression expected, not `unittest`

    /tmp/tmpdn9f7btr.d(32): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpdn9f7btr.d(50): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpdn9f7btr.d(50): Error: semicolon expected, not `main`

    /tmp/tmpdn9f7btr.d(50): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdn9f7btr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptb19tx7l.d(60): Error: found `unittest` when expecting `]`

    /tmp/tmptb19tx7l.d(61): Error: no identifier for declarator `string[4]`

    /tmp/tmptb19tx7l.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb19tx7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\",\
    \ \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, numeral; numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= numeral;\n  \
    \          number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptb19tx7l.d(60): Error: found `unittest` when expecting `]`

    /tmp/tmptb19tx7l.d(61): Error: no identifier for declarator `string[4]`

    /tmp/tmptb19tx7l.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb19tx7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    static string[10] roman_numerals = [\"\", \"i\", \"ii\"\
    , \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10]\
    \ roman_tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\",\
    \ \"lxxx\", \"xc\"];\n    static string[10] roman_hundreds = [\"\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static\
    \ string[4] roman_thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    if (number\
    \ > 1000)\n        return \"\";\n    else\n    {\n        result ~= roman_thousands[number\
    \ / 1000];\n        number %= 1000;\n        result ~= roman_hundreds[number /\
    \ 100];\n        number %= 100;\n        result ~= roman_tens[number / 10];\n\
    \        number %= 10;\n        result ~= roman_numerals[number];\n        return\
    \ result;\n    }\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number > 0 && number <=\
    \ 1000) {\n        if (number >= 1000) {\n            result ~= roman_thousands[number\
    \ / 1000 - 1];\n            number %= 1000;\n        }\n        if (number >=\
    \ 100) {\n            result ~= roman_hundreds[number / 100 - 1];\n          \
    \  number %= 100;\n        }\n        if (number >= 10) {\n            result\
    \ ~= roman_tens[number / 10 - 1];\n            number %= 10;\n        }\n    \
    \    if (number > 0) {\n            result ~= roman_numerals[number - 1];\n  \
    \      }\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfm3df38s.d(52): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfm3df38s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    long remainder = number;\n    while (remainder > 0) {\n       \
    \ if (remainder >= 1000) {\n            result ~= \"m\";\n            remainder\
    \ -= 1000;\n        } else if (remainder >= 900) {\n            result ~= \"cm\"\
    ;\n            remainder -= 900;\n        } else if (remainder >= 500) {\n   \
    \         result ~= \"d\";\n            remainder -= 500;\n        } else if (remainder\
    \ >= 400) {\n            result ~= \"cd\";\n            remainder -= 400;\n  \
    \      } else if (remainder >= 100) {\n            result ~= \"c\";\n        \
    \    remainder -= 100;\n        } else if (remainder >= 90) {\n            result\
    \ ~= \"xc\";\n            remainder -= 90;\n        } else if (remainder >= 50)\
    \ {\n            result ~= \"l\";\n            remainder -= 50;\n        } else\
    \ if (remainder >= 40) {\n            result ~= \"xl\";\n            remainder\
    \ -= 40;\n        } else if (remainder >= 10) {\n            result ~= \"x\";\n\
    \            remainder -= 10;\n        } else if (remainder >= 9) {\n        \
    \    result ~= \"ix\";\n            remainder -= 9;\n        } else if (remainder\
    \ >= 5) {\n            result ~= \"v\";\n            remainder -= 5;\n       \
    \ } else if (remainder >= 4) {\n            result ~= \"iv\";\n            remainder\
    \ -= 4;\n        } else if (remainder >= 1) {\n            result ~= \"i\";\n\
    \            remainder -= 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\",\
    \ \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    if (number > 1000)\n        return \"\
    \";\n    result ~= roman_thousands[number / 1000];\n    number %= 1000;\n    result\
    \ ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~= roman_tens[number\
    \ / 10];\n    number %= 10;\n    result ~= roman_numerals[number];\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] romans = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ for (size_t i = 0; i < values.length; i++) \n    {\n        while (number >=\
    \ values[i]) \n        {\n            number -= values[i];\n            result\
    \ ~= romans[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number > 0 && number <=\
    \ 1000) {\n        result ~= roman_thousands[number / 1000];\n        number %=\
    \ 1000;\n        result ~= roman_hundreds[number / 100];\n        number %= 100;\n\
    \        result ~= roman_tens[number / 10];\n        number %= 10;\n        result\
    \ ~= roman_numerals[number];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ arabic_numerals = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L,\
    \ 9L, 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals)\n\
    \    {\n        while(number >= arabic_numerals[i])\n        {\n            result\
    \ ~= numeral;\n            number -= arabic_numerals[i];\n        }\n    }\n \
    \   return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6mwr2002.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6mwr2002.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = [\n        tuple(1000L, \"m\"),\n       \
    \ tuple(900L, \"cm\"),\n        tuple(500L, \"d\"),\n        tuple(400L, \"cd\"\
    ),\n        tuple(100L, \"c\"),\n        tuple(90L, \"xc\"),\n        tuple(50L,\
    \ \"l\"),\n        tuple(40L, \"xl\"),\n        tuple(10L, \"x\"),\n        tuple(9L,\
    \ \"ix\"),\n        tuple(5L, \"v\"),\n        tuple(4L, \"iv\"),\n        tuple(1L,\
    \ \"i\")\n    ];\n    foreach(tuple!(long, string) roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= roman_numeral[0])\n        {\n            result\
    \ ~= roman_numeral[1];\n            number -= roman_numeral[0];\n        }\n \
    \   }\n    return result;\n}\n/*\n    Given a string of roman numerals, return\
    \ the integer equivalent.\n    Restrictions: 1 <= num <= 1000\n    The string\
    \ is case insensitive.\n    The string is in lowercase.\n    The string is in\
    \ mini roman numerals.\n    The string is valid.\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmogvk4gg.d(46): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmogvk4gg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ implement\n    return \"\";\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4hc2xkue.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x428135]

    ??:? void tmp4hc2xkue.__unittest_L23_C1() [0x427ab8]

    ??:? void tmp4hc2xkue.__modtest() [0x427eb4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bddf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fe05]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4302b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd91]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42acc5]

    ??:? runModuleUnitTests [0x42bbb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428584]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10]\
    \ roman_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"];\n    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10]\
    \ roman_thousands = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\", \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_millions = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_billions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_billions = [\"x\", \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjr6uf0hb.d(31): Error: unterminated string constant starting at
    /tmp/tmpjr6uf0hb.d(49)

    /tmp/tmpjr6uf0hb.d(36): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpjr6uf0hb.d(36): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpjr6uf0hb.d(37): Error: found `lii` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(38): Error: found `cli` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(39): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(40): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpjr6uf0hb.d(41): Error: found `i` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(42): Error: found `iv` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(43): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(44): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    string\
    \ result = \"\";\n    if (number >= 1000) {\n        result ~= roman_thousands[number\
    \ / 1000];\n        number %= 1000;\n    }\n    if (number >= 100) {\n       \
    \ result ~= roman_hundreds[number / 100];\n        number %= 100;\n    }\n   \
    \ if (number >= 10) {\n        result ~= roman_tens[number / 10];\n        number\
    \ %= 10;\n    }\n    if (number > 0) {\n        result ~= roman_numerals[number];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp8c24v7v.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284e5]

    ??:? void tmpp8c24v7v.__unittest_L50_C1() [0x427e68]

    ??:? void tmpp8c24v7v.__modtest() [0x428264]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cc9f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bbae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430984]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430461]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb85]

    ??:? runModuleUnitTests [0x42ca75]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ Implement me!\n    return \"\";\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwoogmp6n.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x428135]

    ??:? void tmpwoogmp6n.__unittest_L23_C1() [0x427ab8]

    ??:? void tmpwoogmp6n.__modtest() [0x427eb4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bddf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fe05]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4302b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd91]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42acc5]

    ??:? runModuleUnitTests [0x42bbb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428584]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\n/*\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9iulf3id.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9iulf3id.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman;\n            number\
    \ -= numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    static string[10] roman_numerals = [\n        \"i\", \"\
    ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n\
    \    static string[10] roman_tens = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundreds = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_thousands\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_tens_of_thousands = [\n \
    \       \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    , \"c\"\n    ];\n    static string[10] roman_hundreds_of_thousands = [\n     \
    \   \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\",\
    \ \"m\"\n    ];\n    static string[10] roman_millions = [\n        \"m\", \"mm\"\
    , \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n \
    \   static string[10] roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static\
    \ string[10] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"ccc\", \"\
    cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10]\
    \ roman\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp458gcpwx.d(49): Error: semicolon expected, not `unittest`

    /tmp/tmp458gcpwx.d(49): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp458gcpwx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[int] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[int] roman_hundreds = [\n        \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[int] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n  \
    \  static string[int] roman_ten_thousands = [\n        \"xm\", \"xxm\", \"xxxm\"\
    \n    ];\n    static string[int] roman_hundred_thousands = [\n        \"cm\",\
    \ \"ccm\", \"cccm\"\n    ];\n    static string[int] roman_millions = [\n     \
    \   \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_ten_millions\
    \ = [\n        \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundred_millions\
    \ = [\n        \"cm\", \"ccm\", \"cccm\"\n    ];\n    static string[int] roman_billions\
    \ = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_ten_billions\
    \ = [\n        \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundred_billions\
    \ = [\n        \"cm\", \"ccm\", \"cccm\"\n    ];\n    static string[int] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_ten_trillions\
    \ = [\n        \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundred_trillions\
    \ = [\n\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp89v6_juh.d(64): Error: expression expected, not `unittest`

    /tmp/tmp89v6_juh.d(65): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmp89v6_juh.d(83): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmp89v6_juh.d(83): Error: semicolon expected, not `main`

    /tmp/tmp89v6_juh.d(83): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp89v6_juh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] nums = [1L, 4L, 5L, 9L, 10L, 40L, 50L, 90L, 100L,\
    \ 400L, 500L, 900L, 1000L];\n    string[] romans = [\"i\", \"iv\", \"v\", \"ix\"\
    , \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    while\
    \ (number > 0) {\n        auto i = nums.length;\n        while (nums[i - 1] >\
    \ number) {\n            i--;\n        }\n        result ~= romans[i - 1];\n \
    \       number -= nums[i - 1];\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    if (number <= 0)\n        return result;\n    if (number\
    \ > 1000)\n        return result;\n    long num = number;\n    long divisor =\
    \ 1000;\n    long quotient = 0;\n    long remainder = 0;\n    while (divisor >\
    \ 0)\n    {\n        quotient = num / divisor;\n        remainder = num % divisor;\n\
    \        switch (divisor)\n        {\n            case 1000:\n               \
    \ result ~= \"m\" * quotient;\n                break;\n            case 500:\n\
    \                if (remainder >= 500)\n                {\n                  \
    \  result ~= \"d\";\n                    remainder -= 500;\n                }\n\
    \                break;\n            case 100:\n                if (remainder\
    \ >= 100)\n                {\n                    if (remainder >= 900)\n    \
    \                {\n                        result ~= \"cm\";\n              \
    \          remainder -= 900;\n                    }\n                    else\n\
    \                    {\n                        result ~= \"c\" * (remainder /\
    \ 100);\n                        remainder %= 100;\n                    }\n  \
    \              }\n                break;\n            case 50:\n             \
    \   if (remainder >= 50)\n                {\n                    result ~= \"\
    l\";\n                    remainder -= 50;\n                }\n              \
    \  break;\n            case 10:\n                if (remainder >= 10)\n      \
    \          {\n                    if (remainder >= 90)\n                    {\n\
    \                        result ~= \"xc\";\n                        remainder\
    \ -= 90;\n                    }\n                    else\n                  \
    \  {\n                        result ~= \"x\" * (remainder / 10);\n          \
    \              remainder %= 10;\n                    }\n                }\n  \
    \              break;\n            case 5:\n                if (remainder >= 5)\n\
    \                {\n                    result ~= \"v\";\n                   \
    \ remainder -= 5;\n                }\n                break;\n            case\
    \ 1:\n                if (remainder >= 1)\n                {\n               \
    \     if (remainder >= 9)\n                    {\n                        result\
    \ ~= \"ix\";\n                        remainder -= 9;\n                    }\n\
    \                    else\n                    {\n                        result\
    \ ~= \"i\" * remainder;\n                        remainder = 0;\n            \
    \        }\n                }\n                break;\n        }\n        num\
    \ = remainder\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0z0ujpob.d(106): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmp0z0ujpob.d(125): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp0z0ujpob.d(125): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0z0ujpob.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = [\n        tuple(1000L, \"m\"),\n       \
    \ tuple(900L, \"cm\"),\n        tuple(500L, \"d\"),\n        tuple(400L, \"cd\"\
    ),\n        tuple(100L, \"c\"),\n        tuple(90L, \"xc\"),\n        tuple(50L,\
    \ \"l\"),\n        tuple(40L, \"xl\"),\n        tuple(10L, \"x\"),\n        tuple(9L,\
    \ \"ix\"),\n        tuple(5L, \"v\"),\n        tuple(4L, \"iv\"),\n        tuple(1L,\
    \ \"i\")\n    ];\n    foreach(tuple!(long, string) roman_numeral; roman_numerals)\
    \ {\n        while(number >= roman_numeral[0]) {\n            result ~= roman_numeral[1];\n\
    \            number -= roman_numeral[0];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9gtpxy_9.d(36): Error: `tuple!(long, string)` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9gtpxy_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10]\
    \ roman_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"];\n    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10]\
    \ roman_thousands = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\", \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_millions = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_billions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_billions = [\"x\", \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjr6uf0hb.d(31): Error: unterminated string constant starting at
    /tmp/tmpjr6uf0hb.d(49)

    /tmp/tmpjr6uf0hb.d(36): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpjr6uf0hb.d(36): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpjr6uf0hb.d(37): Error: found `lii` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(38): Error: found `cli` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(39): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(40): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpjr6uf0hb.d(41): Error: found `i` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(42): Error: found `iv` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(43): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(44): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    auto roman = tuple(\n        tuple(\"m\", 1000L),\n    \
    \    tuple(\"d\", 500L),\n        tuple(\"c\", 100L),\n        tuple(\"l\", 50L),\n\
    \        tuple(\"x\", 10L),\n        tuple(\"v\", 5L),\n        tuple(\"i\", 1L)\n\
    \    );\n    foreach(i, roman; number > 0)\n    {\n        auto r = roman[i];\n\
    \        auto n = r[1];\n        auto s = r[0];\n        if(number >= n)\n   \
    \     {\n            result ~= s;\n            number -= n;\n        }\n     \
    \   else if(i > 0)\n        {\n            auto prev = roman[i - 1];\n       \
    \     auto pn = prev[1];\n            auto ps = prev[0];\n            if(number\
    \ >= n - pn)\n            {\n                result ~= ps ~ s;\n             \
    \   number -= n - pn;\n            }\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa3nyzblq.d(30): Error: invalid `foreach` aggregate `number > 0L`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa3nyzblq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_ten_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\",\
    \ \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\",\
    \ \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions = [\n      \
    \  \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\"\n    ];\n    static string[10] roman_hundred_millions = [\n        \"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n \
    \   ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\
    , \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy22kg5lj.d(47): Error: unterminated string constant starting at
    /tmp/tmpy22kg5lj.d(66)

    /tmp/tmpy22kg5lj.d(53): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpy22kg5lj.d(53): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpy22kg5lj.d(54): Error: found `lii` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(55): Error: found `cli` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(56): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(57): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpy22kg5lj.d(58): Error: found `i` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(59): Error: found `iv` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(60): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(61): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numbers = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\", \"\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5afa0_29.d(30): Error: unterminated string constant starting at
    /tmp/tmp5afa0_29.d(48)

    /tmp/tmp5afa0_29.d(35): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmp5afa0_29.d(35): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmp5afa0_29.d(36): Error: found `lii` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(37): Error: found `cli` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(38): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(39): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmp5afa0_29.d(40): Error: found `i` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(41): Error: found `iv` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(42): Error: found `xliii` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(43): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppfgg984i.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppfgg984i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_digits = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] roman_values_sorted\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_digits_sorted\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ roman_digits_sorted_reversed = [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"\
    i\"];\n    static const long[] roman_values_sorted_reversed = [1000L, 500L, 100L,\
    \ 50L, 10L, 5L, 1L];\n    static const string[] roman_digits_reversed = [\"m\"\
    , \"d\", \"c\", \"l\", \"x\", \"v\", \"i\"];\n    static const long[] roman_values_reversed\
    \ = [1000L, 500L, 100L, 50L, 10L, 5L, 1L];\n    static const string[] roman_digits_reversed_sorted\
    \ = [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"i\"];\n    static const long[]\
    \ roman_values_reversed_sorted = [1000L, 500L, 100L, 50L, 10L, 5L, 1L];\n    static\
    \ const string[] roman_digits_reversed_sorted_reversed = [\"i\", \"v\", \"x\"\
    , \"l\", \"c\", \"d\", \"m\"];\n    static const long[] roman_values_reversed_sorted_reversed\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_digits_sorted_reversed_reversed\
    \ = [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"i\"];\n    static const long[]\
    \ roman_values_sorted_re\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw6qo366g.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmpw6qo366g.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw6qo366g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_ten_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\",\
    \ \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\",\
    \ \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions = [\n      \
    \  \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\"\n    ];\n    static string[10] roman_hundred_millions = [\n        \"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n \
    \   ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\
    , \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy22kg5lj.d(47): Error: unterminated string constant starting at
    /tmp/tmpy22kg5lj.d(66)

    /tmp/tmpy22kg5lj.d(53): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpy22kg5lj.d(53): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpy22kg5lj.d(54): Error: found `lii` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(55): Error: found `cli` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(56): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(57): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpy22kg5lj.d(58): Error: found `i` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(59): Error: found `iv` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(60): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(61): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_ten_thousands = [\n        \"x\"\
    , \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"l\", \"lx\", \"lxx\", \"lxxx\"\n    ];\n    static string[4]\
    \ roman_millions = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static\
    \ string[4] roman_ten_millions = [\n        \"d\", \"dc\", \"dcc\", \"dccc\"\n\
    \    ];\n    static string[4] roman_hundred_millions = [\n        \"m\", \"mm\"\
    , \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_billions = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_ten_billions\
    \ = [\n        \"l\", \"lx\", \"lxx\", \"lxxx\"\n    ];\n    static string[4]\
    \ roman_hundred_billions = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n\
    \    static string[4] roman_trillions = [\n        \"d\", \"dc\", \"dcc\", \"\
    dccc\"\n    ];\n    static string[4] roman_ten\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp71pisj1s.d(60): Error: semicolon expected, not `unittest`

    /tmp/tmp71pisj1s.d(60): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp71pisj1s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ implement\n    return \"\";\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4hc2xkue.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x428135]

    ??:? void tmp4hc2xkue.__unittest_L23_C1() [0x427ab8]

    ??:? void tmp4hc2xkue.__modtest() [0x427eb4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bddf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42acee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fe05]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4302b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fd91]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42acc5]

    ??:? runModuleUnitTests [0x42bbb5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428584]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    return thousands[number / 1000] ~ hundreds[(number / 100) % 10] ~ tens[(number\
    \ / 10) % 10] ~ digits[number % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] values = [1000L, 900L, 500L, 400L, 100L, 90L, 50L,\
    \ 40L, 10L, 9L, 5L, 4L, 1L];\n    string[] numerals = [\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n  \
    \  foreach(i, val; values)\n    {\n        while(number >= val)\n        {\n \
    \           result ~= numerals[i];\n            number -= val;\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ int[int] decimal_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals)\n\
    \    {\n        while(number >= decimal_numerals[i])\n        {\n            result\
    \ ~= numeral;\n            number -= decimal_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzradm8xv.d(20): Error: not an associative array initializer

    /tmp/tmpzradm8xv.d(23): Error: not an associative array initializer

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzradm8xv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdn9f7btr.d(31): Error: expression expected, not `unittest`

    /tmp/tmpdn9f7btr.d(32): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpdn9f7btr.d(50): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpdn9f7btr.d(50): Error: semicolon expected, not `main`

    /tmp/tmpdn9f7btr.d(50): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdn9f7btr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ int[int] decimal_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals)\n\
    \    {\n        while(number >= decimal_numerals[i])\n        {\n            result\
    \ ~= numeral;\n            number -= decimal_numerals[i];\n        }\n    }\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5s0fnuso.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5s0fnuso.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[] roman_tens =\
    \ [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[] roman_hundreds = [\n        \"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static\
    \ string[] roman_numerals_map = [\n        \"i\", \"v\", \"x\", \"l\", \"c\",\
    \ \"d\", \"m\"\n    ];\n    static string[] roman_numerals_map_upper = [\n   \
    \     \"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"\n    ];\n    static long[]\
    \ roman_numerals_values = [\n        1, 5, 10, 50, 100, 500, 1000\n    ];\n  \
    \  static long[] roman_numerals_values_upper = [\n        1, 5, 10, 50, 100, 500,\
    \ 1000\n    ];\n    static string[] roman_numerals_subtract = [\n        \"iv\"\
    , \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"\n    ];\n    static string[] roman_numerals_subtract_upper\
    \ = [\n        \"IV\", \"IX\", \"XL\", \"XC\", \"CD\", \"CM\"\n    ];\n    static\
    \ long[] roman_numerals_subtract_values = [\n        4, 9, 40, 90, 400, 900\n\
    \    ];\n    static long[] roman_numerals_subtract_values_upper = [\n        4,\
    \ 9, 40, 90, 400, 900\n    ];\n    static string[] roman_numerals_add = [\n  \
    \      \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8u01vkxv.d(56): Error: unterminated string constant starting at
    /tmp/tmp8u01vkxv.d(75)

    /tmp/tmp8u01vkxv.d(62): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmp8u01vkxv.d(62): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmp8u01vkxv.d(63): Error: found `lii` when expecting `;` following statement

    /tmp/tmp8u01vkxv.d(64): Error: found `cli` when expecting `;` following statement

    /tmp/tmp8u01vkxv.d(65): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmp8u01vkxv.d(66): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmp8u01vkxv.d(67): Error: found `i` when expecting `;` following statement

    /tmp/tmp8u01vkxv.d(68): Error: found `iv` when expecting `;` following statement

    /tmp/tmp8u01vkxv.d(69): Error: found `xliii` when expecting `;` following statement

    /tmp/tmp8u01vkxv.d(70): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\n/*\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwrhkiz17.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwrhkiz17.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] numbers = [1L, 4L, 5L, 9L, 10L, 40L, 50L, 90L, 100L,\
    \ 400L, 500L, 900L, 1000L];\n    string[] letters = [\"i\", \"iv\", \"v\", \"\
    ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n  \
    \  foreach(n; numbers)\n    {\n        while(number >= n)\n        {\n       \
    \     result ~= letters[numbers.indexOf(n)];\n            number -= n;\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsi2t__dr.d(27): Error: no property `indexOf` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsi2t__dr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number >= 1 && number <= 1000);\n\
    \    auto ones = cast(int) number % 10;\n    auto tens = cast(int) number / 10\
    \ % 10;\n    auto hundreds = cast(int) number / 100 % 10;\n    auto thousands\
    \ = cast(int) number / 1000 % 10;\n    return roman_thousands[thousands] ~ roman_hundreds[hundreds]\
    \ ~ roman_tens[tens] ~ roman_numerals[ones];\n}\n/*\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsqwpn5h7.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsqwpn5h7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    string result = \"\";\n    if (number > 1000)\n        return \"\";\n\
    \    if (number >= 100)\n    {\n        result ~= hundreds[number / 100];\n  \
    \      number %= 100;\n    }\n    if (number >= 10)\n    {\n        result ~=\
    \ tens[number / 10];\n        number %= 10;\n    }\n    result ~= digits[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmptsraz_kb.d(29): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42850e]

    ??:? immutable(char)[] tmptsraz_kb.int_to_mini_roman(long) [0x427c54]

    ??:? void tmptsraz_kb.__unittest_L40_C1() [0x4280fa]

    ??:? void tmptsraz_kb.__modtest() [0x4281e0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cc17]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bb26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43044d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303d9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bafd]

    ??:? runModuleUnitTests [0x42c9ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n\
    \        while(number >= arabic_numerals[i])\n        {\n            result ~=\
    \ roman_numeral;\n            number -= arabic_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n\
    \        while(number >= arabic_numerals[i])\n        {\n            result ~=\
    \ roman_numeral;\n            number -= arabic_numerals[i];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10]\
    \ roman_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"];\n    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10]\
    \ roman_thousands = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\", \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_millions = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_billions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_billions = [\"x\", \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjr6uf0hb.d(31): Error: unterminated string constant starting at
    /tmp/tmpjr6uf0hb.d(49)

    /tmp/tmpjr6uf0hb.d(36): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpjr6uf0hb.d(36): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpjr6uf0hb.d(37): Error: found `lii` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(38): Error: found `cli` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(39): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(40): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpjr6uf0hb.d(41): Error: found `i` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(42): Error: found `iv` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(43): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(44): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\"i\", \"x\", \"c\", \"m\", \"v\", \"l\", \"d\"];\n\
    \    static long[10] roman_values = [1, 10, 100, 1000, 5, 50, 500];\n    static\
    \ long[10] roman_subtractors = [1, 10, 100, 1000, 1, 10, 100];\n    static string[10]\
    \ roman_subtractors_str = [\"i\", \"x\", \"c\", \"m\", \"i\", \"x\", \"c\"];\n\
    \    static long[10] roman_subtractors_value = [1, 10, 100, 1000, 1, 10, 100];\n\
    \    static long[10] roman_subtractors_value_sub = [1, 10, 100, 1000, 1, 10, 100];\n\
    \    static string[10] roman_subtractors_str_sub = [\"i\", \"x\", \"c\", \"m\"\
    , \"i\", \"x\", \"c\"];\n    static long[10] roman_subtractors_value_sub_sub =\
    \ [1, 10, 100, 1000, 1, 10, 100];\n    static string[10] roman_subtractors_str_sub_sub\
    \ = [\"i\", \"x\", \"c\", \"m\", \"i\", \"x\", \"c\"];\n    static long[10] roman_subtractors_value_sub_sub_sub\
    \ = [1, 10, 100, 1000, 1, 10, 100];\n    static string[10] roman_subtractors_str_sub_sub_sub\
    \ = [\"i\", \"x\", \"c\", \"m\", \"i\", \"x\", \"c\"];\n    static long[10] roman_subtractors_value_sub_sub_sub_sub\
    \ = [1, 10, 100, 1000, 1, 10, 100];\n    static string[10] roman_subtractors_str_sub_sub_sub_sub\
    \ = [\"i\", \"x\", \"c\", \"m\", \"i\", \"x\", \"c\"];\n    static long[10] roman_subtractors_value_sub_sub_sub_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsaxe862g.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmpsaxe862g.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsaxe862g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= values[i])\n        {\n\
    \            number -= values[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [ \"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\" ];\n    static string[10] roman_tens\
    \ = [ \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    \ ];\n    static string[10] roman_hundreds = [ \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" ];\n    static string[4] roman_thousands\
    \ = [ \"m\", \"mm\", \"mmm\", \"mmmmm\" ];\n    static string[4] roman_tens_thousands\
    \ = [ \"xm\", \"xxm\", \"xxxm\", \"xlm\" ];\n    static string[4] roman_hundreds_thousands\
    \ = [ \"cm\", \"ccm\", \"cccm\", \"cdm\" ];\n    static string[4] roman_millions\
    \ = [ \"m\", \"mm\", \"mmm\", \"mmmmm\" ];\n    static string[4] roman_tens_millions\
    \ = [ \"xm\", \"xxm\", \"xxxm\", \"xlm\" ];\n    static string[4] roman_hundreds_millions\
    \ = [ \"cm\", \"ccm\", \"cccm\", \"cdm\" ];\n    static string[4] roman_billions\
    \ = [ \"m\", \"mm\", \"mmm\", \"mmmmm\" ];\n    static string[4] roman_tens_billions\
    \ = [ \"xm\", \"xxm\", \"xxxm\", \"xlm\" ];\n    static string[4] roman_hundreds_billions\
    \ = [ \"cm\", \"ccm\", \"cccm\", \"cdm\" ];\n    static string[4] roman_trillions\
    \ = [ \"m\", \"mm\", \"mmm\", \"mmmmm\" ];\n    static string[4] roman_tens_trillions\
    \ = [ \"xm\", \"xxm\", \"xxxm\", \"xlm\" ];\n    static string[4] roman_hundreds_trillions\
    \ = [\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn_sy2m64.d(36): Error: expression expected, not `unittest`

    /tmp/tmpn_sy2m64.d(37): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpn_sy2m64.d(55): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpn_sy2m64.d(55): Error: semicolon expected, not `main`

    /tmp/tmpn_sy2m64.d(55): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_sy2m64.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\n        \"\", \"i\", \"ii\"\
    , \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands = [\n        \"\"\
    , \"m\", \"mm\", \"mmm\"\n    ];\n    if (number > 1000)\n        return \"\"\
    ;\n    result = roman_thousands[number / 1000];\n    number %= 1000;\n    result\
    \ ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~= roman_tens[number\
    \ / 10];\n    number %= 10;\n    result ~= roman_numerals[number];\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptb19tx7l.d(60): Error: found `unittest` when expecting `]`

    /tmp/tmptb19tx7l.d(61): Error: no identifier for declarator `string[4]`

    /tmp/tmptb19tx7l.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb19tx7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_digits = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_symbols\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const long[]\
    \ roman_subtractors = [1L, 10L, 100L];\n    static const string[] roman_subtractor_symbols\
    \ = [\"i\", \"x\", \"c\"];\n    static const long[] roman_subtractor_values =\
    \ [1L, 10L, 100L];\n    static const string[] roman_subtractor_symbols = [\"i\"\
    , \"x\", \"c\"];\n    static const long[] roman_subtractor_values = [1L, 10L,\
    \ 100L];\n    static const string[] roman_subtractor_symbols = [\"i\", \"x\",\
    \ \"c\"];\n    static const long[] roman_subtractor_values = [1L, 10L, 100L];\n\
    \    static const string[] roman_subtractor_symbols = [\"i\", \"x\", \"c\"];\n\
    \    static const long[] roman_subtractor_values = [1L, 10L, 100L];\n    static\
    \ const string[] roman_subtractor_symbols = [\"i\", \"x\", \"c\"];\n    static\
    \ const long[] roman_subtractor_values = [1L, 10L, 100L];\n    static const string[]\
    \ roman_subtractor_symbols = [\"i\", \"x\", \"c\"];\n    static const long[] roman_subtractor_values\
    \ = [1L, 10L, 100L];\n    static const string[] roman_subtractor_symbols = [\"\
    i\", \"x\", \"c\"];\n    static const long[] roman_subtractor_values = [1L, 10L,\
    \ 100L];\n    static const string[] roman_subtractor_symbols = [\"i\", \"x\",\
    \ \"c\"];\n    static const long[] roman_\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmt6reh73.d(40): Error: semicolon expected, not `unittest`

    /tmp/tmpmt6reh73.d(40): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmt6reh73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] roman_values = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ long[] roman_values_sorted = [1, 5, 10, 50, 100, 500, 1000];\n    static string[]\
    \ roman_numerals_sorted = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static string[] roman_numerals_sorted_reversed = [\"m\", \"d\", \"c\", \"\
    l\", \"x\", \"v\", \"i\"];\n    static long[] roman_values_sorted_reversed = [1000,\
    \ 500, 100, 50, 10, 5, 1];\n    static long[] roman_values_sorted_reversed_cumulative\
    \ = [1000, 1500, 1600, 1650, 1660, 1665, 1666];\n    static string[] roman_numerals_sorted_reversed_cumulative\
    \ = [\"m\", \"md\", \"mcd\", \"mcld\", \"mclxd\", \"mclvxd\", \"mclvixd\"];\n\
    \    static string[] roman_numerals_sorted_reversed_cumulative_reversed = [\"\
    d\", \"xd\", \"vxd\", \"lvxd\", \"clvxd\", \"mclvxd\", \"mclvixd\"];\n    static\
    \ long[] roman_values_sorted_reversed_cumulative_reversed = [1, 11, 111, 1111,\
    \ 11111, 111111, 1111111];\n    static long[] roman_values_sorted_reversed_cumulative_reversed_reversed\
    \ = [1, 10, 100, 1000, 10000, 100000, 1000000];\n    static string[] roman_numerals_sorted_reversed_cumulative_reversed_reversed\
    \ = [\"i\", \"xi\", \"cxi\", \"mxcxi\", \"mxcxli\", \"mxcxlvi\", \"mxcxlvii\"\
    ];\n    static string[] r\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpozhyc1rw.d(33): Error: semicolon expected, not `unittest`

    /tmp/tmpozhyc1rw.d(33): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozhyc1rw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const string[] roman_symbols =\
    \ [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const int[] roman_symbol_counts\
    \ = [2, 1, 2, 1, 2, 1, 2];\n    static const int[] roman_symbol_values = [1, 5,\
    \ 10, 50, 100, 500, 1000];\n    static const string[] roman_symbol_strings = [\"\
    i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const int[] roman_symbol_string_lengths\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static const int[] roman_symbol_string_offsets\
    \ = [0, 1, 3, 4, 6, 7, 9];\n    static const int[] roman_symbol_string_indexes\
    \ = [0, 1, 2, 3, 4, 5, 6];\n    static const int[] roman_symbol_string_index_offsets\
    \ = [0, 1, 2, 3, 4, 5, 6];\n    static const int[] roman_symbol_string_index_lengths\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static const int[] roman_symbol_string_index_values\
    \ = [0, 1, 2, 3, 4, 5, 6];\n    static const int[] roman_symbol_string_index_string_lengths\
    \ = [1, 1, 1, 1, 1, 1, 1];\n    static const int[] roman_symbol_string_index_string_offsets\
    \ = [0, 1, 3, 4, 6, 7, 9];\n    static const int[] roman_symbol_string_index_string_indexes\
    \ = [0, 1, 2, 3, 4, 5, 6];\n    static const int[] roman_symbol_string_index_string_index_offsets\
    \ = [0, 1, 2,\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpocmx43z0.d(36): Error: expression expected, not `unittest`

    /tmp/tmpocmx43z0.d(37): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpocmx43z0.d(55): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpocmx43z0.d(55): Error: semicolon expected, not `main`

    /tmp/tmpocmx43z0.d(55): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocmx43z0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10]\
    \ roman_numerals_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\"\
    , \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_numerals_hundreds = [\"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\
    ];\n    static string[10] roman_numerals_thousands = [\"m\", \"mm\", \"mmm\",\
    \ \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_numerals_ten_thousands = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\"\
    , \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_numerals_hundred_thousands\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_numerals_millions = [\"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_numerals_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\"\
    , \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_numerals_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_numerals_billions = [\"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeomt6yen.d(30): Error: unterminated string constant starting at
    /tmp/tmpeomt6yen.d(48)

    /tmp/tmpeomt6yen.d(35): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpeomt6yen.d(35): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpeomt6yen.d(36): Error: found `lii` when expecting `;` following statement

    /tmp/tmpeomt6yen.d(37): Error: found `cli` when expecting `;` following statement

    /tmp/tmpeomt6yen.d(38): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpeomt6yen.d(39): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpeomt6yen.d(40): Error: found `i` when expecting `;` following statement

    /tmp/tmpeomt6yen.d(41): Error: found `iv` when expecting `;` following statement

    /tmp/tmpeomt6yen.d(42): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpeomt6yen.d(43): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10]\
    \ roman_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"];\n    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10]\
    \ roman_thousands = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\", \"x\"];\n    static string[10] roman_tenthousands = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundredthousands = [\"c\", \"cc\", \"ccc\", \"cd\",\
    \ \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_tenmillions = [\"x\", \"xx\", \"xxx\",\
    \ \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundredmillions = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\"\
    , \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_billions = [\"m\", \"\
    mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n   \
    \ static string[10] roman_tenbillions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu5kytr19.d(32): Error: expression expected, not `unittest`

    /tmp/tmpu5kytr19.d(33): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpu5kytr19.d(51): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpu5kytr19.d(51): Error: semicolon expected, not `main`

    /tmp/tmpu5kytr19.d(51): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu5kytr19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string roman_numerals = \"ixcm\";\n    static long[] roman_values\
    \ = [1L, 10L, 100L, 1000L];\n    static string[] roman_subtractives = [\"iv\"\
    , \"xl\", \"cd\", \"m\"];\n    static long[] roman_subtractive_values = [4L, 40L,\
    \ 400L, 4000L];\n    for (size_t i = 0; i < roman_numerals.length; i++) {\n  \
    \      long value = roman_values[i];\n        long subtractive_value = roman_subtractive_values[i];\n\
    \        string subtractive = roman_subtractives[i];\n        while (number >=\
    \ subtractive_value) {\n            result ~= subtractive;\n            number\
    \ -= subtractive_value;\n        }\n        while (number >= value) {\n      \
    \      result ~= roman_numerals[i];\n            number -= value;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd01wswvw.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284ad]

    ??:? void tmpd01wswvw.__unittest_L40_C1() [0x427e34]

    ??:? void tmpd01wswvw.__modtest() [0x428230]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cc67]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bb76]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43049d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43094c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430429]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb4d]

    ??:? runModuleUnitTests [0x42ca3d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428970]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = tuple(\n        tuple(\"i\", 1L),\n     \
    \   tuple(\"v\", 5L),\n        tuple(\"x\", 10L),\n        tuple(\"l\", 50L),\n\
    \        tuple(\"c\", 100L),\n        tuple(\"d\", 500L),\n        tuple(\"m\"\
    , 1000L)\n    );\n    foreach(i; roman_numerals.length - 1 .. 0)\n    {\n    \
    \    auto numeral = roman_numerals[i];\n        auto next_numeral = roman_numerals[i\
    \ - 1];\n        auto numeral_value = numeral[1];\n        auto next_numeral_value\
    \ = next_numeral[1];\n        auto numeral_symbol = numeral[0];\n        auto\
    \ next_numeral_symbol = next_numeral[0];\n        auto numeral_count = number\
    \ / numeral_value;\n        if(numeral_count > 0)\n        {\n            if(numeral_count\
    \ == 4)\n            {\n                result ~= numeral_symbol ~ next_numeral_symbol;\n\
    \            }\n            else\n            {\n                result ~= repeat(numeral_symbol,\
    \ numeral_count);\n            }\n            number -= numeral_value * numeral_count;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp66wmf_r4.d(32): Error: variable `i` cannot be read at compile time

    /tmp/tmp66wmf_r4.d(33): Error: variable `i` cannot be read at compile time

    /tmp/tmp66wmf_r4.d(47): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp66wmf_r4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_symbols\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const long[]\
    \ roman_symbol_values = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const\
    \ string[] roman_symbol_pairs = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"\
    ];\n    static const long[] roman_symbol_pair_values = [4L, 9L, 40L, 90L, 400L,\
    \ 900L];\n    static const string[] roman_symbol_triplets = [\"ivi\", \"ivx\"\
    , \"ixl\", \"ixc\", \"xlc\", \"xcd\", \"cdm\", \"cmm\"];\n    static const long[]\
    \ roman_symbol_triplet_values = [4L, 9L, 40L, 90L, 400L, 900L, 900L, 900L];\n\
    \    static const string[] roman_symbol_quadruplets = [\"iviv\", \"ivix\", \"\
    ivxl\", \"ivxc\", \"ixlv\", \"ixlx\", \"ixxc\", \"xlcv\", \"xlcx\", \"xcdv\",\
    \ \"xcdx\", \"cdmx\", \"cdmm\"];\n    static const long[] roman_symbol_quadruplet_values\
    \ = [4L, 9L, 40L, 90L, 400L, 400L, 400L, 400L, 400L, 400L, 400L, 400L, 400L];\n\
    \    static const string[] roman_symbol_quintuplets = [\"ivivi\", \"ivivx\", \"\
    ivixl\", \"ivixc\", \"ivxlv\", \"ivxlx\", \"ivxxc\", \"ixlvi\", \"ixlvx\", \"\
    ixlxc\", \"ixxcv\", \"ixxcx\", \"xlcvx\", \"xlcxc\", \"xcdvx\nunittest\n{\n  \
    \  alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpshuyt398.d(30): Error: unterminated string constant starting at
    /tmp/tmpshuyt398.d(48)

    /tmp/tmpshuyt398.d(35): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpshuyt398.d(35): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpshuyt398.d(36): Error: found `lii` when expecting `;` following statement

    /tmp/tmpshuyt398.d(37): Error: found `cli` when expecting `;` following statement

    /tmp/tmpshuyt398.d(38): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpshuyt398.d(39): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpshuyt398.d(40): Error: found `i` when expecting `;` following statement

    /tmp/tmpshuyt398.d(41): Error: found `iv` when expecting `;` following statement

    /tmp/tmpshuyt398.d(42): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpshuyt398.d(43): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n   \
    \ string result = \"\";\n    result ~= thousands[number / 1000];\n    result ~=\
    \ hundreds[(number % 1000) / 100];\n    result ~= tens[(number % 100) / 10];\n\
    \    result ~= ones[number % 10];\n    return result;\n}\n/*\nunittest\n{\n  \
    \  alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprk2cshya.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprk2cshya.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"x\", \"xx\", \"xxx\", \"\
    xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    ];\n    static string[4] thousands = [\"m\", \"mm\", \"mmm\", \"mmmmm\"];\n  \
    \  string result = \"\";\n    if (number > 0)\n    {\n        if (number >= 1000)\n\
    \        {\n            result ~= thousands[cast(int)(number / 1000)];\n     \
    \       number %= 1000;\n        }\n        if (number >= 100)\n        {\n  \
    \          result ~= hundreds[cast(int)(number / 100)];\n            number %=\
    \ 100;\n        }\n        if (number >= 10)\n        {\n            result ~=\
    \ tens[cast(int)(number / 10)];\n            number %= 10;\n        }\n      \
    \  if (number > 0)\n        {\n            result ~= digits[cast(int)number];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm6q21rtt.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284dd]

    ??:? void tmpm6q21rtt.__unittest_L49_C1() [0x427e60]

    ??:? void tmpm6q21rtt.__modtest() [0x42825c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cc97]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bba6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43097c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430459]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb7d]

    ??:? runModuleUnitTests [0x42ca6d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[int] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[int] roman_hundreds = [\n        \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[int] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n  \
    \  string result = \"\";\n    if (number > 0) {\n        if (number >= 1000) {\n\
    \            result ~= roman_thousands[number / 1000 - 1];\n            number\
    \ %= 1000;\n        }\n        if (number >= 100) {\n            result ~= roman_hundreds[number\
    \ / 100 - 1];\n            number %= 100;\n        }\n        if (number >= 10)\
    \ {\n            result ~= roman_tens[number / 10 - 1];\n            number %=\
    \ 10;\n        }\n        if (number > 0) {\n            result ~= roman_numerals[number\
    \ - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3_vamdth.d(20): Error: not an associative array initializer

    /tmp/tmp3_vamdth.d(23): Error: not an associative array initializer

    /tmp/tmp3_vamdth.d(26): Error: not an associative array initializer

    /tmp/tmp3_vamdth.d(29): Error: not an associative array initializer

    /tmp/tmp3_vamdth.d(35): Error: cannot implicitly convert expression `number /
    1000L - 1L` of type `long` to `int`

    /tmp/tmp3_vamdth.d(39): Error: cannot implicitly convert expression `number /
    100L - 1L` of type `long` to `int`

    /tmp/tmp3_vamdth.d(43): Error: cannot implicitly convert expression `number /
    10L - 1L` of type `long` to `int`

    /tmp/tmp3_vamdth.d(47): Error: cannot implicitly convert expression `number -
    1L` of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_vamdth.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] romans = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    string result = \"\";\n    result ~= thousands[number / 1000];\n    number\
    \ %= 1000;\n    result ~= hundreds[number / 100];\n    number %= 100;\n    result\
    \ ~= tens[number / 10];\n    number %= 10;\n    result ~= romans[number];\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    auto arabic_numerals\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    foreach(i, roman_numeral;\
    \ roman_numerals)\n    {\n        while(number >= arabic_numerals[i])\n      \
    \  {\n            result ~= roman_numerals[i];\n            number -= arabic_numerals[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    if (number <= 0) return result;\n    if (number > 1000) return\
    \ result;\n    auto roman_numerals = [\n        tuple(1L, \"i\"),\n        tuple(4L,\
    \ \"iv\"),\n        tuple(5L, \"v\"),\n        tuple(9L, \"ix\"),\n        tuple(10L,\
    \ \"x\"),\n        tuple(40L, \"xl\"),\n        tuple(50L, \"l\"),\n        tuple(90L,\
    \ \"xc\"),\n        tuple(100L, \"c\"),\n        tuple(400L, \"cd\"),\n      \
    \  tuple(500L, \"d\"),\n        tuple(900L, \"cm\"),\n        tuple(1000L, \"\
    m\")\n    ];\n    for (auto roman_numeral : roman_numerals) {\n        auto value\
    \ = roman_numeral[0];\n        auto numeral = roman_numeral[1];\n        while\
    \ (number >= value) {\n            result ~= numeral;\n            number -= value;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg2dh9tkt.d(38): Error: no identifier for declarator `roman_numeral`

    /tmp/tmpg2dh9tkt.d(38): Error: expression expected, not `:`

    /tmp/tmpg2dh9tkt.d(38): Error: found `roman_numerals` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg2dh9tkt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number >= 1 && number <= 1000);\n\
    \    return roman_thousands[number / 1000] ~ roman_hundreds[(number / 100) % 10]\
    \ ~ roman_tens[(number / 10) % 10] ~ roman_numerals[number % 10];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\n        \"\", \"i\", \"ii\"\
    , \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands = [\n        \"\"\
    , \"m\", \"mm\", \"mmm\"\n    ];\n    long thousands = number / 1000;\n    long\
    \ hundreds = (number % 1000) / 100;\n    long tens = (number % 100) / 10;\n  \
    \  long ones = number % 10;\n    result ~= roman_thousands[thousands];\n    result\
    \ ~= roman_hundreds[hundreds];\n    result ~= roman_tens[tens];\n    result ~=\
    \ roman_numerals[ones];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ int[int] arabic_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral;\
    \ roman_numerals)\n    {\n        while(number >= arabic_numerals[i])\n      \
    \  {\n            result ~= roman_numeral;\n            number -= arabic_numerals[i];\n\
    \        }\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp074uqc1t.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp074uqc1t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdn9f7btr.d(31): Error: expression expected, not `unittest`

    /tmp/tmpdn9f7btr.d(32): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpdn9f7btr.d(50): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpdn9f7btr.d(50): Error: semicolon expected, not `main`

    /tmp/tmpdn9f7btr.d(50): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdn9f7btr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] nums = [1000L, 900L, 500L, 400L, 100L, 90L, 50L,\
    \ 40L, 10L, 9L, 5L, 4L, 1L];\n    string[] romans = [\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n  \
    \  foreach(i, num; nums)\n    {\n        while(number >= num)\n        {\n   \
    \         result ~= romans[i];\n            number -= num;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_ten_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\",\
    \ \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\",\
    \ \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions = [\n      \
    \  \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\"\n    ];\n    static string[10] roman_hundred_millions = [\n        \"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n \
    \   ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\
    , \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy22kg5lj.d(47): Error: unterminated string constant starting at
    /tmp/tmpy22kg5lj.d(66)

    /tmp/tmpy22kg5lj.d(53): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpy22kg5lj.d(53): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpy22kg5lj.d(54): Error: found `lii` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(55): Error: found `cli` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(56): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(57): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpy22kg5lj.d(58): Error: found `i` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(59): Error: found `iv` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(60): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(61): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, numeral; zip(decimal_numerals, roman_numerals))\n\
    \    {\n        while(number >= numeral[0])\n        {\n            result ~=\
    \ numeral[1];\n            number -= numeral[0];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphfb8yfpz.d(23): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphfb8yfpz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic = [1000L, 900L,\
    \ 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result =\
    \ \"\";\n    foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n\
    \        {\n            number -= arabic[i];\n            result ~= r;\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\",\
    \ \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    if (number > 1000)\n        return \"\
    \";\n    result ~= roman_thousands[number / 1000];\n    number %= 1000;\n    result\
    \ ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~= roman_tens[number\
    \ / 10];\n    number %= 10;\n    result ~= roman_numerals[number];\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] roman_values_sorted\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_numerals_sorted\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ roman_numerals_sorted_reversed = [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\",\
    \ \"i\"];\n    static const long[] roman_values_sorted_reversed = [1000L, 500L,\
    \ 100L, 50L, 10L, 5L, 1L];\n    static const long[] roman_values_sorted_reversed_minus_one\
    \ = [500L, 100L, 50L, 10L, 5L, 1L, 0L];\n    static const long[] roman_values_sorted_reversed_minus_two\
    \ = [100L, 50L, 10L, 5L, 1L, 0L, 0L];\n    static const long[] roman_values_sorted_reversed_minus_three\
    \ = [50L, 10L, 5L, 1L, 0L, 0L, 0L];\n    static const long[] roman_values_sorted_reversed_minus_four\
    \ = [10L, 5L, 1L, 0L, 0L, 0L, 0L];\n    static const long[] roman_values_sorted_reversed_minus_five\
    \ = [5L, 1L, 0L, 0L, 0L, 0L, 0L];\n    static const long[] roman_values_sorted_reversed_minus_six\
    \ = [1L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static const long[] roman_values_sorted_reversed_minus_seven\
    \ = [0L, 0L, 0L, 0L, 0L,\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyum5l1c_.d(33): Error: expression expected, not `unittest`

    /tmp/tmpyum5l1c_.d(34): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpyum5l1c_.d(52): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpyum5l1c_.d(52): Error: semicolon expected, not `main`

    /tmp/tmpyum5l1c_.d(52): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyum5l1c_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptb19tx7l.d(60): Error: found `unittest` when expecting `]`

    /tmp/tmptb19tx7l.d(61): Error: no identifier for declarator `string[4]`

    /tmp/tmptb19tx7l.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb19tx7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number >= 1 && number <= 1000);\n\
    \    string result = \"\";\n    result ~= roman_thousands[number / 1000];\n  \
    \  number %= 1000;\n    result ~= roman_hundreds[number / 100];\n    number %=\
    \ 100;\n    result ~= roman_tens[number / 10];\n    number %= 10;\n    result\
    \ ~= roman_numerals[number];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[cast(int)(number\
    \ / 1000)] ~\n           roman_hundreds[cast(int)((number / 100) % 10)] ~\n  \
    \         roman_tens[cast(int)((number / 10) % 10)] ~\n           roman_digits[cast(int)(number\
    \ % 10)];\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n  \
    \  assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzrgkglfh.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzrgkglfh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    long num = number;\n    while (num > 0)\n    {\n        if (num\
    \ >= 1000)\n        {\n            result ~= \"m\";\n            num -= 1000;\n\
    \        }\n        else if (num >= 900)\n        {\n            result ~= \"\
    cm\";\n            num -= 900;\n        }\n        else if (num >= 500)\n    \
    \    {\n            result ~= \"d\";\n            num -= 500;\n        }\n   \
    \     else if (num >= 400)\n        {\n            result ~= \"cd\";\n       \
    \     num -= 400;\n        }\n        else if (num >= 100)\n        {\n      \
    \      result ~= \"c\";\n            num -= 100;\n        }\n        else if (num\
    \ >= 90)\n        {\n            result ~= \"xc\";\n            num -= 90;\n \
    \       }\n        else if (num >= 50)\n        {\n            result ~= \"l\"\
    ;\n            num -= 50;\n        }\n        else if (num >= 40)\n        {\n\
    \            result ~= \"xl\";\n            num -= 40;\n        }\n        else\
    \ if (num >= 10)\n        {\n            result ~= \"x\";\n            num -=\
    \ 10;\n        }\n        else if (num >= 9)\n        {\n            result ~=\
    \ \"ix\";\n            num -= 9;\n        }\n        else if (num >= 5)\n    \
    \    {\n            result ~= \"v\";\n            num -= 5;\n        }\n     \
    \   else if (num >= 4)\n        {\n            result ~= \"iv\";\n           \
    \ num -= 4;\n        }\n        else if (num >= 1)\n        {\n            result\
    \ ~= \"i\";\n            num -= 1;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    int i = values.length - 1;\n    while (number > 0) {\n        int\
    \ v = values[i];\n        if (number >= v) {\n            result ~= numerals[i];\n\
    \            number -= v;\n        } else {\n            i--;\n        }\n   \
    \ }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl4m86ffz.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl4m86ffz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv;\n    import std.array;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.stdio;\n    import std.traits;\n    import std.meta;\n    import std.typecons;\n\
    \    import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.typecons;\n    import std.math;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.typecons;\n    import std.math;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.typecons;\n    import std.math;\n \
    \   import std.range;\n    import std.algorithm;\n    import std.typecons;\n \
    \   import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.typecons;\n    import std.math;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.typecons;\n    import std.math;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.typecons;\n    import std.math;\n \
    \   import std.range;\n    import std.algorithm;\n    import std.typecons;\n \
    \   import std.math;\n    import std.range;\n    import std.algorithm;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.typecons;\n    import std.math;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.typecons;\n    import std.math;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.typecons;\n    import std.math;\n\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1oz13xmg.d(89): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1oz13xmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] tens = [\n\
    \        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[10] hundreds = [\n        \"\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[4] thousands = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    assert(number\
    \ > 0 && number <= 1000);\n    return thousands[number / 1000] ~\n           hundreds[(number\
    \ / 100) % 10] ~\n           tens[(number / 10) % 10] ~\n           digits[number\
    \ % 10];\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n   \
    \ assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\");\n\
    \    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\"\
    );\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) == \"i\");\n\
    \    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) == \"xliii\"\
    );\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L) == \"xciv\"\
    );\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L) ==\
    \ \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2iu2t6l.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2iu2t6l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    static assert(roman_numerals.length\
    \ == numbers.length);\n    static assert(numbers[0] == 1000L);\n    static assert(numbers[numbers.length\
    \ - 1] == 1L);\n    static assert(numbers[numbers.length - 2] == 4L);\n    static\
    \ assert(numbers[numbers.length - 3] == 5L);\n    static assert(numbers[numbers.length\
    \ - 4] == 9L);\n    static assert(numbers[numbers.length - 5] == 10L);\n    static\
    \ assert(numbers[numbers.length - 6] == 40L);\n    static assert(numbers[numbers.length\
    \ - 7] == 50L);\n    static assert(numbers[numbers.length - 8] == 90L);\n    static\
    \ assert(numbers[numbers.length - 9] == 100L);\n    static assert(numbers[numbers.length\
    \ - 10] == 400L);\n    static assert(numbers[numbers.length - 11] == 500L);\n\
    \    static assert(numbers[numbers.length - 12] == 900L);\n    static assert(numbers[numbers.length\
    \ - 13] == 1000L);\n    static assert(roman_numerals[0] == \"m\");\n    static\
    \ assert(roman_numerals[roman_numerals.length - 1] == \"i\");\n    static assert(roman_numerals[roman_numerals.length\
    \ - 2] == \"iv\");\n    static assert(roman_numerals[roman_numerals.length - 3]\
    \ == \"v\");\n    static assert(roman_numerals[roman_numerals.length - 4] == \"\
    ix\");\n    static assert(roman_numerals[roman_numer\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2rcicsiz.d(43): Error: found `unittest` when expecting `,`

    /tmp/tmp2rcicsiz.d(62): Error: found `void` when expecting `,`

    /tmp/tmp2rcicsiz.d(62): Error: found `{` when expecting `,`

    /tmp/tmp2rcicsiz.d(62): Error: expression expected, not `}`

    /tmp/tmp2rcicsiz.d(62): Error: found `End of File` when expecting `,`

    /tmp/tmp2rcicsiz.d(62): Error: found `End of File` when expecting `]`

    /tmp/tmp2rcicsiz.d(62): Error: found `End of File` when expecting `)`

    /tmp/tmp2rcicsiz.d(62): Error: found `End of File` when expecting `;`

    /tmp/tmp2rcicsiz.d(62): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2rcicsiz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, num; numbers)\n    {\n        while(number >= num)\n\
    \        {\n            result ~= roman_numerals[i];\n            number -= num;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_digits[number % 10];\n}\n/*\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1fxm2bbt.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1fxm2bbt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] divisors = [1, 10, 100,\
    \ 1000];\n    static const int[] multipliers = [1, 10, 100, 1000];\n    static\
    \ const int[] subtractors = [1, 10, 100, 1000];\n    static const int[] subtractor_values\
    \ = [1, 10, 100, 1000];\n    static const int[] subtractor_multipliers = [1, 10,\
    \ 100, 1000];\n    static const int[] subtractor_divisors = [1, 10, 100, 1000];\n\
    \    static const int[] subtractor_indices = [1, 10, 100, 1000];\n    static const\
    \ int[] subtractor_multiplier_indices = [1, 10, 100, 1000];\n    static const\
    \ int[] subtractor_divisor_indices = [1, 10, 100, 1000];\n    static const int[]\
    \ subtractor_value_indices = [1, 10, 100, 1000];\n    static const int[] subtractor_value_multipliers\
    \ = [1, 10, 100, 1000];\n    static const int[] subtractor_value_divisors = [1,\
    \ 10, 100, 1000];\n    static const int[] subtractor_value_multiplier_indices\
    \ = [1, 10, 100, 1000];\n    static const int[] subtractor_value_divisor_indices\
    \ = [1, 10, 100, 1000];\n    static const int[] subtractor_value_multiplier_divisors\
    \ = [1, 10, 100, 1000];\n    static const int[] subtractor_value_multiplier_divisor_indices\
    \ = [1, 10, 100, 1000];\n    static const int[] subtractor_value_multiplier_divisor_multipliers\
    \ = [1, 10, 100, 1000];\n    static const int[] subtractor_value_multiplier_divisor_divisors\
    \ = [1, 10, 100, 1000];\n    static const int[] subtractor_value_multiplier_divisor_multiplier_indices\
    \ = [1, 10, 100, 1000];\n    static const int[]\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz91gm91r.d(42): Error: no identifier for declarator `int[]`

    /tmp/tmpz91gm91r.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz91gm91r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\",\
    \ \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    if (number > 0) {\n        result = roman_thousands[number\
    \ / 1000];\n        result ~= roman_hundreds[(number % 1000) / 100];\n       \
    \ result ~= roman_tens[(number % 100) / 10];\n        result ~= roman_numerals[number\
    \ % 10];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\"\
    , \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static\
    \ string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    assert(number >= 1 && number <= 1000);\n    return\
    \ roman_thousands[number / 1000] ~ roman_hundreds[(number / 100) % 10] ~ roman_tens[(number\
    \ / 10) % 10] ~ roman_digits[number % 10];\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] decimal_order = [0,\
    \ 2, 4, 6];\n    static const int[] subtractive_order = [1, 3, 5];\n    static\
    \ const int[] subtractive_values = [1, 10, 100];\n    static const string[] subtractive_symbols\
    \ = [\"i\", \"x\", \"c\"];\n    static const string[] subtractive_symbols_5 =\
    \ [\"v\", \"l\", \"d\"];\n    static const string[] subtractive_symbols_10 = [\"\
    x\", \"c\", \"m\"];\n    static const string[] subtractive_symbols_50 = [\"l\"\
    , \"d\", \"m\"];\n    static const string[] subtractive_symbols_100 = [\"c\",\
    \ \"m\", \"m\"];\n    static const string[] subtractive_symbols_500 = [\"d\",\
    \ \"m\", \"m\"];\n    static const string[] subtractive_symbols_1000 = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] subtractive_symbols_5000 = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] subtractive_symbols_10000 = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] subtractive_symbols_50000 = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] subtractive_symbols_100000 = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] subtractive_symbols_500000 = [\"m\"\
    , \"m\", \"m\"];\n    static const string[] subtractive_symbols_1000000 = [\"\
    m\", \"m\", \"m\"];\n    static const string[] subtractive_symbols_5000000 = [\"\
    m\", \"m\", \"m\"];\n    static const string[] subtractive_symbols_10000000 =\
    \ [\"m\", \"m\", \"m\"];\n    static const string[] subtractive_symbols_50000000\
    \ = [\"m\", \"m\", \"m\"];\n    static const string[] subtractive\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyfwto0tj.d(42): Error: semicolon expected, not `unittest`

    /tmp/tmpyfwto0tj.d(42): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyfwto0tj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static long[] arabic = [ 1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result = \"\";\n  \
    \  foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n        {\n\
    \            number -= arabic[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2efk11mu.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2efk11mu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[9] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[9] roman_tens = [\"x\", \"xx\", \"\
    xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[3]\
    \ roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[3] roman_thousands = [\"m\", \"mm\", \"mmm\"\
    ];\n    static string[4] roman_order = [\"ones\", \"tens\", \"hundreds\", \"thousands\"\
    ];\n    static long[4] roman_divisors = [1, 10, 100, 1000];\n    static long[4]\
    \ roman_max = [9, 99, 999, 1000];\n    static long[4] roman_min = [0, 10, 100,\
    \ 1000];\n    static string[4] roman_numerals_arr = [roman_numerals, roman_tens,\
    \ roman_hundreds, roman_thousands];\n    static string[4] roman_order_arr = [roman_order,\
    \ roman_order, roman_order, roman_order];\n    static long[4] roman_divisors_arr\
    \ = [roman_divisors, roman_divisors, roman_divisors, roman_divisors];\n    static\
    \ long[4] roman_max_arr = [roman_max, roman_max, roman_max, roman_max];\n    static\
    \ long[4] roman_min_arr = [roman_min, roman_min, roman_min, roman_min];\n    static\
    \ string[4] roman_numerals_arr_arr = [roman_numerals_arr, roman_numerals_arr,\
    \ roman_numerals_arr, roman_numerals_arr];\n    static string[4] roman_order_arr_arr\
    \ = [roman_\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgsxu8lhd.d(35): Error: comma expected separating array initializers,
    not `unittest`

    /tmp/tmpgsxu8lhd.d(36): Error: semicolon expected, not `{`

    /tmp/tmpgsxu8lhd.d(54): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgsxu8lhd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10]\
    \ roman_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"];\n    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10]\
    \ roman_thousands = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\", \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_millions = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_billions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_billions = [\"x\", \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjr6uf0hb.d(31): Error: unterminated string constant starting at
    /tmp/tmpjr6uf0hb.d(49)

    /tmp/tmpjr6uf0hb.d(36): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpjr6uf0hb.d(36): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpjr6uf0hb.d(37): Error: found `lii` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(38): Error: found `cli` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(39): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(40): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpjr6uf0hb.d(41): Error: found `i` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(42): Error: found `iv` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(43): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpjr6uf0hb.d(44): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] tens = [\n\
    \        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[10] hundreds = [\n        \"\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[4] thousands = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    assert(number\
    \ >= 1 && number <= 1000);\n    string result = \"\";\n    result ~= thousands[number\
    \ / 1000];\n    number %= 1000;\n    result ~= hundreds[number / 100];\n    number\
    \ %= 100;\n    result ~= tens[number / 10];\n    number %= 10;\n    result ~=\
    \ digits[number];\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    string result = \"\";\n\
    \    while (number > 0) {\n        auto digit = number % 10;\n        result =\
    \ roman_numerals[digit] ~ result;\n        number /= 10;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2_69g1ox.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42825d]

    ??:? void tmp2_69g1ox.__unittest_L31_C1() [0x427be4]

    ??:? void tmp2_69g1ox.__modtest() [0x427fe0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c0c3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42afd2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ffa1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430450]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ff2d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42afa9]

    ??:? runModuleUnitTests [0x42be99]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428720]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [ 1, 5, 10, 50, 100, 500, 1000 ];\n    static const long[] roman_subtractors\
    \ = [ 1, 10, 100 ];\n    static const string[] roman_subtractors_str = [ \"i\"\
    , \"x\", \"c\" ];\n    static const string[] roman_subtractors_str_5 = [ \"v\"\
    , \"l\", \"d\" ];\n    static const string[] roman_subtractors_str_10 = [ \"x\"\
    , \"c\", \"m\" ];\n    static const string[] roman_subtractors_str_50 = [ \"l\"\
    , \"d\", \"m\" ];\n    static const string[] roman_subtractors_str_100 = [ \"\
    c\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_500 = [\
    \ \"d\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_1000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_5000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_10000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_50000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_100000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_500000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_1000000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_5000000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string[] roman_subtractors_str_10000000\
    \ = [ \"m\", \"m\", \"m\" ];\n    static const string\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5xbomddk.d(39): Error: no identifier for declarator `string`

    /tmp/tmp5xbomddk.d(39): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5xbomddk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    if (number < 1 || number > 1000)\n        return result;\n    auto\
    \ roman_numerals = tuple(\n        tuple('i', 'v', 'x'),\n        tuple('x', 'l',\
    \ 'c'),\n        tuple('c', 'd', 'm'),\n        tuple('m', 'v', 'x')\n    );\n\
    \    int i = 0;\n    while (number > 0) {\n        int digit = number % 10;\n\
    \        number /= 10;\n        if (digit == 0) {\n            i++;\n        \
    \    continue;\n        }\n        if (digit < 4) {\n            result = repeat(roman_numerals[i][0],\
    \ digit) ~ result;\n        } else if (digit == 4) {\n            result = roman_numerals[i][0]\
    \ ~ roman_numerals[i][1] ~ result;\n        } else if (digit == 5) {\n       \
    \     result = roman_numerals[i][1] ~ result;\n        } else if (digit < 9) {\n\
    \            result = roman_numerals[i][1] ~ repeat(roman_numerals[i][0], digit\
    \ - 5) ~ result;\n        } else {\n            result = roman_numerals[i][0]\
    \ ~ roman_numerals[i][2] ~ result;\n        }\n        i++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj8fh8ewd.d(38): Error: undefined identifier `repeat`

    /tmp/tmpj8fh8ewd.d(40): Error: variable `i` cannot be read at compile time

    /tmp/tmpj8fh8ewd.d(40): Error: variable `i` cannot be read at compile time

    /tmp/tmpj8fh8ewd.d(40): Error: incompatible types for `(cast(int)roman_numerals.__expand_field_0.__expand_field_0)
    ~ (cast(int)roman_numerals.__expand_field_0.__expand_field_1)`: both operands
    are of type `int`

    /tmp/tmpj8fh8ewd.d(42): Error: variable `i` cannot be read at compile time

    /tmp/tmpj8fh8ewd.d(44): Error: variable `i` cannot be read at compile time

    /tmp/tmpj8fh8ewd.d(44): Error: undefined identifier `repeat`

    /tmp/tmpj8fh8ewd.d(46): Error: variable `i` cannot be read at compile time

    /tmp/tmpj8fh8ewd.d(46): Error: variable `i` cannot be read at compile time

    /tmp/tmpj8fh8ewd.d(46): Error: incompatible types for `(cast(int)roman_numerals.__expand_field_0.__expand_field_0)
    ~ (cast(int)roman_numerals.__expand_field_0.__expand_field_2)`: both operands
    are of type `int`

    Failed: ["dmd", "-unittest", "'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ immutable int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static immutable string[] symbols = [\"i\", \"iv\", \"v\", \"ix\", \"x\"\
    , \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    static immutable\
    \ int[] divisors = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n \
    \   static immutable string[] roman_symbols = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static\
    \ immutable string[] roman_symbols_lower = [\"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static immutable\
    \ string[] roman_symbols_upper = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\"\
    , \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n    static immutable string[]\
    \ roman_symbols_title = [\"M\", \"Cm\", \"D\", \"Cd\", \"C\", \"Xc\", \"L\", \"\
    Xl\", \"X\", \"Ix\", \"V\", \"Iv\", \"I\"];\n    static immutable string[] roman_symbols_alternate\
    \ = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\"\
    , \"V\", \"IV\", \"I\"];\n    static immutable string[] roman_symbols_alternate_lower\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"];\n    static immutable string[] roman_symbols_alternate_upper\
    \ = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfn88o5d7.d(29): Error: unterminated string constant starting at
    /tmp/tmpfn88o5d7.d(47)

    /tmp/tmpfn88o5d7.d(34): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpfn88o5d7.d(34): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpfn88o5d7.d(35): Error: found `lii` when expecting `;` following statement

    /tmp/tmpfn88o5d7.d(36): Error: found `cli` when expecting `;` following statement

    /tmp/tmpfn88o5d7.d(37): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpfn88o5d7.d(38): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpfn88o5d7.d(39): Error: found `i` when expecting `;` following statement

    /tmp/tmpfn88o5d7.d(40): Error: found `iv` when expecting `;` following statement

    /tmp/tmpfn88o5d7.d(41): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpfn88o5d7.d(42): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    string roman_numeral;\n    if (number\
    \ <= 0 || number > 1000)\n    {\n        return \"\";\n    }\n    roman_numeral\
    \ = roman_thousands[number / 1000];\n    number %= 1000;\n    roman_numeral ~=\
    \ roman_hundreds[number / 100];\n    number %= 100;\n    roman_numeral ~= roman_tens[number\
    \ / 10];\n    number %= 10;\n    roman_numeral ~= roman_numerals[number];\n  \
    \  return roman_numeral;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static const string roman_numerals = \"ivxlcdm\";\n    static const\
    \ int[] values = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] decimal_values\
    \ = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    static const string[] roman_values = [\"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n   \
    \ static const string[] roman_tens = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static const string[] roman_hundreds =\
    \ [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n\
    \    static const string[] roman_thousands = [\"m\", \"mm\", \"mmm\", \"mv\",\
    \ \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"];\n    static const string[] roman_ten_thousands\
    \ = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    ];\n    static const string[] roman_hundred_thousands = [\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static const string[]\
    \ roman_millions = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"\
    vmmm\", \"mx\"];\n    static const string[] roman_ten_millions = [\"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static const\
    \ string[] roman_hundred_millions = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\"];\n    static const string[] roman_billions =\
    \ [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"v\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3d32ulta.d(33): Error: unterminated string constant starting at
    /tmp/tmp3d32ulta.d(51)

    /tmp/tmp3d32ulta.d(38): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmp3d32ulta.d(38): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmp3d32ulta.d(39): Error: found `lii` when expecting `;` following statement

    /tmp/tmp3d32ulta.d(40): Error: found `cli` when expecting `;` following statement

    /tmp/tmp3d32ulta.d(41): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmp3d32ulta.d(42): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmp3d32ulta.d(43): Error: found `i` when expecting `;` following statement

    /tmp/tmp3d32ulta.d(44): Error: found `iv` when expecting `;` following statement

    /tmp/tmp3d32ulta.d(45): Error: found `xliii` when expecting `;` following statement

    /tmp/tmp3d32ulta.d(46): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv : to;\n    import std.string : toLower;\n    import std.algorithm :\
    \ map;\n    import std.range : iota;\n    import std.array : array;\n    import\
    \ std.math : ceil;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n    import std.typecons : tuple;\n\
    \    import std.typecons : tuple;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : tuple;\n   \nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf6oo179z.d(72): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf6oo179z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, val; values)\n    {\n        while(number >= val)\n        {\n\
    \            result ~= roman_numerals[i];\n            number -= val;\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] decimal_values\
    \ = [1L, 10L, 100L, 1000L];\n    static const string[] roman_numerals_decimal\
    \ = [\"i\", \"x\", \"c\", \"m\"];\n    static const string[] roman_numerals_subtractive\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const string[]\
    \ roman_numerals_additive = [\"ii\", \"iii\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"xx\", \"xxx\", \"l\", \"li\", \"lii\", \"liii\", \"lv\", \"lvi\", \"lvii\"\
    , \"lviii\", \"lxx\", \"lxxi\", \"lxxii\", \"lxxiii\", \"lxxiv\", \"lxxv\", \"\
    lxxvi\", \"lxxvii\", \"lxxviii\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\"\
    , \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\"\
    , \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\"\
    , \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\"\
    , \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\"\
    , \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\"\
    , \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\"\
    , \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\", \"lxxx\"\
    , \"lxxx\", \"lxxx\", \"lxxx\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp19bav0x.d(25): Error: unterminated string constant starting at
    /tmp/tmpp19bav0x.d(43)

    /tmp/tmpp19bav0x.d(30): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpp19bav0x.d(30): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpp19bav0x.d(31): Error: found `lii` when expecting `;` following statement

    /tmp/tmpp19bav0x.d(32): Error: found `cli` when expecting `;` following statement

    /tmp/tmpp19bav0x.d(33): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpp19bav0x.d(34): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpp19bav0x.d(35): Error: found `i` when expecting `;` following statement

    /tmp/tmpp19bav0x.d(36): Error: found `iv` when expecting `;` following statement

    /tmp/tmpp19bav0x.d(37): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpp19bav0x.d(38): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] divisors = [1L,\
    \ 10L, 100L, 1000L];\n    static const long[] multipliers = [1L, 10L, 100L, 1000L];\n\
    \    static const long[] subtractors = [1L, 10L, 100L, 1000L];\n    static const\
    \ long[] subtractor_multipliers = [1L, 2L, 2L, 4L];\n    static const long[] subtractor_divisors\
    \ = [1L, 10L, 100L, 1000L];\n    static const long[] subtractor_indices = [1L,\
    \ 2L, 2L, 4L];\n    static const long[] divisor_indices = [0L, 2L, 4L, 6L];\n\
    \    static const long[] multiplier_indices = [0L, 2L, 4L, 6L];\n    static const\
    \ long[] subtractor_multiplier_indices = [0L, 2L, 2L, 4L];\n    static const long[]\
    \ subtractor_divisor_indices = [0L, 2L, 4L, 6L];\n    static const long[] subtractor_index_indices\
    \ = [0L, 2L, 2L, 4L];\n    static const long[] divisor_index_indices = [0L, 2L,\
    \ 4L, 6L];\n    static const long[] multiplier_index_indices = [0L, 2L, 4L, 6L];\n\
    \    static const long[] subtractor_multiplier_index_indices = [0L, 2L, 2L, 4L];\n\
    \    static const long[] subtractor_divisor_index_indices = [0L, 2L, 4L, 6L];\n\
    \    static const long[] subtractor_index_index_indices = [0L, 2L, 2L, 4L];\n\
    \    static const long[] divisor_index_index_indices = [0L, 2L, 4L, 6L];\n   \
    \ static const long[] multiplier_index_\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppa36jsr_.d(40): Error: semicolon expected, not `unittest`

    /tmp/tmppa36jsr_.d(40): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppa36jsr_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"\
    , \"v\", \"x\", \"l\"];\n    string result = \"\";\n    long num = number;\n \
    \   long digit = 0;\n    long i = 0;\n    while (num > 0) {\n        digit = num\
    \ % 10;\n        num /= 10;\n        if (digit == 0) {\n            i += 2;\n\
    \            continue;\n        }\n        if (digit <= 3) {\n            result\
    \ = repeat(roman_numerals[i], digit) ~ result;\n        } else if (digit == 4)\
    \ {\n            result = roman_numerals[i] ~ roman_numerals[i + 1] ~ result;\n\
    \        } else if (digit <= 8) {\n            result = roman_numerals[i + 1]\
    \ ~ repeat(roman_numerals[i], digit - 5) ~ result;\n        } else {\n       \
    \     result = roman_numerals[i] ~ roman_numerals[i + 2] ~ result;\n        }\n\
    \        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpredgi2u1.d(33): Error: undefined identifier `repeat`

    /tmp/tmpredgi2u1.d(37): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpredgi2u1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ for (size_t i = 0; i < roman.length; i++) {\n        while (number >= decimal[i])\
    \ {\n            number -= decimal[i];\n            result ~= roman[i];\n    \
    \    }\n    }\n    return result;\n}\n/*\n    Given a string, return a new string\
    \ with the reversed order of characters.\n    Restrictions: 1 <= str.length <=\
    \ 1000\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphq4_mapv.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphq4_mapv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number >= 1 && number <= 1000);\n    string result\
    \ = \"\";\n    result ~= roman_thousands[number / 1000];\n    number %= 1000;\n\
    \    result ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~=\
    \ roman_tens[number / 10];\n    number %= 10;\n    result ~= roman_digits[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number > 0) {\n       \
    \ if (number >= 1000) {\n            result ~= roman_thousands[cast(int)(number\
    \ / 1000) - 1];\n            number %= 1000;\n        }\n        if (number >=\
    \ 100) {\n            result ~= roman_hundreds[cast(int)(number / 100) - 1];\n\
    \            number %= 100;\n        }\n        if (number >= 10) {\n        \
    \    result ~= roman_tens[cast(int)(number / 10) - 1];\n            number %=\
    \ 10;\n        }\n        if (number > 0) {\n            result ~= roman_numerals[cast(int)number\
    \ - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ roman;\n    static string[10] roman_numerals = [\n        \"i\", \"ii\", \"\
    iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[10] roman_thousands = [\n        \"\
    m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n\
    \    ];\n    static string[10] roman_ten_thousands = [\n        \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n \
    \   static string[10] roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static\
    \ string[10] roman_millions = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\"\
    , \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundred_millions = [\n  \
    \      \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"\n    ];\n    static string[10] roman_billions = [\n        \"m\", \"\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvc2cildt.d(48): Error: unterminated string constant starting at
    /tmp/tmpvc2cildt.d(67)

    /tmp/tmpvc2cildt.d(54): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpvc2cildt.d(54): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpvc2cildt.d(55): Error: found `lii` when expecting `;` following statement

    /tmp/tmpvc2cildt.d(56): Error: found `cli` when expecting `;` following statement

    /tmp/tmpvc2cildt.d(57): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpvc2cildt.d(58): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpvc2cildt.d(59): Error: found `i` when expecting `;` following statement

    /tmp/tmpvc2cildt.d(60): Error: found `iv` when expecting `;` following statement

    /tmp/tmpvc2cildt.d(61): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpvc2cildt.d(62): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tenthousands = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_hundredthousands\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_millions = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static\
    \ string[4] roman_tenmillions = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n\
    \    ];\n    static string[4] roman_hundredmillions = [\n        \"m\", \"mm\"\
    , \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_billions = [\n       \
    \ \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tenbillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_hundredbillions = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n\
    \    static string[4] roman_trillions = [\n        \"m\", \"mm\", \"mmm\", \"\
    mmmm\"\n    ];\n    static string[4] roman_tentrillions = [\n        \"m\", \"\
    mm\", \"mmm\", \"mmmm\"\n    ];\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqi916bp.d(62): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqi916bp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] numbers = [1000L,\
    \ 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppfgg984i.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppfgg984i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.algorithm : map, joiner;\n    import std.array : array;\n    import std.conv\
    \ : to;\n    import std.range : iota;\n    import std.typecons : tuple;\n    import\
    \ std.math : ceil;\n    import std.string : repeat;\n    import std.typecons :\
    \ tuple;\n    import std.algorithm : map;\n    import std.array : array;\n   \
    \ import std.conv : to;\n    import std.range : iota;\n    import std.math : ceil;\n\
    \    import std.string : repeat;\n    import std.typecons : tuple;\n    import\
    \ std.algorithm : map;\n    import std.array : array;\n    import std.conv : to;\n\
    \    import std.range : iota;\n    import std.math : ceil;\n    import std.string\
    \ : repeat;\n    import std.typecons : tuple;\n    import std.algorithm : map;\n\
    \    import std.array : array;\n    import std.conv : to;\n    import std.range\
    \ : iota;\n    import std.math : ceil;\n    import std.string : repeat;\n    import\
    \ std.typecons : tuple;\n    import std.algorithm : map;\n    import std.array\
    \ : array;\n    import std.conv : to;\n    import std.range : iota;\n    import\
    \ std.math : ceil;\n    import std.string : repeat;\n    import std.typecons :\
    \ tuple;\n    import std.algorithm : map;\n    import std.array : array;\n   \
    \ import std.conv : to;\n    import std.range : iota;\n    import std.math : ceil;\n\
    \    import std.string : repeat;\n    import std.typecons : tuple;\n    import\
    \ std.algorithm : map;\n    import std.array : array;\n    import std.conv : to;\n\
    \    import std.range : iota;\n    import std.math : ceil;\n    import std.string\
    \ : repeat;\n    import std.typecons : tuple;\n    import std.algorithm : map;\n\
    \    import std.array : array;\n    import std.conv : to;\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr2gkxqet.d(73): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr2gkxqet.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\",\
    \ \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_thousands\
    \ = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_thousands\
    \ = [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_millions =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_millions = [\"\
    \", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_millions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_billions = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_billions = [\"\"\
    , \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_billions = [\"\
    \", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_trillions = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_trillions = [\"\",\
    \ \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_trillions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_quadrillion =\
    \ [\"\", \"m\", \"mm\", \"mmm\"]\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7jm8n0q4.d(37): Error: semicolon expected, not `unittest`

    /tmp/tmp7jm8n0q4.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7jm8n0q4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    for (size_t i = 0; i < roman_numerals.length; i++)\
    \ \n    {\n        while (number >= decimal_numerals[i]) \n        {\n       \
    \     number -= decimal_numerals[i];\n            result ~= roman_numerals[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] decimal_order = [0,\
    \ 2, 4, 6];\n    static const int[] subtractive_order = [1, 3, 5];\n    static\
    \ const int[] subtractive_values = [4, 9, 40, 90, 400, 900];\n    static const\
    \ int[] subtractive_indices = [0, 2, 4, 5, 5, 5];\n    static const int[] subtractive_lengths\
    \ = [1, 1, 2, 2, 3, 3];\n    static const int[] subtractive_offsets = [0, 0, 1,\
    \ 1, 2, 2];\n    static const int[] subtractive_repeats = [1, 1, 1, 1, 1, 1];\n\
    \    static const int[] subtractive_repeats_2 = [1, 1, 1, 2, 1, 1];\n    static\
    \ const int[] subtractive_repeats_3 = [1, 1, 1, 1, 1, 2];\n    static const int[]\
    \ subtractive_repeats_4 = [1, 1, 1, 1, 1, 1];\n    static const int[] subtractive_repeats_5\
    \ = [1, 1, 1, 1, 1, 1];\n    static const int[] subtractive_repeats_6 = [1, 1,\
    \ 1, 1, 1, 1];\n    static const int[] subtractive_repeats_7 = [1, 1, 1, 1, 1,\
    \ 1];\n    static const int[] subtractive_repeats_8 = [1, 1, 1, 1, 1, 1];\n  \
    \  static const int[] subtractive_repeats_9 = [1, 1, 1, 1, 1, 1];\n    static\
    \ const int[] subtractive_repeats_10 = [1, 1, 1, 1, 1, 1];\n    static const int[]\
    \ subtractive_repeats_11 = [1, 1, 1, 1, 1, 1];\n    static const int[] subtractive_repeats_12\
    \ = [1, 1, 1, 1, 1, 1];\n    static const int[] subtractive_repe\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq_n7kw6x.d(41): Error: semicolon expected, not `unittest`

    /tmp/tmpq_n7kw6x.d(41): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_n7kw6x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] digits = [0, 0, 0, 0,\
    \ 0, 0, 0];\n    static const int[] numeral_counts = [0, 0, 0, 0, 0, 0, 0];\n\
    \    static const int[] numeral_values = [0, 0, 0, 0, 0, 0, 0];\n    static const\
    \ string[] numerals = [\"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n    static\
    \ const string[] roman_numerals_reversed = [\"m\", \"d\", \"c\", \"l\", \"x\"\
    , \"v\", \"i\"];\n    static const int[] values_reversed = [1000, 500, 100, 50,\
    \ 10, 5, 1];\n    static const int[] digits_reversed = [0, 0, 0, 0, 0, 0, 0];\n\
    \    static const int[] numeral_counts_reversed = [0, 0, 0, 0, 0, 0, 0];\n   \
    \ static const int[] numeral_values_reversed = [0, 0, 0, 0, 0, 0, 0];\n    static\
    \ const string[] numerals_reversed = [\"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    ];\n    static const string[] numerals_reversed_reversed = [\"\", \"\", \"\",\
    \ \"\", \"\", \"\", \"\"];\n    static const string[] numerals_reversed_reversed_reversed\
    \ = [\"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n    static const string[] numerals_reversed_reversed_reversed_reversed\
    \ = [\"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n    static const string[] numerals_reversed_reversed_reversed_reversed_reversed\
    \ = [\"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n    static const string[] numerals_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = [\"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu2l77rfi.d(36): Error: unterminated string constant starting at
    /tmp/tmpu2l77rfi.d(54)

    /tmp/tmpu2l77rfi.d(41): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpu2l77rfi.d(41): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpu2l77rfi.d(42): Error: found `lii` when expecting `;` following statement

    /tmp/tmpu2l77rfi.d(43): Error: found `cli` when expecting `;` following statement

    /tmp/tmpu2l77rfi.d(44): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpu2l77rfi.d(45): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpu2l77rfi.d(46): Error: found `i` when expecting `;` following statement

    /tmp/tmpu2l77rfi.d(47): Error: found `iv` when expecting `;` following statement

    /tmp/tmpu2l77rfi.d(48): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpu2l77rfi.d(49): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static long[] arabic_numerals\
    \ = [ 1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L ];\n \
    \   string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n   \
    \ {\n        while(number >= arabic_numerals[i])\n        {\n            result\
    \ ~= roman_numeral;\n            number -= arabic_numerals[i];\n        }\n  \
    \  }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp02b0n7rv.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp02b0n7rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_thousands = [\n        \"\
    xm\", \"xxm\", \"xxxm\", \"xlm\"\n    ];\n    static string[4] roman_hundreds_thousands\
    \ = [\n        \"cm\", \"ccm\", \"cccm\", \"cdm\"\n    ];\n    static string[4]\
    \ roman_millions = [\n        \"mm\", \"mmm\", \"mmmm\", \"mmmmm\"\n    ];\n \
    \   static string[4] roman_tens_millions = [\n        \"xmm\", \"xxmm\", \"xxxmm\"\
    , \"xlmm\"\n    ];\n    static string[4] roman_hundreds_millions = [\n       \
    \ \"cmm\", \"ccmm\", \"cccmm\", \"cdmm\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"mmm\", \"mmmm\", \"mmmmm\", \"mmmmmm\"\n    ];\n    static string[4]\
    \ roman_tens_billions = [\n        \"xmmm\", \"xxmmm\", \"xxxmmm\", \"xlmmm\"\n\
    \    ];\n    static string[4] roman_hundreds_billions = [\n        \"cmmm\", \"\
    ccmmm\", \"cccmmm\", \"cdmmm\"\n    ];\n    static string[4] roman_trillions =\
    \ [\n        \"mmmm\", \"mmmmm\", \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4qgw5y7z.d(56): Error: unterminated string constant starting at
    /tmp/tmp4qgw5y7z.d(75)

    /tmp/tmp4qgw5y7z.d(62): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmp4qgw5y7z.d(62): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmp4qgw5y7z.d(63): Error: found `lii` when expecting `;` following statement

    /tmp/tmp4qgw5y7z.d(64): Error: found `cli` when expecting `;` following statement

    /tmp/tmp4qgw5y7z.d(65): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmp4qgw5y7z.d(66): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmp4qgw5y7z.d(67): Error: found `i` when expecting `;` following statement

    /tmp/tmp4qgw5y7z.d(68): Error: found `iv` when expecting `;` following statement

    /tmp/tmp4qgw5y7z.d(69): Error: found `xliii` when expecting `;` following statement

    /tmp/tmp4qgw5y7z.d(70): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[int] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[int] roman_hundreds = [\n        \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[int] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n  \
    \  static string[int] roman_tens_of_thousands = [\n        \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[int]\
    \ roman_hundreds_of_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[int] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_tens_of_millions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[int] roman_hundreds_of_millions = [\n    \
    \    \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n\
    \    ];\n    static string[int] roman_billions = [\n        \"m\", \"mm\", \"\
    mmm\"\n    ];\n    static string[int] roman_tens_of_billions = [\n        \"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n\
    \   \nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvltqk2qw.d(54): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvltqk2qw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, numeral; roman_numerals)\n    {\n    \
    \    while(number >= decimal_numerals[i])\n        {\n            result ~= numeral;\n\
    \            number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8e_oi4dm.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8e_oi4dm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number >= 1 && number <= 1000);\n\
    \    return roman_thousands[cast(int)(number / 1000)] ~\n           roman_hundreds[cast(int)((number\
    \ % 1000) / 100)] ~\n           roman_tens[cast(int)((number % 100) / 10)] ~\n\
    \           roman_numerals[cast(int)(number % 10)];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] thresholds =\
    \ [1L, 4L, 5L, 9L, 10L, 40L, 50L, 90L, 100L, 400L, 500L, 900L, 1000L];\n    static\
    \ const string[] roman_symbols = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\"\
    , \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    static const long[]\
    \ roman_symbols_lengths = [1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L];\n\
    \    static const string[] roman_symbols_upper = [\"I\", \"IV\", \"V\", \"IX\"\
    , \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"];\n    static\
    \ const long[] roman_symbols_upper_lengths = [1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L,\
    \ 1L, 2L, 1L, 2L, 1L];\n    static const string[] roman_symbols_lower = [\"i\"\
    , \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"\
    cm\", \"m\"];\n    static const long[] roman_symbols_lower_lengths = [1L, 2L,\
    \ 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L];\n    static const string[] roman_symbols_lower_upper\
    \ = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\"\
    , \"D\", \"CM\", \"M\"];\n    static const long[] roman_symbols_lower_upper_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppajy8rxk.d(31): Error: semicolon expected, not `unittest`

    /tmp/tmppajy8rxk.d(31): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppajy8rxk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number > 0 && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_digits[number % 10];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[4] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mmmm\"];\n    string result = \"\";\n    if (number\
    \ > 1000)\n    {\n        result ~= roman_thousands[number / 1000 - 1];\n    \
    \    number %= 1000;\n    }\n    if (number > 100)\n    {\n        result ~= roman_hundreds[number\
    \ / 100 - 1];\n        number %= 100;\n    }\n    if (number > 10)\n    {\n  \
    \      result ~= roman_tens[number / 10 - 1];\n        number %= 10;\n    }\n\
    \    if (number > 0)\n    {\n        result ~= roman_numerals[number - 1];\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const char[] roman_numerals = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_values_length\
    \ = [1, 2, 2, 2, 3, 3, 4];\n    static const int[] roman_values_length_sum = [1,\
    \ 3, 5, 7, 10, 13, 17];\n    static const int[] roman_values_length_sum_minus_one\
    \ = [0, 2, 4, 6, 9, 12, 16];\n    static const int[] roman_values_length_sum_minus_two\
    \ = [0, 1, 3, 5, 8, 11, 15];\n    static const int[] roman_values_length_sum_minus_three\
    \ = [0, 0, 2, 4, 7, 10, 14];\n    static const int[] roman_values_length_sum_minus_four\
    \ = [0, 0, 1, 3, 6, 9, 13];\n    static const int[] roman_values_length_sum_minus_five\
    \ = [0, 0, 0, 2, 5, 8, 12];\n    static const int[] roman_values_length_sum_minus_six\
    \ = [0, 0, 0, 1, 4, 7, 11];\n    static const int[] roman_values_length_sum_minus_seven\
    \ = [0, 0, 0, 0, 3, 6, 10];\n    static const int[] roman_values_length_sum_minus_eight\
    \ = [0, 0, 0, 0, 2, 5, 9];\n    static const int[] roman_values_length_sum_minus_nine\
    \ = [0, 0, 0, 0, 1, 4, 8];\n    static const int[] roman_values_length_sum_minus_ten\
    \ = [0, 0, 0, 0, 0, 3, 7];\n    static const int[] roman_values_length_sum_minus_eleven\
    \ = [0, 0, 0, 0, 0, 2, 6];\n    static const int[] roman_values_length_sum_minus_twelve\
    \ = [0, 0, 0, 0, 0,\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxdu518y9.d(36): Error: expression expected, not `unittest`

    /tmp/tmpxdu518y9.d(37): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpxdu518y9.d(55): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpxdu518y9.d(55): Error: semicolon expected, not `main`

    /tmp/tmpxdu518y9.d(55): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxdu518y9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] max_values =\
    \ [3L, 1L, 1L, 1L, 3L, 1L, 3L];\n    static const long[] min_values = [0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L];\n    static const long[] max_repeats = [1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L];\n    static const long[] min_repeats = [0L, 0L, 0L, 0L, 0L, 0L,\
    \ 0L];\n    static const long[] max_subtracts = [1L, 0L, 0L, 0L, 1L, 0L, 1L];\n\
    \    static const long[] min_subtracts = [0L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static\
    \ const long[] subtract_values = [1L, 0L, 0L, 0L, 10L, 0L, 100L];\n    static\
    \ const long[] subtract_repeats = [1L, 0L, 0L, 0L, 1L, 0L, 1L];\n    static const\
    \ long[] subtract_subtracts = [0L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static const\
    \ long[] subtract_subtract_values = [0L, 0L, 0L, 0L, 0L, 0L, 0L];\n    static\
    \ const long[] subtract_subtract_repeats = [0L, 0L, 0L, 0L, 0L, 0L, 0L];\n   \
    \ static const long[] subtract_subtract_subtracts = [0L, 0L, 0L, 0L, 0L, 0L, 0L];\n\
    \    static const long[] subtract_subtract_subtract_values = [0L, 0L, 0L, 0L,\
    \ 0L, 0L, 0L];\n    static const long[] subtract_sub\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbft19kcd.d(36): Error: semicolon expected, not `unittest`

    /tmp/tmpbft19kcd.d(36): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbft19kcd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= numeral;\n  \
    \          number -= values[i];\n        }\n    }\n    return result;\n}\n/*\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcphp9kfg.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcphp9kfg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static long[] roman_numerals_values\
    \ = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= roman_numerals_values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= roman_numerals_values[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n  \
    \  assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzaaqicnv.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzaaqicnv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string roman_numerals = \"ivxlcdm\";\n    static long[]\
    \ values = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static long[] digits =\
    \ [1L, 2L, 3L, 4L, 5L, 6L, 7L];\n    static long[] roman_digits = [0L, 1L, 2L,\
    \ 3L, 1L, 0L, 1L, 2L, 3L, 1L];\n    static long[] roman_digits_5 = [0L, 0L, 0L,\
    \ 0L, 1L, 1L, 1L, 1L, 1L, 0L];\n    static long[] roman_digits_10 = [0L, 0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 1L];\n    static long[] roman_digits_50 = [0L, 0L, 0L,\
    \ 0L, 0L, 1L, 1L, 1L, 1L, 1L];\n    static long[] roman_digits_100 = [0L, 0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L];\n    static long[] roman_digits_500 = [0L,\
    \ 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L];\n    static long[] roman_digits_1000 =\
    \ [0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L];\n    static long[][] roman_digits_arr\
    \ = [roman_digits, roman_digits_5, roman_digits_10, roman_digits_50, roman_digits_100,\
    \ roman_digits_500, roman_digits_1000];\n    static long[] roman_digits_arr_len\
    \ = [10L, 10L, 10L, 10L, 10L, 10L, 10L];\n    static long[] roman_digits_arr_max\
    \ = [3\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5yp02v6e.d(34): Error: comma expected separating array initializers,
    not `unittest`

    /tmp/tmp5yp02v6e.d(35): Error: semicolon expected, not `{`

    /tmp/tmp5yp02v6e.d(53): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5yp02v6e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ int[int] decimal_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, roman; roman_numerals)\n\
    \    {\n        while(number >= decimal_numerals[i])\n        {\n            result\
    \ ~= roman;\n            number -= decimal_numerals[i];\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgmnkfx0v.d(20): Error: not an associative array initializer

    /tmp/tmpgmnkfx0v.d(23): Error: not an associative array initializer

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgmnkfx0v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptb19tx7l.d(60): Error: found `unittest` when expecting `]`

    /tmp/tmptb19tx7l.d(61): Error: no identifier for declarator `string[4]`

    /tmp/tmptb19tx7l.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb19tx7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[] roman_tens =\
    \ [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[] roman_hundreds = [\n        \"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static\
    \ string[] roman_tens_thousands = [\n        \"xm\", \"xxm\", \"xxxm\", \"xlm\"\
    , \"lm\", \"lxm\", \"lxxm\", \"lxxxm\", \"xcm\"\n    ];\n    static string[] roman_hundreds_thousands\
    \ = [\n        \"cm\", \"ccm\", \"cccm\", \"cdm\", \"dm\", \"dcm\", \"dccm\",\
    \ \"dcccm\", \"cmm\"\n    ];\n    static string[] roman_millions = [\n       \
    \ \"m\", \"mm\", \"mmm\"\n    ];\n    static string[] roman_tens_millions = [\n\
    \        \"xm\", \"xxm\", \"xxxm\", \"xlm\", \"lm\", \"lxm\", \"lxxm\", \"lxxxm\"\
    , \"xcm\"\n    ];\n    static string[] roman_hundreds_millions = [\n        \"\
    cm\", \"ccm\", \"cccm\", \"cdm\", \"dm\", \"dcm\", \"dccm\", \"dcccm\", \"cmm\"\
    \n    ];\n    static string[] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\
    \n    ];\n    static string[] roman_tens_billions = [\n        \"xm\", \"xxm\"\
    , \"xxxm\", \"xlm\", \"lm\", \"lxm\", \"lxxm\", \"lxxxm\", \"xcm\"\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiffkemus.d(52): Error: comma expected separating array initializers,
    not `unittest`

    /tmp/tmpiffkemus.d(53): Error: semicolon expected, not `{`

    /tmp/tmpiffkemus.d(71): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiffkemus.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    auto arabic_numerals\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    foreach(i, numeral;\
    \ arabic_numerals)\n    {\n        while(number >= numeral)\n        {\n     \
    \       result ~= roman_numerals[i];\n            number -= numeral;\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number >= 1000) {\n    \
    \    result ~= roman_thousands[number / 1000];\n        number %= 1000;\n    }\n\
    \    if (number >= 100) {\n        result ~= roman_hundreds[number / 100];\n \
    \       number %= 100;\n    }\n    if (number >= 10) {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, v; values)\n    {\n        while(number >= v)\n        {\n      \
    \      result ~= roman[i];\n            number -= v;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ immutable int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static immutable string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\"\
    , \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    int i = values.length - 1;\n    while (number > 0) {\n        while\
    \ (number < values[i]) {\n            i--;\n        }\n        result ~= numerals[i];\n\
    \        number -= values[i];\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number > 0 && number <= 1000);\n\
    \    return roman_thousands[number / 1000] ~ roman_hundreds[(number / 100) % 10]\
    \ ~ roman_tens[(number / 10) % 10] ~ roman_numerals[number % 10];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numbers = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n   \
    \ static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\", \"\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5afa0_29.d(30): Error: unterminated string constant starting at
    /tmp/tmp5afa0_29.d(48)

    /tmp/tmp5afa0_29.d(35): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmp5afa0_29.d(35): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmp5afa0_29.d(36): Error: found `lii` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(37): Error: found `cli` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(38): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(39): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmp5afa0_29.d(40): Error: found `i` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(41): Error: found `iv` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(42): Error: found `xliii` when expecting `;` following statement

    /tmp/tmp5afa0_29.d(43): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    string\
    \ result = \"\";\n    int i = 0;\n    while (number > 0) \n    {\n        int\
    \ digit = number % 10;\n        number /= 10;\n        if (digit == 0) \n    \
    \    {\n            i += 2;\n            continue;\n        }\n        if (digit\
    \ <= 3) \n        {\n            result = repeat(roman[i], digit) ~ result;\n\
    \        }\n        else if (digit == 4) \n        {\n            result = roman[i]\
    \ ~ roman[i + 1] ~ result;\n        }\n        else if (digit <= 8) \n       \
    \ {\n            result = roman[i + 1] ~ repeat(roman[i], digit - 5) ~ result;\n\
    \        }\n        else \n        {\n            result = roman[i] ~ roman[i\
    \ + 2] ~ result;\n        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_mdlbi32.d(34): Error: undefined identifier `repeat`

    /tmp/tmp_mdlbi32.d(42): Error: undefined identifier `repeat`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_mdlbi32.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] romans = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\", \"x\"];\n    static string[10] tens = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"];\n    static string[10] thousands = [\"m\", \"mm\", \"mmm\",\
    \ \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[4]\
    \ big_numbers = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] big_numbers_roman\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] big_numbers_tens = [\"\
    \", \"x\", \"xx\", \"xxx\"];\n    static string[4] big_numbers_hundreds = [\"\"\
    , \"c\", \"cc\", \"ccc\"];\n    static string[4] big_numbers_thousands = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] big_numbers_tenthousands = [\"\
    \", \"x\", \"xx\", \"xxx\"];\n    static string[4] big_numbers_hundredthousands\
    \ = [\"\", \"c\", \"cc\", \"ccc\"];\n    static string[4] big_numbers_million\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] big_numbers_tenmillion\
    \ = [\"\", \"x\", \"xx\", \"xxx\"];\n    static string[4] big_numbers_hundredmillion\
    \ = [\"\", \"c\", \"cc\", \"ccc\"];\n    static string[4] big_numbers_billion\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] big_numbers_tenbillion\
    \ = [\"\", \"x\", \"xx\", \"xxx\"];\n    static string[4] big_numbers\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptkfc6or0.d(37): Error: semicolon expected, not `unittest`

    /tmp/tmptkfc6or0.d(37): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptkfc6or0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptb19tx7l.d(60): Error: found `unittest` when expecting `]`

    /tmp/tmptb19tx7l.d(61): Error: no identifier for declarator `string[4]`

    /tmp/tmptb19tx7l.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb19tx7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, roman_num; zip(roman, values))\n    {\n        while(number >= roman_num[1])\n\
    \        {\n            result ~= roman_num[0];\n            number -= roman_num[1];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp40it33ur.d(23): Error: undefined identifier `zip`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp40it33ur.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals) {\n\
    \        while(number >= values[i]) {\n            result ~= numeral;\n      \
    \      number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const int[] roman_indexes\
    \ = [0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6];\n    static\
    \ const string[] roman_subtractives = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\"\
    , \"cm\"];\n    static const long[] roman_subtractive_values = [4L, 9L, 40L, 90L,\
    \ 400L, 900L];\n    static const int[] roman_subtractive_indexes = [0, 0, 1, 1,\
    \ 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5];\n    static const string[]\
    \ roman_subtractive_prefixes = [\"i\", \"x\", \"c\", \"m\"];\n    static const\
    \ string[] roman_subtractive_suffixes = [\"v\", \"l\", \"d\"];\n    static const\
    \ string[] roman_subtractive_suffixes_2 = [\"i\", \"x\", \"c\"];\n    static const\
    \ string[] roman_subtractive_suffixes_3 = [\"v\", \"l\", \"d\"];\n    static const\
    \ string[] roman_subtractive_suffixes_4 = [\"i\", \"x\", \"c\"];\n    static const\
    \ string[] roman_subtractive_suffixes_5 = [\"v\", \"l\", \"d\"];\n    static const\
    \ string[] roman_subtractive_suffixes_6 = [\"i\", \"x\", \"c\"];\n    static const\
    \ string[] roman_subtractive_suffixes_7 = [\"v\", \"l\", \"d\"];\n    static const\
    \ string[] roman_subtractive_suffixes_8 = [\"i\", \"x\", \"c\"];\n    static const\
    \ string[] roman_subtractive_suffixes_9 =\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8t3y9pyw.d(36): Error: expression expected, not `unittest`

    /tmp/tmp8t3y9pyw.d(37): Error: semicolon expected, not `{`

    /tmp/tmp8t3y9pyw.d(55): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8t3y9pyw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[10] roman_thousands = [\"m\", \"mm\", \"mmm\"\
    , \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"];\n    static string[10] roman_ten_thousands\
    \ = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    ];\n    static string[10] roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"\
    cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[10] roman_millions\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    ];\n    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    ];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"mv\", \"\
    v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"];\n    static string[10] roman_ten_billions\
    \ = [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    ];\n    static string[10] r\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiaemma6n.d(32): Error: semicolon expected, not `unittest`

    /tmp/tmpiaemma6n.d(32): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiaemma6n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_letters\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ roman_subtractives = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n   \
    \ static const long[] roman_subtractive_values = [4L, 9L, 40L, 90L, 400L, 900L];\n\
    \    static const string[] roman_subtractive_letters = [\"iv\", \"ix\", \"xl\"\
    , \"xc\", \"cd\", \"cm\"];\n    static const string[] roman_additives = [\"ii\"\
    , \"iii\", \"vv\", \"vii\", \"xx\", \"xxi\", \"xxii\", \"xxiii\", \"ll\", \"lv\"\
    , \"lx\", \"lxx\", \"lxxx\", \"lxxxi\", \"lxxxii\", \"lxxxiii\", \"cc\", \"cl\"\
    , \"cx\", \"cxx\", \"cxxx\", \"cxxi\", \"cxxii\", \"cxxiii\", \"ccc\", \"ccl\"\
    , \"ccx\", \"ccxx\", \"ccxxx\", \"ccxxi\", \"ccxxii\", \"ccxxiii\", \"cccc\",\
    \ \"cccl\", \"cccx\", \"cccxx\", \"cccxxx\", \"cccxxi\", \"cccxxii\", \"cccxxiii\"\
    , \"ccccc\", \"ccccl\", \"ccccx\", \"ccccxx\", \"ccccxxx\", \"ccccxxi\", \"ccccxxii\"\
    , \"ccccxxiii\"];\n    static const long[] roman_additive_values = [2L, 3L, 5L,\
    \ 7L, 10L, 11L, 12L, 13L, 50L, 55L, 60L, 70L, 80L, 81L, 82L, 83L, 100L, 500L,\
    \ 600L, 700L, 800L, 801L, 802L, 803L, 1000L, 1500L, 1600\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprv0e67mk.d(28): Error: comma expected separating array initializers,
    not `unittest`

    /tmp/tmprv0e67mk.d(29): Error: semicolon expected, not `{`

    /tmp/tmprv0e67mk.d(47): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprv0e67mk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_tenthousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundredthousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_tenmillions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundredmillions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_tenbillions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcwf1e2wi.d(30): Error: unterminated string constant starting at
    /tmp/tmpcwf1e2wi.d(48)

    /tmp/tmpcwf1e2wi.d(35): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpcwf1e2wi.d(35): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpcwf1e2wi.d(36): Error: found `lii` when expecting `;` following statement

    /tmp/tmpcwf1e2wi.d(37): Error: found `cli` when expecting `;` following statement

    /tmp/tmpcwf1e2wi.d(38): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpcwf1e2wi.d(39): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpcwf1e2wi.d(40): Error: found `i` when expecting `;` following statement

    /tmp/tmpcwf1e2wi.d(41): Error: found `iv` when expecting `;` following statement

    /tmp/tmpcwf1e2wi.d(42): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpcwf1e2wi.d(43): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] roman_subtractors\
    \ = [1L, 10L, 100L];\n    static const string[] roman_subtractors_str = [\"i\"\
    , \"x\", \"c\"];\n    static const string[] roman_subtractors_str_5 = [\"v\",\
    \ \"l\", \"d\"];\n    static const string[] roman_subtractors_str_10 = [\"x\"\
    , \"c\", \"m\"];\n    static const long[] roman_subtractors_5 = [5L, 50L, 500L];\n\
    \    static const long[] roman_subtractors_10 = [10L, 100L, 1000L];\n    static\
    \ const long[] roman_subtractors_5_10 = [15L, 150L, 1500L];\n    static const\
    \ long[] roman_subtractors_10_5 = [6L, 60L, 600L];\n    static const long[] roman_subtractors_10_10\
    \ = [11L, 110L, 1100L];\n    static const long[] roman_subtractors_10_10_10 =\
    \ [16L, 160L, 1600L];\n    static const long[] roman_subtractors_10_10_5 = [7L,\
    \ 70L, 700L];\n    static const long[] roman_subtractors_10_5_10 = [17L, 170L,\
    \ 1700L];\n    static const long[] roman_subtractors_5_10_10 = [18L, 180L, 1800L];\n\
    \    static const long[] roman_subtractors_5_5_10 = [8L, 80L, 800L];\n    static\
    \ const long[] roman_subtractors_5_10_5 = [13L, 130L, 1300L];\n    static const\
    \ long[] roman_subtractors_10_5_5 = [14L, 140L, 1400L];\n    static const long[]\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwusgd9u0.d(39): Error: no identifier for declarator `long[]`

    /tmp/tmpwusgd9u0.d(39): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwusgd9u0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic = [1000L, 900L,\
    \ 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n    string result =\
    \ \"\";\n    foreach(i, roman_digit; roman)\n    {\n        while(number >= arabic[i])\n\
    \        {\n            number -= arabic[i];\n            result ~= roman_digit;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[] roman_symbols\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ roman_subtractives = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n   \
    \ static const long[] subtractive_values = [4L, 9L, 40L, 90L, 400L, 900L];\n \
    \   static const string[] subtractive_symbols = [\"iv\", \"ix\", \"xl\", \"xc\"\
    , \"cd\", \"cm\"];\n    static const string[] subtractive_numerals = [\"iv\",\
    \ \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const string[] subtractive_numerals\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const string[]\
    \ subtractive_numerals = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n \
    \   static const string[] subtractive_numerals = [\"iv\", \"ix\", \"xl\", \"xc\"\
    , \"cd\", \"cm\"];\n    static const string[] subtractive_numerals = [\"iv\",\
    \ \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const string[] subtractive_numerals\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const string[]\
    \ subtractive_numerals = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n \
    \   static const string[] subtractive_numerals = [\"iv\", \"ix\", \"xl\", \"xc\"\
    , \"cd\", \"cm\"];\n    static const string[] subtractive_numerals = [\"iv\",\
    \ \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const string[] subtractive_numerals\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppvq98jyz.d(36): Error: expression expected, not `unittest`

    /tmp/tmppvq98jyz.d(37): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmppvq98jyz.d(55): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmppvq98jyz.d(55): Error: semicolon expected, not `main`

    /tmp/tmppvq98jyz.d(55): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppvq98jyz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_ten_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\",\
    \ \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\",\
    \ \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions = [\n      \
    \  \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\"\n    ];\n    static string[10] roman_hundred_millions = [\n        \"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n \
    \   ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\
    , \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy22kg5lj.d(47): Error: unterminated string constant starting at
    /tmp/tmpy22kg5lj.d(66)

    /tmp/tmpy22kg5lj.d(53): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpy22kg5lj.d(53): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpy22kg5lj.d(54): Error: found `lii` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(55): Error: found `cli` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(56): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(57): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpy22kg5lj.d(58): Error: found `i` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(59): Error: found `iv` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(60): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpy22kg5lj.d(61): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\n        \"i\", \"ii\", \"\
    iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[10] roman_thousands = [\n        \"\
    m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n\
    \    ];\n    static string[10] roman_ten_thousands = [\n        \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n \
    \   static string[10] roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static\
    \ string[10] roman_millions = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\"\
    , \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundred_millions = [\n  \
    \      \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"\n    ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjl9oh_0v.d(48): Error: unterminated string constant starting at
    /tmp/tmpjl9oh_0v.d(67)

    /tmp/tmpjl9oh_0v.d(54): Error: comma expected separating array initializers, not
    `xix`

    /tmp/tmpjl9oh_0v.d(54): Error: semicolon expected, not `");\x0a    assert(candidate(152L)
    == "c`

    /tmp/tmpjl9oh_0v.d(55): Error: found `lii` when expecting `;` following statement

    /tmp/tmpjl9oh_0v.d(56): Error: found `cli` when expecting `;` following statement

    /tmp/tmpjl9oh_0v.d(57): Error: found `dxxvi` when expecting `;` following statement

    /tmp/tmpjl9oh_0v.d(58): Error: Implicit string concatenation is deprecated, use
    ");\x0a    assert(candidate(500L) == "d ~ ");\x0a    assert(candidate(1L) == "
    instead

    /tmp/tmpjl9oh_0v.d(59): Error: found `i` when expecting `;` following statement

    /tmp/tmpjl9oh_0v.d(60): Error: found `iv` when expecting `;` following statement

    /tmp/tmpjl9oh_0v.d(61): Error: found `xliii` when expecting `;` following statement

    /tmp/tmpjl9oh_0v.d(62): Error: found `xc` when expecting `;` following statement

    /tmp'
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\n/*\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwrhkiz17.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwrhkiz17.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] roman_values = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ long[] roman_values_sorted = [1, 5, 10, 50, 100, 500, 1000];\n    static string[]\
    \ roman_numerals_sorted = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static string[] roman_numerals_sorted_reversed = [\"m\", \"d\", \"c\", \"\
    l\", \"x\", \"v\", \"i\"];\n    static long[] roman_values_sorted_reversed = [1000,\
    \ 500, 100, 50, 10, 5, 1];\n    static long[] roman_values_sorted_reversed_minus_one\
    \ = [1000, 500, 100, 50, 10, 5, 0];\n    static long[] roman_values_sorted_reversed_minus_two\
    \ = [1000, 500, 100, 50, 10, 0, 0];\n    static long[] roman_values_sorted_reversed_minus_three\
    \ = [1000, 500, 100, 50, 0, 0, 0];\n    static long[] roman_values_sorted_reversed_minus_four\
    \ = [1000, 500, 100, 0, 0, 0, 0];\n    static long[] roman_values_sorted_reversed_minus_five\
    \ = [1000, 500, 0, 0, 0, 0, 0];\n    static long[] roman_values_sorted_reversed_minus_six\
    \ = [1000, 0, 0, 0, 0, 0, 0];\n    static long[] roman_values_sorted_reversed_minus_seven\
    \ = [0, 0, 0, 0, 0, 0, 0];\n    static string[] roman_numerals_sorted_reversed_minus_one\
    \ = [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"\"];\n    static string[] roman_numerals_sorted_revers\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz0lw9whw.d(35): Error: semicolon expected, not `unittest`

    /tmp/tmpz0lw9whw.d(35): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz0lw9whw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164540
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_tenthousands = [\n        \"\",\
    \ \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredthousands\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tenmillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredmillions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tenbillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredbillions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tentrillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundred\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_0bht5a.d(63): Error: semicolon expected, not `unittest`

    /tmp/tmpo_0bht5a.d(63): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_0bht5a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    long[] values = [1000L, 900L, 500L, 400L, 100L, 90L, 50L,\
    \ 40L, 10L, 9L, 5L, 4L, 1L];\n    string[] numerals = [\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n  \
    \  for (int i = 0; i < values.length; i++) \n    {\n        while (number >= values[i])\
    \ \n        {\n            result ~= numerals[i];\n            number -= values[i];\n\
    \        }\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuddoxn6w.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuddoxn6w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number > 1000) {\n     \
    \   result ~= roman_thousands[number / 1000];\n        number %= 1000;\n    }\n\
    \    if (number > 100) {\n        result ~= roman_hundreds[number / 100];\n  \
    \      number %= 100;\n    }\n    if (number > 10) {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmphect0gf6.d(38): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42858e]

    ??:? immutable(char)[] tmphect0gf6.int_to_mini_roman(long) [0x427cea]

    ??:? void tmphect0gf6.__unittest_L48_C1() [0x428176]

    ??:? void tmphect0gf6.__modtest() [0x42825c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cc97]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42bba6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43097c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430459]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb7d]

    ??:? runModuleUnitTests [0x42ca6d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C'
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_digits = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_digits\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, roman_digit; roman_digits)\n    {\n  \
    \      while(number >= arabic_digits[i])\n        {\n            result ~= roman_digit;\n\
    \            number -= arabic_digits[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static const string roman_numerals = \"ivxlcdm\";\n    static const\
    \ long[] values = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const string[]\
    \ roman_values = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static\
    \ const long[] divisors = [1L, 10L, 100L, 1000L];\n    static const string[] roman_divisors\
    \ = [\"i\", \"x\", \"c\", \"m\"];\n    static const long[] divisor_values = [1L,\
    \ 10L, 100L, 1000L];\n    static const string[] roman_divisor_values = [\"i\"\
    , \"x\", \"c\", \"m\"];\n    static const long[] divisor_subtractors = [1L, 10L,\
    \ 100L, 1000L];\n    static const string[] roman_divisor_subtractors = [\"i\"\
    , \"x\", \"c\", \"m\"];\n    static const long[] divisor_subtractor_values = [1L,\
    \ 10L, 100L, 1000L];\n    static const string[] roman_divisor_subtractor_values\
    \ = [\"i\", \"x\", \"c\", \"m\"];\n    static const long[] divisor_subtractor_subtractors\
    \ = [1L, 10L, 100L, 1000L];\n    static const string[] roman_divisor_subtractor_subtractors\
    \ = [\"i\", \"x\", \"c\", \"m\"];\n    static const long[] divisor_subtractor_subtractor_values\
    \ = [1L, 10L, 100L, 1000L];\n    static const string[] roman_divisor_subtractor_subtractor_values\
    \ = [\"i\", \"x\", \"c\", \"m\"];\n    static const long[] divisor_subtractor_subtractor_subtractors\
    \ = [1L, 10L, 100L, 1000L];\n    static const string[] roman_divisor_subtractor_subtractor_subtractors\
    \ = [\"i\",\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc1k395u2.d(38): Error: expression expected, not `unittest`

    /tmp/tmpc1k395u2.d(39): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpc1k395u2.d(57): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpc1k395u2.d(57): Error: semicolon expected, not `main`

    /tmp/tmpc1k395u2.d(57): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc1k395u2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_digits = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_subtractors\
    \ = [1, 10, 100];\n    static const int[] roman_subtractors_values = [1, 10, 100];\n\
    \    static const string[] roman_subtractors_symbols = [\"i\", \"x\", \"c\"];\n\
    \    static const string[] roman_subtractors_symbols_subtracted = [\"v\", \"l\"\
    , \"d\"];\n    static const string[] roman_subtractors_symbols_subtracted_subtracted\
    \ = [\"x\", \"c\", \"m\"];\n    static const string[] roman_subtractors_symbols_subtracted_subtracted_subtracted\
    \ = [\"l\", \"d\", \"m\"];\n    static const string[] roman_subtractors_symbols_subtracted_subtracted_subtracted_subtracted\
    \ = [\"c\", \"m\", \"m\"];\n    static const string[] roman_subtractors_symbols_subtracted_subtracted_subtracted_subtracted_subtracted\
    \ = [\"d\", \"m\", \"m\"];\n    static const string[] roman_subtractors_symbols_subtracted_subtracted_subtracted_subtracted_subtracted_subtracted\
    \ = [\"m\", \"m\", \"m\"];\n    static const string[] roman_subtractors_symbols_subtracted_subtracted_subtracted_subtracted_subtracted_subtracted_subtracted\
    \ = [\"m\", \"m\", \"m\"];\n    static const string[] roman_subtractors_symbols_subtracted_subtracted_subtracted_subtracted_subtracted_subtracted_subtracted_subtracted\
    \ = [\"m\", \"m\", \"m\"];\n    static const string[] roman_subtractors_symbols_subtracted_subtracted_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpprk1dov2.d(34): Error: semicolon expected, not `unittest`

    /tmp/tmpprk1dov2.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpprk1dov2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] max_values =\
    \ [3L, 1L, 1L, 1L, 3L, 1L, 3L];\n    static const long[] min_values = [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L];\n    static const long[] mid_values = [2L, 1L, 1L, 1L,\
    \ 2L, 1L, 2L];\n    static const long[] next_values = [1L, 10L, 10L, 10L, 100L,\
    \ 100L, 100L];\n    static const long[] prev_values = [10L, 1L, 1L, 10L, 1L, 10L,\
    \ 1L];\n    static const long[] next_indexes = [2L, 4L, 4L, 4L, 6L, 6L, 6L];\n\
    \    static const long[] prev_indexes = [1L, 3L, 3L, 5L, 3L, 5L, 5L];\n    static\
    \ const long[] next_max_values = [1L, 3L, 1L, 1L, 3L, 1L, 3L];\n    static const\
    \ long[] prev_max_values = [3L, 1L, 1L, 3L, 1L, 3L, 1L];\n    static const long[]\
    \ next_min_values = [1L, 1L, 1L, 1L, 1L, 1L, 1L];\n    static const long[] prev_min_values\
    \ = [1L, 1L, 1L, 1L, 1L, 1L, 1L];\n    static const long[] next_mid_values = [1L,\
    \ 2L, 1L, 1L, 2L, 1L, 2L];\n    static const long[] prev_mid_values = [2L, 1L,\
    \ 1L, 2L, 1L, 2L, 1L];\n    static const long[] next_next_values = [10L, 100L,\
    \ 10L, 10L, 100L, 100L,\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnungc_r8.d(36): Error: expression expected, not `unittest`

    /tmp/tmpnungc_r8.d(37): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpnungc_r8.d(55): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpnungc_r8.d(55): Error: semicolon expected, not `main`

    /tmp/tmpnungc_r8.d(55): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnungc_r8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number > 1000)\n       \
    \ return \"\";\n    else if (number == 1000)\n        return \"m\";\n    else\n\
    \    {\n        result ~= roman_thousands[number / 1000];\n        number %= 1000;\n\
    \        result ~= roman_hundreds[number / 100];\n        number %= 100;\n   \
    \     result ~= roman_tens[number / 10];\n        number %= 10;\n        result\
    \ ~= roman_numerals[number];\n        return result;\n    }\n}\n/*\n    Given\
    \ a string containing a roman numeral, return its integer equivalent.\n    Restrictions:\
    \ 1 <= num <= 1000\n    The string will be in lowercase.\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1dnf0ol.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1dnf0ol.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_ten_thousands = [\n        \"x\"\
    , \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_ten_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n   \
    \ static string[4] roman_hundred_millions = [\n        \"c\", \"cc\", \"ccc\"\
    , \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\", \"mm\"\
    , \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_ten_billions = [\n   \
    \     \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_ten_trillions = [\n        \"x\",\nunittest\n{\n    alias candidate =\
    \ int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeos6xa5p.d(61): Error: expression expected, not `unittest`

    /tmp/tmpeos6xa5p.d(62): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmpeos6xa5p.d(80): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmpeos6xa5p.d(80): Error: semicolon expected, not `main`

    /tmp/tmpeos6xa5p.d(80): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeos6xa5p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_thousands = [\n        \"\
    xm\", \"xxm\", \"xxxm\", \"xlm\"\n    ];\n    static string[4] roman_hundreds_thousands\
    \ = [\n        \"cm\", \"ccm\", \"cccm\", \"cdm\"\n    ];\n    static string[4]\
    \ roman_millions = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static\
    \ string[4] roman_tens_millions = [\n        \"xm\", \"xxm\", \"xxxm\", \"xlm\"\
    \n    ];\n    static string[4] roman_hundreds_millions = [\n        \"cm\", \"\
    ccm\", \"cccm\", \"cdm\"\n    ];\n    static string[4] roman_billions = [\n  \
    \      \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_billions\
    \ = [\n        \"xm\", \"xxm\", \"xxxm\", \"xlm\"\n    ];\n    static string[4]\
    \ roman_hundreds_billions = [\n        \"cm\", \"ccm\", \"cccm\", \"cdm\"\n  \
    \  ];\n    static string[4] roman_trillions = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvoxdlk4u.d(59): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvoxdlk4u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164539
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] roman_values\
    \ = [1L, 5L, 10L, 50L, 100L, 500L, 1000L];\n    static const long[] roman_values_len\
    \ = [1L, 1L, 1L, 1L, 1L, 1L, 1L];\n    static const long[] roman_values_len_cum\
    \ = [1L, 2L, 3L, 4L, 5L, 6L, 7L];\n    static const long[] roman_values_len_cum_rev\
    \ = [7L, 6L, 5L, 4L, 3L, 2L, 1L];\n    static const long[] roman_values_len_rev\
    \ = [1L, 1L, 1L, 1L, 1L, 1L, 1L];\n    static const string[] roman_numerals_rev\
    \ = [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"i\"];\n    static const long[]\
    \ roman_values_rev = [1000L, 500L, 100L, 50L, 10L, 5L, 1L];\n    static const\
    \ long[] roman_values_len_rev_cum = [1L, 2L, 3L, 4L, 5L, 6L, 7L];\n    static\
    \ const long[] roman_values_len_rev_cum_rev = [7L, 6L, 5L, 4L, 3L, 2L, 1L];\n\
    \    static const long[] roman_values_len_rev_rev = [1L, 1L, 1L, 1L, 1L, 1L, 1L];\n\
    \    static const string[] roman_numerals_rev_rev = [\"i\", \"v\", \"x\", \"l\"\
    , \"c\", \"d\", \"m\"];\n    static const long[] roman_values_rev_rev = [1L, 5L,\
    \ 10L, 50L, 100L, 500L, 1000L];\n    static const long[] roman_values_len_rev_rev_cum\
    \ = [1L, 2L, 3L, 4L, 5L, 6L, 7L];\n   \nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8gza7mmy.d(35): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gza7mmy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number > 0 && number <= 1000);\n\
    \    string result = \"\";\n    result ~= roman_thousands[number / 1000];\n  \
    \  number %= 1000;\n    result ~= roman_hundreds[number / 100];\n    number %=\
    \ 100;\n    result ~= roman_tens[number / 10];\n    number %= 10;\n    result\
    \ ~= roman_numerals[number];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164541
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_symbols = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const string[] roman_symbol_pairs\
    \ = [\"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"];\n    static const int[]\
    \ roman_value_pairs = [4, 9, 40, 90, 400, 900];\n    static const string[] roman_symbol_triples\
    \ = [\"ivi\", \"ixi\", \"xlv\", \"xcv\", \"cdx\", \"cmx\"];\n    static const\
    \ int[] roman_value_triples = [5, 10, 45, 95, 405, 905];\n    static const string[]\
    \ roman_symbol_quadruples = [\"ivii\", \"ixii\", \"xlvi\", \"xcvi\", \"cdxi\"\
    , \"cmxi\"];\n    static const int[] roman_value_quadruples = [6, 11, 46, 96,\
    \ 406, 906];\n    static const string[] roman_symbol_quintuples = [\"iviii\",\
    \ \"ixiii\", \"xlvii\", \"xcvii\", \"cdxii\", \"cmxii\"];\n    static const int[]\
    \ roman_value_quintuples = [7, 12, 47, 97, 407, 907];\n    static const string[]\
    \ roman_symbol_sextuples = [\"iviiii\", \"ixiiii\", \"xlviii\", \"xcviii\", \"\
    cdxiii\", \"cmxiii\"];\n    static const int[] roman_value_sextuples = [8, 13,\
    \ 48, 98, 408, 908];\n    static const string[] roman_symbol_septuples = [\"iviiiii\"\
    , \"ixiiiii\", \"xlviiii\", \"xcviiii\", \"cdxiiii\", \"cmxiiii\"];\n    static\
    \ const int[] roman_value_septuples = [9, 14, 49, 99, 409, 909];\n    static const\
    \ string[] roman_symbol_octuples = [\"iviiiiii\", \"ixiiiiii\",\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8lrgn78q.d(35): Error: expression expected, not `unittest`

    /tmp/tmp8lrgn78q.d(36): Error: comma expected separating array initializers, not
    `{`

    /tmp/tmp8lrgn78q.d(54): Error: comma expected separating array initializers, not
    `void`

    /tmp/tmp8lrgn78q.d(54): Error: semicolon expected, not `main`

    /tmp/tmp8lrgn78q.d(54): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8lrgn78q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164541
