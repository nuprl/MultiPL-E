language: d
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, numeral; roman_numerals)\n    {\n    \
    \    while(number >= decimal_numerals[i])\n        {\n            result ~= numeral;\n\
    \            number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5cptnpfe.d(31): Error: expression expected, not `unittest`\n/tmp/tmp5cptnpfe.d(32):
    Error: comma expected separating array initializers, not `{`\n/tmp/tmp5cptnpfe.d(50):
    Error: comma expected separating array initializers, not `void`\n/tmp/tmp5cptnpfe.d(50):
    Error: semicolon expected, not `main`\n/tmp/tmp5cptnpfe.d(50): Error: found `{`
    when expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp5cptnpfe.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal_numerals\
    \ = [1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1L];\n   \
    \ string result = \"\";\n    foreach(i, numeral; roman_numerals)\n    {\n    \
    \    while(number >= decimal_numerals[i])\n        {\n            result ~= numeral;\n\
    \            number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] decimal_values = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ long[] decimal_values_reversed = decimal_values.dup.reverse;\n    static long[]\
    \ decimal_values_reversed_without_last = decimal_values_reversed[0..$-1];\n  \
    \  static string[] roman_numerals_reversed = roman_numerals.dup.reverse;\n   \
    \ static string[] roman_numerals_reversed_without_last = roman_numerals_reversed[0..$-1];\n\
    \    static long[] decimal_values_reversed_without_last_and_last_two = decimal_values_reversed[0..$-2];\n\
    \    static string[] roman_numerals_reversed_without_last_and_last_two = roman_numerals_reversed[0..$-2];\n\
    \    static long[] decimal_values_reversed_without_last_and_last_three = decimal_values_reversed[0..$-3];\n\
    \    static string[] roman_numerals_reversed_without_last_and_last_three = roman_numerals_reversed[0..$-3];\n\
    \    static long[] decimal_values_reversed_without_last_and_last_four = decimal_values_reversed[0..$-4];\n\
    \    static string[] roman_numerals_reversed_without_last_and_last_four = roman_numerals_reversed[0..$-4];\n\
    \    static long[] decimal_values_reversed_without_last_and_last_five = decimal_values_reversed[0..$-5];\n\
    \    static string[] roman_numerals_reversed_without_last_and_last_five = roman_numerals_reversed[0..$-5];\n\
    \    static long[] decimal_values_reversed_without\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwf9q5maq.d(35): Error: semicolon expected, not `unittest`\n/tmp/tmpwf9q5maq.d(35):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpwf9q5maq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    string result = \"\";\n\
    \    while (number > 0) {\n        result ~= roman_digits[number % 10];\n    \
    \    number /= 10;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmptdwoccel.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x42823d]\n??:? void tmptdwoccel.__unittest_L30_C1() [0x427bc4]\n??:?
    void tmptdwoccel.__modtest() [0x427fc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c9f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b906]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43022d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4306dc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4301b9]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b8dd]\n??:? runModuleUnitTests [0x42c7cd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428700]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428687]\n??:? _d_run_main [0x4285f2]\n??:? main [0x427fd3]\n??:?
    __libc_start_main [0x3fdbb554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens_of_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundreds_of_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_tens_of_millions = [\n  \
    \      \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    , \"c\"\n    ];\n    static string[10] roman_hundreds_of_millions = [\n      \
    \  \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"\
    m\"\n    ];\n    static string[10] roman_billions = [\n       \nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnk2aa9ts.d(49): Error: expression expected, not `unittest`\n/tmp/tmpnk2aa9ts.d(50):
    Error: comma expected separating array initializers, not `{`\n/tmp/tmpnk2aa9ts.d(68):
    Error: comma expected separating array initializers, not `void`\n/tmp/tmpnk2aa9ts.d(68):
    Error: semicolon expected, not `main`\n/tmp/tmpnk2aa9ts.d(68): Error: found `{`
    when expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpnk2aa9ts.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ struct RomanNumeral {\n        long value;\n        string symbol;\n    }\n\
    \    romanNumerals[] = [\n        RomanNumeral(1L, \"i\"),\n        RomanNumeral(4L,\
    \ \"iv\"),\n        RomanNumeral(5L, \"v\"),\n        RomanNumeral(9L, \"ix\"\
    ),\n        RomanNumeral(10L, \"x\"),\n        RomanNumeral(40L, \"xl\"),\n  \
    \      RomanNumeral(50L, \"l\"),\n        RomanNumeral(90L, \"xc\"),\n       \
    \ RomanNumeral(100L, \"c\"),\n        RomanNumeral(400L, \"cd\"),\n        RomanNumeral(500L,\
    \ \"d\"),\n        RomanNumeral(900L, \"cm\"),\n        RomanNumeral(1000L, \"\
    m\")\n    ];\n    string result = \"\";\n    foreach(i, romanNumeral; romanNumerals)\
    \ {\n        while(number >= romanNumeral.value) {\n            result ~= romanNumeral.symbol;\n\
    \            number -= romanNumeral.value;\n        }\n    }\n    return result;\n\
    }\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5qxh_q7g.d(48): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5qxh_q7g.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[int] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[int] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[int] roman_hundreds = [\n        \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[int] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n  \
    \  static string[int] roman_tenthousands = [\n        \"xm\", \"xxm\", \"xxxm\"\
    \n    ];\n    static string[int] roman_hundredthousands = [\n        \"cm\", \"\
    ccm\", \"cccm\"\n    ];\n    static string[int] roman_millions = [\n        \"\
    m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_tenmillions = [\n \
    \       \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundredmillions\
    \ = [\n        \"cm\", \"ccm\", \"cccm\"\n    ];\n    static string[int] roman_billions\
    \ = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_tenbillions\
    \ = [\n        \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundredbillions\
    \ = [\n        \"cm\", \"ccm\", \"cccm\"\n    ];\n    static string[int] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[int] roman_tentrillions\
    \ = [\n        \"xm\", \"xxm\", \"xxxm\"\n    ];\n    static string[int] roman_hundredtrillions\
    \ = [\n        \"cm\", \"ccm\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj4qe78sj.d(62): Error: unterminated string constant starting
    at /tmp/tmpj4qe78sj.d(81)\n/tmp/tmpj4qe78sj.d(68): Error: comma expected separating
    array initializers, not `xix`\n/tmp/tmpj4qe78sj.d(68): Error: semicolon expected,
    not `");\\x0a    assert(candidate(152L) == "c`\n/tmp/tmpj4qe78sj.d(69): Error:
    found `lii` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(70): Error:
    found `cli` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(71): Error:
    found `dxxvi` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(72):
    Error: Implicit string concatenation is deprecated, use ");\\x0a    assert(candidate(500L)
    == "d ~ ");\\x0a    assert(candidate(1L) == " instead\n/tmp/tmpj4qe78sj.d(73):
    Error: found `i` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(74):
    Error: found `iv` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(75):
    Error: found `xliii` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(76):
    Error: found `xc` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(77):
    Error: found `xciv` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(78):
    Error: found `xxxii` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(79):
    Error: found `m` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(80):
    Error: found `mxciv` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(81):
    Error: found `m` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(83):
    Error: found `End of File` when expecting `;` following statement\n/tmp/tmpj4qe78sj.d(83):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj4qe78sj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    string result = \"\";\n    while (number\
    \ > 0) \n    {\n        auto digit = number % 10;\n        result = roman_numerals[digit]\
    \ ~ result;\n        number /= 10;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpazgrykqq.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x42825d]\n??:? void tmpazgrykqq.__unittest_L30_C1() [0x427be4]\n??:?
    void tmpazgrykqq.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c0c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42afd2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ffa1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430450]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42ff2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42afa9]\n??:? runModuleUnitTests [0x42be99]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428720]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4286a7]\n??:? _d_run_main [0x428612]\n??:? main [0x427ff3]\n??:?
    __libc_start_main [0x2aebd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L,\
    \ 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n\
    \    static long[] roman_values = [1, 5, 10, 50, 100, 500, 1000];\n    static\
    \ long[] roman_values_reversed = roman_values.dup.reverse;\n    static string[]\
    \ roman_numerals_reversed = roman_numerals.dup.reverse;\n    static long[] roman_values_reversed_sorted\
    \ = roman_values_reversed.dup.sort;\n    static string[] roman_numerals_reversed_sorted\
    \ = roman_numerals_reversed.dup.sort;\n    static long[] roman_values_sorted =\
    \ roman_values_reversed_sorted.dup.reverse;\n    static string[] roman_numerals_sorted\
    \ = roman_numerals_reversed_sorted.dup.reverse;\n    static long[] roman_values_sorted_reversed\
    \ = roman_values_sorted.dup.reverse;\n    static string[] roman_numerals_sorted_reversed\
    \ = roman_numerals_sorted.dup.reverse;\n    static long[] roman_values_reversed_sorted_reversed\
    \ = roman_values_sorted_reversed.dup.reverse;\n    static string[] roman_numerals_reversed_sorted_reversed\
    \ = roman_numerals_sorted_reversed.dup.reverse;\n    static long[] roman_values_sorted_reversed_reversed\
    \ = roman_values_reversed_sorted_reversed.dup.reverse;\n    static string[] roman_numerals_sorted_reversed_reversed\
    \ = roman_numerals_reversed_sorted_reversed.dup.reverse;\n    static long[] roman_values_sorted_reversed_reversed_reversed\
    \ = roman_values_sorted_reversed_\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbd05bjb5.d(35): Error: semicolon expected, not `unittest`\n/tmp/tmpbd05bjb5.d(35):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbd05bjb5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] romans = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] romans_tens = [\"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static\
    \ string[10] romans_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] romans_thousands = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tenthousands = [\"\"\
    , \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] romans_hundredthousands =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] romans_millions = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tenmillions = [\"\"\
    , \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] romans_hundredmillions = [\"\
    \", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] romans_billions = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tenbillions = [\"\", \"\
    xm\", \"xxm\", \"xxxm\"];\n    static string[4] romans_hundredbillions = [\"\"\
    , \"cm\", \"ccm\", \"cccm\"];\n    static string[4] romans_trillions = [\"\",\
    \ \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tentrillions = [\"\",\
    \ \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] romans_hundredtrillions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] romans_quadrillions\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] romans_tenquadrillions\
    \ =\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyptpdjt9.d(37): Error: expression expected, not `unittest`\n/tmp/tmpyptpdjt9.d(38):
    Error: semicolon expected, not `{`\n/tmp/tmpyptpdjt9.d(56): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpyptpdjt9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\n        \"i\", \"ii\", \"\
    iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[10] roman_thousands = [\n        \"\
    m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n\
    \    ];\n    if (number > 0) {\n        if (number < 10) {\n            result\
    \ = roman_numerals[number - 1];\n        } else if (number < 100) {\n        \
    \    result = roman_tens[number / 10 - 1] ~ roman_numerals[number % 10 - 1];\n\
    \        } else if (number < 1000) {\n            result = roman_hundreds[number\
    \ / 100 - 1] ~ roman_tens[(number % 100) / 10 - 1] ~ roman_numerals[number % 10\
    \ - 1];\n        } else if (number < 10000) {\n            result = roman_thousands[number\
    \ / 1000 - 1] ~ roman_hundreds[(number % 1000) / 100 - 1] ~ roman_tens[(number\
    \ % 100) / 10 - 1] ~ roman_numerals[number % 10 - 1];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmph0r07vdu.d(39): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428826]\n??:? immutable(char)[] tmph0r07vdu.int_to_mini_roman(long)
    [0x427e39]\n??:? void tmph0r07vdu.__unittest_L46_C1() [0x4281c5]\n??:? void tmph0r07vdu.__modtest()
    [0x4284f4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430968]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430445]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b4c1]\n??:? runModuleUnitTests [0x42c3b1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c38]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428bbf]\n??:? _d_run_main [0x428b2a]\n??:? main [0x428507]\n??:?
    __libc_start_main [0x9e1ac554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result = \"\";\n    auto numeral = tuple(\"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\");\n    auto value\
    \ = tuple(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1);\n    foreach(i,\
    \ v; value)\n    {\n        while(number >= v)\n        {\n            result\
    \ ~= numeral[i];\n            number -= v;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number >= 1 && number <= 1000);\n    string result\
    \ = \"\";\n    result ~= roman_thousands[number / 1000];\n    number %= 1000;\n\
    \    result ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~=\
    \ roman_tens[number / 10];\n    number %= 10;\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz1_rl7hq.d(43): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpz1_rl7hq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] decimal_values = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400,\
    \ 500, 600, 700, 800, 900, 1000];\n    static const string[] roman_values = [\"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n   \
    \ static const string[] roman_values_upper = [\"I\", \"II\", \"III\", \"IV\",\
    \ \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XX\", \"XXX\", \"XL\", \"\
    L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\"\
    , \"DC\", \"DCC\", \"DCCC\", \"CM\", \"M\"];\n    static const string[] roman_values_lower\
    \ = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\
    , \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\
    ];\n    static const string[] roman_values_lower_mini = [\"i\", \"i\", \"i\",\
    \ \"i\", \"v\", \"v\", \"v\", \"v\", \"x\", \"x\", \"x\", \"x\", \"l\", \"l\"\
    , \"l\", \"l\", \"c\", \"c\", \"c\", \"c\", \"d\", \"d\", \"\nunittest\n{\n  \
    \  alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx198as0c.d(26): Error: unterminated string constant starting
    at /tmp/tmpx198as0c.d(44)\n/tmp/tmpx198as0c.d(31): Error: comma expected separating
    array initializers, not `xix`\n/tmp/tmpx198as0c.d(31): Error: semicolon expected,
    not `");\\x0a    assert(candidate(152L) == "c`\n/tmp/tmpx198as0c.d(32): Error:
    found `lii` when expecting `;` following statement\n/tmp/tmpx198as0c.d(33): Error:
    found `cli` when expecting `;` following statement\n/tmp/tmpx198as0c.d(34): Error:
    found `dxxvi` when expecting `;` following statement\n/tmp/tmpx198as0c.d(35):
    Error: Implicit string concatenation is deprecated, use ");\\x0a    assert(candidate(500L)
    == "d ~ ");\\x0a    assert(candidate(1L) == " instead\n/tmp/tmpx198as0c.d(36):
    Error: found `i` when expecting `;` following statement\n/tmp/tmpx198as0c.d(37):
    Error: found `iv` when expecting `;` following statement\n/tmp/tmpx198as0c.d(38):
    Error: found `xliii` when expecting `;` following statement\n/tmp/tmpx198as0c.d(39):
    Error: found `xc` when expecting `;` following statement\n/tmp/tmpx198as0c.d(40):
    Error: found `xciv` when expecting `;` following statement\n/tmp/tmpx198as0c.d(41):
    Error: found `xxxii` when expecting `;` following statement\n/tmp/tmpx198as0c.d(42):
    Error: found `m` when expecting `;` following statement\n/tmp/tmpx198as0c.d(43):
    Error: found `mxciv` when expecting `;` following statement\n/tmp/tmpx198as0c.d(44):
    Error: found `m` when expecting `;` following statement\n/tmp/tmpx198as0c.d(46):
    Error: found `End of File` when expecting `;` following statement\n/tmp/tmpx198as0c.d(46):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx198as0c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_thousands\
    \ = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_thousands\
    \ = [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_millions =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_millions = [\"\
    \", \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_millions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_billions = [\"\
    \", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_billions = [\"\"\
    , \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_billions = [\"\
    \", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_trillions = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_trillions = [\"\",\
    \ \"xm\", \"xxm\", \"xxxm\"];\n    static string[4] roman_hundred_trillions =\
    \ [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static string[4] roman_quadrillion =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    static string\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwtzllifb.d(37): Error: no identifier for declarator `string`\n/tmp/tmpwtzllifb.d(37):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpwtzllifb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
    \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
    \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ decimal_numerals = [\n        1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L,\
    \ 10L, 9L, 5L, 4L, 1L\n    ];\n    string result = \"\";\n    foreach(i, numeral;\
    \ roman_numerals)\n    {\n        while(number >= decimal_numerals[i])\n     \
    \   {\n            result ~= numeral;\n            number -= decimal_numerals[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
