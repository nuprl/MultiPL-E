language: d
name: HumanEval_3_below_zero
results:
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations) \n    {\n        balance +=\
    \ op;\n        if (balance < 0) \n        {\n            return true;\n      \
    \  }\n    }\n    return false;\n}\n/*\n    You're given a list of integers, and\
    \ you're asked to find the first element of the list that is\n    divisible by\
    \ 3. If there is no such element, function should return -1.\n    >>> first_divisible_by_3([1,\
    \ 2, 3, 4, 5, 6])\n    3\n    >>> first_divisible_by_3([1, 2, 4, 5, 6])\n    -1\n\
    */\nlong first_divisible_by_3(long[] nums) \n{\n    foreach(num; nums) \n    {\n\
    \        if (num % 3 == 0) \n        {\n            return num;\n        }\n \
    \   }\n    return -1;\n}\n/*\n    You're given a list of integers, and you're\
    \ asked to find the first element of the list that is\n    divisible by 3. If\
    \ there is no such element, function should return -1.\n    >>> first_divisible_by_3([1,\
    \ 2, 3, 4, 5, 6])\n    3\n    >>> first_divisible_by_3([1, 2, 4, 5, 6])\n    -1\n\
    */\nlong first_divisible_by_3(long[] nums) \n{\n    foreach(num; nums) \n    {\n\
    \        if (num % 3 == 0) \n        {\n            return num;\n        }\n \
    \   }\n    return -1;\n}\n/*\n    You're given a list of integers, and you're\
    \ asked to find the first element of the list that is\n    divisible by 3. If\
    \ there is no such element, function should return -1.\n    >>> first_divisible_by_3([1,\
    \ 2, 3, 4, 5, 6])\n    3\n    >>> first_divisible_by_3([1, 2, 4, 5, 6])\n    -1\n\
    */\nlong first_divisible_by_3(long[] nums) \n{\nunittest\n{\n    alias candidate\
    \ = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L,\
    \ 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L])\
    \ == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n\
    \    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L,\
    \ -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbtpnv7y2.d(74): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtpnv7y2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\n/*\n    You're given a list of deposit and withdrawal operations on a bank\
    \ account that starts with\n    zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n    at that point function\
    \ should return True. Otherwise it should return False.\n    >>> below_zero([1L,\
    \ 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n\
    */\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n You're given a list of deposit\
    \ and withdrawal operations on a bank account that starts with\n    zero balance.\
    \ Your task is to detect if at any point the balance of account fallls below zero,\
    \ and\n    at that point function should return True. Otherwise it should return\
    \ False.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L,\
    \ 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n\
    \    long balance = 0;\n    foreach(op; operations)\n    {\n        balance +=\
    \ op;\n        if(balance < 0)\n            return true;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([])\
    \ == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n  \
    \  assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L,\
    \ -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L,\
    \ 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L,\
    \ 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
