language: d
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            if(i > 0 && consonants.find(word[i-1])\
    \ != -1)\n            {\n                if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                {\n                    if(abs(i - (word.length - 1))\
    \ < distance)\n                    {\n                        distance = abs(i\
    \ - (word.length - 1));\n                        result = c;\n               \
    \     }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8w1g3nfn.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmp8w1g3nfn.d(31): Error: no property
    `find` for type `string`\n/tmp/tmp8w1g3nfn.d(33): Error: no property `find` for
    type `string`\n/tmp/tmp8w1g3nfn.d(35): Error: no property `find` for type `string`\n/tmp/tmp8w1g3nfn.d(39):
    Error: cannot implicitly convert expression `abs(i - (word.length - 1LU))` of
    type `ulong` to `int`\n/tmp/tmp8w1g3nfn.d(40): Error: cannot implicitly convert
    expression `c` of type `immutable(char)` to `string`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp8w1g3nfn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.canFind(word[index]))\n\
    \        {\n            distance = word.length - index - 1;\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = word[index..$];\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjusfd970.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpjusfd970.d(29): Error: cannot
    implicitly convert expression `word.length - 1LU` of type `ulong` to `int`\n/tmp/tmpjusfd970.d(32):
    Error: no property `canFind` for type `string`\n/tmp/tmpjusfd970.d(34): Error:
    cannot implicitly convert expression `word.length - cast(ulong)index - 1LU` of
    type `ulong` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjusfd970.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int vowel_index = -1;\n    int word_length = word.length;\n\
    \    int i = word_length - 1;\n    while (i >= 0)\n    {\n        if (consonants.find(word[i])\
    \ != -1)\n        {\n            int j = i - 1;\n            while (j >= 0)\n\
    \            {\n                if (vowels.find(word[j]) != -1)\n            \
    \    {\n                    if (vowel_index == -1)\n                    {\n  \
    \                      vowel_index = j;\n                        closest_vowel\
    \ = word[j];\n                    }\n                    else\n              \
    \      {\n                        if (abs(i - j) < abs(i - vowel_index))\n   \
    \                     {\n                            vowel_index = j;\n      \
    \                      closest_vowel = word[j];\n                        }\n \
    \                   }\n                }\n                j--;\n            }\n\
    \        }\n        i--;\n    }\n    return closest_vowel;\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2fkv98cg.d(29): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmp2fkv98cg.d(33): Error: no property
    `find` for type `string`\n/tmp/tmp2fkv98cg.d(38): Error: no property `find` for
    type `string`\n/tmp/tmp2fkv98cg.d(43): Error: cannot implicitly convert expression
    `word[cast(ulong)j]` of type `immutable(char)` to `string`\n/tmp/tmp2fkv98cg.d(50):
    Error: cannot implicitly convert expression `word[cast(ulong)j]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2fkv98cg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_dist = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int dist = word.length - i;\n            if(dist < min_dist)\n    \
    \        {\n                min_dist = dist;\n                index = i;\n   \
    \         }\n        }\n    }\n    if(index != 0)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb1g9b738.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpb1g9b738.d(31): Error: no property
    `canFind` for type `string`\n/tmp/tmpb1g9b738.d(33): Error: cannot implicitly
    convert expression `word.length - i` of type `ulong` to `int`\n/tmp/tmpb1g9b738.d(37):
    Error: cannot implicitly convert expression `i` of type `ulong` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1g9b738.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = 0;\n    int closest_consonant_index\
    \ = 0;\n    int closest_distance = 0;\n    int current_distance = 0;\n    int\
    \ current_vowel_index = 0;\n    int current_consonant_index = 0;\n    bool found_vowel\
    \ = false;\n    bool found_consonant = false;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  found_vowel = true;\n            current_vowel_index = i;\n        }\n    \
    \    else if (consonants.find(word[i]) != -1)\n        {\n            found_consonant\
    \ = true;\n            current_consonant_index = i;\n        }\n        if (found_vowel\
    \ && found_consonant)\n        {\n            current_distance = current_consonant_index\
    \ - current_vowel_index;\n            if (current_distance > closest_distance)\n\
    \            {\n                closest_distance = current_distance;\n       \
    \         closest_vowel_index = current_vowel_index;\n                closest_consonant_index\
    \ = current_consonant_index;\n            }\n            found_vowel = false;\n\
    \            found_consonant = false;\n        }\n    }\n    if (closest_vowel_index\
    \ != 0)\n    {\n        closest_vowel = word[closest_vowel_index];\n    }\n  \
    \  return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvkdjv62z.d(38): Error: no property `find` for type `string`\n/tmp/tmpvkdjv62z.d(43):
    Error: no property `find` for type `string`\n/tmp/tmpvkdjv62z.d(63): Error: cannot
    implicitly convert expression `word[cast(ulong)closest_vowel_index]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvkdjv62z.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsdy7waaz.d(27): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpsdy7waaz.d(30): Error: no property
    `canFind` for type `string`\n/tmp/tmpsdy7waaz.d(32): Error: cannot implicitly
    convert expression `word.length - i` of type `ulong` to `int`\n/tmp/tmpsdy7waaz.d(36):
    Error: cannot implicitly convert expression `c` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsdy7waaz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, vowel; vowels)\n\
    \    {\n        int index = word.find(vowel);\n        if(index != -1)\n     \
    \   {\n            int distance = word.length - index;\n            if(distance\
    \ < min_distance)\n            {\n                int left_index = index - 1;\n\
    \                int right_index = index + 1;\n                if(left_index >=\
    \ 0 && right_index < word.length)\n                {\n                    if(consonants.find(word[left_index])\
    \ != -1 && consonants.find(word[right_index]) != -1)\n                    {\n\
    \                        min_distance = distance;\n                        result\
    \ = word[index..$];\n                    }\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnurdkjt7.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpnurdkjt7.d(31): Error: no property
    `find` for type `string`\n/tmp/tmpnurdkjt7.d(34): Error: cannot implicitly convert
    expression `word.length - cast(ulong)index` of type `ulong` to `int`\n/tmp/tmpnurdkjt7.d(41):
    Error: no property `find` for type `string`\n/tmp/tmpnurdkjt7.d(41): Error: no
    property `find` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnurdkjt7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_index = word.length;\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            if(index > 0 && consonants.find(word[index -\
    \ 1]) != -1)\n            {\n                int distance = word.length - index;\n\
    \                if(distance < min_distance)\n                {\n            \
    \        min_distance = distance;\n                    min_index = index;\n  \
    \                  result = c;\n                }\n            }\n        }\n\
    \        index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4fnplgw3.d(29): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmp4fnplgw3.d(30): Error: cannot
    implicitly convert expression `word.length` of type `ulong` to `int`\n/tmp/tmp4fnplgw3.d(33):
    Error: no property `find` for type `string`\n/tmp/tmp4fnplgw3.d(35): Error: no
    property `find` for type `string`\n/tmp/tmp4fnplgw3.d(37): Error: cannot implicitly
    convert expression `word.length - cast(ulong)index` of type `ulong` to `int`\n/tmp/tmp4fnplgw3.d(42):
    Error: cannot implicitly convert expression `c` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4fnplgw3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ char c; word)\n    {\n        if(vowels.canFind(c))\n        {\n           \
    \ int distance = word.length - i;\n            if(distance < min_distance)\n \
    \           {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp27qsvom2.d(27): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmp27qsvom2.d(30): Error: no property
    `canFind` for type `string`\n/tmp/tmp27qsvom2.d(32): Error: cannot implicitly
    convert expression `word.length - i` of type `ulong` to `int`\n/tmp/tmp27qsvom2.d(36):
    Error: cannot implicitly convert expression `c` of type `char` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27qsvom2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_dist = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            int dist = word.length\
    \ - i;\n            if(dist < min_dist)\n            {\n                if(i ==\
    \ 0)\n                {\n                    if(consonants.find(word[i+1]) !=\
    \ -1)\n                    {\n                        min_dist = dist;\n     \
    \                   result = c;\n                    }\n                }\n  \
    \              else if(i == word.length - 1)\n                {\n            \
    \        if(consonants.find(word[i-1]) != -1)\n                    {\n       \
    \                 min_dist = dist;\n                        result = c;\n    \
    \                }\n                }\n                else\n                {\n\
    \                    if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_dist = dist;\n  \
    \                      result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdfe7ytjp.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpdfe7ytjp.d(31): Error: no property
    `find` for type `string`\n/tmp/tmpdfe7ytjp.d(33): Error: cannot implicitly convert
    expression `word.length - i` of type `ulong` to `int`\n/tmp/tmpdfe7ytjp.d(38):
    Error: no property `find` for type `string`\n/tmp/tmpdfe7ytjp.d(41): Error: cannot
    implicitly convert expression `c` of type `immutable(char)` to `string`\n/tmp/tmpdfe7ytjp.d(46):
    Error: no property `find` for type `string`\n/tmp/tmpdfe7ytjp.d(49): Error: cannot
    implicitly convert expression `c` of type `immutable(char)` to `string`\n/tmp/tmpdfe7ytjp.d(54):
    Error: no property `find` for type `string`\n/tmp/tmpdfe7ytjp.d(54): Error: no
    property `find` for type `string`\n/tmp/tmpdfe7ytjp.d(57): Error: cannot implicitly
    convert expression `c` of type `immutable(char)` to `string`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpdfe7ytjp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            if(consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n            {\n                if(abs(i\
    \ - word.length) < distance)\n                {\n                    distance\
    \ = abs(i - word.length);\n                    result = c;\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxaa0p_i_.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpxaa0p_i_.d(31): Error: no property
    `find` for type `string`\n/tmp/tmpxaa0p_i_.d(33): Error: no property `find` for
    type `string`\n/tmp/tmpxaa0p_i_.d(33): Error: no property `find` for type `string`\n/tmp/tmpxaa0p_i_.d(37):
    Error: cannot implicitly convert expression `abs(i - word.length)` of type `ulong`
    to `int`\n/tmp/tmpxaa0p_i_.d(38): Error: cannot implicitly convert expression
    `c` of type `immutable(char)` to `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpxaa0p_i_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    int closest =\
    \ word.length;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index < closest)\n            {\n       \
    \         result = word[index..$];\n                closest = index;\n       \
    \     }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2w12007_.d(27): Error: cannot implicitly convert expression
    `word.length - 1LU` of type `ulong` to `int`\n/tmp/tmp2w12007_.d(28): Error: cannot
    implicitly convert expression `word.length` of type `ulong` to `int`\n/tmp/tmp2w12007_.d(31):
    Error: no property `find` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp2w12007_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsdy7waaz.d(27): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpsdy7waaz.d(30): Error: no property
    `canFind` for type `string`\n/tmp/tmpsdy7waaz.d(32): Error: cannot implicitly
    convert expression `word.length - i` of type `ulong` to `int`\n/tmp/tmpsdy7waaz.d(36):
    Error: cannot implicitly convert expression `c` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsdy7waaz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpei__x3q_.d(27): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpei__x3q_.d(30): Error: no property
    `find` for type `string`\n/tmp/tmpei__x3q_.d(32): Error: cannot implicitly convert
    expression `word.length - i` of type `ulong` to `int`\n/tmp/tmpei__x3q_.d(36):
    Error: cannot implicitly convert expression `c` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpei__x3q_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(min_distance == word.length)\n\
    \        return result;\n    else\n    {\n        if(consonants.find(word[index\
    \ - 1]) != -1)\n            return word[index..$];\n        else\n           \
    \ return result;\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz55wxr34.d(29): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpz55wxr34.d(32): Error: no property
    `find` for type `string`\n/tmp/tmpz55wxr34.d(34): Error: cannot implicitly convert
    expression `word.length - i` of type `ulong` to `int`\n/tmp/tmpz55wxr34.d(38):
    Error: cannot implicitly convert expression `i` of type `ulong` to `int`\n/tmp/tmpz55wxr34.d(46):
    Error: no property `find` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpz55wxr34.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if (consonants.find(word[i+1])\
    \ != -1 && distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq09m5kdx.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpq09m5kdx.d(31): Error: no property
    `find` for type `string`\n/tmp/tmpq09m5kdx.d(33): Error: cannot implicitly convert
    expression `word.length - cast(ulong)i` of type `ulong` to `int`\n/tmp/tmpq09m5kdx.d(34):
    Error: no property `find` for type `string`\n/tmp/tmpq09m5kdx.d(37): Error: cannot
    implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to
    `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq09m5kdx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, vowel; vowels)\n\
    \    {\n        int index = word.find(vowel);\n        if(index != -1)\n     \
    \   {\n            if(index != 0 && index != word.length - 1)\n            {\n\
    \                if(consonants.find(word[index - 1]) != -1 && consonants.find(word[index\
    \ + 1]) != -1)\n                {\n                    if(index < min_distance)\n\
    \                    {\n                        min_distance = index;\n      \
    \                  result = vowel;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn10b4h_l.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpn10b4h_l.d(31): Error: no property
    `find` for type `string`\n/tmp/tmpn10b4h_l.d(36): Error: no property `find` for
    type `string`\n/tmp/tmpn10b4h_l.d(36): Error: no property `find` for type `string`\n/tmp/tmpn10b4h_l.d(41):
    Error: cannot implicitly convert expression `vowel` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn10b4h_l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int minDistance = word.length;\n    foreach(i, c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < minDistance)\n            {\n\
    \                minDistance = distance;\n                result = c;\n      \
    \      }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvm4efdja.d(27): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpvm4efdja.d(30): Error: no property
    `canFind` for type `string`\n/tmp/tmpvm4efdja.d(32): Error: cannot implicitly
    convert expression `word.length - i` of type `ulong` to `int`\n/tmp/tmpvm4efdja.d(36):
    Error: cannot implicitly convert expression `c` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm4efdja.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && i < word.length - 1)\n         \
    \   {\n                if (vowels.find(word[i-1]) == -1 && vowels.find(word[i+1])\
    \ == -1)\n                {\n                    distance = word.length - i;\n\
    \                    if (distance < min_distance)\n                    {\n   \
    \                     min_distance = distance;\n                        result\
    \ = word[i];\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4iz0epli.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmp4iz0epli.d(31): Error: no property
    `find` for type `string`\n/tmp/tmp4iz0epli.d(35): Error: no property `find` for
    type `string`\n/tmp/tmp4iz0epli.d(35): Error: no property `find` for type `string`\n/tmp/tmp4iz0epli.d(37):
    Error: cannot implicitly convert expression `word.length - cast(ulong)i` of type
    `ulong` to `int`\n/tmp/tmp4iz0epli.d(41): Error: cannot implicitly convert expression
    `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4iz0epli.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int left = i;\n \
    \           int right = i;\n            while(left >= 0 && consonants.canFind(word[left]))\n\
    \                left--;\n            while(right < word.length && consonants.canFind(word[right]))\n\
    \                right++;\n            if(left >= 0 && right < word.length)\n\
    \            {\n                if(distance > abs(i - left))\n               \
    \ {\n                    distance = abs(i - left);\n                    result\
    \ = c;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpll4m57f9.d(28): Error: cannot implicitly convert expression
    `word.length` of type `ulong` to `int`\n/tmp/tmpll4m57f9.d(31): Error: no property
    `canFind` for type `string`\n/tmp/tmpll4m57f9.d(33): Error: cannot implicitly
    convert expression `i` of type `ulong` to `int`\n/tmp/tmpll4m57f9.d(34): Error:
    cannot implicitly convert expression `i` of type `ulong` to `int`\n/tmp/tmpll4m57f9.d(35):
    Error: no property `canFind` for type `string`\n/tmp/tmpll4m57f9.d(37): Error:
    no property `canFind` for type `string`\n/tmp/tmpll4m57f9.d(43): Error: cannot
    implicitly convert expression `abs(i - cast(ulong)left)` of type `ulong` to `int`\n/tmp/tmpll4m57f9.d(44):
    Error: cannot implicitly convert expression `c` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpll4m57f9.d", "-I/tmp"]\n'''
  stdout: b''
