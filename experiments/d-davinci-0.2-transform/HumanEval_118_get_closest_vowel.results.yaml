language: d
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            if(i > 0 && consonants.find(word[i-1])\
    \ != -1)\n            {\n                if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                {\n                    if(abs(i - (word.length - 1))\
    \ < distance)\n                    {\n                        distance = abs(i\
    \ - (word.length - 1));\n                        result = c;\n               \
    \     }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfw22mzla.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpfw22mzla.d(31): Error: no property `find` for type `string`

    /tmp/tmpfw22mzla.d(33): Error: no property `find` for type `string`

    /tmp/tmpfw22mzla.d(35): Error: no property `find` for type `string`

    /tmp/tmpfw22mzla.d(39): Error: cannot implicitly convert expression `abs(i - (word.length
    - 1LU))` of type `ulong` to `int`

    /tmp/tmpfw22mzla.d(40): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfw22mzla.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int index = word.length - 1;\n    while (index >= 0)\n    {\n        if (vowels.canFind(word[index]))\n\
    \        {\n            distance = word.length - index - 1;\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = word[index..$];\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3mjc4x74.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3mjc4x74.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp3mjc4x74.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp3mjc4x74.d(34): Error: cannot implicitly convert expression `word.length
    - cast(ulong)index - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3mjc4x74.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int vowel_index = -1;\n    int word_length = word.length;\n\
    \    int i = word_length - 1;\n    while (i >= 0)\n    {\n        if (consonants.find(word[i])\
    \ != -1)\n        {\n            int j = i - 1;\n            while (j >= 0)\n\
    \            {\n                if (vowels.find(word[j]) != -1)\n            \
    \    {\n                    if (vowel_index == -1)\n                    {\n  \
    \                      vowel_index = j;\n                        closest_vowel\
    \ = word[j];\n                    }\n                    else\n              \
    \      {\n                        if (abs(i - j) < abs(i - vowel_index))\n   \
    \                     {\n                            vowel_index = j;\n      \
    \                      closest_vowel = word[j];\n                        }\n \
    \                   }\n                }\n                j--;\n            }\n\
    \        }\n        i--;\n    }\n    return closest_vowel;\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmcee293y.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpmcee293y.d(33): Error: no property `find` for type `string`

    /tmp/tmpmcee293y.d(38): Error: no property `find` for type `string`

    /tmp/tmpmcee293y.d(43): Error: cannot implicitly convert expression `word[cast(ulong)j]`
    of type `immutable(char)` to `string`

    /tmp/tmpmcee293y.d(50): Error: cannot implicitly convert expression `word[cast(ulong)j]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmcee293y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_dist = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int dist = word.length - i;\n            if(dist < min_dist)\n    \
    \        {\n                min_dist = dist;\n                index = i;\n   \
    \         }\n        }\n    }\n    if(index != 0)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp45i_89bd.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp45i_89bd.d(31): Error: no property `canFind` for type `string`

    /tmp/tmp45i_89bd.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp45i_89bd.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp45i_89bd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = 0;\n    int closest_consonant_index\
    \ = 0;\n    int closest_distance = 0;\n    int current_distance = 0;\n    int\
    \ current_vowel_index = 0;\n    int current_consonant_index = 0;\n    bool found_vowel\
    \ = false;\n    bool found_consonant = false;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  found_vowel = true;\n            current_vowel_index = i;\n        }\n    \
    \    else if (consonants.find(word[i]) != -1)\n        {\n            found_consonant\
    \ = true;\n            current_consonant_index = i;\n        }\n        if (found_vowel\
    \ && found_consonant)\n        {\n            current_distance = current_consonant_index\
    \ - current_vowel_index;\n            if (current_distance > closest_distance)\n\
    \            {\n                closest_distance = current_distance;\n       \
    \         closest_vowel_index = current_vowel_index;\n                closest_consonant_index\
    \ = current_consonant_index;\n            }\n            found_vowel = false;\n\
    \            found_consonant = false;\n        }\n    }\n    if (closest_vowel_index\
    \ != 0)\n    {\n        closest_vowel = word[closest_vowel_index];\n    }\n  \
    \  return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjun3vzcg.d(38): Error: no property `find` for type `string`

    /tmp/tmpjun3vzcg.d(43): Error: no property `find` for type `string`

    /tmp/tmpjun3vzcg.d(63): Error: cannot implicitly convert expression `word[cast(ulong)closest_vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjun3vzcg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, vowel; vowels)\n\
    \    {\n        int index = word.find(vowel);\n        if(index != -1)\n     \
    \   {\n            int distance = word.length - index;\n            if(distance\
    \ < min_distance)\n            {\n                int left_index = index - 1;\n\
    \                int right_index = index + 1;\n                if(left_index >=\
    \ 0 && right_index < word.length)\n                {\n                    if(consonants.find(word[left_index])\
    \ != -1 && consonants.find(word[right_index]) != -1)\n                    {\n\
    \                        min_distance = distance;\n                        result\
    \ = word[index..$];\n                    }\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpggnc5ef_.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpggnc5ef_.d(31): Error: no property `find` for type `string`

    /tmp/tmpggnc5ef_.d(34): Error: cannot implicitly convert expression `word.length
    - cast(ulong)index` of type `ulong` to `int`

    /tmp/tmpggnc5ef_.d(41): Error: no property `find` for type `string`

    /tmp/tmpggnc5ef_.d(41): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpggnc5ef_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_index = word.length;\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            if(index > 0 && consonants.find(word[index -\
    \ 1]) != -1)\n            {\n                int distance = word.length - index;\n\
    \                if(distance < min_distance)\n                {\n            \
    \        min_distance = distance;\n                    min_index = index;\n  \
    \                  result = c;\n                }\n            }\n        }\n\
    \        index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpupinna1y.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpupinna1y.d(30): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpupinna1y.d(33): Error: no property `find` for type `string`

    /tmp/tmpupinna1y.d(35): Error: no property `find` for type `string`

    /tmp/tmpupinna1y.d(37): Error: cannot implicitly convert expression `word.length
    - cast(ulong)index` of type `ulong` to `int`

    /tmp/tmpupinna1y.d(42): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpupinna1y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ char c; word)\n    {\n        if(vowels.canFind(c))\n        {\n           \
    \ int distance = word.length - i;\n            if(distance < min_distance)\n \
    \           {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr23z2i1s.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpr23z2i1s.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpr23z2i1s.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpr23z2i1s.d(36): Error: cannot implicitly convert expression `c` of type
    `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr23z2i1s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_dist = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            int dist = word.length\
    \ - i;\n            if(dist < min_dist)\n            {\n                if(i ==\
    \ 0)\n                {\n                    if(consonants.find(word[i+1]) !=\
    \ -1)\n                    {\n                        min_dist = dist;\n     \
    \                   result = c;\n                    }\n                }\n  \
    \              else if(i == word.length - 1)\n                {\n            \
    \        if(consonants.find(word[i-1]) != -1)\n                    {\n       \
    \                 min_dist = dist;\n                        result = c;\n    \
    \                }\n                }\n                else\n                {\n\
    \                    if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_dist = dist;\n  \
    \                      result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2nj62uw5.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp2nj62uw5.d(31): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp2nj62uw5.d(38): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(41): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp2nj62uw5.d(46): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(49): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp2nj62uw5.d(54): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(54): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(57): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2nj62uw5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            if(consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n            {\n                if(abs(i\
    \ - word.length) < distance)\n                {\n                    distance\
    \ = abs(i - word.length);\n                    result = c;\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg9guj1g3.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpg9guj1g3.d(31): Error: no property `find` for type `string`

    /tmp/tmpg9guj1g3.d(33): Error: no property `find` for type `string`

    /tmp/tmpg9guj1g3.d(33): Error: no property `find` for type `string`

    /tmp/tmpg9guj1g3.d(37): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmpg9guj1g3.d(38): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9guj1g3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    int closest =\
    \ word.length;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index < closest)\n            {\n       \
    \         result = word[index..$];\n                closest = index;\n       \
    \     }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw05krbh5.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpw05krbh5.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpw05krbh5.d(31): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw05krbh5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpds3xz59i.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpds3xz59i.d(30): Error: no property `find` for type `string`

    /tmp/tmpds3xz59i.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpds3xz59i.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpds3xz59i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(min_distance == word.length)\n\
    \        return result;\n    else\n    {\n        if(consonants.find(word[index\
    \ - 1]) != -1)\n            return word[index..$];\n        else\n           \
    \ return result;\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpketxa8uf.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpketxa8uf.d(32): Error: no property `find` for type `string`

    /tmp/tmpketxa8uf.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpketxa8uf.d(38): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpketxa8uf.d(46): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpketxa8uf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if (consonants.find(word[i+1])\
    \ != -1 && distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = word[i];\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ceg7wcl.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7ceg7wcl.d(31): Error: no property `find` for type `string`

    /tmp/tmp7ceg7wcl.d(33): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmp7ceg7wcl.d(34): Error: no property `find` for type `string`

    /tmp/tmp7ceg7wcl.d(37): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ceg7wcl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, vowel; vowels)\n\
    \    {\n        int index = word.find(vowel);\n        if(index != -1)\n     \
    \   {\n            if(index != 0 && index != word.length - 1)\n            {\n\
    \                if(consonants.find(word[index - 1]) != -1 && consonants.find(word[index\
    \ + 1]) != -1)\n                {\n                    if(index < min_distance)\n\
    \                    {\n                        min_distance = index;\n      \
    \                  result = vowel;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb1zl80gs.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpb1zl80gs.d(31): Error: no property `find` for type `string`

    /tmp/tmpb1zl80gs.d(36): Error: no property `find` for type `string`

    /tmp/tmpb1zl80gs.d(36): Error: no property `find` for type `string`

    /tmp/tmpb1zl80gs.d(41): Error: cannot implicitly convert expression `vowel` of
    type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1zl80gs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int minDistance = word.length;\n    foreach(i, c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < minDistance)\n            {\n\
    \                minDistance = distance;\n                result = c;\n      \
    \      }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp679jaynl.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp679jaynl.d(30): Error: no property `canFind` for type `string`

    /tmp/tmp679jaynl.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp679jaynl.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp679jaynl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && i < word.length - 1)\n         \
    \   {\n                if (vowels.find(word[i-1]) == -1 && vowels.find(word[i+1])\
    \ == -1)\n                {\n                    distance = word.length - i;\n\
    \                    if (distance < min_distance)\n                    {\n   \
    \                     min_distance = distance;\n                        result\
    \ = word[i];\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjwvabbho.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjwvabbho.d(31): Error: no property `find` for type `string`

    /tmp/tmpjwvabbho.d(35): Error: no property `find` for type `string`

    /tmp/tmpjwvabbho.d(35): Error: no property `find` for type `string`

    /tmp/tmpjwvabbho.d(37): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmpjwvabbho.d(41): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwvabbho.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int left = i;\n \
    \           int right = i;\n            while(left >= 0 && consonants.canFind(word[left]))\n\
    \                left--;\n            while(right < word.length && consonants.canFind(word[right]))\n\
    \                right++;\n            if(left >= 0 && right < word.length)\n\
    \            {\n                if(distance > abs(i - left))\n               \
    \ {\n                    distance = abs(i - left);\n                    result\
    \ = c;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz8l0dw_o.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpz8l0dw_o.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpz8l0dw_o.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpz8l0dw_o.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpz8l0dw_o.d(35): Error: no property `canFind` for type `string`

    /tmp/tmpz8l0dw_o.d(37): Error: no property `canFind` for type `string`

    /tmp/tmpz8l0dw_o.d(43): Error: cannot implicitly convert expression `abs(i - cast(ulong)left)`
    of type `ulong` to `int`

    /tmp/tmpz8l0dw_o.d(44): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz8l0dw_o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >=\
    \ 0)\n    {\n        if (vowels.canFind(word[index]))\n        {\n           \
    \ if (index > 0 && vowels.canFind(word[index - 1]))\n            {\n         \
    \       index--;\n                continue;\n            }\n            else if\
    \ (index < word.length - 1 && vowels.canFind(word[index + 1]))\n            {\n\
    \                index++;\n                continue;\n            }\n        \
    \    else\n            {\n                result = word[index..$];\n         \
    \       break;\n            }\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0fit9lz7.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp0fit9lz7.d(30): Error: no property `canFind` for type `string`

    /tmp/tmp0fit9lz7.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp0fit9lz7.d(37): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0fit9lz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int pos = word.find(c);\n\
    \            if(pos > 0 && pos < word.length - 1)\n            {\n           \
    \     if(!vowels.canFind(word[pos - 1]) && !vowels.canFind(word[pos + 1]))\n \
    \               {\n                    if(distance > pos)\n                  \
    \  {\n                        distance = pos;\n                        result\
    \ = c;\n                    }\n                }\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4bzj12q7.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp4bzj12q7.d(30): Error: no property `canFind` for type `string`

    /tmp/tmp4bzj12q7.d(32): Error: no property `find` for type `string`

    /tmp/tmp4bzj12q7.d(35): Error: no property `canFind` for type `string`

    /tmp/tmp4bzj12q7.d(35): Error: no property `canFind` for type `string`

    /tmp/tmp4bzj12q7.d(40): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4bzj12q7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i > 0 && i < word.length - 1)\n            {\n              \
    \  if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n   \
    \             {\n                    int distance = word.length - i;\n       \
    \             if (distance < min_distance)\n                    {\n          \
    \              min_distance = distance;\n                        result = word[i..$];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcfx47sxl.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpcfx47sxl.d(30): Error: no property `find` for type `string`

    /tmp/tmpcfx47sxl.d(34): Error: no property `find` for type `string`

    /tmp/tmpcfx47sxl.d(34): Error: no property `find` for type `string`

    /tmp/tmpcfx47sxl.d(36): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcfx47sxl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length - 1;\n    while (index >= 0)\n \
    \   {\n        if (consonants.find(word[index]) != -1)\n        {\n          \
    \  if (index == word.length - 1)\n            {\n                index--;\n  \
    \              continue;\n            }\n            if (vowels.find(word[index\
    \ + 1]) != -1)\n            {\n                result = word[index + 1];\n   \
    \             break;\n            }\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw3hkn6s2.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpw3hkn6s2.d(31): Error: no property `find` for type `string`

    /tmp/tmpw3hkn6s2.d(38): Error: no property `find` for type `string`

    /tmp/tmpw3hkn6s2.d(40): Error: cannot implicitly convert expression `word[cast(ulong)(index
    + 1)]` of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw3hkn6s2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8boq0faa.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8boq0faa.d(30): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(32): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(34): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8boq0faa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = 0;\n            for(int j = i + 1; j < word.length; j++)\n            {\n\
    \                if(consonants.find(word[j]) != -1)\n                {\n     \
    \               distance = j - i;\n                    break;\n              \
    \  }\n            }\n            if(distance != 0 && distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4tq2ljo3.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp4tq2ljo3.d(31): Error: no property `find` for type `string`

    /tmp/tmp4tq2ljo3.d(34): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmp4tq2ljo3.d(36): Error: no property `find` for type `string`

    /tmp/tmp4tq2ljo3.d(38): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmp4tq2ljo3.d(45): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4tq2ljo3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int left_distance\
    \ = 0;\n            int right_distance = 0;\n            for(int j = i - 1; j\
    \ >= 0; j--)\n            {\n                if(consonants.find(word[j]) != -1)\n\
    \                {\n                    left_distance = i - j;\n             \
    \       break;\n                }\n            }\n            for(int j = i +\
    \ 1; j < word.length; j++)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    right_distance = j - i;\n   \
    \                 break;\n                }\n            }\n            if(left_distance\
    \ != 0 && right_distance != 0)\n            {\n                if(min_distance\
    \ > left_distance + right_distance)\n                {\n                    min_distance\
    \ = left_distance + right_distance;\n                    result = c;\n       \
    \         }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsus4_q7j.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpsus4_q7j.d(31): Error: no property `find` for type `string`

    /tmp/tmpsus4_q7j.d(35): Error: cannot implicitly convert expression `i - 1LU`
    of type `ulong` to `int`

    /tmp/tmpsus4_q7j.d(37): Error: no property `find` for type `string`

    /tmp/tmpsus4_q7j.d(39): Error: cannot implicitly convert expression `i - cast(ulong)j`
    of type `ulong` to `int`

    /tmp/tmpsus4_q7j.d(43): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmpsus4_q7j.d(45): Error: no property `find` for type `string`

    /tmp/tmpsus4_q7j.d(47): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmpsus4_q7j.d(56): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsus4_q7j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_dist = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            int dist = word.length\
    \ - i;\n            if(dist < min_dist)\n            {\n                if(i ==\
    \ 0)\n                {\n                    if(consonants.find(word[i+1]) !=\
    \ -1)\n                    {\n                        min_dist = dist;\n     \
    \                   result = c;\n                    }\n                }\n  \
    \              else if(i == word.length - 1)\n                {\n            \
    \        if(consonants.find(word[i-1]) != -1)\n                    {\n       \
    \                 min_dist = dist;\n                        result = c;\n    \
    \                }\n                }\n                else\n                {\n\
    \                    if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_dist = dist;\n  \
    \                      result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2nj62uw5.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp2nj62uw5.d(31): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp2nj62uw5.d(38): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(41): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp2nj62uw5.d(46): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(49): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp2nj62uw5.d(54): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(54): Error: no property `find` for type `string`

    /tmp/tmp2nj62uw5.d(57): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2nj62uw5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n      \
    \  {\n            int vowel_index = word.find_first_of(vowels, i);\n         \
    \   if(vowel_index != -1)\n            {\n                distance = vowel_index\
    \ - i;\n                if(distance < min_distance)\n                {\n     \
    \               min_distance = distance;\n                    result = word[vowel_index..vowel_index];\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn9lsna6f.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpn9lsna6f.d(32): Error: no property `find` for type `string`

    /tmp/tmpn9lsna6f.d(34): Error: no property `find_first_of` for type `string`

    /tmp/tmpn9lsna6f.d(37): Error: cannot implicitly convert expression `cast(ulong)vowel_index
    - i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn9lsna6f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_dist = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            int left_dist\
    \ = 0;\n            int right_dist = 0;\n            for(int j = i - 1; j >= 0;\
    \ j--)\n            {\n                if(consonants.find(word[j]) != -1)\n  \
    \              {\n                    left_dist = i - j;\n                   \
    \ break;\n                }\n            }\n            for(int j = i + 1; j <\
    \ word.length; j++)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    right_dist = j - i;\n       \
    \             break;\n                }\n            }\n            if(left_dist\
    \ != 0 && right_dist != 0)\n            {\n                int dist = min(left_dist,\
    \ right_dist);\n                if(dist < min_dist)\n                {\n     \
    \               min_dist = dist;\n                    result = c;\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjdp33o23.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjdp33o23.d(31): Error: no property `find` for type `string`

    /tmp/tmpjdp33o23.d(35): Error: cannot implicitly convert expression `i - 1LU`
    of type `ulong` to `int`

    /tmp/tmpjdp33o23.d(37): Error: no property `find` for type `string`

    /tmp/tmpjdp33o23.d(39): Error: cannot implicitly convert expression `i - cast(ulong)j`
    of type `ulong` to `int`

    /tmp/tmpjdp33o23.d(43): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmpjdp33o23.d(45): Error: no property `find` for type `string`

    /tmp/tmpjdp33o23.d(47): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmpjdp33o23.d(53): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpjdp33o23.d(57): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjdp33o23.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n        {\n\
    \            int vowel_index = word.find(vowels, i);\n            if(vowel_index\
    \ != -1)\n            {\n                int distance = vowel_index - i;\n   \
    \             if(distance < min_distance)\n                {\n               \
    \     min_distance = distance;\n                    index = vowel_index;\n   \
    \             }\n            }\n        }\n    }\n    if(index != 0)\n    {\n\
    \        result = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpop7oftt6.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpop7oftt6.d(32): Error: no property `find` for type `string`

    /tmp/tmpop7oftt6.d(34): Error: no property `find` for type `string`

    /tmp/tmpop7oftt6.d(37): Error: cannot implicitly convert expression `cast(ulong)vowel_index
    - i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpop7oftt6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int left_distance\
    \ = 0;\n            int right_distance = 0;\n            for(int j = i - 1; j\
    \ >= 0; j--)\n            {\n                if(consonants.find(word[j]) != -1)\n\
    \                {\n                    left_distance = i - j;\n             \
    \       break;\n                }\n            }\n            for(int j = i +\
    \ 1; j < word.length; j++)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    right_distance = j - i;\n   \
    \                 break;\n                }\n            }\n            if(left_distance\
    \ != 0 && right_distance != 0)\n            {\n                int distance =\
    \ min(left_distance, right_distance);\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         result = c;\n                }\n            }\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsswwt3zt.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpsswwt3zt.d(31): Error: no property `find` for type `string`

    /tmp/tmpsswwt3zt.d(35): Error: cannot implicitly convert expression `i - 1LU`
    of type `ulong` to `int`

    /tmp/tmpsswwt3zt.d(37): Error: no property `find` for type `string`

    /tmp/tmpsswwt3zt.d(39): Error: cannot implicitly convert expression `i - cast(ulong)j`
    of type `ulong` to `int`

    /tmp/tmpsswwt3zt.d(43): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmpsswwt3zt.d(45): Error: no property `find` for type `string`

    /tmp/tmpsswwt3zt.d(47): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmpsswwt3zt.d(53): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpsswwt3zt.d(57): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsswwt3zt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i == 0)\n                {\n                    if(consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \                else if(i == word.length - 1)\n                {\n          \
    \          if(consonants.find(word[i-1]) != -1)\n                    {\n     \
    \                   min_distance = distance;\n                        result =\
    \ c;\n                    }\n                }\n                else\n       \
    \         {\n                    if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpme0wqk0q.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpme0wqk0q.d(31): Error: no property `find` for type `string`

    /tmp/tmpme0wqk0q.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpme0wqk0q.d(38): Error: no property `find` for type `string`

    /tmp/tmpme0wqk0q.d(41): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmpme0wqk0q.d(46): Error: no property `find` for type `string`

    /tmp/tmpme0wqk0q.d(49): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmpme0wqk0q.d(54): Error: no property `find` for type `string`

    /tmp/tmpme0wqk0q.d(54): Error: no property `find` for type `string`

    /tmp/tmpme0wqk0q.d(57): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpme0wqk0q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i > 0 && consonants.find(word[i-1]) != -1)\n             \
    \   {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7eynulqc.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7eynulqc.d(31): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp7eynulqc.d(36): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(38): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(41): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7eynulqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            int distance = 0;\n            for (int j = i;\
    \ j < word.length; j++)\n            {\n                if (consonants.find(word[j])\
    \ != -1)\n                {\n                    distance = j - i;\n         \
    \           break;\n                }\n            }\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               index = i;\n            }\n        }\n    }\n    if (min_distance\
    \ != word.length)\n    {\n        result = word[index..$];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagopsz75.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpagopsz75.d(32): Error: no property `find` for type `string`

    /tmp/tmpagopsz75.d(37): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagopsz75.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = 0;\n    int closest_vowel_distance\
    \ = 0;\n    int word_length = word.length;\n    int i = 0;\n    int j = 0;\n \
    \   int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n\
    \    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n\
    \    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int ii =\
    \ 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n   \
    \ int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr =\
    \ 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n   \
    \ int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aa =\
    \ 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n   \
    \ int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkmy9ouh6.d(88): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkmy9ouh6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8boq0faa.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8boq0faa.d(30): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(32): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(34): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8boq0faa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != 0)\n    {\n        result\
    \ = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdma7x1rk.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpdma7x1rk.d(31): Error: no property `find` for type `string`

    /tmp/tmpdma7x1rk.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpdma7x1rk.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpdma7x1rk.d(43): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdma7x1rk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = word.length;\n    for (int i = word.length\
    \ - 1; i > 0; i--)\n    {\n        if (vowels.canFind(word[i]) && !vowels.canFind(word[i\
    \ - 1]))\n        {\n            if (distance > i)\n            {\n          \
    \      distance = i;\n                result = word[i];\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjbpi_26o.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjbpi_26o.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpjbpi_26o.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpjbpi_26o.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpjbpi_26o.d(35): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjbpi_26o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index > 0 && index < word.length\
    \ - 1)\n    {\n        if(vowels.find(word[index - 1]) == -1 && vowels.find(word[index\
    \ + 1]) == -1)\n        {\n            result = word[index..$];\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp730jukxc.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp730jukxc.d(31): Error: no property `find` for type `string`

    /tmp/tmp730jukxc.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp730jukxc.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp730jukxc.d(43): Error: no property `find` for type `string`

    /tmp/tmp730jukxc.d(43): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp730jukxc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int left_distance\
    \ = i;\n            int right_distance = word.length - i - 1;\n            if(left_distance\
    \ == 0 || right_distance == 0)\n                continue;\n            if(consonants.find(word[left_distance\
    \ - 1]) != -1 && consonants.find(word[i + 1]) != -1)\n            {\n        \
    \        if(min_distance > min(left_distance, right_distance))\n             \
    \   {\n                    min_distance = min(left_distance, right_distance);\n\
    \                    result = c;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqx09al9a.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpqx09al9a.d(31): Error: no property `find` for type `string`

    /tmp/tmpqx09al9a.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpqx09al9a.d(34): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmpqx09al9a.d(37): Error: no property `find` for type `string`

    /tmp/tmpqx09al9a.d(37): Error: no property `find` for type `string`

    /tmp/tmpqx09al9a.d(39): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpqx09al9a.d(41): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpqx09al9a.d(42): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqx09al9a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, ch; word)\n\
    \    {\n        if(vowels.canFind(ch))\n        {\n            int distance =\
    \ word.length - i;\n            if(distance < min_distance)\n            {\n \
    \               if(i > 0 && consonants.canFind(word[i-1]))\n                {\n\
    \                    if(i < word.length - 1 && consonants.canFind(word[i+1]))\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = ch;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpli5i8vzs.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpli5i8vzs.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpli5i8vzs.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpli5i8vzs.d(36): Error: no property `canFind` for type `string`

    /tmp/tmpli5i8vzs.d(38): Error: no property `canFind` for type `string`

    /tmp/tmpli5i8vzs.d(41): Error: cannot implicitly convert expression `ch` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpli5i8vzs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl5n88d_b.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpl5n88d_b.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpl5n88d_b.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpl5n88d_b.d(37): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl5n88d_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest = \"\";\n    int min_dist = word.length;\n    foreach(i, c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            int dist\
    \ = word.length - i;\n            if(dist < min_dist)\n            {\n       \
    \         min_dist = dist;\n                closest = c;\n            }\n    \
    \    }\n    }\n    return closest;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjnh4dfto.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjnh4dfto.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpjnh4dfto.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpjnh4dfto.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjnh4dfto.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          if(i > 0 && i < word.length - 1)\n            {\n                if(!vowels.canFind(word[i\
    \ - 1]) && !vowels.canFind(word[i + 1]))\n                {\n                \
    \    if(abs(i - word.length) < min_distance)\n                    {\n        \
    \                min_distance = abs(i - word.length);\n                      \
    \  index = i;\n                    }\n                }\n            }\n     \
    \   }\n    }\n    if(index != 0)\n    {\n        result = word[index];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjwb0mbxh.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjwb0mbxh.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpjwb0mbxh.d(35): Error: no property `canFind` for type `string`

    /tmp/tmpjwb0mbxh.d(35): Error: no property `canFind` for type `string`

    /tmp/tmpjwb0mbxh.d(39): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmpjwb0mbxh.d(40): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpjwb0mbxh.d(48): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwb0mbxh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, char c; word)\n    {\n        if(vowels.find(c) != -1)\n       \
    \ {\n            int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(min_distance == word.length)\n\
    \        return result;\n    else\n    {\n        if(consonants.find(word[index\
    \ - 1]) != -1 && consonants.find(word[index + 1]) != -1)\n            return word[index..$];\n\
    \        else\n            return result;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq6w2lex7.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpq6w2lex7.d(32): Error: no property `find` for type `string`

    /tmp/tmpq6w2lex7.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpq6w2lex7.d(38): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpq6w2lex7.d(46): Error: no property `find` for type `string`

    /tmp/tmpq6w2lex7.d(46): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq6w2lex7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = 0;\n    int distance = 0;\n \
    \   int word_length = word.length;\n    int vowel_length = vowels.length;\n  \
    \  int vowel_index = 0;\n    int word_index = 0;\n    int vowel_pos = 0;\n   \
    \ int word_pos = 0;\n    int vowel_pos_right = 0;\n    int word_pos_right = 0;\n\
    \    int vowel_pos_left = 0;\n    int word_pos_left = 0;\n    bool found_vowel\
    \ = false;\n    bool found_consonant = false;\n    bool found_vowel_right = false;\n\
    \    bool found_consonant_right = false;\n    bool found_vowel_left = false;\n\
    \    bool found_consonant_left = false;\n    for (vowel_index = 0; vowel_index\
    \ < vowel_length; vowel_index++)\n    {\n        vowel_pos = vowels.indexOf(vowels[vowel_index]);\n\
    \        word_pos = word.indexOf(vowels[vowel_index]);\n        if (word_pos !=\
    \ -1)\n        {\n            found_vowel = true;\n            vowel_pos_right\
    \ = vowels.indexOf(vowels[vowel_index], vowel_pos + 1);\n            word_pos_right\
    \ = word.indexOf(vowels[vowel_index], word_pos + 1);\n            vowel_pos_left\
    \ = vowels.indexOf(vowels[vowel_index], vowel_pos - 1);\n            word_pos_left\
    \ = word.indexOf(vowels[vowel_index], word_pos - 1);\n            if (vowel_pos_right\
    \ != -1)\n            {\n                found_vowel_right = true;\n         \
    \   }\n            if (word_pos_right != -1)\n            {\n                found_consonant_right\
    \ = true;\n            }\n            if (vowel_pos_left != -1)\n            {\n\
    \               \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp92v7daox.d(67): Error: found `unittest` instead of statement

    /tmp/tmp92v7daox.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp92v7daox.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp92v7daox.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp92v7daox.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_index = 0;\n    int min_distance\
    \ = word.length;\n    foreach(vowel; vowels)\n    {\n        index = word.find(vowel);\n\
    \        if(index != -1)\n        {\n            if(consonants.find(word[index\
    \ - 1]) != -1 && consonants.find(word[index + 1]) != -1)\n            {\n    \
    \            if(abs(index - word.length) < min_distance)\n                {\n\
    \                    min_distance = abs(index - word.length);\n              \
    \      min_index = index;\n                }\n            }\n        }\n    }\n\
    \    if(min_index != 0)\n    {\n        result = word[min_index..min_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp00rseamo.d(30): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp00rseamo.d(33): Error: no property `find` for type `string`

    /tmp/tmp00rseamo.d(36): Error: no property `find` for type `string`

    /tmp/tmp00rseamo.d(36): Error: no property `find` for type `string`

    /tmp/tmp00rseamo.d(40): Error: cannot implicitly convert expression `abs(cast(ulong)index
    - word.length)` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp00rseamo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            if(i\
    \ > 0 && consonants.find(word[i-1]) != -1)\n            {\n                if(i\
    \ < word.length - 1 && consonants.find(word[i+1]) != -1)\n                {\n\
    \                    if(abs(i - word.length) < min)\n                    {\n \
    \                       min = abs(i - word.length);\n                        index\
    \ = i;\n                    }\n                }\n            }\n        }\n \
    \   }\n    if(index != 0)\n    {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7t_4v8df.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7t_4v8df.d(32): Error: no property `find` for type `string`

    /tmp/tmp7t_4v8df.d(34): Error: no property `find` for type `string`

    /tmp/tmp7t_4v8df.d(36): Error: no property `find` for type `string`

    /tmp/tmp7t_4v8df.d(40): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmp7t_4v8df.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp7t_4v8df.d(49): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7t_4v8df.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int minDistance = 0;\n    int wordLength\
    \ = word.length;\n    int vowelIndex = 0;\n    int consonantIndex = 0;\n    int\
    \ i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n   \
    \ int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n\
    \    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n\
    \    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n\
    \    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n\
    \    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n\
    \    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int a = 0;\n\
    \    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n\
    \    int g = 0;\n    int h = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk\
    \ = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81_g8fzb.d(92): Error: no identifier for declarator `int`

    /tmp/tmp81_g8fzb.d(92): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81_g8fzb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index > 0 && index < word.length\
    \ - 1)\n    {\n        result = word[index..$];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq76owj8e.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpq76owj8e.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpq76owj8e.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpq76owj8e.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq76owj8e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest_vowel = \"\";\n    int closest_vowel_index = 0;\n    int closest_vowel_distance\
    \ = 0;\n    int word_length = word.length;\n    int vowel_length = vowels.length;\n\
    \    int vowel_index = 0;\n    int vowel_distance = 0;\n    for (int i = 0; i\
    \ < word_length; i++)\n    {\n        for (int j = 0; j < vowel_length; j++)\n\
    \        {\n            if (word[i] == vowels[j])\n            {\n           \
    \     vowel_index = i;\n                vowel_distance = word_length - vowel_index;\n\
    \                if (vowel_distance > closest_vowel_distance)\n              \
    \  {\n                    closest_vowel_distance = vowel_distance;\n         \
    \           closest_vowel_index = vowel_index;\n                    closest_vowel\
    \ = word[closest_vowel_index];\n                }\n            }\n        }\n\
    \    }\n    return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1qxvb6y_.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp1qxvb6y_.d(30): Error: cannot implicitly convert expression `vowels.length`
    of type `ulong` to `int`

    /tmp/tmp1qxvb6y_.d(45): Error: cannot implicitly convert expression `word[cast(ulong)closest_vowel_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1qxvb6y_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                result = c;\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdf_ouv19.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpdf_ouv19.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpdf_ouv19.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpdf_ouv19.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdf_ouv19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = 0;\n    int min_index = 0;\n    int word_length = word.length;\n    int vowel_length\
    \ = vowels.length;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l\
    \ = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int\
    \ q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n   \
    \ int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    for (i = 0; i < word_length; i++)\n    {\n        if (word[i] == 'a')\n \
    \       {\n            a = i;\n        }\n        if (word[i] == 'e')\n      \
    \  {\n            e = i;\n        }\n        if (word[i] == 'i')\n        {\n\
    \            i = i;\n        }\n        if (word[i] == 'o')\n        {\n     \
    \       o = i;\n        }\n        if (word[i] == 'u')\n        {\n          \
    \  u = i;\n        }\n        if (word[i] == 'A')\n        {\n            A =\
    \ i;\n        }\n        if (word[i] == 'E')\n        {\n            E = i;\n\
    \        }\n        if (word[i] == 'I')\n        {\n            I = i;\n     \
    \   }\n        if (word[i] == 'O')\n        {\n            O = i;\n        }\n\
    \        if (word[i] == 'U')\n        {\n            U = i;\n        }\n    }\n\
    \    if (a != 0)\n    {\n        index = a;\n        distance = word_length -\
    \ index;\n        if (min_distance == 0)\n        {\n            min_distance\
    \ =\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp45vkbjbz.d(101): Error: expression expected, not `unittest`

    /tmp/tmp45vkbjbz.d(102): Error: found `{` when expecting `;` following statement

    /tmp/tmp45vkbjbz.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp45vkbjbz.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp45vkbjbz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1t2yn4ee.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp1t2yn4ee.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp1t2yn4ee.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp1t2yn4ee.d(38): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1t2yn4ee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ char c; word)\n    {\n        if(vowels.canFind(c))\n        {\n           \
    \ int distance = word.length - i;\n            if(distance < min_distance)\n \
    \           {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr23z2i1s.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpr23z2i1s.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpr23z2i1s.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpr23z2i1s.d(36): Error: cannot implicitly convert expression `c` of type
    `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr23z2i1s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int\
    \ distance = 0;\n            int j = i;\n            while(j >= 0 && consonants.find(word[j])\
    \ != -1)\n            {\n                j--;\n                distance++;\n \
    \           }\n            if(distance > 0)\n            {\n                j\
    \ = i;\n                while(j < word.length && consonants.find(word[j]) != -1)\n\
    \                {\n                    j++;\n                    distance++;\n\
    \                }\n                if(distance > 0)\n                {\n    \
    \                if(min_distance == 0 || distance < min_distance)\n          \
    \          {\n                        min_distance = distance;\n             \
    \           index = i;\n                    }\n                }\n           \
    \ }\n        }\n    }\n    if(min_distance > 0)\n    {\n        result = word[index..index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdml3y8l2.d(32): Error: no property `find` for type `string`

    /tmp/tmpdml3y8l2.d(35): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpdml3y8l2.d(36): Error: no property `find` for type `string`

    /tmp/tmpdml3y8l2.d(43): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpdml3y8l2.d(44): Error: no property `find` for type `string`

    /tmp/tmpdml3y8l2.d(54): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdml3y8l2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index > 0 && index < word.length\
    \ - 1)\n    {\n        if(!vowels.canFind(word[index - 1]) && !vowels.canFind(word[index\
    \ + 1]))\n        {\n            result = word[index..$];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvfuhfr4d.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpvfuhfr4d.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpvfuhfr4d.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpvfuhfr4d.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpvfuhfr4d.d(43): Error: no property `canFind` for type `string`

    /tmp/tmpvfuhfr4d.d(43): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvfuhfr4d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int left_distance\
    \ = 0;\n            int right_distance = 0;\n            for(int j = i; j >= 0;\
    \ j--)\n            {\n                if(consonants.canFind(word[j]))\n     \
    \           {\n                    left_distance = i - j;\n                  \
    \  break;\n                }\n            }\n            for(int j = i; j < word.length;\
    \ j++)\n            {\n                if(consonants.canFind(word[j]))\n     \
    \           {\n                    right_distance = j - i;\n                 \
    \   break;\n                }\n            }\n            if(left_distance !=\
    \ 0 && right_distance != 0)\n            {\n                if(min_distance >\
    \ min(left_distance, right_distance))\n                {\n                   \
    \ min_distance = min(left_distance, right_distance);\n                    result\
    \ = c;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoqsl0bfu.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpoqsl0bfu.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpoqsl0bfu.d(35): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpoqsl0bfu.d(37): Error: no property `canFind` for type `string`

    /tmp/tmpoqsl0bfu.d(39): Error: cannot implicitly convert expression `i - cast(ulong)j`
    of type `ulong` to `int`

    /tmp/tmpoqsl0bfu.d(43): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpoqsl0bfu.d(45): Error: no property `canFind` for type `string`

    /tmp/tmpoqsl0bfu.d(47): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmpoqsl0bfu.d(53): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpoqsl0bfu.d(55): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpoqsl0bfu.d(56): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string'
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int closest_vowel_index = -1;\n    int closest_vowel_distance = word.length;\n\
    \    int current_vowel_distance;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            current_vowel_distance = word.length - i;\n          \
    \  if(current_vowel_distance < closest_vowel_distance)\n            {\n      \
    \          closest_vowel_distance = current_vowel_distance;\n                closest_vowel_index\
    \ = i;\n            }\n        }\n    }\n    if(closest_vowel_index == -1)\n \
    \   {\n        return \"\";\n    }\n    else\n    {\n        return word[closest_vowel_index..closest_vowel_index];\n\
    \    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpajc8dlym.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpajc8dlym.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpajc8dlym.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpajc8dlym.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajc8dlym.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i - 1;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp96p8z93b.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp96p8z93b.d(31): Error: no property `canFind` for type `string`

    /tmp/tmp96p8z93b.d(33): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmp96p8z93b.d(37): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp96p8z93b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word) {\n        if(vowels.canFind(c)) {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance) {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_37erc0d.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_37erc0d.d(29): Error: no property `canFind` for type `string`

    /tmp/tmp_37erc0d.d(30): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp_37erc0d.d(33): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_37erc0d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd752872y.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpd752872y.d(31): Error: no property `find` for type `string`

    /tmp/tmpd752872y.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpd752872y.d(37): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd752872y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int\
    \ closest = -1;\n    int i = word.length - 1;\n    while (i >= 0) {\n        if\
    \ (vowels.find(word[i]) != -1) {\n            closest = i;\n            break;\n\
    \        }\n        i--;\n    }\n    if (closest == -1) {\n        return \"\"\
    ;\n    }\n    i = closest - 1;\n    while (i >= 0) {\n        if (consonants.find(word[i])\
    \ != -1) {\n            return word[closest..closest];\n        }\n        i--;\n\
    \    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpna7ruy7l.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpna7ruy7l.d(30): Error: no property `find` for type `string`

    /tmp/tmpna7ruy7l.d(41): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpna7ruy7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int j = i;\n            while(j >= 0 && consonants.find(word[j])\
    \ != -1)\n            {\n                j--;\n            }\n            if(j\
    \ >= 0)\n            {\n                j = i;\n                while(j < word.length\
    \ && consonants.find(word[j]) != -1)\n                {\n                    j++;\n\
    \                }\n                if(j < word.length)\n                {\n \
    \                   distance = j - i;\n                    if(distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd57ckrft.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpd57ckrft.d(32): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpd57ckrft.d(35): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpd57ckrft.d(42): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(48): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmpd57ckrft.d(52): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd57ckrft.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                if(i > 0 && consonants.find(word[i-1]) != -1)\n\
    \                {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        index = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if(index != 0)\n    {\n        result =\
    \ word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3c_njtoe.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3c_njtoe.d(32): Error: no property `find` for type `string`

    /tmp/tmp3c_njtoe.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp3c_njtoe.d(37): Error: no property `find` for type `string`

    /tmp/tmp3c_njtoe.d(39): Error: no property `find` for type `string`

    /tmp/tmp3c_njtoe.d(42): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3c_njtoe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8boq0faa.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8boq0faa.d(30): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(32): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(34): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8boq0faa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8boq0faa.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8boq0faa.d(30): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(32): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(34): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8boq0faa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                int left = i - 1;\n                int right = i + 1;\n     \
    \           if(left >= 0 && right < word.length)\n                {\n        \
    \            if(consonants.find(word[left]) != -1 && consonants.find(word[right])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9bl77amx.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp9bl77amx.d(31): Error: no property `find` for type `string`

    /tmp/tmp9bl77amx.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp9bl77amx.d(36): Error: cannot implicitly convert expression `i - 1LU`
    of type `ulong` to `int`

    /tmp/tmp9bl77amx.d(37): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmp9bl77amx.d(40): Error: no property `find` for type `string`

    /tmp/tmp9bl77amx.d(40): Error: no property `find` for type `string`

    /tmp/tmp9bl77amx.d(43): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9bl77amx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ char c; word)\n    {\n        if(vowels.canFind(c))\n        {\n           \
    \ int distance = word.length - i;\n            if(distance < min_distance)\n \
    \           {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr23z2i1s.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpr23z2i1s.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpr23z2i1s.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpr23z2i1s.d(36): Error: cannot implicitly convert expression `c` of type
    `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr23z2i1s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    foreach(i, c; word)\n    {\n    \
    \    if(vowels.canFind(c))\n        {\n            int d = word.length - i;\n\
    \            if(d > distance)\n            {\n                distance = d;\n\
    \                result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmqtnyn93.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpmqtnyn93.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpmqtnyn93.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmqtnyn93.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index == 0)\n        return result;\n\
    \    if(consonants.find(word[index - 1]) != -1 && consonants.find(word[index +\
    \ 1]) != -1)\n        return word[index..$];\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpspb44t5x.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpspb44t5x.d(32): Error: no property `find` for type `string`

    /tmp/tmpspb44t5x.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpspb44t5x.d(38): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpspb44t5x.d(44): Error: no property `find` for type `string`

    /tmp/tmpspb44t5x.d(44): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpspb44t5x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != 0)\n    {\n        result\
    \ = word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdma7x1rk.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpdma7x1rk.d(31): Error: no property `find` for type `string`

    /tmp/tmpdma7x1rk.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpdma7x1rk.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpdma7x1rk.d(43): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdma7x1rk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int left_distance\
    \ = i;\n            int right_distance = word.length - i - 1;\n            if(left_distance\
    \ > 0 && right_distance > 0)\n            {\n                if(consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n                {\n            \
    \        if(min_distance > min(left_distance, right_distance))\n             \
    \       {\n                        min_distance = min(left_distance, right_distance);\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqgc48yf7.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpqgc48yf7.d(31): Error: no property `find` for type `string`

    /tmp/tmpqgc48yf7.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpqgc48yf7.d(34): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmpqgc48yf7.d(37): Error: no property `find` for type `string`

    /tmp/tmpqgc48yf7.d(37): Error: no property `find` for type `string`

    /tmp/tmpqgc48yf7.d(39): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpqgc48yf7.d(41): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpqgc48yf7.d(42): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqgc48yf7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            if(i\
    \ != 0 && i != word.length-1)\n            {\n                if(consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n                {\n            \
    \        if(abs(i - word.length) < min)\n                    {\n             \
    \           min = abs(i - word.length);\n                        index = i;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if(index != 0)\n    {\n        result = word[index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_exvfoip.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_exvfoip.d(32): Error: no property `find` for type `string`

    /tmp/tmp_exvfoip.d(36): Error: no property `find` for type `string`

    /tmp/tmp_exvfoip.d(36): Error: no property `find` for type `string`

    /tmp/tmp_exvfoip.d(40): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmp_exvfoip.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp_exvfoip.d(49): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_exvfoip.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word) {\n        if(vowels.canFind(c)) {\n            int distance\
    \ = word.length - i - 1;\n            if(distance < min_distance) {\n        \
    \        min_distance = distance;\n                index = i;\n            }\n\
    \        }\n    }\n    if(min_distance < word.length) {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplt_vz8rl.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplt_vz8rl.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplt_vz8rl.d(31): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmplt_vz8rl.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplt_vz8rl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = -1;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index > 0 && index < word.length\
    \ - 1)\n    {\n        if(!vowels.canFind(word[index - 1]) && !vowels.canFind(word[index\
    \ + 1]))\n        {\n            result = word[index..$];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqrh75g53.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpqrh75g53.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpqrh75g53.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpqrh75g53.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpqrh75g53.d(43): Error: no property `canFind` for type `string`

    /tmp/tmpqrh75g53.d(43): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqrh75g53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int j = i;\n            while(j > 0 && consonants.find(word[j]) !=\
    \ -1)\n            {\n                j--;\n            }\n            if(j ==\
    \ 0)\n            {\n                j = i;\n                while(j < word.length\
    \ && consonants.find(word[j]) != -1)\n                {\n                    j++;\n\
    \                }\n                if(j == word.length)\n                {\n\
    \                    continue;\n                }\n            }\n           \
    \ distance = i - j;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp48kpm06x.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp48kpm06x.d(32): Error: no property `find` for type `string`

    /tmp/tmp48kpm06x.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp48kpm06x.d(35): Error: no property `find` for type `string`

    /tmp/tmp48kpm06x.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp48kpm06x.d(42): Error: no property `find` for type `string`

    /tmp/tmp48kpm06x.d(51): Error: cannot implicitly convert expression `i - cast(ulong)j`
    of type `ulong` to `int`

    /tmp/tmp48kpm06x.d(55): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp48kpm06x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1 && distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg22eabp5.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpg22eabp5.d(31): Error: no property `find` for type `string`

    /tmp/tmpg22eabp5.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpg22eabp5.d(34): Error: no property `find` for type `string`

    /tmp/tmpg22eabp5.d(34): Error: no property `find` for type `string`

    /tmp/tmpg22eabp5.d(37): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg22eabp5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i - 1;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp96p8z93b.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp96p8z93b.d(31): Error: no property `canFind` for type `string`

    /tmp/tmp96p8z93b.d(33): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmp96p8z93b.d(37): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp96p8z93b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) ==\
    \ -1)\n                {\n                    if (min_distance > abs(i - word.length\
    \ + 1))\n                    {\n                        min_distance = abs(i -\
    \ word.length + 1);\n                        result = word[i];\n             \
    \       }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyj4yqmpt.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpyj4yqmpt.d(30): Error: no property `find` for type `string`

    /tmp/tmpyj4yqmpt.d(34): Error: no property `find` for type `string`

    /tmp/tmpyj4yqmpt.d(34): Error: no property `find` for type `string`

    /tmp/tmpyj4yqmpt.d(38): Error: cannot implicitly convert expression `abs(cast(ulong)i
    - word.length + 1LU)` of type `ulong` to `int`

    /tmp/tmpyj4yqmpt.d(39): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyj4yqmpt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int\
    \ distance = word.length - i;\n            if(distance < min_distance)\n     \
    \       {\n                min_distance = distance;\n                result =\
    \ c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp71mx2jp3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp71mx2jp3.d(30): Error: no property `find` for type `string`

    /tmp/tmp71mx2jp3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp71mx2jp3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp71mx2jp3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int vowel_index = 0;\n    int consonant_index = 0;\n    int word_length =\
    \ word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n\
    \        {\n            vowel_index = i;\n            foreach(j, d; word[i..$])\n\
    \            {\n                if(consonants.find(d) != -1)\n               \
    \ {\n                    consonant_index = j;\n                    distance =\
    \ consonant_index - vowel_index;\n                    if(distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnph5sgde.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpnph5sgde.d(32): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpnph5sgde.d(35): Error: no property `find` for type `string`

    /tmp/tmpnph5sgde.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpnph5sgde.d(40): Error: no property `find` for type `string`

    /tmp/tmpnph5sgde.d(42): Error: cannot implicitly convert expression `j` of type
    `ulong` to `int`

    /tmp/tmpnph5sgde.d(47): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnph5sgde.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int j = i;\n            while(j >= 0 && consonants.find(word[j])\
    \ != -1)\n            {\n                j--;\n            }\n            if(j\
    \ >= 0)\n            {\n                j = i;\n                while(j < word.length\
    \ && consonants.find(word[j]) != -1)\n                {\n                    j++;\n\
    \                }\n                if(j < word.length)\n                {\n \
    \                   distance = j - i;\n                    if(distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd57ckrft.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpd57ckrft.d(32): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpd57ckrft.d(35): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpd57ckrft.d(42): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(48): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmpd57ckrft.d(52): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd57ckrft.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && i < word.length - 1)\n         \
    \   {\n                if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i\
    \ + 1]) == -1)\n                {\n                    distance = word.length\
    \ - i;\n                    if (distance < minDistance)\n                    {\n\
    \                        minDistance = distance;\n                        result\
    \ = word[i];\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5gbk_53_.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp5gbk_53_.d(31): Error: no property `find` for type `string`

    /tmp/tmp5gbk_53_.d(35): Error: no property `find` for type `string`

    /tmp/tmp5gbk_53_.d(35): Error: no property `find` for type `string`

    /tmp/tmp5gbk_53_.d(37): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    /tmp/tmp5gbk_53_.d(41): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5gbk_53_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int current_distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          current_distance = word.length - i;\n            if(current_distance\
    \ < min_distance)\n            {\n                min_distance = current_distance;\n\
    \                result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpffvr989y.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpffvr989y.d(32): Error: no property `canFind` for type `string`

    /tmp/tmpffvr989y.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpffvr989y.d(38): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpffvr989y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n      \
    \  {\n            foreach(j, v; vowels)\n            {\n                if(word.find(v,\
    \ i) != -1)\n                {\n                    distance = word.find(v, i)\
    \ - i;\n                    if(distance < min_distance)\n                    {\n\
    \                        min_distance = distance;\n                        result\
    \ = v;\n                    }\n                }\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpca_khpxr.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpca_khpxr.d(32): Error: no property `find` for type `string`

    /tmp/tmpca_khpxr.d(36): Error: no property `find` for type `string`

    /tmp/tmpca_khpxr.d(38): Error: no property `find` for type `string`

    /tmp/tmpca_khpxr.d(42): Error: cannot implicitly convert expression `v` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpca_khpxr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >=\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (index == word.length - 1)\n            {\n                index--;\n\
    \                continue;\n            }\n            if (vowels.find(word[index\
    \ + 1]) == -1)\n            {\n                result = word[index];\n       \
    \         break;\n            }\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm5lhmhy0.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpm5lhmhy0.d(30): Error: no property `find` for type `string`

    /tmp/tmpm5lhmhy0.d(37): Error: no property `find` for type `string`

    /tmp/tmpm5lhmhy0.d(39): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm5lhmhy0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int left_distance = 0;\n            int right_distance = 0;\n   \
    \         for(int j = i - 1; j >= 0; j--)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    left_distance++;\n          \
    \      }\n                else\n                {\n                    break;\n\
    \                }\n            }\n            for(int j = i + 1; j < word.length;\
    \ j++)\n            {\n                if(consonants.find(word[j]) != -1)\n  \
    \              {\n                    right_distance++;\n                }\n \
    \               else\n                {\n                    break;\n        \
    \        }\n            }\n            distance = left_distance + right_distance;\n\
    \            if(distance < min_distance)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp342gbfos.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp342gbfos.d(32): Error: no property `find` for type `string`

    /tmp/tmp342gbfos.d(36): Error: cannot implicitly convert expression `i - 1LU`
    of type `ulong` to `int`

    /tmp/tmp342gbfos.d(38): Error: no property `find` for type `string`

    /tmp/tmp342gbfos.d(47): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmp342gbfos.d(49): Error: no property `find` for type `string`

    /tmp/tmp342gbfos.d(62): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp342gbfos.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int closest = word.length;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            if (i > 0 && i < word.length - 1)\n            {\n       \
    \         if (vowels.find(word[i-1]) == -1 && vowels.find(word[i+1]) == -1)\n\
    \                {\n                    if (i < closest)\n                   \
    \ {\n                        closest = i;\n                        result = word[i];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph_emb16m.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmph_emb16m.d(30): Error: no property `find` for type `string`

    /tmp/tmph_emb16m.d(34): Error: no property `find` for type `string`

    /tmp/tmph_emb16m.d(34): Error: no property `find` for type `string`

    /tmp/tmph_emb16m.d(39): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8boq0faa.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8boq0faa.d(30): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(32): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(34): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8boq0faa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length - 1;\n    bool found = false;\n\
    \    while (index > 0 && !found)\n    {\n        if (consonants.find(word[index])\
    \ != -1)\n        {\n            if (vowels.find(word[index - 1]) != -1)\n   \
    \         {\n                result = word[index - 1];\n                found\
    \ = true;\n            }\n            else\n            {\n                index--;\n\
    \            }\n        }\n        else\n        {\n            index--;\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpimrvyhaw.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpimrvyhaw.d(32): Error: no property `find` for type `string`

    /tmp/tmpimrvyhaw.d(34): Error: no property `find` for type `string`

    /tmp/tmpimrvyhaw.d(36): Error: cannot implicitly convert expression `word[cast(ulong)(index
    - 1)]` of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpimrvyhaw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int closest = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            if(i > 0 && i <\
    \ word.length - 1)\n            {\n                if(!vowels.canFind(word[i -\
    \ 1]) && !vowels.canFind(word[i + 1]))\n                {\n                  \
    \  if(abs(i - word.length) < closest)\n                    {\n               \
    \         closest = abs(i - word.length);\n                        result = c;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplpcvkj9n.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplpcvkj9n.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplpcvkj9n.d(34): Error: no property `canFind` for type `string`

    /tmp/tmplpcvkj9n.d(34): Error: no property `canFind` for type `string`

    /tmp/tmplpcvkj9n.d(38): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmplpcvkj9n.d(39): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplpcvkj9n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int left_consonant = word[i..$].find(consonants);\n            int\
    \ right_consonant = word[0..i].rfind(consonants);\n            if(left_consonant\
    \ != -1 && right_consonant != -1)\n            {\n                distance = left_consonant\
    \ + right_consonant;\n                if(distance < min_distance)\n          \
    \      {\n                    min_distance = distance;\n                    result\
    \ = c;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpriddblim.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpriddblim.d(32): Error: no property `find` for type `string`

    /tmp/tmpriddblim.d(34): Error: no property `find` for type `string`

    /tmp/tmpriddblim.d(35): Error: no property `rfind` for type `string`

    /tmp/tmpriddblim.d(42): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpriddblim.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int left = i;\n            int right = i;\n            while(left\
    \ >= 0 && consonants.find(word[left]) != -1)\n            {\n                left--;\n\
    \            }\n            while(right < word.length && consonants.find(word[right])\
    \ != -1)\n            {\n                right++;\n            }\n           \
    \ if(left >= 0 && right < word.length)\n            {\n                distance\
    \ = right - left - 1;\n                if(distance < minDistance)\n          \
    \      {\n                    minDistance = distance;\n                    result\
    \ = c;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ildf2j9.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp0ildf2j9.d(32): Error: no property `find` for type `string`

    /tmp/tmp0ildf2j9.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp0ildf2j9.d(35): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp0ildf2j9.d(36): Error: no property `find` for type `string`

    /tmp/tmp0ildf2j9.d(40): Error: no property `find` for type `string`

    /tmp/tmp0ildf2j9.d(50): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ildf2j9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(consonants.find(c) != -1)\n        {\n            foreach(j,\
    \ v; vowels)\n            {\n                if(word.find(v, i) != -1)\n     \
    \           {\n                    int distance = word.find(v, i) - i;\n     \
    \               if(distance < min_distance)\n                    {\n         \
    \               min_distance = distance;\n                        result = v;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2sk7v88.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpq2sk7v88.d(31): Error: no property `find` for type `string`

    /tmp/tmpq2sk7v88.d(35): Error: no property `find` for type `string`

    /tmp/tmpq2sk7v88.d(37): Error: no property `find` for type `string`

    /tmp/tmpq2sk7v88.d(41): Error: cannot implicitly convert expression `v` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2sk7v88.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = int.max;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = 0;\n\
    \            for(int j = i; j < word.length; j++)\n            {\n           \
    \     if(consonants.canFind(word[j]))\n                {\n                   \
    \ distance++;\n                }\n                else if(vowels.canFind(word[j]))\n\
    \                {\n                    break;\n                }\n          \
    \  }\n            if(distance < min_distance)\n            {\n               \
    \ min_distance = distance;\n                result = c;\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv7os75yf.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpv7os75yf.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpv7os75yf.d(36): Error: no property `canFind` for type `string`

    /tmp/tmpv7os75yf.d(40): Error: no property `canFind` for type `string`

    /tmp/tmpv7os75yf.d(48): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv7os75yf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != 0)\n    {\n        result\
    \ = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5f951k2o.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp5f951k2o.d(31): Error: no property `find` for type `string`

    /tmp/tmp5f951k2o.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp5f951k2o.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5f951k2o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int i = word.length;\n    int j = 0;\n    int k\
    \ = 0;\n    while (i > 0)\n    {\n        if (vowels.find(word[i-1]) != -1)\n\
    \        {\n            j = i;\n            break;\n        }\n        i--;\n\
    \    }\n    while (j > 0)\n    {\n        if (vowels.find(word[j-1]) == -1)\n\
    \        {\n            k = j;\n            break;\n        }\n        j--;\n\
    \    }\n    if (k > 0)\n    {\n        result = word[k-1];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5sfjyqpq.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp5sfjyqpq.d(32): Error: no property `find` for type `string`

    /tmp/tmp5sfjyqpq.d(41): Error: no property `find` for type `string`

    /tmp/tmp5sfjyqpq.d(50): Error: cannot implicitly convert expression `word[cast(ulong)(k
    - 1)]` of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5sfjyqpq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpds3xz59i.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpds3xz59i.d(30): Error: no property `find` for type `string`

    /tmp/tmpds3xz59i.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpds3xz59i.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpds3xz59i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            int left_distance = 0;\n            int right_distance = 0;\n   \
    \         for (int j = i - 1; j >= 0; j--)\n            {\n                if\
    \ (consonants.find(word[j]) != -1)\n                {\n                    left_distance\
    \ = i - j;\n                    break;\n                }\n            }\n   \
    \         for (int j = i + 1; j < word.length; j++)\n            {\n         \
    \       if (consonants.find(word[j]) != -1)\n                {\n             \
    \       right_distance = j - i;\n                    break;\n                }\n\
    \            }\n            if (left_distance != 0 && right_distance != 0)\n \
    \           {\n                int distance = min(left_distance, right_distance);\n\
    \                if (distance < min_distance)\n                {\n           \
    \         min_distance = distance;\n                    result = word[i];\n  \
    \              }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu320qb1z.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpu320qb1z.d(31): Error: no property `find` for type `string`

    /tmp/tmpu320qb1z.d(37): Error: no property `find` for type `string`

    /tmp/tmpu320qb1z.d(45): Error: no property `find` for type `string`

    /tmp/tmpu320qb1z.d(53): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpu320qb1z.d(57): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu320qb1z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min = int.max;\n    foreach(i, c; word)\n    {\n   \
    \     if(vowels.canFind(c))\n        {\n            int left = i;\n          \
    \  int right = i;\n            while(left >= 0 && consonants.canFind(word[left]))\n\
    \                left--;\n            while(right < word.length && consonants.canFind(word[right]))\n\
    \                right++;\n            if(left >= 0 && right < word.length)\n\
    \            {\n                if(right - left < min)\n                {\n  \
    \                  min = right - left;\n                    result = c;\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1jr3wtyf.d(31): Error: no property `canFind` for type `string`

    /tmp/tmp1jr3wtyf.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp1jr3wtyf.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp1jr3wtyf.d(35): Error: no property `canFind` for type `string`

    /tmp/tmp1jr3wtyf.d(37): Error: no property `canFind` for type `string`

    /tmp/tmp1jr3wtyf.d(44): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1jr3wtyf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i == 0)\n            {\n                if\
    \ (consonants.find(word[i+1]) != -1)\n                {\n                    distance\
    \ = 1;\n                }\n            }\n            else if (i == word.length\
    \ - 1)\n            {\n                if (consonants.find(word[i-1]) != -1)\n\
    \                {\n                    distance = 1;\n                }\n   \
    \         }\n            else\n            {\n                if (consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n                {\n            \
    \        distance = 1;\n                }\n            }\n            if (distance\
    \ == 1)\n            {\n                if (min_distance > distance)\n       \
    \         {\n                    min_distance = distance;\n                  \
    \  result = word[i];\n                }\n            }\n            distance =\
    \ 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoq_e61k_.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpoq_e61k_.d(32): Error: no property `find` for type `string`

    /tmp/tmpoq_e61k_.d(36): Error: no property `find` for type `string`

    /tmp/tmpoq_e61k_.d(43): Error: no property `find` for type `string`

    /tmp/tmpoq_e61k_.d(50): Error: no property `find` for type `string`

    /tmp/tmpoq_e61k_.d(50): Error: no property `find` for type `string`

    /tmp/tmpoq_e61k_.d(60): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoq_e61k_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(min_distance != word.length)\n\
    \    {\n        result = word[index..$];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3x487d76.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3x487d76.d(31): Error: no property `canFind` for type `string`

    /tmp/tmp3x487d76.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp3x487d76.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3x487d76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int temp = 0;\n    int index\
    \ = 0;\n    int index_temp = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            temp = i;\n            index_temp = index;\n\
    \            if(index > 0)\n            {\n                if(vowels.find(word[index-1])\
    \ == -1)\n                {\n                    if(distance == 0)\n         \
    \           {\n                        distance = temp;\n                    \
    \    result = c;\n                    }\n                    else if(temp < distance)\n\
    \                    {\n                        distance = temp;\n           \
    \             result = c;\n                    }\n                }\n        \
    \    }\n        }\n        index++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_lerd2yx.d(33): Error: no property `find` for type `string`

    /tmp/tmp_lerd2yx.d(35): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp_lerd2yx.d(39): Error: no property `find` for type `string`

    /tmp/tmp_lerd2yx.d(44): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp_lerd2yx.d(49): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, vowel; vowels)\n    {\n        index = word.find(vowel);\n     \
    \   if(index != -1)\n        {\n            if(index != 0 && index != word.length\
    \ - 1)\n            {\n                if(consonants.find(word[index - 1]) !=\
    \ -1 && consonants.find(word[index + 1]) != -1)\n                {\n         \
    \           if(min_distance > abs(index - word.length))\n                    {\n\
    \                        min_distance = abs(index - word.length);\n          \
    \              result = vowel;\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbxajob0j.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpbxajob0j.d(32): Error: no property `find` for type `string`

    /tmp/tmpbxajob0j.d(37): Error: no property `find` for type `string`

    /tmp/tmpbxajob0j.d(37): Error: no property `find` for type `string`

    /tmp/tmpbxajob0j.d(41): Error: cannot implicitly convert expression `abs(cast(ulong)index
    - word.length)` of type `ulong` to `int`

    /tmp/tmpbxajob0j.d(42): Error: cannot implicitly convert expression `vowel` of
    type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbxajob0j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n            {\n                if(distance\
    \ < min_distance)\n                {\n                    min_distance = distance;\n\
    \                    index = i;\n                }\n            }\n        }\n\
    \    }\n    if(min_distance != word.length)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpky464f9d.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpky464f9d.d(32): Error: no property `find` for type `string`

    /tmp/tmpky464f9d.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpky464f9d.d(35): Error: no property `find` for type `string`

    /tmp/tmpky464f9d.d(35): Error: no property `find` for type `string`

    /tmp/tmpky464f9d.d(40): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpky464f9d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    for (i =\
    \ 0; i < word.length; i++)\n    {\n        for (j = 0; j < vowels.length; j++)\n\
    \        {\n            if (word[i] == vowels[j])\n            {\n           \
    \     for (k = i; k < word.length; k++)\n                {\n                 \
    \   for (l = 0; l < consonants.length; l++)\n                    {\n         \
    \               if (word[k] == consonants[l])\n                        {\n   \
    \                         distance = k - i;\n                            if (distance\
    \ < min_distance)\n                            {\n                           \
    \     min_distance = distance;\n                                result = word[i];\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7yza3zi4.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7yza3zi4.d(50): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7yza3zi4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            if(i > 0 && consonants.canFind(word[i-1])\
    \ && i < word.length - 1 && consonants.canFind(word[i+1]))\n            {\n  \
    \              if(i < distance)\n                {\n                    distance\
    \ = i;\n                    result = c;\n                }\n            }\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_vx5yb72.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp_vx5yb72.d(31): Error: no property `canFind` for type `string`

    /tmp/tmp_vx5yb72.d(33): Error: no property `canFind` for type `string`

    /tmp/tmp_vx5yb72.d(33): Error: no property `canFind` for type `string`

    /tmp/tmp_vx5yb72.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp_vx5yb72.d(38): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_vx5yb72.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(consonants.find(c)\
    \ != -1)\n        {\n            foreach(j, v; vowels)\n            {\n      \
    \          if(word.find(v, i) != -1)\n                {\n                    distance\
    \ = word.find(v, i) - i;\n                    if(distance < min_distance)\n  \
    \                  {\n                        min_distance = distance;\n     \
    \                   index = word.find(v, i);\n                        result =\
    \ v;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprna49w4c.d(30): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmprna49w4c.d(33): Error: no property `find` for type `string`

    /tmp/tmprna49w4c.d(37): Error: no property `find` for type `string`

    /tmp/tmprna49w4c.d(39): Error: no property `find` for type `string`

    /tmp/tmprna49w4c.d(43): Error: no property `find` for type `string`

    /tmp/tmprna49w4c.d(44): Error: cannot implicitly convert expression `v` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprna49w4c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = -1;\n    int closest_consonant_index\
    \ = -1;\n    int word_length = word.length;\n    for (int i = 0; i < word_length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (closest_consonant_index != -1)\n            {\n                if (closest_vowel_index\
    \ == -1)\n                {\n                    closest_vowel_index = i;\n  \
    \                  closest_vowel = word[i..i];\n                }\n          \
    \      else if (i - closest_consonant_index < closest_vowel_index - closest_consonant_index)\n\
    \                {\n                    closest_vowel_index = i;\n           \
    \         closest_vowel = word[i..i];\n                }\n            }\n    \
    \    }\n        else if (consonants.find(word[i]) != -1)\n        {\n        \
    \    closest_consonant_index = i;\n        }\n    }\n    return closest_vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsmx8a894.d(30): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpsmx8a894.d(33): Error: no property `find` for type `string`

    /tmp/tmpsmx8a894.d(49): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsmx8a894.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            if (i + 1 < word.length && vowels.find(word[i +\
    \ 1]) == -1)\n            {\n                int distance = word.length - i -\
    \ 1;\n                if (distance < min_distance)\n                {\n      \
    \              min_distance = distance;\n                    result = word[i..$];\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk0kdrbw4.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpk0kdrbw4.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpk0kdrbw4.d(30): Error: no property `find` for type `string`

    /tmp/tmpk0kdrbw4.d(32): Error: no property `find` for type `string`

    /tmp/tmpk0kdrbw4.d(34): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk0kdrbw4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          if(i > 0 && i < word.length - 1)\n            {\n                if(!vowels.canFind(word[i-1])\
    \ && !vowels.canFind(word[i+1]))\n                {\n                    if(abs(word.length\
    \ - i) < min_distance)\n                    {\n                        min_distance\
    \ = abs(word.length - i);\n                        index = i;\n              \
    \      }\n                }\n            }\n        }\n    }\n    if(index !=\
    \ 0)\n    {\n        result = word[index..$];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzjtaokxu.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpzjtaokxu.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpzjtaokxu.d(35): Error: no property `canFind` for type `string`

    /tmp/tmpzjtaokxu.d(35): Error: no property `canFind` for type `string`

    /tmp/tmpzjtaokxu.d(39): Error: cannot implicitly convert expression `abs(word.length
    - i)` of type `ulong` to `int`

    /tmp/tmpzjtaokxu.d(40): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjtaokxu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx6e3xloz.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpx6e3xloz.d(32): Error: no property `find` for type `string`

    /tmp/tmpx6e3xloz.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpx6e3xloz.d(38): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx6e3xloz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) ==\
    \ -1)\n                {\n                    if (min_distance > abs(i - word.length))\n\
    \                    {\n                        min_distance = abs(i - word.length);\n\
    \                        result = word[i];\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnv2xu49d.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpnv2xu49d.d(30): Error: no property `find` for type `string`

    /tmp/tmpnv2xu49d.d(34): Error: no property `find` for type `string`

    /tmp/tmpnv2xu49d.d(34): Error: no property `find` for type `string`

    /tmp/tmpnv2xu49d.d(38): Error: cannot implicitly convert expression `abs(cast(ulong)i
    - word.length)` of type `ulong` to `int`

    /tmp/tmpnv2xu49d.d(39): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnv2xu49d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest_vowel = \"\";\n    int closest_vowel_index = 0;\n    int closest_vowel_distance\
    \ = 0;\n    int word_length = word.length;\n    int i = 0;\n    int j = 0;\n \
    \   int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n\
    \    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n\
    \    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int ii =\
    \ 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n   \
    \ int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr =\
    \ 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n   \
    \ int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aa =\
    \ 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n   \
    \ int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n    int q\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzlb8vm2s.d(91): Error: semicolon expected, not `unittest`

    /tmp/tmpzlb8vm2s.d(91): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzlb8vm2s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1t2yn4ee.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp1t2yn4ee.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp1t2yn4ee.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp1t2yn4ee.d(38): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1t2yn4ee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            if(consonants.canFind(word[i-1]) && consonants.canFind(word[i+1]))\n\
    \            {\n                distance = abs(i - word.length/2);\n         \
    \       if(distance < min_distance)\n                {\n                    min_distance\
    \ = distance;\n                    index = i;\n                }\n           \
    \ }\n        }\n    }\n    if(index != 0)\n    {\n        result = word[index..index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppo53nwk3.d(30): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmppo53nwk3.d(33): Error: no property `canFind` for type `string`

    /tmp/tmppo53nwk3.d(35): Error: no property `canFind` for type `string`

    /tmp/tmppo53nwk3.d(35): Error: no property `canFind` for type `string`

    /tmp/tmppo53nwk3.d(37): Error: cannot implicitly convert expression `abs(i - word.length
    / 2LU)` of type `ulong` to `int`

    /tmp/tmppo53nwk3.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppo53nwk3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = 0;\n            for (int j = i; j\
    \ < word.length; j++)\n            {\n                if (consonants.find(word[j])\
    \ != -1)\n                {\n                    distance++;\n               \
    \ }\n                else\n                {\n                    if (distance\
    \ < min_distance)\n                    {\n                        min_distance\
    \ = distance;\n                        result = word[i];\n                   \
    \ }\n                    break;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmh15kv3f.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpmh15kv3f.d(32): Error: no property `find` for type `string`

    /tmp/tmpmh15kv3f.d(37): Error: no property `find` for type `string`

    /tmp/tmpmh15kv3f.d(46): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmh15kv3f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            int j = i + 1;\n            while (j < word.length && consonants.find(word[j])\
    \ != -1)\n            {\n                j++;\n            }\n            if (j\
    \ < word.length && vowels.find(word[j]) == -1)\n            {\n              \
    \  int distance = j - i;\n                if (distance < min_distance)\n     \
    \           {\n                    min_distance = distance;\n                \
    \    result = word[i];\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbq521lkq.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpbq521lkq.d(31): Error: no property `find` for type `string`

    /tmp/tmpbq521lkq.d(34): Error: no property `find` for type `string`

    /tmp/tmpbq521lkq.d(38): Error: no property `find` for type `string`

    /tmp/tmpbq521lkq.d(44): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbq521lkq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                result = c;\n                min_distance = distance;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz69f_5vg.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpz69f_5vg.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpz69f_5vg.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpz69f_5vg.d(35): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz69f_5vg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = int.max;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = 0;\n\
    \            for(int j = i + 1; j < word.length; j++)\n            {\n       \
    \         if(consonants.canFind(word[j]))\n                {\n               \
    \     distance = j - i;\n                    break;\n                }\n     \
    \       }\n            if(distance < min_distance)\n            {\n          \
    \      min_distance = distance;\n                result = c;\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq5fag6dp.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpq5fag6dp.d(34): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmpq5fag6dp.d(36): Error: no property `canFind` for type `string`

    /tmp/tmpq5fag6dp.d(38): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmpq5fag6dp.d(45): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq5fag6dp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = 0;\n    int min_index\
    \ = 0;\n    int index = 0;\n    foreach(i, c; word)\n    {\n        if(consonants.find(c)\
    \ != -1)\n        {\n            if(vowels.find(word[i+1]) != -1)\n          \
    \  {\n                distance = i - index;\n                if(distance < min_distance\
    \ || min_distance == 0)\n                {\n                    min_distance =\
    \ distance;\n                    min_index = i;\n                }\n         \
    \   }\n            index = i;\n        }\n    }\n    if(min_distance != 0)\n \
    \   {\n        result = word[min_index+1];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsimszntg.d(34): Error: no property `find` for type `string`

    /tmp/tmpsimszntg.d(36): Error: no property `find` for type `string`

    /tmp/tmpsimszntg.d(38): Error: cannot implicitly convert expression `i - cast(ulong)index`
    of type `ulong` to `int`

    /tmp/tmpsimszntg.d(42): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpsimszntg.d(45): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpsimszntg.d(50): Error: cannot implicitly convert expression `word[cast(ulong)(min_index
    + 1)]` of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsimszntg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int left_distance\
    \ = i;\n            int right_distance = word.length - i - 1;\n            if(left_distance\
    \ > 0 && right_distance > 0)\n            {\n                if(left_distance\
    \ < right_distance)\n                {\n                    if(vowels.canFind(word[i\
    \ - 1]))\n                    {\n                        continue;\n         \
    \           }\n                    else\n                    {\n             \
    \           if(right_distance < min_distance)\n                        {\n   \
    \                         min_distance = right_distance;\n                   \
    \         result = c;\n                        }\n                    }\n    \
    \            }\n                else\n                {\n                    if(vowels.canFind(word[i\
    \ + 1]))\n                    {\n                        continue;\n         \
    \           }\n                    else\n                    {\n             \
    \           if(left_distance < min_distance)\n                        {\n    \
    \                        min_distance = left_distance;\n                     \
    \       result = c;\n                        }\n                    }\n      \
    \          }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8tkpai4o.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp8tkpai4o.d(30): Error: no property `canFind` for type `string`

    /tmp/tmp8tkpai4o.d(32): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp8tkpai4o.d(33): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmp8tkpai4o.d(38): Error: no property `canFind` for type `string`

    /tmp/tmp8tkpai4o.d(47): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp8tkpai4o.d(53): Error: no property `canFind` for type `string`

    /tmp/tmp8tkpai4o.d(62): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8tkpai4o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int vowel_index = 0;\n    int consonant_index = 0;\n    foreach(i, letter;\
    \ word)\n    {\n        if(vowels.canFind(letter))\n        {\n            vowel_index\
    \ = i;\n            foreach(j, consonant; word[i..$])\n            {\n       \
    \         if(consonants.canFind(consonant))\n                {\n             \
    \       consonant_index = j;\n                    distance = consonant_index -\
    \ vowel_index;\n                    if(distance < min_distance)\n            \
    \        {\n                        min_distance = distance;\n               \
    \         closest_vowel = letter;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return closest_vowel;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp84xd1uy9.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp84xd1uy9.d(34): Error: no property `canFind` for type `string`

    /tmp/tmp84xd1uy9.d(36): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp84xd1uy9.d(39): Error: no property `canFind` for type `string`

    /tmp/tmp84xd1uy9.d(41): Error: cannot implicitly convert expression `j` of type
    `ulong` to `int`

    /tmp/tmp84xd1uy9.d(46): Error: cannot implicitly convert expression `letter` of
    type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp84xd1uy9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8boq0faa.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8boq0faa.d(30): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(32): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(34): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8boq0faa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_dist = int.max;\n    int distance = 0;\n    int\
    \ last_consonant = -1;\n    int last_vowel = -1;\n    foreach(i, c; word)\n  \
    \  {\n        if(consonants.canFind(c))\n        {\n            last_consonant\
    \ = i;\n        }\n        else if(vowels.canFind(c))\n        {\n           \
    \ last_vowel = i;\n            distance = last_consonant - last_vowel;\n     \
    \       if(distance > 0 && distance < min_dist)\n            {\n             \
    \   min_dist = distance;\n                result = c;\n            }\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppmempu05.d(34): Error: no property `canFind` for type `string`

    /tmp/tmppmempu05.d(36): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmppmempu05.d(38): Error: no property `canFind` for type `string`

    /tmp/tmppmempu05.d(40): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmppmempu05.d(45): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = -1;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != -1)\n    {\n        result\
    \ = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnm5nngdj.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpnm5nngdj.d(31): Error: no property `find` for type `string`

    /tmp/tmpnm5nngdj.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpnm5nngdj.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnm5nngdj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n            {\n                distance = abs(i - word.length);\n  \
    \              if(distance < min_distance)\n                {\n              \
    \      min_distance = distance;\n                    result = c;\n           \
    \     }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8z7p5qq_.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp8z7p5qq_.d(32): Error: no property `find` for type `string`

    /tmp/tmp8z7p5qq_.d(34): Error: no property `find` for type `string`

    /tmp/tmp8z7p5qq_.d(34): Error: no property `find` for type `string`

    /tmp/tmp8z7p5qq_.d(36): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmp8z7p5qq_.d(40): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8z7p5qq_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = 0;\n    int distance\
    \ = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n   \
    \     {\n            distance = word.length - i;\n            if(distance < min_distance\
    \ || min_distance == 0)\n            {\n                if(i > 0 && consonants.find(word[i-1])\
    \ != -1)\n                {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0tkezrd1.d(33): Error: no property `find` for type `string`

    /tmp/tmp0tkezrd1.d(35): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp0tkezrd1.d(38): Error: no property `find` for type `string`

    /tmp/tmp0tkezrd1.d(40): Error: no property `find` for type `string`

    /tmp/tmp0tkezrd1.d(43): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0tkezrd1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = 0;\n \
    \   int index = 0;\n    int min_index = 0;\n    int word_length = word.length;\n\
    \    for (int i = 0; i < word_length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            index = i;\n            distance = word_length\
    \ - index;\n            if (distance > min_distance)\n            {\n        \
    \        min_distance = distance;\n                min_index = index;\n      \
    \      }\n        }\n    }\n    if (min_distance == 0)\n    {\n        return\
    \ result;\n    }\n    else\n    {\n        result = word[min_index];\n       \
    \ return result;\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_i6snfd.d(31): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpf_i6snfd.d(34): Error: no property `find` for type `string`

    /tmp/tmpf_i6snfd.d(51): Error: cannot implicitly convert expression `word[cast(ulong)min_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_i6snfd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int j = i;\n            while(j >= 0 && consonants.find(word[j])\
    \ != -1)\n            {\n                j--;\n            }\n            if(j\
    \ >= 0)\n            {\n                j = i;\n                while(j < word.length\
    \ && consonants.find(word[j]) != -1)\n                {\n                    j++;\n\
    \                }\n                if(j < word.length)\n                {\n \
    \                   distance = j - i;\n                    if(distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd57ckrft.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpd57ckrft.d(32): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpd57ckrft.d(35): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpd57ckrft.d(42): Error: no property `find` for type `string`

    /tmp/tmpd57ckrft.d(48): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    /tmp/tmpd57ckrft.d(52): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd57ckrft.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int new_distance\
    \ = word.length - i;\n            if(new_distance < distance)\n            {\n\
    \                distance = new_distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpew3woar4.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpew3woar4.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpew3woar4.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpew3woar4.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpew3woar4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int pos = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            pos = word.rfind(c);\n            distance = word.length\
    \ - pos;\n            if(distance < min_distance)\n            {\n           \
    \     min_distance = distance;\n                result = c;\n            }\n \
    \       }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjll7858q.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjll7858q.d(33): Error: no property `find` for type `string`

    /tmp/tmpjll7858q.d(35): Error: no property `rfind` for type `string`

    /tmp/tmpjll7858q.d(36): Error: cannot implicitly convert expression `word.length
    - cast(ulong)pos` of type `ulong` to `int`

    /tmp/tmpjll7858q.d(40): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjll7858q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0) {\n        if (vowels.find(word[index]) != -1) {\n            if (vowels.find(word[index\
    \ - 1]) == -1) {\n                result = word[index];\n                break;\n\
    \            }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprxcvu6dc.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmprxcvu6dc.d(29): Error: no property `find` for type `string`

    /tmp/tmprxcvu6dc.d(30): Error: no property `find` for type `string`

    /tmp/tmprxcvu6dc.d(31): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprxcvu6dc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if (distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = word[i..$];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuxxhwikq.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpuxxhwikq.d(30): Error: no property `find` for type `string`

    /tmp/tmpuxxhwikq.d(32): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuxxhwikq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = 0;\n    int closest_vowel_distance\
    \ = word.length;\n    int word_length = word.length;\n    int i = 0;\n    int\
    \ j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n   \
    \ int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n\
    \    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n\
    \    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n\
    \    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n\
    \    int ii = 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm\
    \ = 0;\n    int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n \
    \   int rr = 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv\
    \ = 0;\n    int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n \
    \   int aa = 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee\
    \ = 0;\n    int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int iii = 0;\n\
    \    int jjj = 0;\n    int kkk = 0;\n    int lll = 0\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptkgk2ntp.d(87): Error: semicolon expected, not `unittest`

    /tmp/tmptkgk2ntp.d(87): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptkgk2ntp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            int left = i - 1;\n            int right = i + 1;\n            while\
    \ (left >= 0 && consonants.find(word[left]) != -1)\n            {\n          \
    \      left--;\n            }\n            while (right < word.length && consonants.find(word[right])\
    \ != -1)\n            {\n                right++;\n            }\n           \
    \ if (left >= 0 && right < word.length)\n            {\n                if (right\
    \ - left - 1 < min_distance)\n                {\n                    min_distance\
    \ = right - left - 1;\n                    result = word[i];\n               \
    \ }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbj5eihje.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpbj5eihje.d(31): Error: no property `find` for type `string`

    /tmp/tmpbj5eihje.d(35): Error: no property `find` for type `string`

    /tmp/tmpbj5eihje.d(39): Error: no property `find` for type `string`

    /tmp/tmpbj5eihje.d(48): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbj5eihje.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n        {\n\
    \            int vowel_index = vowels.find(word[i+1]);\n            if(vowel_index\
    \ != -1)\n            {\n                int distance = i - vowel_index;\n   \
    \             if(distance < min_distance)\n                {\n               \
    \     min_distance = distance;\n                    index = vowel_index;\n   \
    \             }\n            }\n        }\n    }\n    if(index != 0)\n    {\n\
    \        result = vowels[index..index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnwv5mdze.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpnwv5mdze.d(32): Error: no property `find` for type `string`

    /tmp/tmpnwv5mdze.d(34): Error: no property `find` for type `string`

    /tmp/tmpnwv5mdze.d(37): Error: cannot implicitly convert expression `i - cast(ulong)vowel_index`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwv5mdze.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length - 1;\n    while (index >= 0)\n \
    \   {\n        if (vowels.find(word[index]) != -1)\n        {\n            if\
    \ (index == word.length - 1)\n            {\n                index--;\n      \
    \          continue;\n            }\n            if (consonants.find(word[index\
    \ + 1]) != -1)\n            {\n                result = word[index];\n       \
    \         break;\n            }\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqytixpnk.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpqytixpnk.d(31): Error: no property `find` for type `string`

    /tmp/tmpqytixpnk.d(38): Error: no property `find` for type `string`

    /tmp/tmpqytixpnk.d(40): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqytixpnk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = 0;\n    int distance = 0;\n    int index_of_vowel\
    \ = 0;\n    int index_of_consonant = 0;\n    int index_of_second_consonant = 0;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            index_of_vowel = i;\n            for (int j =\
    \ i; j < word.length; j++)\n            {\n                if (consonants.find(word[j])\
    \ != -1)\n                {\n                    index_of_consonant = j;\n   \
    \                 for (int k = j; k < word.length; k++)\n                    {\n\
    \                        if (consonants.find(word[k]) != -1)\n               \
    \         {\n                            index_of_second_consonant = k;\n    \
    \                        distance = index_of_second_consonant - index_of_vowel;\n\
    \                            if (distance < min_distance || min_distance == 0)\n\
    \                            {\n                                min_distance =\
    \ distance;\n                                result = word[i];\n             \
    \               }\n                        }\n                    }\n        \
    \        }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp19zz1wyz.d(35): Error: no property `find` for type `string`

    /tmp/tmp19zz1wyz.d(40): Error: no property `find` for type `string`

    /tmp/tmp19zz1wyz.d(45): Error: no property `find` for type `string`

    /tmp/tmp19zz1wyz.d(52): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp19zz1wyz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = 0;\n    int distance = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(consonants.find(c) != -1)\n        {\n         \
    \   foreach(j, v; vowels)\n            {\n                if(word.find(v, i) !=\
    \ -1)\n                {\n                    distance = word.find(v, i) - i;\n\
    \                    if(min_distance == 0 || distance < min_distance)\n      \
    \              {\n                        min_distance = distance;\n         \
    \               result = v;\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaig1_sfj.d(32): Error: no property `find` for type `string`

    /tmp/tmpaig1_sfj.d(36): Error: no property `find` for type `string`

    /tmp/tmpaig1_sfj.d(38): Error: no property `find` for type `string`

    /tmp/tmpaig1_sfj.d(42): Error: cannot implicitly convert expression `v` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaig1_sfj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i > 0 && consonants.find(word[i-1]) != -1)\n             \
    \   {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7eynulqc.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7eynulqc.d(31): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp7eynulqc.d(36): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(38): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(41): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7eynulqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    foreach(i, letter; word)\n    {\n        if(vowels.canFind(letter))\n\
    \        {\n            index = word.length - i - 1;\n            distance = index\
    \ - word.canFind(vowels, index);\n            if(distance > 0 && distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = letter;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5ojoy5lm.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp5ojoy5lm.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp5ojoy5lm.d(34): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmp5ojoy5lm.d(35): Error: no property `canFind` for type `string`

    /tmp/tmp5ojoy5lm.d(39): Error: cannot implicitly convert expression `letter` of
    type `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            if(i\
    \ > 0 && consonants.find(word[i-1]) != -1)\n            {\n                if(i\
    \ < word.length-1 && consonants.find(word[i+1]) != -1)\n                {\n  \
    \                  if(abs(word.length-1-i) < min)\n                    {\n   \
    \                     min = abs(word.length-1-i);\n                        index\
    \ = i;\n                    }\n                }\n            }\n        }\n \
    \   }\n    if(index != 0)\n    {\n        result = word[index..index];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz7op__et.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpz7op__et.d(32): Error: no property `find` for type `string`

    /tmp/tmpz7op__et.d(34): Error: no property `find` for type `string`

    /tmp/tmpz7op__et.d(36): Error: no property `find` for type `string`

    /tmp/tmpz7op__et.d(40): Error: cannot implicitly convert expression `abs(word.length
    - 1LU - i)` of type `ulong` to `int`

    /tmp/tmpz7op__et.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz7op__et.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length;\n    int i = len - 1;\n    while (i > 0)\n    {\n  \
    \      if (vowels.find(word[i]) != -1)\n        {\n            if (vowels.find(word[i-1])\
    \ == -1)\n            {\n                return word[i..$];\n            }\n \
    \       }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp256he3ef.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp256he3ef.d(30): Error: no property `find` for type `string`

    /tmp/tmp256he3ef.d(32): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp256he3ef.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int pos = word.length;\n    int pos_vowel = -1;\n    int\
    \ pos_consonant = -1;\n    int min_distance = word.length;\n    foreach(i, c;\
    \ word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            pos_vowel\
    \ = i;\n            if(pos_consonant != -1)\n            {\n                if(pos_vowel\
    \ - pos_consonant < min_distance)\n                {\n                    min_distance\
    \ = pos_vowel - pos_consonant;\n                    pos = pos_vowel;\n       \
    \         }\n            }\n        }\n        else if(consonants.find(c) != -1)\n\
    \        {\n            pos_consonant = i;\n        }\n    }\n    if(pos != word.length)\n\
    \    {\n        result = word[pos..$];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3zujhjs.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpk3zujhjs.d(31): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpk3zujhjs.d(34): Error: no property `find` for type `string`

    /tmp/tmpk3zujhjs.d(36): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpk3zujhjs.d(46): Error: no property `find` for type `string`

    /tmp/tmpk3zujhjs.d(48): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3zujhjs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_dist = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int dist = word.length\
    \ - i;\n            if(dist < min_dist)\n            {\n                min_dist\
    \ = dist;\n                result = c;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ncyosow.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp4ncyosow.d(30): Error: no property `canFind` for type `string`

    /tmp/tmp4ncyosow.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp4ncyosow.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = -1;\n    int min_distance = word.length;\n \
    \   foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                if(i == 0)\n                {\n              \
    \      if(consonants.find(word[i+1]) != -1)\n                    {\n         \
    \               min_distance = distance;\n                        index = i;\n\
    \                    }\n                }\n                else if(i == word.length\
    \ - 1)\n                {\n                    if(consonants.find(word[i-1]) !=\
    \ -1)\n                    {\n                        min_distance = distance;\n\
    \                        index = i;\n                    }\n                }\n\
    \                else\n                {\n                    if(consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n                    {\n        \
    \                min_distance = distance;\n                        index = i;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if(index != -1)\n    {\n        result = word[index..index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp73dz9f41.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp73dz9f41.d(32): Error: no property `find` for type `string`

    /tmp/tmp73dz9f41.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp73dz9f41.d(39): Error: no property `find` for type `string`

    /tmp/tmp73dz9f41.d(42): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp73dz9f41.d(47): Error: no property `find` for type `string`

    /tmp/tmp73dz9f41.d(50): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp73dz9f41.d(55): Error: no property `find` for type `string`

    /tmp/tmp73dz9f41.d(55): Error: no property `find` for type `string`

    /tmp/tmp73dz9f41.d(58): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp73dz9f41.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = -1;\n    int distance = 0;\n    int\
    \ min_distance = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            index = i;\n            distance = word.length\
    \ - index;\n            if(distance < min_distance)\n            {\n         \
    \       min_distance = distance;\n                result = c;\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeon4u7h1.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpeon4u7h1.d(32): Error: no property `find` for type `string`

    /tmp/tmpeon4u7h1.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpeon4u7h1.d(35): Error: cannot implicitly convert expression `word.length
    - cast(ulong)index` of type `ulong` to `int`

    /tmp/tmpeon4u7h1.d(39): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeon4u7h1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int\
    \ closest_vowel_index = -1;\n    int closest_consonant_index = -1;\n    int closest_distance\
    \ = -1;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n     \
    \   {\n            if(closest_consonant_index != -1)\n            {\n        \
    \        if(closest_distance == -1 || i - closest_consonant_index < closest_distance)\n\
    \                {\n                    closest_distance = i - closest_consonant_index;\n\
    \                    closest_vowel_index = i;\n                }\n           \
    \ }\n        }\n        else if(consonants.canFind(c))\n        {\n          \
    \  closest_consonant_index = i;\n        }\n    }\n    if(closest_vowel_index\
    \ == -1)\n    {\n        return \"\";\n    }\n    return word[closest_vowel_index..closest_vowel_index];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8dhvdxx5.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp8dhvdxx5.d(38): Error: cannot implicitly convert expression `i - cast(ulong)closest_consonant_index`
    of type `ulong` to `int`

    /tmp/tmp8dhvdxx5.d(39): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp8dhvdxx5.d(43): Error: no property `canFind` for type `string`

    /tmp/tmp8dhvdxx5.d(45): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8dhvdxx5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = word.length;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            if (i > 0 && i < word.length - 1)\n            {\n       \
    \         if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n\
    \                {\n                    if (distance > abs(word.length - i))\n\
    \                    {\n                        distance = abs(word.length - i);\n\
    \                        result = word[i];\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjcrsezic.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpjcrsezic.d(30): Error: no property `find` for type `string`

    /tmp/tmpjcrsezic.d(34): Error: no property `find` for type `string`

    /tmp/tmpjcrsezic.d(34): Error: no property `find` for type `string`

    /tmp/tmpjcrsezic.d(38): Error: cannot implicitly convert expression `abs(word.length
    - cast(ulong)i)` of type `ulong` to `int`

    /tmp/tmpjcrsezic.d(39): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = 0;\n            for (int j = i; j\
    \ < word.length; j++)\n            {\n                if (consonants.find(word[j])\
    \ != -1)\n                {\n                    distance++;\n               \
    \ }\n                else\n                {\n                    break;\n   \
    \             }\n            }\n            if (distance < min_distance)\n   \
    \         {\n                min_distance = distance;\n                result\
    \ = word[i];\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfraeu2nz.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpfraeu2nz.d(32): Error: no property `find` for type `string`

    /tmp/tmpfraeu2nz.d(37): Error: no property `find` for type `string`

    /tmp/tmpfraeu2nz.d(49): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfraeu2nz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = 0;\n    int distance\
    \ = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n      \
    \  {\n            index = i;\n            distance = word.length - index;\n  \
    \          if(min_distance == 0)\n            {\n                min_distance\
    \ = distance;\n                result = c;\n            }\n            else if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7lrgzu6v.d(33): Error: no property `canFind` for type `string`

    /tmp/tmp7lrgzu6v.d(35): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp7lrgzu6v.d(36): Error: cannot implicitly convert expression `word.length
    - cast(ulong)index` of type `ulong` to `int`

    /tmp/tmp7lrgzu6v.d(40): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    /tmp/tmp7lrgzu6v.d(45): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7lrgzu6v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) ==\
    \ -1)\n                {\n                    if (min_distance > abs(word.length\
    \ - i - 1))\n                    {\n                        min_distance = abs(word.length\
    \ - i - 1);\n                        result = word[i..$];\n                  \
    \  }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbqdz8juk.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpbqdz8juk.d(30): Error: no property `find` for type `string`

    /tmp/tmpbqdz8juk.d(34): Error: no property `find` for type `string`

    /tmp/tmpbqdz8juk.d(34): Error: no property `find` for type `string`

    /tmp/tmpbqdz8juk.d(38): Error: cannot implicitly convert expression `abs(word.length
    - cast(ulong)i - 1LU)` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbqdz8juk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length;\n    int distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          if(i > 0 && consonants.canFind(word[i-1]) && i < word.length - 1 &&\
    \ consonants.canFind(word[i+1]))\n            {\n                if(i < distance)\n\
    \                {\n                    distance = i;\n                    result\
    \ = c;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw2qrxhg9.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpw2qrxhg9.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpw2qrxhg9.d(32): Error: no property `canFind` for type `string`

    /tmp/tmpw2qrxhg9.d(34): Error: no property `canFind` for type `string`

    /tmp/tmpw2qrxhg9.d(34): Error: no property `canFind` for type `string`

    /tmp/tmpw2qrxhg9.d(38): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpw2qrxhg9.d(39): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw2qrxhg9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = 0;\n    int index\
    \ = 0;\n    int min_index = 0;\n    int word_length = word.length;\n    int vowel_length\
    \ = vowels.length;\n    int consonant_length = consonants.length;\n    for (int\
    \ i = 0; i < word_length; i++)\n    {\n        for (int j = 0; j < vowel_length;\
    \ j++)\n        {\n            if (word[i] == vowels[j])\n            {\n    \
    \            for (int k = 0; k < consonant_length; k++)\n                {\n \
    \                   if (word[i - 1] == consonants[k])\n                    {\n\
    \                        for (int l = 0; l < consonant_length; l++)\n        \
    \                {\n                            if (word[i + 1] == consonants[l])\n\
    \                            {\n                                distance = i;\n\
    \                                if (distance < min_distance || min_distance ==\
    \ 0)\n                                {\n                                    min_distance\
    \ = distance;\n                                    min_index = i;\n          \
    \                      }\n                            }\n                    \
    \    }\n                    }\n                }\n            }\n        }\n \
    \   }\n    if (min_distance != 0)\n    {\n        result = word[min_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl_q3dzue.d(32): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpl_q3dzue.d(33): Error: cannot implicitly convert expression `vowels.length`
    of type `ulong` to `int`

    /tmp/tmpl_q3dzue.d(34): Error: cannot implicitly convert expression `consonants.length`
    of type `ulong` to `int`

    /tmp/tmpl_q3dzue.d(64): Error: cannot implicitly convert expression `word[cast(ulong)min_index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_q3dzue.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != 0)\n    {\n        result\
    \ = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd1adhdab.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpd1adhdab.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpd1adhdab.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpd1adhdab.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd1adhdab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int temp = 0;\n    for (int\
    \ i = word.length - 1; i > 0; i--)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            if (vowels.find(word[i - 1]) == -1)\n          \
    \  {\n                temp = i;\n                break;\n            }\n     \
    \   }\n    }\n    if (temp == 0)\n    {\n        return result;\n    }\n    for\
    \ (int i = temp; i > 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (vowels.find(word[i - 1]) == -1)\n            {\n \
    \               distance = temp - i;\n                if (distance < temp)\n \
    \               {\n                    temp = distance;\n                    result\
    \ = word[i];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0odnkjcq.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp0odnkjcq.d(31): Error: no property `find` for type `string`

    /tmp/tmp0odnkjcq.d(33): Error: no property `find` for type `string`

    /tmp/tmp0odnkjcq.d(46): Error: no property `find` for type `string`

    /tmp/tmp0odnkjcq.d(48): Error: no property `find` for type `string`

    /tmp/tmp0odnkjcq.d(54): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0odnkjcq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int left = word[i..$].find(consonants);\n            int right =\
    \ word[0..i].find(consonants);\n            if(left != -1 && right != -1)\n  \
    \          {\n                distance = min(left, right);\n                if(distance\
    \ < min_distance)\n                {\n                    min_distance = distance;\n\
    \                    result = c;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqlv4s426.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpqlv4s426.d(32): Error: no property `find` for type `string`

    /tmp/tmpqlv4s426.d(34): Error: no property `find` for type `string`

    /tmp/tmpqlv4s426.d(35): Error: no property `find` for type `string`

    /tmp/tmpqlv4s426.d(38): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpqlv4s426.d(42): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqlv4s426.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) ==\
    \ -1)\n                {\n                    if (min_distance > abs(word.length\
    \ - i - 1))\n                    {\n                        min_distance = abs(word.length\
    \ - i - 1);\n                        result = word[i];\n                    }\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp39dm8403.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp39dm8403.d(30): Error: no property `find` for type `string`

    /tmp/tmp39dm8403.d(34): Error: no property `find` for type `string`

    /tmp/tmp39dm8403.d(34): Error: no property `find` for type `string`

    /tmp/tmp39dm8403.d(38): Error: cannot implicitly convert expression `abs(word.length
    - cast(ulong)i - 1LU)` of type `ulong` to `int`

    /tmp/tmp39dm8403.d(39): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp39dm8403.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != 0)\n    {\n        result\
    \ = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd1adhdab.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpd1adhdab.d(31): Error: no property `canFind` for type `string`

    /tmp/tmpd1adhdab.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpd1adhdab.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd1adhdab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int i = word.length - 1;\n    while (i >= 0)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = word.length - 1 - i;\n           \
    \ if (distance < min_distance)\n            {\n                min_distance =\
    \ distance;\n                result = word[i..$];\n            }\n        }\n\
    \        i--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp541_gvw1.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp541_gvw1.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp541_gvw1.d(32): Error: no property `find` for type `string`

    /tmp/tmp541_gvw1.d(34): Error: cannot implicitly convert expression `word.length
    - 1LU - cast(ulong)i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp541_gvw1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int j = i;\n            while(j >= 0 && consonants.find(word[j])\
    \ != -1)\n            {\n                j--;\n            }\n            if(j\
    \ >= 0)\n            {\n                j = i;\n                while(j < word.length\
    \ && consonants.find(word[j]) != -1)\n                {\n                    j++;\n\
    \                }\n                if(j < word.length)\n                {\n \
    \                   distance = i - j;\n                    if(distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdjn4zyln.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpdjn4zyln.d(32): Error: no property `find` for type `string`

    /tmp/tmpdjn4zyln.d(34): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpdjn4zyln.d(35): Error: no property `find` for type `string`

    /tmp/tmpdjn4zyln.d(41): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpdjn4zyln.d(42): Error: no property `find` for type `string`

    /tmp/tmpdjn4zyln.d(48): Error: cannot implicitly convert expression `i - cast(ulong)j`
    of type `ulong` to `int`

    /tmp/tmpdjn4zyln.d(52): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjn4zyln.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n    \
    \        int distance = word.length - i - 1;\n            if(distance < min_distance)\n\
    \            {\n                if(i > 0 && consonants.canFind(word[i - 1]))\n\
    \                {\n                    if(i < word.length - 1 && consonants.canFind(word[i\
    \ + 1]))\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnh5ixzwj.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpnh5ixzwj.d(32): Error: no property `canFind` for type `string`

    /tmp/tmpnh5ixzwj.d(34): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmpnh5ixzwj.d(37): Error: no property `canFind` for type `string`

    /tmp/tmpnh5ixzwj.d(39): Error: no property `canFind` for type `string`

    /tmp/tmpnh5ixzwj.d(42): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnh5ixzwj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i > 0 && consonants.find(word[i-1]) != -1)\n             \
    \   {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7eynulqc.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7eynulqc.d(31): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp7eynulqc.d(36): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(38): Error: no property `find` for type `string`

    /tmp/tmp7eynulqc.d(41): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7eynulqc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min = word.length;\n   \
    \ foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n  \
    \          if(i > 0 && vowels.find(word[i-1]) == -1)\n            {\n        \
    \        if(i < min)\n                {\n                    min = i;\n      \
    \              result = c;\n                }\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsawwq_l2.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpsawwq_l2.d(31): Error: no property `find` for type `string`

    /tmp/tmpsawwq_l2.d(33): Error: no property `find` for type `string`

    /tmp/tmpsawwq_l2.d(37): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmpsawwq_l2.d(38): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsawwq_l2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                result = c;\n                min_distance = distance;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz69f_5vg.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpz69f_5vg.d(30): Error: no property `canFind` for type `string`

    /tmp/tmpz69f_5vg.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmpz69f_5vg.d(35): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz69f_5vg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                if(i > 0 && consonants.find(word[i-1]) != -1)\n\
    \                {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        index = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if(index != 0)\n    {\n        result =\
    \ word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3c_njtoe.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3c_njtoe.d(32): Error: no property `find` for type `string`

    /tmp/tmp3c_njtoe.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp3c_njtoe.d(37): Error: no property `find` for type `string`

    /tmp/tmp3c_njtoe.d(39): Error: no property `find` for type `string`

    /tmp/tmp3c_njtoe.d(42): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3c_njtoe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int i = word.length - 1;\n    while (i >= 0) {\n       \
    \ if (consonants.find(word[i]) != -1) {\n            if (i != word.length - 1)\
    \ {\n                if (vowels.find(word[i + 1]) != -1) {\n                 \
    \   result = word[i + 1];\n                    break;\n                }\n   \
    \         }\n            if (i != 0) {\n                if (vowels.find(word[i\
    \ - 1]) != -1) {\n                    result = word[i - 1];\n                \
    \    break;\n                }\n            }\n        }\n        i--;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmperqve9s_.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmperqve9s_.d(30): Error: no property `find` for type `string`

    /tmp/tmperqve9s_.d(32): Error: no property `find` for type `string`

    /tmp/tmperqve9s_.d(33): Error: cannot implicitly convert expression `word[cast(ulong)(i
    + 1)]` of type `immutable(char)` to `string`

    /tmp/tmperqve9s_.d(38): Error: no property `find` for type `string`

    /tmp/tmperqve9s_.d(39): Error: cannot implicitly convert expression `word[cast(ulong)(i
    - 1)]` of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmperqve9s_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    int index = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            if(consonants.find(word[i\
    \ - 1]) != -1 && consonants.find(word[i + 1]) != -1)\n            {\n        \
    \        if(abs(i - word.length) < distance)\n                {\n            \
    \        distance = abs(i - word.length);\n                    index = i;\n  \
    \              }\n            }\n        }\n    }\n    if(distance != word.length)\n\
    \    {\n        result = word[index..$];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn3egr4v5.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpn3egr4v5.d(32): Error: no property `find` for type `string`

    /tmp/tmpn3egr4v5.d(34): Error: no property `find` for type `string`

    /tmp/tmpn3egr4v5.d(34): Error: no property `find` for type `string`

    /tmp/tmpn3egr4v5.d(38): Error: cannot implicitly convert expression `abs(i - word.length)`
    of type `ulong` to `int`

    /tmp/tmpn3egr4v5.d(39): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn3egr4v5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int vowel_index = -1;\n    int consonant_index = -1;\n \
    \   int distance = 0;\n    int min_distance = word.length;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            vowel_index = i;\n            for (int j = i; j >= 0; j--)\n\
    \            {\n                if (consonants.find(word[j]) != -1)\n        \
    \        {\n                    consonant_index = j;\n                    distance\
    \ = vowel_index - consonant_index;\n                    if (distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = word[i];\n                    }\n             \
    \       break;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvcca5lpd.d(31): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpvcca5lpd.d(34): Error: no property `find` for type `string`

    /tmp/tmpvcca5lpd.d(39): Error: no property `find` for type `string`

    /tmp/tmpvcca5lpd.d(46): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvcca5lpd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            for (int j = i - 1; j >= 0; j--)\n          \
    \  {\n                if (vowels.find(word[j]) == -1)\n                {\n   \
    \                 distance = i - j;\n                    if (distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = word[i];\n                    }\n             \
    \       break;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt_6u6vuw.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpt_6u6vuw.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpt_6u6vuw.d(31): Error: no property `find` for type `string`

    /tmp/tmpt_6u6vuw.d(35): Error: no property `find` for type `string`

    /tmp/tmpt_6u6vuw.d(41): Error: cannot implicitly convert expression `word[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_6u6vuw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ consonants = \"bcdfghjklmnpqrstvwxyz\";\n    string result = \"\";\n    int\
    \ min_distance = word.length;\n    foreach(v; vowels)\n    {\n        int index\
    \ = word.find(v);\n        if(index != -1)\n        {\n            if(index !=\
    \ 0 && index != word.length - 1)\n            {\n                if(consonants.find(word[index\
    \ - 1]) != -1 && consonants.find(word[index + 1]) != -1)\n                {\n\
    \                    if(min_distance > abs(index - word.length))\n           \
    \         {\n                        min_distance = abs(index - word.length);\n\
    \                        result = v;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpccinp03i.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpccinp03i.d(31): Error: no property `find` for type `string`

    /tmp/tmpccinp03i.d(36): Error: no property `find` for type `string`

    /tmp/tmpccinp03i.d(36): Error: no property `find` for type `string`

    /tmp/tmpccinp03i.d(40): Error: cannot implicitly convert expression `abs(cast(ulong)index
    - word.length)` of type `ulong` to `int`

    /tmp/tmpccinp03i.d(41): Error: cannot implicitly convert expression `v` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpccinp03i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    int\
    \ closest = word.length;\n    string closestVowel = \"\";\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < closest)\n            {\n                closest\
    \ = distance;\n                closestVowel = c;\n            }\n        }\n \
    \   }\n    return closestVowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1uske92k.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp1uske92k.d(30): Error: no property `canFind` for type `string`

    /tmp/tmp1uske92k.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp1uske92k.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1uske92k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int i = word.length - 1;\n    while (i >= 0)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = word.length - i - 1;\n           \
    \ if (distance < min_distance)\n            {\n                min_distance =\
    \ distance;\n                result = word[i..$];\n            }\n        }\n\
    \        i--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvu890pc5.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpvu890pc5.d(29): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpvu890pc5.d(32): Error: no property `find` for type `string`

    /tmp/tmpvu890pc5.d(34): Error: cannot implicitly convert expression `word.length
    - cast(ulong)i - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvu890pc5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = word.length;\n    int index = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int temp\
    \ = word.length - i;\n            if(temp < distance)\n            {\n       \
    \         distance = temp;\n                index = i;\n            }\n      \
    \  }\n    }\n    if(distance == word.length)\n    {\n        return result;\n\
    \    }\n    else\n    {\n        foreach(i, c; word[index..$])\n        {\n  \
    \          if(consonants.canFind(c))\n            {\n                return word[index..$][i-1..$];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7c0zdqma.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7c0zdqma.d(32): Error: no property `canFind` for type `string`

    /tmp/tmp7c0zdqma.d(34): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp7c0zdqma.d(38): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    /tmp/tmp7c0zdqma.d(50): Error: no property `canFind` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7c0zdqma.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length;\n    int i = len - 1;\n    while (i > 0)\n    {\n  \
    \      if (vowels.find(word[i]) != -1)\n        {\n            if (vowels.find(word[i-1])\
    \ == -1)\n            {\n                return word[i..$];\n            }\n \
    \       }\n        i--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp256he3ef.d(26): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp256he3ef.d(30): Error: no property `find` for type `string`

    /tmp/tmp256he3ef.d(32): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp256he3ef.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(vowel;\
    \ vowels)\n    {\n        int index = word.find(vowel);\n        if(index != -1)\n\
    \        {\n            if(index != 0 && index != word.length - 1)\n         \
    \   {\n                if(word[index - 1] != vowel && word[index + 1] != vowel)\n\
    \                {\n                    if(min_distance > abs(index - word.length))\n\
    \                    {\n                        min_distance = abs(index - word.length);\n\
    \                        result = vowel;\n                    }\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyvhiqmu7.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpyvhiqmu7.d(30): Error: no property `find` for type `string`

    /tmp/tmpyvhiqmu7.d(39): Error: cannot implicitly convert expression `abs(cast(ulong)index
    - word.length)` of type `ulong` to `int`

    /tmp/tmpyvhiqmu7.d(40): Error: cannot implicitly convert expression `vowel` of
    type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyvhiqmu7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ char c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n        \
    \    int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptjan1k3j.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmptjan1k3j.d(30): Error: no property `find` for type `string`

    /tmp/tmptjan1k3j.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmptjan1k3j.d(36): Error: cannot implicitly convert expression `c` of type
    `char` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptjan1k3j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                int left_index = i - 1;\n                int right_index = i\
    \ + 1;\n                if(left_index >= 0 && right_index < word.length)\n   \
    \             {\n                    if(consonants.find(word[left_index]) != -1\
    \ && consonants.find(word[right_index]) != -1)\n                    {\n      \
    \                  min_distance = distance;\n                        result =\
    \ c;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0hw9jbeo.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp0hw9jbeo.d(31): Error: no property `find` for type `string`

    /tmp/tmp0hw9jbeo.d(33): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmp0hw9jbeo.d(36): Error: cannot implicitly convert expression `i - 1LU`
    of type `ulong` to `int`

    /tmp/tmp0hw9jbeo.d(37): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmp0hw9jbeo.d(40): Error: no property `find` for type `string`

    /tmp/tmp0hw9jbeo.d(40): Error: no property `find` for type `string`

    /tmp/tmp0hw9jbeo.d(43): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hw9jbeo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n      \
    \  {\n            int j = i + 1;\n            while(j < word.length)\n       \
    \     {\n                if(vowels.find(word[j]) != -1)\n                {\n \
    \                   distance = j - i;\n                    if(distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = word[j..$];\n                    }\n          \
    \          break;\n                }\n                j++;\n            }\n  \
    \      }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6e8otoxy.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp6e8otoxy.d(32): Error: no property `find` for type `string`

    /tmp/tmp6e8otoxy.d(34): Error: cannot implicitly convert expression `i + 1LU`
    of type `ulong` to `int`

    /tmp/tmp6e8otoxy.d(37): Error: no property `find` for type `string`

    /tmp/tmp6e8otoxy.d(39): Error: cannot implicitly convert expression `cast(ulong)j
    - i` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6e8otoxy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i - 1;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp96p8z93b.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp96p8z93b.d(31): Error: no property `canFind` for type `string`

    /tmp/tmp96p8z93b.d(33): Error: cannot implicitly convert expression `word.length
    - i - 1LU` of type `ulong` to `int`

    /tmp/tmp96p8z93b.d(37): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp96p8z93b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164167
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length - 1;\n    int distance = 0;\n  \
    \  int min_distance = word.length;\n    while (index >= 0)\n    {\n        if\
    \ (vowels.find(word[index]) != -1)\n        {\n            if (index + 1 < word.length)\n\
    \            {\n                if (consonants.find(word[index + 1]) != -1)\n\
    \                {\n                    distance = word.length - index - 1;\n\
    \                    if (distance < min_distance)\n                    {\n   \
    \                     min_distance = distance;\n                        result\
    \ = word[index..$];\n                    }\n                }\n            }\n\
    \            if (index - 1 >= 0)\n            {\n                if (consonants.find(word[index\
    \ - 1]) != -1)\n                {\n                    distance = word.length\
    \ - index;\n                    if (distance < min_distance)\n               \
    \     {\n                        min_distance = distance;\n                  \
    \      result = word[index..$];\n                    }\n                }\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3ssx4r4x.d(28): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp3ssx4r4x.d(30): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp3ssx4r4x.d(33): Error: no property `find` for type `string`

    /tmp/tmp3ssx4r4x.d(37): Error: no property `find` for type `string`

    /tmp/tmp3ssx4r4x.d(39): Error: cannot implicitly convert expression `word.length
    - cast(ulong)index - 1LU` of type `ulong` to `int`

    /tmp/tmp3ssx4r4x.d(49): Error: no property `find` for type `string`

    /tmp/tmp3ssx4r4x.d(51): Error: cannot implicitly convert expression `word.length
    - cast(ulong)index` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3ssx4r4x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8boq0faa.d(27): Error: cannot implicitly convert expression `word.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp8boq0faa.d(30): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(32): Error: no property `find` for type `string`

    /tmp/tmp8boq0faa.d(34): Error: cannot implicitly convert expression `word[cast(ulong)index]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8boq0faa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int pos = 0;\n    int min = word.length;\n    for\
    \ (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            if (i > 0 && i < word.length - 1)\n            {\n\
    \                if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1])\
    \ == -1)\n                {\n                    if (min > abs(word.length - i))\n\
    \                    {\n                        min = abs(word.length - i);\n\
    \                        pos = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if (pos != 0)\n    {\n        result = word[pos];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphhsj7thf.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmphhsj7thf.d(31): Error: no property `find` for type `string`

    /tmp/tmphhsj7thf.d(35): Error: no property `find` for type `string`

    /tmp/tmphhsj7thf.d(35): Error: no property `find` for type `string`

    /tmp/tmphhsj7thf.d(39): Error: cannot implicitly convert expression `abs(word.length
    - cast(ulong)i)` of type `ulong` to `int`

    /tmp/tmphhsj7thf.d(48): Error: cannot implicitly convert expression `word[cast(ulong)pos]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphhsj7thf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplx3t3uh3.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(30): Error: no property `canFind` for type `string`

    /tmp/tmplx3t3uh3.d(32): Error: cannot implicitly convert expression `word.length
    - i` of type `ulong` to `int`

    /tmp/tmplx3t3uh3.d(36): Error: cannot implicitly convert expression `c` of type
    `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx3t3uh3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164166
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n    int closest_vowel_distance\
    \ = -1;\n    int word_length = word.length;\n    int i = 0;\n    while (i < word_length)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            int distance\
    \ = word_length - i;\n            if (closest_vowel_distance == -1 || distance\
    \ < closest_vowel_distance)\n            {\n                closest_vowel_distance\
    \ = distance;\n                closest_vowel_index = i;\n                closest_vowel\
    \ = word[i..i+1];\n            }\n        }\n        i++;\n    }\n    return closest_vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2t15s8tv.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp2t15s8tv.d(33): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2t15s8tv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length;\n    int closest = word.length;\n\
    \    int distance = word.length;\n    foreach(char c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            distance = index - closest;\n            if(distance\
    \ > 1)\n            {\n                result = word[closest];\n             \
    \   break;\n            }\n            else\n            {\n                closest\
    \ = index;\n            }\n        }\n        else\n        {\n            closest\
    \ = index;\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7is1stye.d(27): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7is1stye.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7is1stye.d(29): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmp7is1stye.d(32): Error: no property `find` for type `string`

    /tmp/tmp7is1stye.d(37): Error: cannot implicitly convert expression `word[cast(ulong)closest]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7is1stye.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int\
    \ closest = -1;\n    int distance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (consonants.find(word[i-1]) != -1 && consonants.find(word[i+1]) != -1)\n\
    \            {\n                if (i < distance)\n                {\n       \
    \             distance = i;\n                    closest = i;\n              \
    \  }\n            }\n        }\n    }\n    if (closest == -1)\n    {\n       \
    \ return \"\";\n    }\n    return word[closest..closest];\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpthux3wy1.d(28): Error: cannot implicitly convert expression `word.length`
    of type `ulong` to `int`

    /tmp/tmpthux3wy1.d(31): Error: no property `find` for type `string`

    /tmp/tmpthux3wy1.d(33): Error: no property `find` for type `string`

    /tmp/tmpthux3wy1.d(33): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpthux3wy1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
