name: HumanEval_99_closest_integer
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
  \ takes a value (string) representing a number\n    and returns the closest integer\
  \ to it. If the number is equidistant\n    from two integers, round it away from\
  \ zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"\
  15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given\
  \ number is equidistant\n    from two integers, the one you should return is the\
  \ one that is the\n    farthest from zero. For example closest_integer(\"14.5\"\
  ) should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n\
  */\nlong closest_integer(string value) \n"
tests: "unittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"\
  10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"\
  -15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"\
  0\") == 0L);\n}\nvoid main(){}"
completions: ["{\n    long result = 0;\n    double d = to!double(value);\n    if (d\
    \ > 0)\n    {\n        result = cast(long)ceil(d);\n    }\n    else\n    {\n \
    \       result = cast(long)floor(d);\n    }\n    return result;\n}", "{\n    return\
    \ cast(long) round(to!double(value));\n}", "{\n    return round(to!double(value));\n\
    }", "{\n    return round(to!double(value));\n}", "{\n    double d = to!double(value);\n\
    \    return cast(long)round(d);\n}", "{\n    long result = 0;\n    double d =\
    \ to!double(value);\n    if (d > 0)\n    {\n        result = cast(long)d + cast(long)(d\
    \ - cast(long)d);\n    }\n    else\n    {\n        result = cast(long)d - cast(long)(d\
    \ - cast(long)d);\n    }\n    return result;\n}", "{\n    long result = 0;\n \
    \   double d = to!double(value);\n    if(d > 0)\n    {\n        result = cast(long)ceil(d);\n\
    \    }\n    else\n    {\n        result = cast(long)floor(d);\n    }\n    return\
    \ result;\n}", "{\n    return round(to!double(value));\n}", "{\n    return cast(long)\
    \ round(to!double(value));\n}", "{\n    double d = to!double(value);\n    return\
    \ cast(long)round(d);\n}", "{\n    return round(to!double(value));\n}", "{\n \
    \   double d = to!double(value);\n    long l = to!long(d);\n    if (abs(d - l)\
    \ < 0.5)\n        return l;\n    else\n        return l + sign(d);\n}", "{\n \
    \   return round(to!double(value));\n}", "{\n    long result = 0;\n    double\
    \ d = to!double(value);\n    double d1 = floor(d);\n    double d2 = ceil(d);\n\
    \    if (d - d1 > d2 - d)\n        result = cast(long)d2;\n    else\n        result\
    \ = cast(long)d1;\n    return result;\n}", "{\n    double d = to!double(value);\n\
    \    return cast(long)round(d);\n}", "{\n    return cast(long)round(to!double(value));\n\
    }", "{\n    return round(to!double(value));\n}", "{\n    auto result = to!long(value);\n\
    \    if (result == to!long(value))\n        return result;\n    else\n       \
    \ return result + sign(value.to!double);\n}", "{\n    long result = 0;\n    double\
    \ d = to!double(value);\n    double d_abs = abs(d);\n    long l = to!long(d_abs);\n\
    \    double d_diff = d_abs - l;\n    if (d_diff >= 0.5)\n    {\n        result\
    \ = l + 1;\n    }\n    else\n    {\n        result = l;\n    }\n    if (d < 0)\n\
    \    {\n        result = -result;\n    }\n    return result;\n}", "{\n    return\
    \ cast(long)round(to!double(value));\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
