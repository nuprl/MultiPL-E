language: d
name: HumanEval_49_modp
results:
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    long b = n;\n    while (b > 0L) \n    {\n        if ((b\
    \ & 1L) != 0L) \n        {\n            result = (result * a) % p;\n        }\n\
    \        a = (a * a) % p;\n        b >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp34c6n419.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427df5]\n??:? void tmp34c6n419.__unittest_L32_C1() [0x427a7d]\n??:?
    void tmp34c6n419.__modtest() [0x427b78]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42facd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a985]\n??:? runModuleUnitTests [0x42b8f1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281cb]\n??:? _d_run_main [0x428136]\n??:? main [0x427b8b]\n??:?
    __libc_start_main [0x6fde9554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bitlen(0L)\n\
    \    0\n    >>> bitlen(1L)\n    1\n    >>> bitlen(2L)\n    2\n    >>> bitlen(3L)\n\
    \    2\n    >>> bitlen(4L)\n    3\n    >>> bitlen(5L)\n    3\n    >>> bitlen(6L)\n\
    \    3\n    >>> bitlen(7L)\n    3\n    >>> bitlen(8L)\n    4\n    >>> bitlen(9L)\n\
    \    4\n    >>> bitlen(10L)\n    4\n    >>> bitlen(11L)\n    4\n    >>> bitlen(12L)\n\
    \    4\n    >>> bitlen(13L)\n    4\n    >>> bitlen(14L)\n    4\n    >>> bitlen(15L)\n\
    \    4\n    >>> bitlen(16L)\n    5\n    >>> bitlen(17L)\n    5\n    >>> bitlen(18L)\n\
    \    5\n    >>> bitlen(19L)\n    5\n    >>> bitlen(20L)\n    5\n    >>> bitlen(21L)\n\
    \    5\n    >>> bitlen(22L)\n    5\n    >>> bitlen(23L)\n    5\n    >>> bitlen(24L)\n\
    \    5\n    >>> bitlen(25L)\n    5\n    >>> bitlen(26L)\n    5\n    >>> bitlen(27L)\n\
    \    5\n    >>> bitlen(28L)\n    5\n    >>> bitlen(29L)\n    5\n    >>> bitlen(30L)\n\
    \    5\n    >>> bitlen(31L)\n    5\n    >>> bitlen(32L)\n    6\n    >>> bitlen(33L\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8wp38wd7.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp8wp38wd7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bitlength(0L)\n\
    \    0\n    >>> bitlength(1L)\n    1\n    >>> bitlength(2L)\n    2\n    >>> bitlength(3L)\n\
    \    2\n    >>> bitlength(4L)\n    3\n    >>> bitlength(5L)\n    3\n    >>> bitlength(6L)\n\
    \    3\n    >>> bitlength(7L)\n    3\n    >>> bitlength(8L)\n    4\n    >>> bitlength(9L)\n\
    \    4\n    >>> bitlength(10L)\n    4\n    >>> bitlength(11L)\n    4\n    >>>\
    \ bitlength(12L)\n    4\n    >>> bitlength(13L)\n    4\n    >>> bitlength(14L)\n\
    \    4\n    >>> bitlength(15L)\n    4\n    >>> bitlength(16L)\n    5\n    >>>\
    \ bitlength(17L)\n    5\n    >>> bitlength(18L)\n    5\n    >>> bitlength(19L)\n\
    \    5\n    >>> bitlength(20L)\n    5\n    >>> bitlength(21L)\n    5\n    >>>\
    \ bitlength(22L)\n    5\n    >>> bitlength(23L)\n    5\n    >>> bitlength(24L)\n\
    \    5\n    >>> bitlength(25L)\n    5\n    >>> bitlength(26L)\n    5\n    >>>\
    \ bitlength(27L)\n    5\n    >>> bitlength(28L)\n    5\n    >>> bitlength(29L)\n\
    \    5\n    >>> bitlength(30L)\n    5\n    >>> bitlength(31L)\n    5\n    >>>\
    \ bitlength(32L)\n    6\n    >>> bitlength(33L)\n    6\n    >>> bitlength(34L)\n\
    \    6\n    >>>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn4ptulo7.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpn4ptulo7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) {\n        if (n % 2L == 1L) {\n            result = (result\
    \ * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n\
    \    5\n    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n\
    \    5\n    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n\
    \    5\n    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n\
    \    5\n    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n\
    \    5\n    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n\
    \    6\n    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n\
    \    6\n    >>> bits(37L)\n    6\n    >>> bits(38L)\n    6\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpylzlroqj.d(28): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpylzlroqj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else\n    {\n        return (modp(n - 1, p)\
    \ * 2) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n % 2 == 0)\n    {\n        long m = modp(n / 2, p);\n  \
    \      return (m * m) % p;\n    }\n    else\n    {\n        long m = modp(n -\
    \ 1, p);\n        return (2 * m) % p;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n % 2 == 0)\n    {\n        long x = modp(n / 2, p);\n  \
    \      return (x * x) % p;\n    }\n    else\n    {\n        return (2 * modp(n\
    \ - 1, p)) % p;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return\
    \ cast(long) floor(log10(n)) + 1;\n    }\n}\n/*\nReturn the nth digit of n.\n\
    \    >>> nthdigit(0L, 0L)\n    0L\n    >>> nthdigit(0L, 1L)\n    0L\n    >>> nthdigit(1L,\
    \ 0L)\n    1L\n    >>> nthdigit(12345L, 0L)\n    5L\n    >>> nthdigit(12345L,\
    \ 1L)\n    4L\n    >>> nthdigit(12345L, 2L)\n    3L\n    >>> nthdigit(12345L,\
    \ 3L)\n    2L\n    >>> nthdigit(12345L, 4L)\n    1L\n    >>> nthdigit(12345L,\
    \ 5L)\n    0L\n*/\nlong nthdigit(long n, long d) \n{\n    return (n / pow(10L,\
    \ d)) % 10L;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n\
    \    0L\n    >>> sumdigits(1L)\n    1L\n    >>> sumdigits(10L)\n    1\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwpct3hum.d(86): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpwpct3hum.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bitlength(0L)\n\
    \    0\n    >>> bitlength(1L)\n    1\n    >>> bitlength(2L)\n    2\n    >>> bitlength(3L)\n\
    \    2\n    >>> bitlength(4L)\n    3\n    >>> bitlength(5L)\n    3\n    >>> bitlength(6L)\n\
    \    3\n    >>> bitlength(7L)\n    3\n    >>> bitlength(8L)\n    4\n    >>> bitlength(9L)\n\
    \    4\n    >>> bitlength(10L)\n    4\n    >>> bitlength(11L)\n    4\n    >>>\
    \ bitlength(12L)\n    4\n    >>> bitlength(13L)\n    4\n    >>> bitlength(14L)\n\
    \    4\n    >>> bitlength(15L)\n    4\n    >>> bitlength(16L)\n    5\n    >>>\
    \ bitlength(17L)\n    5\n    >>> bitlength(18L)\n    5\n    >>> bitlength(19L)\n\
    \    5\n    >>> bitlength(20L)\n    5\n    >>> bitlength(21L)\n    5\n    >>>\
    \ bitlength(22L)\n    5\n    >>> bitlength(23L)\n    5\n    >>> bitlength(24L)\n\
    \    5\n    >>> bitlength(25L)\n    5\n    >>> bitlength(26L)\n    5\n    >>>\
    \ bitlength(27L)\n    5\n    >>> bitlength(28L)\n    5\n    >>> bitlength(29L)\n\
    \    5\n    >>> bitlength(30L)\n    5\n    >>> bitlength(31L)\n    5\n    >>>\
    \ bitlength(32L)\n    6\n    >>> bitlength(33L\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuywc88cq.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpuywc88cq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(11L)\n    2\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return (long)floor(log10(n)) + 1;\n}\n/*\nReturn the n-th digit\
    \ of n.\n    >>> nthdigit(0L, 0L)\n    0L\n    >>> nthdigit(1L, 0L)\n    1L\n\
    \    >>> nthdigit(11L, 0L)\n    1L\n    >>> nthdigit(11L, 1L)\n    1L\n    >>>\
    \ nthdigit(123456789L, 0L)\n    9L\n    >>> nthdigit(123456789L, 1L)\n    8L\n\
    \    >>> nthdigit(123456789L, 2L)\n    7L\n    >>> nthdigit(123456789L, 3L)\n\
    \    6L\n    >>> nthdigit(123456789L, 4L)\n    5L\n    >>> nthdigit(123456789L,\
    \ 5L)\n    4L\n    >>> nthdigit(123456789L, 6L)\n    3L\n    >>> nthdigit(123456789L,\
    \ 7L)\n    2L\n    >>> nthdigit(123456789L, 8L)\n    1L\n    >>> nthdigit(1234567890123456789L,\
    \ 0L)\n    9L\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8x48ccrp.d(47): Error: C style cast illegal, use `cast(long)floor(log10(n))`\n/tmp/tmp8x48ccrp.d(49):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8x48ccrp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n != 0L) {\n        if (n & 1L) {\n            result = (result *\
    \ n) % p;\n        }\n        n = n >> 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpf0sllne0.d(33): unittest failure\n----------------\n??:?
    _d_unittestp [0x427de5]\n??:? void tmpf0sllne0.__unittest_L28_C1() [0x427a93]\n??:?
    void tmpf0sllne0.__modtest() [0x427b68]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a975]\n??:? runModuleUnitTests [0x42b8e1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281bb]\n??:? _d_run_main [0x428126]\n??:? main [0x427b7b]\n??:?
    __libc_start_main [0x8a22d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return r;\n}\n/*\nReturn\
    \ the number of digits in the binary representation of n.\n    >>> ndigits(0L)\n\
    \    0\n    >>> ndigits(1L)\n    1\n    >>> ndigits(2L)\n    2\n    >>> ndigits(3L)\n\
    \    2\n    >>> ndigits(4L)\n    3\n    >>> ndigits(5L)\n    3\n    >>> ndigits(6L)\n\
    \    3\n    >>> ndigits(7L)\n    3\n    >>> ndigits(8L)\n    4\n    >>> ndigits(9L)\n\
    \    4\n    >>> ndigits(10L)\n    4\n    >>> ndigits(11L)\n    4\n    >>> ndigits(12L)\n\
    \    4\n    >>> ndigits(13L)\n    4\n    >>> ndigits(14L)\n    4\n    >>> ndigits(15L)\n\
    \    4\n    >>> ndigits(16L)\n    5\n    >>> ndigits(17L)\n    5\n    >>> ndigits(18L)\n\
    \    5\n    >>> ndigits(19L)\n    5\n    >>> ndigits(20L)\n    5\n    >>> ndigits(21L)\n\
    \    5\n    >>> ndigits(22L)\n    5\n    >>> ndigits(23L)\n    5\n    >>> ndigits(24L)\n\
    \    5\n    >>> ndigits(25L)\n    5\n    >>> ndigits(26L)\n    5\n    >>> ndigits(27L)\n\
    \    5\n    >>> ndigits(28L)\n    5\n    >>> ndigits(29L)\n    5\n    >>> ndigits(30L)\n\
    \    5\n    >>> ndigits(31L)\n    5\n    >>> ndigits(32L)\n    6\n    >>> ndigits(33L)\n\
    \    6\n    >>> ndigits(34L)\n    6\n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpesolzlqe.d(24): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpesolzlqe.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n         \
    \   res = (res * n) % p;\n        }\n        n = n / 2L;\n        n = n % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpkmwim8yw.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e0d]\n??:? void tmpkmwim8yw.__unittest_L31_C1() [0x427ab7]\n??:?
    void tmpkmwim8yw.__modtest() [0x427b8c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430008]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fae5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a99d]\n??:? runModuleUnitTests [0x42b909]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281e3]\n??:? _d_run_main [0x42814e]\n??:? main [0x427b9f]\n??:?
    __libc_start_main [0xeac22554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n   \
    \ 5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\n    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\n    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8rpi3cpj.d(89): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp8rpi3cpj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \ {\n        return modp(-n, p);\n    }\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    if (n == 1)\n    {\n        return n;\n    }\n    if (n % 2 ==\
    \ 0)\n    {\n        long m = modp(n / 2, p);\n        return (m * m) % p;\n \
    \   }\n    else\n    {\n        return (n * modp(n - 1, p)) % p;\n    }\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp669c5jmx.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e35]\n??:? void tmp669c5jmx.__unittest_L41_C1() [0x427ae3]\n??:?
    void tmp669c5jmx.__modtest() [0x427bb8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb5b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb81]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430030]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb0d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9c5]\n??:? runModuleUnitTests [0x42b931]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428284]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42820b]\n??:? _d_run_main [0x428176]\n??:? main [0x427bcb]\n??:?
    __libc_start_main [0xcec19554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjy8poe9r.d(33): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e6d]\n??:? void tmpjy8poe9r.__unittest_L28_C1() [0x427b17]\n??:?
    void tmpjy8poe9r.__modtest() [0x427bec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9fd]\n??:? runModuleUnitTests [0x42b969]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428243]\n??:? _d_run_main [0x4281ae]\n??:? main [0x427bff]\n??:?
    __libc_start_main [0x2364a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        long result = (half * half) % p;\n\
    \        if (n % 2 == 1)\n            result = (result * n) % p;\n        return\
    \ result;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpux8n4m80.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e25]\n??:? void tmpux8n4m80.__unittest_L32_C1() [0x427acf]\n??:?
    void tmpux8n4m80.__modtest() [0x427ba4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb4b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9de]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb71]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430020]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fafd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9b5]\n??:? runModuleUnitTests [0x42b921]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428274]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281fb]\n??:? _d_run_main [0x428166]\n??:? main [0x427bb7]\n??:?
    __libc_start_main [0xc1ab4554]\n1/1 unittests FAILED\n'''
  stdout: b''
