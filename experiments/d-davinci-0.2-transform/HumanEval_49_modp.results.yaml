language: d
name: HumanEval_49_modp
results:
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    long b = n;\n    while (b > 0L) \n    {\n        if ((b\
    \ & 1L) != 0L) \n        {\n            result = (result * a) % p;\n        }\n\
    \        a = (a * a) % p;\n        b >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppxz7_crk.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmppxz7_crk.__unittest_L32_C1() [0x427a7d]

    ??:? void tmppxz7_crk.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bitlen(0L)\n\
    \    0\n    >>> bitlen(1L)\n    1\n    >>> bitlen(2L)\n    2\n    >>> bitlen(3L)\n\
    \    2\n    >>> bitlen(4L)\n    3\n    >>> bitlen(5L)\n    3\n    >>> bitlen(6L)\n\
    \    3\n    >>> bitlen(7L)\n    3\n    >>> bitlen(8L)\n    4\n    >>> bitlen(9L)\n\
    \    4\n    >>> bitlen(10L)\n    4\n    >>> bitlen(11L)\n    4\n    >>> bitlen(12L)\n\
    \    4\n    >>> bitlen(13L)\n    4\n    >>> bitlen(14L)\n    4\n    >>> bitlen(15L)\n\
    \    4\n    >>> bitlen(16L)\n    5\n    >>> bitlen(17L)\n    5\n    >>> bitlen(18L)\n\
    \    5\n    >>> bitlen(19L)\n    5\n    >>> bitlen(20L)\n    5\n    >>> bitlen(21L)\n\
    \    5\n    >>> bitlen(22L)\n    5\n    >>> bitlen(23L)\n    5\n    >>> bitlen(24L)\n\
    \    5\n    >>> bitlen(25L)\n    5\n    >>> bitlen(26L)\n    5\n    >>> bitlen(27L)\n\
    \    5\n    >>> bitlen(28L)\n    5\n    >>> bitlen(29L)\n    5\n    >>> bitlen(30L)\n\
    \    5\n    >>> bitlen(31L)\n    5\n    >>> bitlen(32L)\n    6\n    >>> bitlen(33L\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptf5mwat2.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptf5mwat2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bitlength(0L)\n\
    \    0\n    >>> bitlength(1L)\n    1\n    >>> bitlength(2L)\n    2\n    >>> bitlength(3L)\n\
    \    2\n    >>> bitlength(4L)\n    3\n    >>> bitlength(5L)\n    3\n    >>> bitlength(6L)\n\
    \    3\n    >>> bitlength(7L)\n    3\n    >>> bitlength(8L)\n    4\n    >>> bitlength(9L)\n\
    \    4\n    >>> bitlength(10L)\n    4\n    >>> bitlength(11L)\n    4\n    >>>\
    \ bitlength(12L)\n    4\n    >>> bitlength(13L)\n    4\n    >>> bitlength(14L)\n\
    \    4\n    >>> bitlength(15L)\n    4\n    >>> bitlength(16L)\n    5\n    >>>\
    \ bitlength(17L)\n    5\n    >>> bitlength(18L)\n    5\n    >>> bitlength(19L)\n\
    \    5\n    >>> bitlength(20L)\n    5\n    >>> bitlength(21L)\n    5\n    >>>\
    \ bitlength(22L)\n    5\n    >>> bitlength(23L)\n    5\n    >>> bitlength(24L)\n\
    \    5\n    >>> bitlength(25L)\n    5\n    >>> bitlength(26L)\n    5\n    >>>\
    \ bitlength(27L)\n    5\n    >>> bitlength(28L)\n    5\n    >>> bitlength(29L)\n\
    \    5\n    >>> bitlength(30L)\n    5\n    >>> bitlength(31L)\n    5\n    >>>\
    \ bitlength(32L)\n    6\n    >>> bitlength(33L)\n    6\n    >>> bitlength(34L)\n\
    \    6\n    >>>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_77bcm1t.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_77bcm1t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) {\n        if (n % 2L == 1L) {\n            result = (result\
    \ * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n\
    \    5\n    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n\
    \    5\n    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n\
    \    5\n    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n\
    \    5\n    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n\
    \    5\n    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n\
    \    6\n    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n\
    \    6\n    >>> bits(37L)\n    6\n    >>> bits(38L)\n    6\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5gmeff2y.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5gmeff2y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else\n    {\n        return (modp(n - 1, p)\
    \ * 2) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n % 2 == 0)\n    {\n        long m = modp(n / 2, p);\n  \
    \      return (m * m) % p;\n    }\n    else\n    {\n        long m = modp(n -\
    \ 1, p);\n        return (2 * m) % p;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n % 2 == 0)\n    {\n        long x = modp(n / 2, p);\n  \
    \      return (x * x) % p;\n    }\n    else\n    {\n        return (2 * modp(n\
    \ - 1, p)) % p;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return\
    \ cast(long) floor(log10(n)) + 1;\n    }\n}\n/*\nReturn the nth digit of n.\n\
    \    >>> nthdigit(0L, 0L)\n    0L\n    >>> nthdigit(0L, 1L)\n    0L\n    >>> nthdigit(1L,\
    \ 0L)\n    1L\n    >>> nthdigit(12345L, 0L)\n    5L\n    >>> nthdigit(12345L,\
    \ 1L)\n    4L\n    >>> nthdigit(12345L, 2L)\n    3L\n    >>> nthdigit(12345L,\
    \ 3L)\n    2L\n    >>> nthdigit(12345L, 4L)\n    1L\n    >>> nthdigit(12345L,\
    \ 5L)\n    0L\n*/\nlong nthdigit(long n, long d) \n{\n    return (n / pow(10L,\
    \ d)) % 10L;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n\
    \    0L\n    >>> sumdigits(1L)\n    1L\n    >>> sumdigits(10L)\n    1\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxoykfea.d(86): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxoykfea.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bitlength(0L)\n\
    \    0\n    >>> bitlength(1L)\n    1\n    >>> bitlength(2L)\n    2\n    >>> bitlength(3L)\n\
    \    2\n    >>> bitlength(4L)\n    3\n    >>> bitlength(5L)\n    3\n    >>> bitlength(6L)\n\
    \    3\n    >>> bitlength(7L)\n    3\n    >>> bitlength(8L)\n    4\n    >>> bitlength(9L)\n\
    \    4\n    >>> bitlength(10L)\n    4\n    >>> bitlength(11L)\n    4\n    >>>\
    \ bitlength(12L)\n    4\n    >>> bitlength(13L)\n    4\n    >>> bitlength(14L)\n\
    \    4\n    >>> bitlength(15L)\n    4\n    >>> bitlength(16L)\n    5\n    >>>\
    \ bitlength(17L)\n    5\n    >>> bitlength(18L)\n    5\n    >>> bitlength(19L)\n\
    \    5\n    >>> bitlength(20L)\n    5\n    >>> bitlength(21L)\n    5\n    >>>\
    \ bitlength(22L)\n    5\n    >>> bitlength(23L)\n    5\n    >>> bitlength(24L)\n\
    \    5\n    >>> bitlength(25L)\n    5\n    >>> bitlength(26L)\n    5\n    >>>\
    \ bitlength(27L)\n    5\n    >>> bitlength(28L)\n    5\n    >>> bitlength(29L)\n\
    \    5\n    >>> bitlength(30L)\n    5\n    >>> bitlength(31L)\n    5\n    >>>\
    \ bitlength(32L)\n    6\n    >>> bitlength(33L\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprupstgul.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprupstgul.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(11L)\n    2\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return (long)floor(log10(n)) + 1;\n}\n/*\nReturn the n-th digit\
    \ of n.\n    >>> nthdigit(0L, 0L)\n    0L\n    >>> nthdigit(1L, 0L)\n    1L\n\
    \    >>> nthdigit(11L, 0L)\n    1L\n    >>> nthdigit(11L, 1L)\n    1L\n    >>>\
    \ nthdigit(123456789L, 0L)\n    9L\n    >>> nthdigit(123456789L, 1L)\n    8L\n\
    \    >>> nthdigit(123456789L, 2L)\n    7L\n    >>> nthdigit(123456789L, 3L)\n\
    \    6L\n    >>> nthdigit(123456789L, 4L)\n    5L\n    >>> nthdigit(123456789L,\
    \ 5L)\n    4L\n    >>> nthdigit(123456789L, 6L)\n    3L\n    >>> nthdigit(123456789L,\
    \ 7L)\n    2L\n    >>> nthdigit(123456789L, 8L)\n    1L\n    >>> nthdigit(1234567890123456789L,\
    \ 0L)\n    9L\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp71448ytd.d(47): Error: C style cast illegal, use `cast(long)floor(log10(n))`

    /tmp/tmp71448ytd.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp71448ytd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n != 0L) {\n        if (n & 1L) {\n            result = (result *\
    \ n) % p;\n        }\n        n = n >> 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp02d_ljdc.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmp02d_ljdc.__unittest_L28_C1() [0x427a93]

    ??:? void tmp02d_ljdc.__modtest() [0x427b68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return r;\n}\n/*\nReturn\
    \ the number of digits in the binary representation of n.\n    >>> ndigits(0L)\n\
    \    0\n    >>> ndigits(1L)\n    1\n    >>> ndigits(2L)\n    2\n    >>> ndigits(3L)\n\
    \    2\n    >>> ndigits(4L)\n    3\n    >>> ndigits(5L)\n    3\n    >>> ndigits(6L)\n\
    \    3\n    >>> ndigits(7L)\n    3\n    >>> ndigits(8L)\n    4\n    >>> ndigits(9L)\n\
    \    4\n    >>> ndigits(10L)\n    4\n    >>> ndigits(11L)\n    4\n    >>> ndigits(12L)\n\
    \    4\n    >>> ndigits(13L)\n    4\n    >>> ndigits(14L)\n    4\n    >>> ndigits(15L)\n\
    \    4\n    >>> ndigits(16L)\n    5\n    >>> ndigits(17L)\n    5\n    >>> ndigits(18L)\n\
    \    5\n    >>> ndigits(19L)\n    5\n    >>> ndigits(20L)\n    5\n    >>> ndigits(21L)\n\
    \    5\n    >>> ndigits(22L)\n    5\n    >>> ndigits(23L)\n    5\n    >>> ndigits(24L)\n\
    \    5\n    >>> ndigits(25L)\n    5\n    >>> ndigits(26L)\n    5\n    >>> ndigits(27L)\n\
    \    5\n    >>> ndigits(28L)\n    5\n    >>> ndigits(29L)\n    5\n    >>> ndigits(30L)\n\
    \    5\n    >>> ndigits(31L)\n    5\n    >>> ndigits(32L)\n    6\n    >>> ndigits(33L)\n\
    \    6\n    >>> ndigits(34L)\n    6\n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz_gzpmso.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_gzpmso.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n         \
    \   res = (res * n) % p;\n        }\n        n = n / 2L;\n        n = n % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgj213fnl.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e0d]

    ??:? void tmpgj213fnl.__unittest_L31_C1() [0x427ab7]

    ??:? void tmpgj213fnl.__modtest() [0x427b8c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430008]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fae5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a99d]

    ??:? runModuleUnitTests [0x42b909]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n   \
    \ 5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\n    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\n    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprs_2tho_.d(89): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprs_2tho_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \ {\n        return modp(-n, p);\n    }\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    if (n == 1)\n    {\n        return n;\n    }\n    if (n % 2 ==\
    \ 0)\n    {\n        long m = modp(n / 2, p);\n        return (m * m) % p;\n \
    \   }\n    else\n    {\n        return (n * modp(n - 1, p)) % p;\n    }\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_54qspai.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e35]

    ??:? void tmp_54qspai.__unittest_L41_C1() [0x427ae3]

    ??:? void tmp_54qspai.__modtest() [0x427bb8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430030]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9c5]

    ??:? runModuleUnitTests [0x42b931]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428284]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbb3y_0jg.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e6d]

    ??:? void tmpbb3y_0jg.__unittest_L28_C1() [0x427b17]

    ??:? void tmpbb3y_0jg.__modtest() [0x427bec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        long result = (half * half) % p;\n\
    \        if (n % 2 == 1)\n            result = (result * n) % p;\n        return\
    \ result;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplel0_mi4.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e25]

    ??:? void tmplel0_mi4.__unittest_L32_C1() [0x427acf]

    ??:? void tmplel0_mi4.__modtest() [0x427ba4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb4b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9de]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb71]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430020]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fafd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9b5]

    ??:? runModuleUnitTests [0x42b921]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428274]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n        {\n\
    \            result = (result * x) % n;\n        }\n        p >>= 1L;\n      \
    \  x = (x * x) % n;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphlkmnf2c.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmphlkmnf2c.__unittest_L32_C1() [0x427a7d]

    ??:? void tmphlkmnf2c.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ else\n        return cast(long)log10(n) + 1;\n}\n/*\nReturn the sum of the digits\
    \ in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n\
    \    1\n    >>> sumdigits(12345L)\n    15\n    >>> sumdigits(12345678901234567890L)\n\
    \    90\n*/\nlong sumdigits(long n) \n{\n    if (n == 0)\n        return 0;\n\
    \    else\n        return n % 10 + sumdigits(n / 10);\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ else\n        return cast(long)log10(n) + 1;\n}\n/*\nReturn the sum of the digits\
    \ in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6uwwr0xk.d(88): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6uwwr0xk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n    9\n*/\n\
    long digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) \n    {\n    \
    \    n = n / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) \n\
    \    {\n        n = n / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\n\
    Return the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) \n\
    \    {\n        n = n / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\n\
    Return the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptayphhsf.d(101): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptayphhsf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n        {\n      \
    \      result = (result * n) % p;\n        }\n        n = n >> 1L;\n        n\
    \ = (n * n) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164305
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> len_num(1L)\n    1\n    >>> len_num(12345L)\n\
    \    5\n    >>> len_num(123456789012345L)\n    15\n    >>> len_num(1234567890123456789L)\n\
    \    19\n*/\nlong len_num(long n) \n{\n    return n.to!string.length;\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sum_digits(1L)\n    1\n    >>> sum_digits(12345L)\n\
    \    15\n    >>> sum_digits(123456789012345L)\n    45\n    >>> sum_digits(1234567890123456789L)\n\
    \    90\n*/\nlong sum_digits(long n) \n{\n    long sum = 0;\n    foreach (c; n.to!string)\n\
    \        sum += c.to!long - '0'.to!long;\n    return sum;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> len_num(1L)\n    1\n    >>> len_num(12345L)\n    5\n\
    \    >>> len_num(123456789012345L)\n    15\n    >>> len_num(1234567890123456789L)\n\
    \    19\n*/\nlong len_num(long n) \n{\n    return n.to!string.length;\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sum_digits(1L)\n    1\n    >>> sum_digits(12345L)\n\
    \    15\n    >>> sum_digits(123456789012345L)\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr8gpe6kw.d(76): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr8gpe6kw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long x = modp(n / 2,\
    \ p);\n        if (n % 2 == 0) \n        {\n            return x * x % p;\n  \
    \      }\n        else \n        {\n            return x * x * 2 % p;\n      \
    \  }\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n   \
    \ 1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n*/\nlong digits(long n) \n{\n  \
    \  if (n == 0) \n    {\n        return 1;\n    }\n    else \n    {\n        return\
    \ 1 + digits(n / 10);\n    }\n}\n/*\nReturn the sum of the digits in n.\n    >>>\
    \ sumdigits(0)\n    0\n    >>> sumdigits(1)\n    1\n    >>> sumdigits(10)\n  \
    \  1\n    >>> sumdigits(10**100)\n    1\n    >>> sumdigits(123456789)\n    45\n\
    */\nlong sumdigits(long n) \n{\n    if (n == 0) \n    {\n        return 0;\n \
    \   }\n    else \n    {\n        return n % 10 + sumdigits(n / 10);\n    }\n}\n\
    /*\nReturn the sum of the digits in n.\n    >>> sumdigits(0)\n    0\n    >>> sumdigits(1)\n\
    \    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(10**100)\n    1\n    >>>\
    \ sumdigits(123456789)\n    45\n*/\nlong sumdigits(long n) \n{\n    if (n == 0)\
    \ \n    {\n        return 0;\n    }\n    else \n    {\n        return n % 10 +\
    \ sumdigits(n / 10);\n    }\n}\n/*\nReturn the sum of the digits in n.\n    >>>\
    \ sumdigits(0\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7gbz7uso.d(108): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gbz7uso.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            r = (r * b) % p;\n        }\n        n >>= 1L;\n     \
    \   b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of bits in\
    \ the binary representation of n.\n    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n\
    \    1\n    >>> bit_length(2L)\n    2\n    >>> bit_length(3L)\n    2\n    >>>\
    \ bit_length(4L)\n    3\n    >>> bit_length(5L)\n    3\n    >>> bit_length(6L)\n\
    \    3\n    >>> bit_length(7L)\n    3\n    >>> bit_length(8L)\n    4\n    >>>\
    \ bit_length(9L)\n    4\n    >>> bit_length(10L)\n    4\n    >>> bit_length(11L)\n\
    \    4\n    >>> bit_length(12L)\n    4\n    >>> bit_length(13L)\n    4\n    >>>\
    \ bit_length(14L)\n    4\n    >>> bit_length(15L)\n    4\n    >>> bit_length(16L)\n\
    \    5\n    >>> bit_length(17L)\n    5\n    >>> bit_length(18L)\n    5\n    >>>\
    \ bit_length(19L)\n    5\n    >>> bit_length(20L)\n    5\n    >>> bit_length(21L)\n\
    \    5\n    >>> bit_length(22L)\n    5\n    >>> bit_length(23L)\n    5\n    >>>\
    \ bit_length(24L)\n    5\n    >>> bit_length(25L)\n    5\n    >>> bit_length(26L)\n\
    \    5\n    >>> bit_length(27L)\n    5\n    >>> bit_length(28L)\n    5\n    >>>\
    \ bit_length(29L)\n    5\n    >>> bit_length(30L)\n    5\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppygqsb7t.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppygqsb7t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    foreach (i; 0 .. n)\n    {\n        res = (res * 2L) % p;\n    }\n    return\
    \ res;\n}\n/*\nReturn the number of bits in the binary representation of n.\n\
    \    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n    1\n    >>> bit_length(2L)\n\
    \    2\n    >>> bit_length(3L)\n    2\n    >>> bit_length(4L)\n    3\n    >>>\
    \ bit_length(5L)\n    3\n    >>> bit_length(6L)\n    3\n    >>> bit_length(7L)\n\
    \    3\n    >>> bit_length(8L)\n    4\n    >>> bit_length(9L)\n    4\n    >>>\
    \ bit_length(10L)\n    4\n    >>> bit_length(11L)\n    4\n    >>> bit_length(12L)\n\
    \    4\n    >>> bit_length(13L)\n    4\n    >>> bit_length(14L)\n    4\n    >>>\
    \ bit_length(15L)\n    4\n    >>> bit_length(16L)\n    5\n    >>> bit_length(17L)\n\
    \    5\n    >>> bit_length(18L)\n    5\n    >>> bit_length(19L)\n    5\n    >>>\
    \ bit_length(20L)\n    5\n    >>> bit_length(21L)\n    5\n    >>> bit_length(22L)\n\
    \    5\n    >>> bit_length(23L)\n    5\n    >>> bit_length(24L)\n    5\n    >>>\
    \ bit_length(25L)\n    5\n    >>> bit_length(26L)\n    5\n    >>> bit_length(27L)\n\
    \    5\n    >>> bit_length(28L)\n    5\n    >>> bit_length(29L)\n    5\n    >>>\
    \ bit_length(30L)\n    5\n    >>> bit_length(31L)\n    5\n    >>> bit_length(32L)\n\
    \    6\n    >>> bit_length(33L)\n    6\n    >>> bit_length(34\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp60o4gapt.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp60o4gapt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \ {\n        return modp(-n, p);\n    }\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    if (n == 1)\n    {\n        return n;\n    }\n    long result\
    \ = 1;\n    while (n > 0)\n    {\n        if (n & 1)\n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1;\n        n = (n * n) % p;\n\
    \    }\n    return result;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n \
    \   >>> digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n*/\nlong digits(long n) \n{\n  \
    \  if (n == 0)\n    {\n        return 1;\n    }\n    long result = 0;\n    while\
    \ (n > 0)\n    {\n        n = n / 10;\n        result++;\n    }\n    return result;\n\
    }\n/*\nReturn the number of digits in the binary representation of n.\n    >>>\
    \ binary_digits(0)\n    1\n    >>> binary_digits(1)\n    1\n    >>> binary_digits(10)\n\
    \    4\n    >>> binary_digits(12345)\n    14\n    >>> binary_digits(10**100)\n\
    \    334\n    >>> binary_digits(10**1000)\n    3333\n*/\nlong binary_digits(long\
    \ n) \n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    long result =\
    \ 0;\n    while (n > 0)\n    {\n        n = n / 2;\n        result++;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of digits in the hexadecimal representation\
    \ of n.\n    >>> hex_digits(0)\n    1\n    >>> hex_digits(1)\n    1\n    >>> hex_\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbi3xs0j2.d(101): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbi3xs0j2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       r = (r * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b) %\
    \ p;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppxz7_crk.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmppxz7_crk.__unittest_L32_C1() [0x427a7d]

    ??:? void tmppxz7_crk.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of 1 bits in n.\n    >>> bitcount(0L)\n    0\n    >>> bitcount(1L)\n    1\n\
    \    >>> bitcount(2L)\n    1\n    >>> bitcount(3L)\n    2\n    >>> bitcount(4L)\n\
    \    1\n    >>> bitcount(5L)\n    2\n    >>> bitcount(6L)\n    2\n    >>> bitcount(7L)\n\
    \    3\n    >>> bitcount(8L)\n    1\n    >>> bitcount(9L)\n    2\n    >>> bitcount(10L)\n\
    \    2\n    >>> bitcount(11L)\n    3\n    >>> bitcount(12L)\n    2\n    >>> bitcount(13L)\n\
    \    3\n    >>> bitcount(14L)\n    3\n    >>> bitcount(15L)\n    4\n    >>> bitcount(16L)\n\
    \    1\n    >>> bitcount(17L)\n    2\n    >>> bitcount(18L)\n    2\n    >>> bitcount(19L)\n\
    \    3\n    >>> bitcount(20L)\n    2\n    >>> bitcount(21L)\n    3\n    >>> bitcount(22L)\n\
    \    3\n    >>> bitcount(23L)\n    4\n    >>> bitcount(24L)\n    2\n    >>> bitcount(25L)\n\
    \    3\n    >>> bitcount(26L)\n    3\n    >>> bitcount(27L)\n    4\n    >>> bitcount(28L)\n\
    \    3\n    >>> bitcount(29L)\n    4\n    >>> bitcount(30L)\n    4\n    >>> bitcount(31L)\n\
    \    5\n    >>> bitcount(32L)\n    1\n    >>> bitcount(33L)\n   \nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb2babc0w.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb2babc0w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the nth Fibonacci number modulo p (be aware\
    \ of numerics).\n    >>> fibp(0L, 101L)\n    0L\n    >>> fibp(1L, 101L)\n    1L\n\
    \    >>> fibp(2L, 101L)\n    1L\n    >>> fibp(3L, 101L)\n    2L\n    >>> fibp(4L,\
    \ 101L)\n    3L\n    >>> fibp(5L, 101L)\n    5L\n    >>> fibp(6L, 101L)\n    8L\n\
    \    >>> fibp(7L, 101L)\n    13L\n    >>> fibp(8L, 101L)\n    21L\n    >>> fibp(9L,\
    \ 101L)\n    34L\n    >>> fibp(10L, 101L)\n    55L\n    >>> fibp(11L, 101L)\n\
    \    89L\n    >>> fibp(12L, 101L)\n    14L\n    >>> fibp(13L, 101L)\n    23L\n\
    \    >>> fibp(14L, 101L)\n    37L\n    >>> fibp(15L, 101L)\n    60L\n    >>> fibp(16L,\
    \ 101L)\n    97L\n    >>> fibp(17L, 101L)\n    31L\n    >>> fibp(18L, 101L)\n\
    \    50L\n    >>> fibp(19L, 101L)\n    81L\n    >>> fibp(20L, 101L)\n    13L\n\
    \    >>> fibp(21L, 101L)\n    21L\n    >>> fibp(22L, 101L)\n    34L\n    >>> fibp(23L,\
    \ 101L)\n    55L\n    >>> fibp(24L, 101L)\n    89L\n    >>> fib\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxhhbw3w3.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxhhbw3w3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of elements of the group of units modulo p.\n    >>> phi(5L)\n    4L\n\
    \    >>> phi(101L)\n    100L\n    >>> phi(11L)\n    10L\n    >>> phi(1L)\n   \
    \ 1L\n    >>> phi(2L)\n    1L\n*/\nlong phi(long p) \n{\n    long result = p;\n\
    \    for (long i = 2; i < p; i++)\n        if (gcd(i, p) == 1)\n            result--;\n\
    \    return result;\n}\n/*\nReturn the order of a modulo p.\n    >>> order(2L,\
    \ 7L)\n    3L\n    >>> order(3L, 11L)\n    10L\n    >>> order(2L, 101L)\n    100L\n\
    \    >>> order(3L, 101L)\n    100L\n    >>> order(2L, 1L)\n    1L\n    >>> order(2L,\
    \ 2L)\n    1L\n*/\nlong order(long a, long p) \n{\n    long result = 1;\n    while\
    \ (modp(a, p) != 1)\n    {\n        a = (a * a) % p;\n        result++;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of elements of the group of units\
    \ modulo p^n.\n    >>> phi_pow(5L, 2L)\n    20L\n    >>> phi_pow(101L, 2L)\n \
    \   10000L\n    >>> phi_pow(11L, 2L)\n    100L\n    >>> phi_pow(1L, 2L)\n    1L\n\
    \    >>> phi\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpigxp8o7_.d(74): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpigxp8o7_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long x = modp(n / 2,\
    \ p);\n        if (n % 2 == 0) \n        {\n            return (x * x) % p;\n\
    \        }\n        else \n        {\n            return (x * x * 2) % p;\n  \
    \      }\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n*/\nlong digits(long n) \n{\n    if (n == 0) \n    {\n        return\
    \ 1;\n    }\n    else \n    {\n        return 1 + digits(n / 10);\n    }\n}\n\
    /*\nReturn the sum of the digits in n.\n    >>> sumdigits(0)\n    0\n    >>> sumdigits(1)\n\
    \    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(10**100)\n    1\n*/\n\
    long sumdigits(long n) \n{\n    if (n == 0) \n    {\n        return 0;\n    }\n\
    \    else \n    {\n        return n % 10 + sumdigits(n / 10);\n    }\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sumdigits(0)\n    0\n    >>> sumdigits(1)\n\
    \    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(10**100)\n    1\n*/\n\
    long sumdigits(long n) \n{\n    if (n == 0) \n    {\n        return 0;\n    }\n\
    \    else \n    {\n        return n % 10 + sumdigits(n / 10);\n    }\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sumdigits(0)\n    0\n    >>> sumdigits(1)\n\
    \    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(10**100)\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpekq4eask.d(102): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpekq4eask.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * x) % p;\n        }\n        n = n / 2L;\n\
    \        x = (x * x) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * x) % p;\n        }\n        n = n / 2L;\n        x =\
    \ (x * x) % p;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n    \n*/\nlong digits(long n) \n{\n    if (n == 0L) {\n        return\
    \ 1L;\n    }\n    long result = 0L;\n    while (n > 0L) {\n        n = n / 10L;\n\
    \        result = result + 1L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n    \n*/\nlong digits(long n) \n{\n    if (n == 0L) {\n        return\
    \ 1L;\n    }\n    long result = 0L;\n    while (n > 0L) {\n        n = n / 10L;\n\
    \        result = result + 1L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n    \n*/\nlong digits(long n) \n{\n    if (n == 0L) {\n        return\
    \ 1L;\n    }\n    long result = 0L;\n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwmdbeo0w.d(103): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwmdbeo0w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164305
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    foreach (i; 0 .. n)\n    {\n        res = (res * 2L) % p;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (pow > 0L) {\n        if ((pow & 1L) != 0L) {\n\
    \            result = (result * n) % p;\n        }\n        pow >>= 1L;\n    \
    \    n = (n * n) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_0c178p9.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmp_0c178p9.__unittest_L30_C1() [0x427a7d]

    ??:? void tmp_0c178p9.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n % 2L) == 1L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n = n / 2L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long r = modp(n / 2, p);\n        r = (r * r) % p;\n        if (n % 2\
    \ == 1)\n            r = (r * 2) % p;\n        return r;\n    }\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwa6q10qk.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e25]

    ??:? void tmpwa6q10qk.__unittest_L32_C1() [0x427aa9]

    ??:? void tmpwa6q10qk.__modtest() [0x427ba4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb4b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9de]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb71]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430020]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fafd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9b5]

    ??:? runModuleUnitTests [0x42b921]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428274]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp40gdwbw0.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmp40gdwbw0.__unittest_L30_C1() [0x427a81]

    ??:? void tmp40gdwbw0.__modtest() [0x427b7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n    19\n\
    \    \n*/\nlong numdigits(long n) \n{\n    long r = 1L;\n    while (n >= 10L)\
    \ \n    {\n        n = n / 10L;\n        r = r + 1L;\n    }\n    return r;\n}\n\
    /*\nReturn the nth digit of n.\n    >>> digit(12345L, 0L)\n    5\n    >>> digit(12345L,\
    \ 1L)\n    4\n    >>> digit(12345L, 2L)\n    3\n    >>> digit(12345L, 3L)\n  \
    \  2\n    >>> digit(12345L, 4L)\n    1\n    >>> digit(12345L, 5L)\n    0\n   \
    \ \n*/\nlong digit(long n, long i) \n{\n    long r = 0L;\n    while (i > 0L) \n\
    \    {\n        r = n % 10L;\n        n = n / 10L;\n        i = i - 1L;\n    }\n\
    \    return r;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzavdffre.d(83): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzavdffre.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164305
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        n\
    \ >>= 1L;\n        base = (base * base) % p;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long a = modp(n / 2, p);\n    a = a * a % p;\n    if (n\
    \ % 2 == 1)\n        a = a * 2 % p;\n    return a;\n}\n/*\nReturn the number of\
    \ digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n\
    \    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n    1001\n\
    \    >>> digits(10**10000)\n    10001\n*/\nlong digits(long n) \n{\n    if (n\
    \ == 0)\n        return 1;\n    return cast(long)floor(log(n) / log(10)) + 1;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n\
    \    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n\
    \    1001\n    >>> digits(10**10000)\n    10001\n*/\nlong digits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    return cast(long)floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n \
    \   >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n    >>> digits(10**10000)\n    10001\n\
    */\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n    return cast(long)floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    100\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp02t5sjc2.d(90): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp02t5sjc2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) \n    {\n        if (p % 2L == 1L) \n   \
    \     {\n            result = (result * x) % n;\n        }\n        x = (x * x)\
    \ % n;\n        p = p / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz8mhaynl.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmpz8mhaynl.__unittest_L32_C1() [0x427a99]

    ??:? void tmpz8mhaynl.__modtest() [0x427b94]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bit_length(0L)\n\
    \    0\n    >>> bit_length(1L)\n    1\n    >>> bit_length(2L)\n    2\n    >>>\
    \ bit_length(3L)\n    2\n    >>> bit_length(4L)\n    3\n    >>> bit_length(5L)\n\
    \    3\n    >>> bit_length(6L)\n    3\n    >>> bit_length(7L)\n    3\n    >>>\
    \ bit_length(8L)\n    4\n    >>> bit_length(9L)\n    4\n    >>> bit_length(10L)\n\
    \    4\n    >>> bit_length(11L)\n    4\n    >>> bit_length(12L)\n    4\n    >>>\
    \ bit_length(13L)\n    4\n    >>> bit_length(14L)\n    4\n    >>> bit_length(15L)\n\
    \    4\n    >>> bit_length(16L)\n    5\n    >>> bit_length(17L)\n    5\n    >>>\
    \ bit_length(18L)\n    5\n    >>> bit_length(19L)\n    5\n    >>> bit_length(20L)\n\
    \    5\n    >>> bit_length(21L)\n    5\n    >>> bit_length(22L)\n    5\n    >>>\
    \ bit_length(23L)\n    5\n    >>> bit_length(24L)\n    5\n    >>> bit_length(25L)\n\
    \    5\n    >>> bit_length(26L)\n    5\n    >>> bit_length(27L)\n    5\n    >>>\
    \ bit_length(28L)\n    5\n    >>> bit_length(29L)\n    5\n    >>> bit_length(30L)\n\
    \    5\n    >>> bit_length(31L)\n    5\n    >>> bit_length(\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcax0n8ev.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcax0n8ev.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(100)\n    3\n\
    \    >>> digits(1000)\n    4\n    >>> digits(10000)\n    5\n    >>> digits(12345)\n\
    \    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    19\n    >>> digits(123456789012345678901234567890)\n    29\n*/\nlong digits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)\
    \ floor(log10(n)) + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(100)\n\
    \    3\n    >>> digits(1000)\n    4\n    >>> digits(10000)\n    5\n    >>> digits(12345)\n\
    \    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    19\n    >>> digits(123456789012345678901234567890)\n    29\n*/\nlong digits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)\
    \ floor(log10(n)) + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(100)\n\
    \    3\n    >>> digits(1000)\n    4\n   \nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3t62inj.d(86): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3t62inj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(101L)\n\
    \    3\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return cast(long) floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the nth digit of n, where the rightmost digit is 0.\n    >>> nthdigit(123456789L,\
    \ 0)\n    9L\n    >>> nthdigit(123456789L, 1)\n    8L\n    >>> nthdigit(123456789L,\
    \ 2)\n    7L\n    >>> nthdigit(123456789L, 3)\n    6L\n    >>> nthdigit(123456789L,\
    \ 4)\n    5L\n    >>> nthdigit(123456789L, 5)\n    4L\n    >>> nthdigit(123456789L,\
    \ 6)\n    3L\n    >>> nthdigit(123456789L, 7)\n    2L\n    >>> nthdigit(123456789L,\
    \ 8)\n    1L\n    >>> nthdigit(123456789L, 9)\n    0L\n*/\nlong nthdigit(long\
    \ n, long d) \n{\n    return (n / modp(10, d)) % 10;\n}\n/*\nReturn the sum of\
    \ the digits of n.\n    >>> sumdigits(0L)\n    0L\n    >>> sumdigits\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpej4b6gce.d(75): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpej4b6gce.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       r = (r * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b) %\
    \ p;\n    }\n    return r;\n}\n/*\nReturn the number of digits in n.\n    >>>\
    \ digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n \
    \   >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n    20\n\
    */\nlong digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) {\n      \
    \  n /= 10L;\n        d += 1L;\n    }\n    return d;\n}\n/*\nReturn the nth digit\
    \ of n, counting from the right.\n    >>> digit(0L, 0L)\n    0\n    >>> digit(0L,\
    \ 1L)\n    0\n    >>> digit(1L, 0L)\n    1\n    >>> digit(12345L, 0L)\n    5\n\
    \    >>> digit(12345L, 1L)\n    4\n    >>> digit(12345L, 2L)\n    3\n    >>> digit(12345L,\
    \ 3L)\n    2\n    >>> digit(12345L, 4L)\n    1\n    >>> digit(12345L, 5L)\n  \
    \  0\n    >>> digit(12345L, 6L)\n    0\n*/\nlong digit(long n, long i) \n{\n \
    \   return (n / pow(10L, i)) % 10L;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n \
    \   2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n*/\nlong digits(long n) \n{\n    long d = 1L;\n    while\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhciax4j.d(96): Error: found `unittest` when expecting `(`

    /tmp/tmpwhciax4j.d(108): Error: found `void` when expecting `)`

    /tmp/tmpwhciax4j.d(108): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhciax4j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n        if (n > 0L) \n \
    \       {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n\
    \    15\n    >>> digits(1234567890123456789L)\n    19\n*/\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8sf3p1xn.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmp8sf3p1xn.__unittest_L49_C1() [0x427abf]

    ??:? void tmp8sf3p1xn.__modtest() [0x427b94]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 0;\n    while (n > 0) \n   \
    \ {\n        n /= 10;\n        d++;\n    }\n    return d;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 0;\n    while (n > 0) \n   \
    \ {\n        n /= 10;\n        d++;\n    }\n    return d;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 0;\n    while (n > 0) \n   \
    \ {\n        n /= 10;\n        d++;\n    }\n    return d;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 0;\n    while (n > 0\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpricos1ef.d(113): Error: found `unittest` when expecting `)`

    /tmp/tmpricos1ef.d(125): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpricos1ef.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    long b = n;\n    while (b > 0L) \n    {\n        if (b\
    \ % 2L == 1L) \n        {\n            result = (result * a) % p;\n        }\n\
    \        a = (a * a) % p;\n        b = b / 2L;\n    }\n    return result;\n}\n\
    /*\nReturn the number of elements in the finite field with p elements.\n    >>>\
    \ card(5L)\n    4L\n    >>> card(101L)\n    100L\n    >>> card(11L)\n    10L\n\
    \    >>> card(2L)\n    1L\n    >>> card(1L)\n    0L\n*/\nlong card(long p) \n\
    {\n    return p - 1L;\n}\n/*\nReturn the order of a modulo p.\n    >>> order(3L,\
    \ 5L)\n    4L\n    >>> order(2L, 101L)\n    100L\n    >>> order(3L, 11L)\n   \
    \ 10L\n    >>> order(2L, 2L)\n    1L\n    >>> order(1L, 1L)\n    0L\n*/\nlong\
    \ order(long a, long p) \n{\n    long result = 0L;\n    long i = 1L;\n    while\
    \ (modp(a, p) != 1L) \n    {\n        i = i + 1L;\n        a = (a * a) % p;\n\
    \    }\n    result = i;\n    return result;\n}\n/*\nReturn the number of elements\
    \ of order n in the finite field with p elements.\n    >>> num_elements_order(4L,\
    \ 5L)\n    1L\n    >>> num_elements_order(100L, 101L)\n    1L\n    >>> num_elements_order(10L,\
    \ 11L)\n    1L\n    >>> num_elements_order(1L, 2L)\n    1L\n    >>> num_elements_order(0L,\
    \ 1L)\n    0L\n*/\nlong num_elements_order(long n, long p) \n{\n\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpimhekfib.d(91): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpimhekfib.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p;\n    else\n        return modp(n/2, p) * modp(n/2, p) * 2 % p;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(123456789L)\n    9\n    >>> numdigits(123456789012345L)\n    15\n\
    \    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long n) \n\
    {\n    long numdigits = 0;\n    while (n > 0) \n    {\n        n /= 10;\n    \
    \    numdigits++;\n    }\n    return numdigits;\n}\n/*\nReturn the sum of the\
    \ digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n \
    \   >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n    15\n    >>> sumdigits(123456789L)\n\
    \    45\n    >>> sumdigits(123456789012345L)\n    90\n    >>> sumdigits(1234567890123456789L)\n\
    \    180\n*/\nlong sumdigits(long n) \n{\n    long sumdigits = 0;\n    while (n\
    \ > 0) \n    {\n        sumdigits += n % 10;\n        n /= 10;\n    }\n    return\
    \ sumdigits;\n}\n/*\nReturn the number of trailing zeros in n!.\n    >>> numtrailingzeros(0L)\n\
    \    0\n    >>> numtrailingzeros(1L)\n    0\n    >>> numtrailingzeros(2L)\n  \
    \  0\n    >>> numtrailing\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplbkqpg4a.d(80): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplbkqpg4a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the smallest prime factor of n.\n    >>> smallest_prime_factor(2L)\n  \
    \  2L\n    >>> smallest_prime_factor(3L)\n    3L\n    >>> smallest_prime_factor(4L)\n\
    \    2L\n    >>> smallest_prime_factor(5L)\n    5L\n    >>> smallest_prime_factor(6L)\n\
    \    2L\n    >>> smallest_prime_factor(7L)\n    7L\n    >>> smallest_prime_factor(8L)\n\
    \    2L\n    >>> smallest_prime_factor(9L)\n    3L\n    >>> smallest_prime_factor(10L)\n\
    \    2L\n    >>> smallest_prime_factor(11L)\n    11L\n    >>> smallest_prime_factor(12L)\n\
    \    2L\n    >>> smallest_prime_factor(13L)\n    13L\n    >>> smallest_prime_factor(14L)\n\
    \    2L\n    >>> smallest_prime_factor(15L)\n    3L\n    >>> smallest_prime_factor(16L)\n\
    \    2L\n    >>> smallest_prime_factor(17L)\n    17L\n    >>> smallest_prime_factor(18L)\n\
    \    2L\n    >>> smallest_prime_factor(19L)\n    19L\n    >>> smallest_prime_factor(20L)\n\
    \    2L\n    >>> smallest_prime_factor(21L)\n    3L\n    >>> smallest_prime_factor(22L)\n\
    \    2L\n    >>> smallest_prime_factor(23L)\n    23L\n    >>> smallest_prime_factor(24L)\n\
    \    2L\n    >>> smallest_prime_factor(25L)\n    5L\n    >>> smallest_prime_factor(26L)\n\
    \    2L\n    >>> smallest_prime_factor(27L)\n\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp05cp6api.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp05cp6api.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n  \
    \  >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(123456789012345L)\n    15\n*/\nlong digits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return cast(long) floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the nth digit of n, counting from the right.\n\
    \    >>> nthdigit(0L, 0L)\n    0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(1L,\
    \ 0L)\n    1\n    >>> nthdigit(1L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n\
    \    5\n    >>> nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n  \
    \  3\n    >>> nthdigit(12345L, 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n\
    \    >>> nthdigit(12345L, 5L)\n    0\n*/\nlong nthdigit(long n, long d) \n{\n\
    \    if (d == 0)\n        return n % 10;\n    else\n        return nthdigit(n\
    \ / 10, d - 1);\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n\
    \    15\n    >>> sumdigits\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfzghljv0.d(76): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfzghljv0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n\
    \    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(12345678901234567890L)\n\
    \    20\n*/\nlong numdigits(long n) \n{\n    long result = 0L;\n    while (n >\
    \ 0L) \n    {\n        n = n / 10L;\n        result = result + 1L;\n    }\n  \
    \  return result;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n\
    \    15\n    >>> sumdigits(12345678901234567890L)\n    90\n*/\nlong sumdigits(long\
    \ n) \n{\n    long result = 0L;\n    while (n > 0L) \n    {\n        result =\
    \ result + n % 10L;\n        n = n / 10L;\n    }\n    return result;\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n\
    \    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n    15\n   \
    \ >>> sumdigits(12345678901234567890L)\n    90\n*/\nlong sumdigits(long n) \n\
    {\n    long result = 0L;\n    while (n > 0L) \n   \nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpale51qzv.d(96): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpale51qzv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the number of elements\
    \ in the group of units modulo p.\n    >>> phi(7L)\n    6L\n    >>> phi(11L)\n\
    \    10L\n    >>> phi(13L)\n    12L\n    >>> phi(17L)\n    16L\n    >>> phi(19L)\n\
    \    18L\n    >>> phi(23L)\n    22L\n    >>> phi(29L)\n    28L\n    >>> phi(31L)\n\
    \    30L\n    >>> phi(37L)\n    36L\n    >>> phi(41L)\n    40L\n    >>> phi(43L)\n\
    \    42L\n    >>> phi(47L)\n    46L\n    >>> phi(53L)\n    52L\n    >>> phi(59L)\n\
    \    58L\n    >>> phi(61L)\n    60L\n    >>> phi(67L)\n    66L\n    >>> phi(71L)\n\
    \    70L\n    >>> phi(73L)\n    72L\n    >>> phi(79L)\n    78L\n    >>> phi(83L)\n\
    \    82L\n    >>> phi(89L)\n    88L\n    >>> phi(97L)\n    96L\n    >>> phi(101L)\n\
    \    100L\n    >>> phi(103L)\n    102L\n    >>> phi(107L)\n    106L\n    >>> phi(109L)\n\
    \    108L\n    >>> phi(113L)\n    112L\n    >>> phi(127L)\n    126L\n    >>> phi(131L)\n\
    \    130L\n    >>> phi(137L)\n    136L\n    >>> phi(139L)\n    138\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnb6gsjtz.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnb6gsjtz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpubqzskgj.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e6d]

    ??:? void tmpubqzskgj.__unittest_L28_C1() [0x427b17]

    ??:? void tmpubqzskgj.__modtest() [0x427bec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\n/*\nReturn the number of digits of n in base\
    \ b.\n    >>> digits(0L, 10L)\n    1L\n    >>> digits(1L, 10L)\n    1L\n    >>>\
    \ digits(10L, 10L)\n    2L\n    >>> digits(100L, 10L)\n    3L\n    >>> digits(1000L,\
    \ 10L)\n    4L\n    >>> digits(123456789L, 10L)\n    9L\n    >>> digits(123456789L,\
    \ 2L)\n    31L\n    >>> digits(123456789L, 8L)\n    12L\n    >>> digits(123456789L,\
    \ 16L)\n    8L\n    >>> digits(123456789L, 32L)\n    7L\n    >>> digits(123456789L,\
    \ 36L)\n    7L\n    >>> digits(123456789L, 62L)\n    6L\n    >>> digits(123456789L,\
    \ 64L)\n    6L\n    >>> digits(123456789L, 100L)\n    6L\n    >>> digits(123456789L,\
    \ 1000L)\n    5L\n    >>> digits(123456789L, 10000L)\n    5L\n    >>> digits(123456789L,\
    \ 100000L)\n    5L\n    >>> digits(123456789L, 1000000L)\n    5L\n    >>> digits(123456789L,\
    \ 10000000L)\n    5L\n    >>> digits(123456789L, 100000000L)\n    5L\n    >>>\
    \ digits(123456789L, 1000000000L)\n    5L\n    >>> digits(123456789L, 10000000000L)\n\
    \    5L\n    >>> digits(123456789L, 100000000000L)\n    5L\n    >>> digits(123456789\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdxszep84.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdxszep84.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long r = modp(n / 2, p);\n        r\
    \ = (r * r) % p;\n        if (n % 2 == 1)\n            r = (r * 2) % p;\n    \
    \    return r;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return r;\n}\n/*\nReturn\
    \ the number of bits in the binary representation of n.\n    >>> bits(1L)\n  \
    \  1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n   \
    \ 3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n    3\n    >>> bits(7L)\n    3\n\
    \    >>> bits(8L)\n    4\n    >>> bits(9L)\n    4\n    >>> bits(10L)\n    4\n\
    \    >>> bits(11L)\n    4\n    >>> bits(12L)\n    4\n    >>> bits(13L)\n    4\n\
    \    >>> bits(14L)\n    4\n    >>> bits(15L)\n    4\n    >>> bits(16L)\n    5\n\
    \    >>> bits(17L)\n    5\n    >>> bits(18L)\n    5\n    >>> bits(19L)\n    5\n\
    \    >>> bits(20L)\n    5\n    >>> bits(21L)\n    5\n    >>> bits(22L)\n    5\n\
    \    >>> bits(23L)\n    5\n    >>> bits(24L)\n    5\n    >>> bits(25L)\n    5\n\
    \    >>> bits(26L)\n    5\n    >>> bits(27L)\n    5\n    >>> bits(28L)\n    5\n\
    \    >>> bits(29L)\n    5\n    >>> bits(30L)\n    5\n    >>> bits(31L)\n    5\n\
    \    >>> bits(32L)\n    6\n    >>> bits(33L)\n    6\n    >>> bits(34L)\n    6\n\
    \    >>> bits(35L)\n    6\n    >>> bits(36L)\n    6\n    >>> bits(37L)\n    6\n\
    \    >>> bits(38L)\n    6\n    >>> bits(39L)\n    6\n    >>> bits(40L)\n    6\n\
    \    >>> bits(41L)\n    6\n    >>> bits(\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpimk4wbn8.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpimk4wbn8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    */\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L) {\n \
    \       n /= 10L;\n        result += 1L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the nth digit of n, starting from the right.\n    >>> nth_digit(1L, 0L)\n  \
    \  0\n    >>> nth_digit(1L, 1L)\n    1\n    >>> nth_digit(12345L, 0L)\n    5\n\
    \    >>> nth_digit(12345L, 1L)\n    4\n    >>> nth_digit(12345L, 2L)\n    3\n\
    \    >>> nth_digit(12345L, 3L)\n    2\n    >>> nth_digit(12345L, 4L)\n    1\n\
    \    >>> nth_digit(12345L, 5L)\n    0\n*/\nlong nth_digit(long n, long k) \n{\n\
    \    return (n / pow(10L, k)) % 10L;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n \
    \   2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    */\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L)\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpryjniu7p.d(92): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpryjniu7p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        return (modp(n / 2,\
    \ p) * modp(n - n / 2, p)) % p;\n    }\n}\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164306
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the smallest prime factor\
    \ of n.\n    >>> smallest_prime_factor(2L)\n    2L\n    >>> smallest_prime_factor(3L)\n\
    \    3L\n    >>> smallest_prime_factor(4L)\n    2L\n    >>> smallest_prime_factor(5L)\n\
    \    5L\n    >>> smallest_prime_factor(6L)\n    2L\n    >>> smallest_prime_factor(7L)\n\
    \    7L\n    >>> smallest_prime_factor(8L)\n    2L\n    >>> smallest_prime_factor(9L)\n\
    \    3L\n    >>> smallest_prime_factor(10L)\n    2L\n    >>> smallest_prime_factor(11L)\n\
    \    11L\n    >>> smallest_prime_factor(12L)\n    2L\n    >>> smallest_prime_factor(13L)\n\
    \    13L\n    >>> smallest_prime_factor(14L)\n    2L\n    >>> smallest_prime_factor(15L)\n\
    \    3L\n    >>> smallest_prime_factor(16L)\n    2L\n    >>> smallest_prime_factor(17L)\n\
    \    17L\n    >>> smallest_prime_factor(18L)\n    2L\n    >>> smallest_prime_factor(19L)\n\
    \    19L\n    >>> smallest_prime_factor(20L)\n    2L\n    >>> smallest_prime_factor(21L)\n\
    \    3L\n    >>> smallest_prime_factor(22L)\n    2L\n    >>> smallest_prime_factor(23L)\n\
    \    23L\n    >>> smallest_prime_factor(24L)\n    2L\n    >>> smallest_prime_factor(25L)\n\
    \    5L\n    >>> smallest_prime_factor(26L)\n    2L\n    >>> smallest_prime_factor(27L)\n\
    \   \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg9_erjpr.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9_erjpr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164305
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i > 0L) \n    {\n     \
    \   if (i % 2L == 1L) \n        {\n            result = (result * power) % p;\n\
    \        }\n        power = (power * power) % p;\n        i = i / 2L;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfgsy1o16.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmpfgsy1o16.__unittest_L33_C1() [0x427a9d]

    ??:? void tmpfgsy1o16.__modtest() [0x427b98]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\n/*\nReturn the number of digits in the base\
    \ 10 representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n   \
    \ 1\n    >>> digits(9L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(99L)\n\
    \    2\n    >>> digits(100L)\n    3\n    >>> digits(999L)\n    3\n    >>> digits(1000L)\n\
    \    4\n    >>> digits(9999L)\n    4\n    >>> digits(10000L)\n    5\n    >>> digits(99999L)\n\
    \    5\n    >>> digits(100000L)\n    6\n    >>> digits(999999L)\n    6\n    >>>\
    \ digits(1000000L)\n    7\n    >>> digits(9999999L)\n    7\n    >>> digits(10000000L)\n\
    \    8\n    >>> digits(99999999L)\n    8\n    >>> digits(100000000L)\n    9\n\
    \    >>> digits(999999999L)\n    9\n    >>> digits(1000000000L)\n    10\n    >>>\
    \ digits(9999999999L)\n    10\n    >>> digits(10000000000L)\n    11\n    >>> digits(99999999999L)\n\
    \    11\n    >>> digits(100000000000L)\n    12\n    >>> digits(999999999999L)\n\
    \    12\n    >>> digits(1000000000000L)\n    13\n    >>> digits(9999999999999L)\n\
    \    13\n    >>> digits(10000000000000L)\n    14\n    >>> digits(99999999999999L)\n\
    \    14\n    >>> digits(100000000000000L)\n    15\n    >>> digits(999999999999999L)\n\
    \    15\n    >>> digits(1000000000000000L)\n    16\n    >>> digits(9999999999999999L)\n\
    \    16\n    >>> digits\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo8lofexp.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8lofexp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\n/*\nReturn the greatest\
    \ common divisor of a and b.\n    >>> gcd(12, 8)\n    4\n    >>> gcd(8, 12)\n\
    \    4\n    >>> gcd(0, 12)\n    12\n    >>> gcd(12, 0)\n    12\n    >>> gcd(0,\
    \ 0)\n    0\n*/\nlong gcd(long a, long b) \n{\n    if (a == 0)\n        return\
    \ b;\n    else if (b == 0)\n        return a;\n    else\n        return gcd(b,\
    \ a % b);\n}\n/*\nReturn the least common multiple of a and b.\n    >>> lcm(12,\
    \ 8)\n    24\n    >>> lcm(8, 12)\n    24\n    >>> lcm(0, 12)\n    0\n    >>> lcm(12,\
    \ 0)\n    0\n    >>> lcm(0, 0)\n    0\n*/\nlong lcm(long a, long b) \n{\n    if\
    \ (a == 0 || b == 0)\n        return 0;\n    else\n        return a * b / gcd(a,\
    \ b);\n}\n/*\nReturn the multiplicative inverse of a modulo b.\n    >>> modinv(3L,\
    \ 5L)\n    2L\n    >>> modinv(1101L, 101L)\n    99L\n    >>> modinv(0L, 101L)\n\
    \    0L\n    >>> modinv(3L, 11L)\n    4L\n    >>> modinv(100L, 101L)\n    1L\n\
    */\nlong modinv(long a, long b) \n{\n    long b0 = b, t, q;\n    long x0 = 0,\
    \ x1 = 1;\n    if (b == 1\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa1hasr4h.d(88): Error: found `unittest` when expecting `)`

    /tmp/tmpa1hasr4h.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa1hasr4h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n /= 2L;\n        if (n > 0L) \n    \
    \    {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp02bv2frb.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmp02bv2frb.__unittest_L34_C1() [0x427abf]

    ??:? void tmp02bv2frb.__modtest() [0x427b94]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return n % p * modp(n - 1, p) % p;\n}\n/*\nReturn the number of digits\
    \ of n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n    1\n    >>> ndigits(10L)\n\
    \    2\n    >>> ndigits(12345L)\n    5\n*/\nlong ndigits(long n) \n{\n    if (n\
    \ == 0)\n        return 1;\n    else\n        return cast(long) floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits of n in base b.\n    >>> ndigits(0L,\
    \ 2L)\n    1\n    >>> ndigits(1L, 2L)\n    1\n    >>> ndigits(10L, 2L)\n    4\n\
    \    >>> ndigits(12345L, 2L)\n    13\n*/\nlong ndigits(long n, long b) \n{\n \
    \   if (n == 0)\n        return 1;\n    else\n        return cast(long) floor(log(n)\
    \ / log(b)) + 1;\n}\n/*\nReturn the number of digits of n in base b.\n    >>>\
    \ ndigits(0L, 2L)\n    1\n    >>> ndigits(1L, 2L)\n    1\n    >>> ndigits(10L,\
    \ 2L)\n    4\n    >>> ndigits(12345L, 2L)\n    13\n*/\nlong ndigits(long n, long\
    \ b) \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)\
    \ floor(log(n) / log(b)) + 1;\n}\n/*\nReturn the number of digits of n in base\
    \ b.\n    >>> ndigits(0L, 2L)\n    1\n    >>> ndigits(1\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8n3gz6m5.d(82): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8n3gz6m5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    */\nlong digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) \n    {\n\
    \        n = n / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\nReturn\
    \ the nth digit of n, counting from the right.\n    >>> nthdigit(0L, 0L)\n   \
    \ 0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n    5\n  \
    \  >>> nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n    3\n    >>>\
    \ nthdigit(12345L, 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n    >>> nthdigit(12345L,\
    \ 5L)\n    0\n*/\nlong nthdigit(long n, long i) \n{\n    return n / pow(10L, i)\
    \ % 10L;\n}\n/*\nReturn the nth digit of n, counting from the left.\n    >>> nthdigit(0L,\
    \ 0L)\n    0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n\
    \    1\n    >>> nthdigit(12345L, 1L)\n    2\n    >>> nthdigit(12345L, 2L)\n  \
    \  3\n\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1maazssj.d(78): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1maazssj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i != 0L) \n    {\n    \
    \    if ((i & 1L) != 0L) \n        {\n            result = (result * power) %\
    \ p;\n        }\n        power = (power * power) % p;\n        i >>= 1L;\n   \
    \ }\n    return result;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(2L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L)\
    \ \n    {\n        n /= 10L;\n        result += 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(2L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n        n /= 10L;\n\
    \        result += 1L;\n    }\n    return result;\n}\n/*\nReturn the number of\
    \ digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(2L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long result = 1L;\n    while (n >= 10L) \nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2j18vnz7.d(102): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2j18vnz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) {\n        r = (r * 2L) % p;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n == 1)\n        return n % p;\n    if (n % 2 == 0)\n\
    \        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n        return\
    \ (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1hgldthu.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e6d]

    ??:? void tmp1hgldthu.__unittest_L28_C1() [0x427b17]

    ??:? void tmp1hgldthu.__modtest() [0x427bec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long x = modp(n / 2, p);\n        if\
    \ (n % 2 == 0)\n            return (x * x) % p;\n        else\n            return\
    \ (x * x * 2) % p;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(11L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return (long)log10(n) + 1;\n}\n/*\nReturn the nth digit of\
    \ n, where the rightmost digit is 0.\n    >>> nthdigit(0L, 0L)\n    0\n    >>>\
    \ nthdigit(0L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n    5\n    >>> nthdigit(12345L,\
    \ 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n    3\n    >>> nthdigit(12345L, 3L)\n\
    \    2\n    >>> nthdigit(12345L, 4L)\n    1\n    >>> nthdigit(12345L, 5L)\n  \
    \  0\n    >>> nthdigit(12345L, 6L)\n    0\n*/\nlong nthdigit(long n, long d) \n\
    {\n    if (d >= numdigits(n))\n        return 0;\n    else\n        return n /\
    \ (long)pow(10, d) % 10;\n}\n/*\nReturn the number of digits in n that are equal\
    \ to d.\n    >>> numdigitsmatch(0L, 0L)\n    1\n    >>> numdigitsmatch(0L, 1L)\n\
    \    0\n    >>> numdigitsmatch(12345L\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa8q1utlb.d(50): Error: C style cast illegal, use `cast(long)log10(n)`

    /tmp/tmpa8q1utlb.d(78): Error: C style cast illegal, use `cast(long)pow(10, d)`

    /tmp/tmpa8q1utlb.d(80): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa8q1utlb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = 1;\n    while (n > 0) {\n        if (n & 1)\n\
    \            res = (res * n) % p;\n        n >>= 1;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpysg3t87v.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmpysg3t87v.__unittest_L29_C1() [0x427a9b]

    ??:? void tmpysg3t87v.__modtest() [0x427b70]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n         \
    \   result = (result * n) % p;\n        }\n        n = n / 2L;\n        n = n\
    \ % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp1glriz7.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e0d]

    ??:? void tmpp1glriz7.__unittest_L31_C1() [0x427ab7]

    ??:? void tmpp1glriz7.__modtest() [0x427b8c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430008]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fae5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a99d]

    ??:? runModuleUnitTests [0x42b909]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n % 2L) == 1L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        n\
    \ = n / 2L;\n        base = (base * base) % p;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = r * r % p;\n    if (n\
    \ % 2 == 1)\n        r = r * 2 % p;\n    return r;\n}\n/*\nReturn the number of\
    \ elements in the group of order p.\n    >>> p = 101L\n    >>> order(0L, p)\n\
    \    1L\n    >>> order(1L, p)\n    1L\n    >>> order(2L, p)\n    50L\n    >>>\
    \ order(3L, p)\n    33L\n    >>> order(4L, p)\n    25L\n    >>> order(5L, p)\n\
    \    20L\n    >>> order(6L, p)\n    16L\n    >>> order(7L, p)\n    14L\n    >>>\
    \ order(8L, p)\n    12L\n    >>> order(9L, p)\n    11L\n    >>> order(10L, p)\n\
    \    10L\n    >>> order(11L, p)\n    10L\n    >>> order(12L, p)\n    9L\n    >>>\
    \ order(13L, p)\n    9L\n    >>> order(14L, p)\n    9L\n    >>> order(15L, p)\n\
    \    9L\n    >>> order(16L, p)\n    8L\n    >>> order(17L, p)\n    8L\n    >>>\
    \ order(18L, p)\n    8L\n    >>> order(19L, p)\n    8L\n    >>> order(20L, p)\n\
    \    8L\n    >>> order(21L, p)\n    8L\n    >>> order(22L, p)\n    8L\n    >>>\
    \ order(23L, p)\n    8L\n    >>> order(24L, p)\n    8L\n    >>> order(25L, p)\n\
    \    7L\n    >>> order(26L, p)\n    7L\n    >>> order(27L, p)\n    7L\n    >>>\
    \ order(28L, p)\n    7L\n    >>> order(29L, p)\n    7L\n    >>> order\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2f9o_jpa.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2f9o_jpa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long factor = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L)\
    \ \n        {\n            result = (result * factor) % p;\n        }\n      \
    \  factor = (factor * factor) % p;\n        n /= 2L;\n    }\n    return result;\n\
    }\n/*\nReturn the nth Fibonacci number modulo p (be aware of numerics).\n    >>>\
    \ fibp(0L, 101L)\n    0L\n    >>> fibp(1L, 101L)\n    1L\n    >>> fibp(2L, 101L)\n\
    \    1L\n    >>> fibp(3L, 101L)\n    2L\n    >>> fibp(4L, 101L)\n    3L\n    >>>\
    \ fibp(5L, 101L)\n    5L\n    >>> fibp(6L, 101L)\n    8L\n    >>> fibp(7L, 101L)\n\
    \    13L\n    >>> fibp(8L, 101L)\n    21L\n    >>> fibp(9L, 101L)\n    34L\n \
    \   >>> fibp(10L, 101L)\n    55L\n    >>> fibp(11L, 101L)\n    89L\n    >>> fibp(12L,\
    \ 101L)\n    14L\n    >>> fibp(13L, 101L)\n    23L\n    >>> fibp(14L, 101L)\n\
    \    37L\n    >>> fibp(15L, 101L)\n    60L\n    >>> fibp(16L, 101L)\n    97L\n\
    \    >>> fibp(17L, 101L)\n    31L\n    >>> fibp(18L, 101L)\n    50L\n    >>> fibp(19L,\
    \ 101L)\n    81L\n    >>> fibp(20L, 101L)\n    65L\n    >>> fibp(21L, 101L)\n\
    \    106L\n    >>> fibp(22L, 101L)\n    17L\n    >>> fibp(23L, 101L)\n    28L\n\
    \    >>> fibp(24L, 101L)\n    45\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1aabkxh0.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1aabkxh0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm2yfg7wg.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmpm2yfg7wg.__unittest_L43_C1() [0x427a81]

    ??:? void tmpm2yfg7wg.__modtest() [0x427b7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n) +\
    \ 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n) +\
    \ 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n) +\
    \ 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcxgvis7d.d(44): Error: C style cast illegal, use `cast(long)log10(n)`

    /tmp/tmpcxgvis7d.d(64): Error: C style cast illegal, use `cast(long)log10(n)`

    /tmp/tmpcxgvis7d.d(84): Error: C style cast illegal, use `cast(long)log10(n)`

    /tmp/tmpcxgvis7d.d(86): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcxgvis7d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0L) \n \
    \   {\n        return modp(-n, p);\n    }\n    if (n == 0L) \n    {\n        return\
    \ 1L;\n    }\n    if (n == 1L) \n    {\n        return 2L % p;\n    }\n    if\
    \ (n % 2L == 0L) \n    {\n        return modp(n / 2L, p) * modp(n / 2L, p) % p;\n\
    \    }\n    else \n    {\n        return 2L * modp(n - 1L, p) % p;\n    }\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\n/*\nReturn the inverse\
    \ of x modulo p.\n    >>> modinv(3L, 5L)\n    2L\n    >>> modinv(2L, 5L)\n   \
    \ 3L\n    >>> modinv(4L, 5L)\n    1L\n    >>> modinv(3L, 11L)\n    4L\n    >>>\
    \ modinv(10L, 17L)\n    13L\n*/\nlong modinv(long x, long p) \n{\n    return modp(x,\
    \ p - 2, p);\n}\n/*\nReturn x^n modulo p (be aware of numerics).\n    >>> modp(3L,\
    \ 5L, 7L)\n    2L\n    >>> modp(1101L, 101L, 1001L)\n    2L\n    >>> modp(0L,\
    \ 101L, 1001L)\n    1L\n    >>> modp(3L, 11L, 101L)\n    8L\n    >>> modp(100L,\
    \ 101L, 1001L)\n    1L\n*/\nlong modp(long x, long n, long p) \n{\n    if (n ==\
    \ 0)\n        return 1;\n    else if (n == 1)\n        return x % p;\n    else\
    \ if (n % 2 == 0)\n        return modp(x * x % p, n / 2, p);\n    else\n     \
    \   return x * modp(x * x % p, n / 2, p) % p;\n}\n/*\nReturn the inverse of x\
    \ modulo p.\n    >>> modinv(3L, 5L)\n    2L\n    >>> modinv(2L, 5L)\n    3L\n\
    \    >>> modinv(4L, 5L)\n    1L\n    >>> modinv(3L\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg5ke2bcq.d(69): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg5ke2bcq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return 0;\n    else\n        return\
    \ (modp(n - 1, p) + modp(n - 2, p)) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyqlq42eq.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmpyqlq42eq.__unittest_L26_C1() [0x427a85]

    ??:? void tmpyqlq42eq.__modtest() [0x427b80]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164305
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) {\n        if (n & 1L) {\n            res = (res * n) % p;\n\
    \        }\n        n = n >> 1L;\n        n = (n * n) % p;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164306
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p != 0L) {\n        if ((p & 1L) != 0L) {\n     \
    \       result = (result * x) % n;\n        }\n        x = (x * x) % n;\n    \
    \    p >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwpx7sxtd.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmpwpx7sxtd.__unittest_L30_C1() [0x427a7d]

    ??:? void tmpwpx7sxtd.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long result = modp(n\
    \ >> 1, p);\n        result = (result * result) % p;\n        if (n & 1) \n  \
    \      {\n            result = (result * 2) % p;\n        }\n        return result;\n\
    \    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(123456789L)\n\
    \    9\n*/\nlong numdigits(long n) \n{\n    long result = 0;\n    while (n > 0)\
    \ \n    {\n        n = n / 10;\n        result = result + 1;\n    }\n    return\
    \ result;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(11L)\n\
    \    2\n    >>> sumdigits(123456789L)\n    45\n*/\nlong sumdigits(long n) \n{\n\
    \    long result = 0;\n    while (n > 0) \n    {\n        result = result + n\
    \ % 10;\n        n = n / 10;\n    }\n    return result;\n}\n/*\nReturn the sum\
    \ of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n \
    \   1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(11L)\n    2\n    >>> sumdigits(123456789L)\n\
    \    45\n*/\nlong sumdigits(long n) \n{\n    long result = 0;\n    while (n >\
    \ 0) \n    {\n        result = result + n % 10;\n        n = n / 10;\n    }\n\
    \    return result;\n}\n/*\nReturn the sum of the digits in n.\n\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3g3fkkhh.d(101): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3g3fkkhh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\n/*\nReturn the number of bits in the binary\
    \ representation of n.\n    >>> num_bits(0L)\n    0\n    >>> num_bits(1L)\n  \
    \  1\n    >>> num_bits(2L)\n    2\n    >>> num_bits(3L)\n    2\n    >>> num_bits(4L)\n\
    \    3\n    >>> num_bits(5L)\n    3\n    >>> num_bits(6L)\n    3\n    >>> num_bits(7L)\n\
    \    3\n    >>> num_bits(8L)\n    4\n    >>> num_bits(9L)\n    4\n    >>> num_bits(10L)\n\
    \    4\n    >>> num_bits(11L)\n    4\n    >>> num_bits(12L)\n    4\n    >>> num_bits(13L)\n\
    \    4\n    >>> num_bits(14L)\n    4\n    >>> num_bits(15L)\n    4\n    >>> num_bits(16L)\n\
    \    5\n    >>> num_bits(17L)\n    5\n    >>> num_bits(18L)\n    5\n    >>> num_bits(19L)\n\
    \    5\n    >>> num_bits(20L)\n    5\n    >>> num_bits(21L)\n    5\n    >>> num_bits(22L)\n\
    \    5\n    >>> num_bits(23L)\n    5\n    >>> num_bits(24L)\n    5\n    >>> num_bits(25L)\n\
    \    5\n    >>> num_bits(26L)\n    5\n    >>> num_bits(27L)\n    5\n    >>> num_bits(28L)\n\
    \    5\n    >>> num_bits(29L)\n    5\n    >>> num_bits(30L)\n    5\n    >>> num_bits(\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp12jt7fmw.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp12jt7fmw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp40gdwbw0.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmp40gdwbw0.__unittest_L30_C1() [0x427a81]

    ??:? void tmp40gdwbw0.__modtest() [0x427b7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpubqzskgj.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e6d]

    ??:? void tmpubqzskgj.__unittest_L28_C1() [0x427b17]

    ??:? void tmpubqzskgj.__modtest() [0x427bec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\n/*\nReturn the number of digits in n.\n  \
    \  >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n   \
    \ 2\n    >>> digits(100L)\n    3\n    >>> digits(1000L)\n    4\n    >>> digits(10000L)\n\
    \    5\n    >>> digits(100000L)\n    6\n    >>> digits(1000000L)\n    7\n    >>>\
    \ digits(10000000L)\n    8\n    >>> digits(100000000L)\n    9\n    >>> digits(1000000000L)\n\
    \    10\n    >>> digits(10000000000L)\n    11\n    >>> digits(100000000000L)\n\
    \    12\n    >>> digits(1000000000000L)\n    13\n    >>> digits(10000000000000L)\n\
    \    14\n    >>> digits(100000000000000L)\n    15\n    >>> digits(1000000000000000L)\n\
    \    16\n    >>> digits(10000000000000000L)\n    17\n    >>> digits(100000000000000000L)\n\
    \    18\n    >>> digits(1000000000000000000L)\n    19\n    >>> digits(10000000000000000000L)\n\
    \    20\n    >>> digits(100000000000000000000L)\n    21\n    >>> digits(1000000000000000000000L)\n\
    \    22\n    >>> digits(10000000000000000000000L)\n    23\n    >>> digits(100000000000000000000000L)\n\
    \    24\n    >>> digits(1000000000000000000000000L)\n    25\n    >>> digits(10000000000000000000000000L)\n\
    \    26\n    >>> digits(100000000000000000000000000L)\n    27\n    >>> digits(1000000000000000000000000000L)\n\
    \    28\n    >>> digits(10000000000000000000000000000L)\n    29\n    >>> digits(100000000000000000000000000000L)\n\
    \    30\n    >>> digits(1000000000000000000000000000000L)\n    31\n    >>> digits(10000000000000000000000000000000L)\n\
    \   \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc3xm22ni.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc3xm22ni.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n\
    \    5\n    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n\
    \    5\n    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n\
    \    5\n    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n\
    \    5\n    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n\
    \    5\n    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n\
    \    6\n    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6vc1f6jt.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6vc1f6jt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n\
    \    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ else\n        return cast(long)floor(log10(n)) + 1;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)floor(log10(n))\
    \ + 1;\n}\n/*\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_wd36yfj.d(94): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_wd36yfj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if\
    \ (n & 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        long result = (half * half) % p;\n\
    \        if (n % 2 == 1)\n            result = (result * 2) % p;\n        return\
    \ result;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789012345L)\n    15\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return (long)log10(n) + 1;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789012345L)\n\
    \    15\n    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n)\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789012345L)\n    15\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz13c4pqk.d(52): Error: C style cast illegal, use `cast(long)log10(n)`

    /tmp/tmpz13c4pqk.d(74): Error: C style cast illegal, use `cast(long)log10(n)`

    /tmp/tmpz13c4pqk.d(92): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz13c4pqk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n\
    \    3\n    >>> numdigits(1000L)\n    4\n    >>> numdigits(10000L)\n    5\n  \
    \  >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    long count = 0;\n    while (n > 0)\
    \ \n    {\n        n /= 10;\n        count++;\n    }\n    return count;\n}\n/*\n\
    Return the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n    3\n    >>>\
    \ numdigits(1000L)\n    4\n    >>> numdigits(10000L)\n    5\n    >>> numdigits(123456789L)\n\
    \    9\n    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long\
    \ n) \n{\n    long count = 0;\n    while (n > 0) \n    {\n        n /= 10;\n \
    \       count++;\n    }\n    return count;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(100L)\n    3\n    >>> numdigits\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wg0xkle.d(84): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wg0xkle.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i > 0L) {\n        if (i\
    \ % 2L == 1L) {\n            result = (result * power) % p;\n        }\n     \
    \   power = (power * power) % p;\n        i /= 2L;\n    }\n    return result;\n\
    }\n/*\nReturn the Jacobi symbol (a/b) (be aware of numerics).\n    >>> jacobi(1L,\
    \ 1L)\n    1\n    >>> jacobi(2L, 1L)\n    1\n    >>> jacobi(3L, 1L)\n    1\n \
    \   >>> jacobi(4L, 1L)\n    1\n    >>> jacobi(5L, 1L)\n    1\n    >>> jacobi(6L,\
    \ 1L)\n    1\n    >>> jacobi(7L, 1L)\n    1\n    >>> jacobi(8L, 1L)\n    1\n \
    \   >>> jacobi(9L, 1L)\n    1\n    >>> jacobi(10L, 1L)\n    1\n    >>> jacobi(11L,\
    \ 1L)\n    1\n    >>> jacobi(12L, 1L)\n    1\n    >>> jacobi(13L, 1L)\n    1\n\
    \    >>> jacobi(14L, 1L)\n    1\n    >>> jacobi(15L, 1L)\n    1\n    >>> jacobi(16L,\
    \ 1L)\n    1\n    >>> jacobi(17L, 1L)\n    1\n    >>> jacobi(18L, 1L)\n    1\n\
    \    >>> jacobi(19L, 1L)\n    1\n    >>> jacobi(20L, 1L)\n    1\n    >>> jacobi(21L,\
    \ 1L)\n    1\n    >>> jacobi(22L, 1L)\n    1\n    >>> jacobi(23L, 1L)\n    1\n\
    \    >>> jacobi(24L, 1L)\n    1\n    >>> jacobi(25L, 1L)\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ntbc7kf.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ntbc7kf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits of n in base b.\n    >>> digits(0L, 10L)\n    1L\n    >>> digits(1L,\
    \ 10L)\n    1L\n    >>> digits(10L, 10L)\n    2L\n    >>> digits(100L, 10L)\n\
    \    3L\n    >>> digits(1000L, 10L)\n    4L\n    >>> digits(123456789L, 10L)\n\
    \    9L\n    >>> digits(123456789L, 2L)\n    31L\n    >>> digits(123456789L, 16L)\n\
    \    8L\n*/\nlong digits(long n, long b) \n{\n    if (n == 0)\n        return\
    \ 1;\n    else\n        return cast(long)floor(log(n) / log(b)) + 1;\n}\n/*\n\
    Return the number of digits of n in base b.\n    >>> digits(0L, 10L)\n    1L\n\
    \    >>> digits(1L, 10L)\n    1L\n    >>> digits(10L, 10L)\n    2L\n    >>> digits(100L,\
    \ 10L)\n    3L\n    >>> digits(1000L, 10L)\n    4L\n    >>> digits(123456789L,\
    \ 10L)\n    9L\n    >>> digits(123456789L, 2L)\n    31L\n    >>> digits(123456789L,\
    \ 16L)\n    8L\n*/\nlong digits(long n, long b) \n{\n    if (n == 0)\n       \
    \ return 1;\n    else\n        return cast(long)floor(log(n) / log(b)) + 1;\n\
    }\n/*\nReturn the number of digits of n in base b.\n   \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9qgnv9h3.d(80): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9qgnv9h3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpubqzskgj.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e6d]

    ??:? void tmpubqzskgj.__unittest_L28_C1() [0x427b17]

    ??:? void tmpubqzskgj.__modtest() [0x427bec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n   \
    \ 5\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n    else\n\
    \        return (long)log10(n) + 1;\n}\n/*\nReturn the sum of the digits of n.\n\
    \    >>> sum_digits(0)\n    0\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(10)\n\
    \    1\n    >>> sum_digits(12345)\n    15\n*/\nlong sum_digits(long n) \n{\n \
    \   if (n == 0)\n        return 0;\n    else\n        return n % 10 + sum_digits(n\
    \ / 10);\n}\n/*\nReturn the sum of the digits of n.\n    >>> sum_digits(0)\n \
    \   0\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(10)\n    1\n    >>> sum_digits(12345)\n\
    \    15\n*/\nlong sum_digits(long n) \n{\n    if (n == 0)\n        return 0;\n\
    \    else\n        return n % 10 + sum_digits(n / 10);\n}\n/*\nReturn the sum\
    \ of the digits of n.\n    >>> sum_digits(0)\n    0\n    >>> sum_digits(1)\n \
    \   1\n    >>> sum_digits(10)\n    1\n    >>> sum_digits(12345)\n    15\n*/\n\
    long sum_digits(long n) \n{\n    if (n == 0)\n        return 0;\n    else\n  \
    \      return n % 10 + sum_\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiqosfp39.d(42): Error: C style cast illegal, use `cast(long)log10(n)`

    /tmp/tmpiqosfp39.d(97): Error: found `unittest` when expecting `;` following `return`
    statement

    /tmp/tmpiqosfp39.d(109): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiqosfp39.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       result = (result * a) % p;\n        }\n        a = (a * a) % p;\n    \
    \    n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long m = modp(n >>\
    \ 1, p);\n        m = m * m % p;\n        if (n & 1) \n        {\n           \
    \ m = m * 2 % p;\n        }\n        return m;\n    }\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n\
    \    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789012345L)\n\
    \    15\n*/\nlong numdigits(long n) \n{\n    long num = 0;\n    while (n > 0)\
    \ \n    {\n        n /= 10;\n        num++;\n    }\n    return num;\n}\n/*\nReturn\
    \ the nth digit of n.\n    >>> nthdigit(12345L, 0)\n    5\n    >>> nthdigit(12345L,\
    \ 1)\n    4\n    >>> nthdigit(12345L, 2)\n    3\n    >>> nthdigit(12345L, 3)\n\
    \    2\n    >>> nthdigit(12345L, 4)\n    1\n    >>> nthdigit(12345L, 5)\n    0\n\
    */\nlong nthdigit(long n, long d) \n{\n    long num = numdigits(n);\n    if (d\
    \ >= num) \n    {\n        return 0;\n    }\n    else \n    {\n        return\
    \ (n / pow(10L, num - d - 1L)) % 10L;\n    }\n}\n/*\nReturn the sum of the digits\
    \ of n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n\
    \    1\n    >>> sumdigits(12345L)\n    15\n    >>> sumdigits(123456789012345L)\n\
    \    45\n*/\nlong sumdigits(long n) \n{\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfc7grd3e.d(99): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfc7grd3e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = 1;\n    while (n > 0)\n    {\n        if (n &\
    \ 1)\n            res = (res * n) % p;\n        n = n >> 1;\n        n = (n *\
    \ n) % p;\n    }\n    return res;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> numdigits(0)\n    1\n    >>> numdigits(1)\n    1\n    >>> numdigits(10)\n\
    \    2\n    >>> numdigits(12345)\n    5\n    >>> numdigits(123456789)\n    9\n\
    */\nlong numdigits(long n) \n{\n    long res = 0;\n    while (n > 0)\n    {\n\
    \        n = n / 10;\n        res++;\n    }\n    return res;\n}\n/*\nReturn the\
    \ nth digit of n.\n    >>> digit(12345, 0)\n    5\n    >>> digit(12345, 1)\n \
    \   4\n    >>> digit(12345, 2)\n    3\n    >>> digit(12345, 3)\n    2\n    >>>\
    \ digit(12345, 4)\n    1\n    >>> digit(12345, 5)\n    0\n*/\nlong digit(long\
    \ n, long i) \n{\n    long res = 0;\n    while (i > 0)\n    {\n        n = n /\
    \ 10;\n        i--;\n    }\n    return n % 10;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0)\n    1\n    >>> numdigits(1)\n    1\n    >>> numdigits(10)\n\
    \    2\n    >>> numdigits(12345)\n    5\n    >>> numdigits(123456789)\n    9\n\
    */\nlong numdigits(long n) \n{\n    long res = 0;\n    while (n > 0)\n    {\n\
    \        n = n / 10;\n        res++;\n    }\n    return res;\n}\n/*\nReturn the\
    \ nth digit of n.\n    >>> digit(12345, 0)\n    5\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7fiitweb.d(102): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7fiitweb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\n/*\nReturn the number of bits in the binary\
    \ representation of n.\n    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n\
    \    1\n    >>> bit_length(2L)\n    2\n    >>> bit_length(3L)\n    2\n    >>>\
    \ bit_length(4L)\n    3\n    >>> bit_length(5L)\n    3\n    >>> bit_length(6L)\n\
    \    3\n    >>> bit_length(7L)\n    3\n    >>> bit_length(8L)\n    4\n    >>>\
    \ bit_length(9L)\n    4\n    >>> bit_length(10L)\n    4\n    >>> bit_length(11L)\n\
    \    4\n    >>> bit_length(12L)\n    4\n    >>> bit_length(13L)\n    4\n    >>>\
    \ bit_length(14L)\n    4\n    >>> bit_length(15L)\n    4\n    >>> bit_length(16L)\n\
    \    5\n    >>> bit_length(17L)\n    5\n    >>> bit_length(18L)\n    5\n    >>>\
    \ bit_length(19L)\n    5\n    >>> bit_length(20L)\n    5\n    >>> bit_length(21L)\n\
    \    5\n    >>> bit_length(22L)\n    5\n    >>> bit_length(23L)\n    5\n    >>>\
    \ bit_length(24L)\n    5\n    >>> bit_length(25L)\n    5\n    >>> bit_length(26L)\n\
    \    5\n    >>> bit_length(27L)\n    5\n    >>> bit_length(28L)\n    5\n    >>>\
    \ bit_length(29L)\n    5\n    >>> bit_length(30L)\n    5\n    >>> bit_length(\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqtp0cf5c.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtp0cf5c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) return\
    \ 1;\n    long k = modp(n / 2, p);\n    if (n % 2 == 0) return (k * k) % p;\n\
    \    else return (k * k * 2) % p;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n \
    \   >>> digits(10)\n    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n\
    \    1001\n    >>> digits(10**10000)\n    10001\n    >>> digits(10**100000)\n\
    \    100001\n    >>> digits(10**1000000)\n    1000001\n    >>> digits(10**10000000)\n\
    \    10000001\n    >>> digits(10**100000000)\n    100000001\n    >>> digits(10**1000000000)\n\
    \    1000000001\n    >>> digits(10**10000000000)\n    10000000001\n    >>> digits(10**100000000000)\n\
    \    100000000001\n    >>> digits(10**1000000000000)\n    1000000000001\n    >>>\
    \ digits(10**10000000000000)\n    10000000000001\n    >>> digits(10**100000000000000)\n\
    \    100000000000001\n    >>> digits(10**1000000000000000)\n    1000000000000001\n\
    \    >>> digits(10**10000000000000000)\n    10000000000000001\n    >>> digits(10**100000000000000000)\n\
    \    100000000000000001\n    >>> digits(10**1000000000000000000)\n    10000000000000000001\n\
    \    >>> digits(10**10000000000000000000)\n    100000000000000000001\n    >>>\
    \ digits(10**100000000000000000000)\n    1000000000000000000001\n    >>> digits(10**1000000000000000000000)\n\
    \    10000000000000000000001\n    >>> digits(10**10000000000000000000000)\n  \
    \  100000000000000000000001\n    >>> digits(10**100000000000000000000000)\n  \
    \  1000000000000000000000001\n    >>> digits(10**1000000000000000000000000)\n\
    \    10000000000000000000000001\n    >>> digits(10**10000000000000000000000000)\n\
    \    100000000000000000000000001\n    >>> digits(10**100000000000000000000000000)\n\
    \    1000000000000000000000000001\n    >>> digits(10**1000000000000000000000000000\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpum8ol6xc.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpum8ol6xc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164305
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            r = (r\
    \ * n) % p;\n        }\n        n = n >> 1L;\n    }\n    return r;\n}\n/*\nReturn\
    \ the number of digits of n in base b.\n    >>> digits(0L, 2L)\n    1L\n    >>>\
    \ digits(1L, 2L)\n    1L\n    >>> digits(2L, 2L)\n    2L\n    >>> digits(3L, 2L)\n\
    \    2L\n    >>> digits(4L, 2L)\n    3L\n    >>> digits(5L, 2L)\n    3L\n    >>>\
    \ digits(6L, 2L)\n    3L\n    >>> digits(7L, 2L)\n    3L\n    >>> digits(8L, 2L)\n\
    \    4L\n    >>> digits(9L, 2L)\n    4L\n    >>> digits(10L, 2L)\n    4L\n   \
    \ >>> digits(11L, 2L)\n    4L\n    >>> digits(12L, 2L)\n    4L\n    >>> digits(13L,\
    \ 2L)\n    4L\n    >>> digits(14L, 2L)\n    4L\n    >>> digits(15L, 2L)\n    4L\n\
    \    >>> digits(16L, 2L)\n    5L\n    >>> digits(17L, 2L)\n    5L\n    >>> digits(18L,\
    \ 2L)\n    5L\n    >>> digits(19L, 2L)\n    5L\n    >>> digits(20L, 2L)\n    5L\n\
    \    >>> digits(21L, 2L)\n    5L\n    >>> digits(22L, 2L)\n    5L\n    >>> digits(23L,\
    \ 2L)\n    5L\n    >>> digits(24L, 2L)\n    5L\n    >>> digits(25L, 2L)\n    5L\n\
    \    >>> digits(26L, 2L)\n    5L\n    >>> digits(27L, 2L)\n    5L\n    >>> digits(28L,\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9b7ws6pc.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9b7ws6pc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    foreach (i; 0 .. n) \n    {\n        result = (result * 2L) % p;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of bits in the binary representation\
    \ of n.\n    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n    1\n    >>>\
    \ bit_length(2L)\n    2\n    >>> bit_length(3L)\n    2\n    >>> bit_length(4L)\n\
    \    3\n    >>> bit_length(5L)\n    3\n    >>> bit_length(6L)\n    3\n    >>>\
    \ bit_length(7L)\n    3\n    >>> bit_length(8L)\n    4\n    >>> bit_length(9L)\n\
    \    4\n    >>> bit_length(10L)\n    4\n    >>> bit_length(11L)\n    4\n    >>>\
    \ bit_length(12L)\n    4\n    >>> bit_length(13L)\n    4\n    >>> bit_length(14L)\n\
    \    4\n    >>> bit_length(15L)\n    4\n    >>> bit_length(16L)\n    5\n    >>>\
    \ bit_length(17L)\n    5\n    >>> bit_length(18L)\n    5\n    >>> bit_length(19L)\n\
    \    5\n    >>> bit_length(20L)\n    5\n    >>> bit_length(21L)\n    5\n    >>>\
    \ bit_length(22L)\n    5\n    >>> bit_length(23L)\n    5\n    >>> bit_length(24L)\n\
    \    5\n    >>> bit_length(25L)\n    5\n    >>> bit_length(26L)\n    5\n    >>>\
    \ bit_length(27L)\n    5\n    >>> bit_length(28L)\n    5\n    >>> bit_length(29L)\n\
    \    5\n    >>> bit_length(30L)\n    5\n    >>> bit_length(31L)\n    5\n    >>>\
    \ bit_length(32L)\n    6\n    >>> bit_length(33L)\n    6\n    >>> bit_length(\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaa4eu9cn.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaa4eu9cn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long x = n;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n \
    \       {\n            res = (res * x) % p;\n        }\n        x = (x * x) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(10**100)\n    100\n\
    \    >>> numdigits(10**1000)\n    1000\n*/\nlong numdigits(long n) \n{\n    long\
    \ res = 1L;\n    while (n >= 10L) \n    {\n        n /= 10L;\n        res += 1L;\n\
    \    }\n    return res;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n\
    \    15\n    >>> sumdigits(10**100)\n    1\n    >>> sumdigits(10**1000)\n    1\n\
    */\nlong sumdigits(long n) \n{\n    long res = 0L;\n    while (n > 0L) \n    {\n\
    \        res += n % 10L;\n        n /= 10L;\n    }\n    return res;\n}\n/*\nReturn\
    \ the number of digits of n in base b.\n    >>> numdigits(0L, 2)\n    1\n    >>>\
    \ numdigits(1L, 2)\n    1\n    >>> numdigits(10L, 2)\n    4\n    >>> numdigits(12345L,\
    \ 2)\n    14\n    >>> numdigits(10**100, 2)\n    332\n    >>> numdigits(10**1000,\
    \ 2)\n    3332\n*/\nlong num\nunittest\n{\n    alias candidate = modp;\n\n   \
    \ assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjh32a_iw.d(98): Error: semicolon expected, not `unittest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjh32a_iw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n != 0L) {\n        if (n % 2L != 0L) {\n            result = (result\
    \ * 2L) % p;\n        }\n        n /= 2L;\n    }\n    return result;\n}\n/*\n\
    Return the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long n) \n{\n  \
    \  long result = 0L;\n    while (n != 0L) {\n        n /= 10L;\n        result\
    \ += 1L;\n    }\n    return result;\n}\n/*\nReturn the nth digit of n.\n    >>>\
    \ nthdigit(0L, 0L)\n    0\n    >>> nthdigit(1L, 0L)\n    1\n    >>> nthdigit(10L,\
    \ 0L)\n    0\n    >>> nthdigit(10L, 1L)\n    1\n    >>> nthdigit(12345L, 0L)\n\
    \    5\n    >>> nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n  \
    \  3\n    >>> nthdigit(12345L, 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n\
    \    >>> nthdigit(12345L, 5L)\n    0\n    >>> nthdigit(1234567890123456789L, 0L)\n\
    \    9\n    >>> nthdigit(1234567890123456789L, 1L)\n    8\n    >>> nthdigit(1234567890123456789L,\
    \ 2L)\n    7\n    >>> nthdigit(1234567890123456789L, 3L)\n    6\n    >>> nthdigit(1234567890123456789L,\
    \ 4L)\n    5\n    >>> nthdigit\nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqrjiwh50.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqrjiwh50.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i != 0L) \n    {\n    \
    \    if ((i & 1L) != 0L) \n        {\n            result = (result * power) %\
    \ p;\n        }\n        power = (power * power) % p;\n        i >>= 1L;\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpohj_f2u5.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmpohj_f2u5.__unittest_L33_C1() [0x427a81]

    ??:? void tmpohj_f2u5.__modtest() [0x427b7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164292
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n\
    \    3\n    >>> numdigits(1234567890L)\n    10\n*/\nlong numdigits(long n) \n\
    {\n    long res = 0L;\n    while (n > 0L) \n    {\n        res = res + 1L;\n \
    \       n = n / 10L;\n    }\n    return res;\n}\n/*\nReturn the sum of the digits\
    \ in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n\
    \    1\n    >>> sumdigits(100L)\n    1\n    >>> sumdigits(1234567890L)\n    45\n\
    */\nlong sumdigits(long n) \n{\n    long res = 0L;\n    while (n > 0L) \n    {\n\
    \        res = res + n % 10L;\n        n = n / 10L;\n    }\n    return res;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>>\
    \ numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n\
    \    3\n    >>> numdigits(1234567890L)\n    10\n*/\nlong numdigits(long n) \n\
    {\n    long res = 0L;\n    while (n > 0L) \n    {\n        res = res + 1L;\n \
    \       n = n / 10L;\n    }\n    return res;\n}\n\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164306
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\n/*\nReturn the greatest common divisor of a and b.\n\
    \    >>> gcd(14, 15)\n    1\n    >>> gcd(2*3*5*11*17, 3*7*11*13*19)\n    3*11\n\
    */\nlong gcd(long a, long b) \n{\n    if (a < 0L) \n    {\n        a = -a;\n \
    \   }\n    if (b < 0L) \n    {\n        b = -b;\n    }\n    while (a != 0L) \n\
    \    {\n        long c = a;\n        a = b % a;\n        b = c;\n    }\n    return\
    \ b;\n}\n/*\nReturn the least common multiple of a and b.\n    >>> lcm(14, 15)\n\
    \    210\n    >>> lcm(2*3*5*11*17, 3*7*11*13*19)\n    2310\n*/\nlong lcm(long\
    \ a, long b) \n{\n    return (a / gcd(a, b)) * b;\n}\n/*\nReturn the integer square\
    \ root of n.\n    >>> isqrt(0)\n    0\n    >>> isqrt(1)\n    1\n    >>> isqrt(4)\n\
    \    2\n    >>> isqrt(15)\n    3\n    >>> isqrt(16)\n    4\n    >>> isqrt(234)\n\
    \    15\n*/\nlong isqrt(long n) \n{\n    long x = n;\n    long y = (x + 1L) >>\
    \ 1L;\n    while (y < x) \n    {\n        x = y;\n        y = (x + n / x) >> 1L;\n\
    \    }\n    return x;\n}\n/*\nReturn the integer square root of n.\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1nr3c1si.d(93): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1nr3c1si.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else\n    {\n        long r = modp(n / 2,\
    \ p);\n        r = (r * r) % p;\n        if (n % 2 == 1)\n        {\n        \
    \    r = (r * 2) % p;\n        }\n        return r;\n    }\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) {\n        if (n & 1L) {\n            result = (result * n)\
    \ % p;\n        }\n        n = n >> 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv277vmv6.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmpv277vmv6.__unittest_L28_C1() [0x427a93]

    ??:? void tmpv277vmv6.__modtest() [0x427b68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n /= 2L;\n        if (n > 0L) \n    \
    \    {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\n/*\n\
    Return the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n    3\n    >>>\
    \ numdigits(1000L)\n    4\n    >>> numdigits(10000L)\n    5\n    >>> numdigits(100000L)\n\
    \    6\n    >>> numdigits(1000000L)\n    7\n    >>> numdigits(10000000L)\n   \
    \ 8\n    >>> numdigits(100000000L)\n    9\n    >>> numdigits(1000000000L)\n  \
    \  10\n    >>> numdigits(10000000000L)\n    11\n    >>> numdigits(100000000000L)\n\
    \    12\n    >>> numdigits(1000000000000L)\n    13\n    >>> numdigits(10000000000000L)\n\
    \    14\n    >>> numdigits(100000000000000L)\n    15\n    >>> numdigits(1000000000000000L)\n\
    \    16\n    >>> numdigits(10000000000000000L)\n    17\n    >>> numdigits(100000000000000000L)\n\
    \    18\n    >>> numdigits(1000000000000000000L)\n    19\n    >>> numdigits(10000000000000000000L)\n\
    \    20\n    >>> numdigits(100000000000000000000L)\n    21\n    >>> numdigits(1000000000000000000000L)\n\
    \    22\n    >>> numdigits(10000000000000000000000L)\n    23\n    >>> numdigits(100000000000000000000000L)\n\
    \    24\n    >>> numdigits(1000000000000000000000000L)\n    25\n    >>> numdigits(10000000000000000000000000L)\n\
    \    26\n    >>> numdigits(1000000000000000000000000\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpspi5ouvg.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpspi5ouvg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long r = modp(n >> 1, p);\n       \
    \ r = (r * r) % p;\n        if (n & 1)\n            r = (r * 2) % p;\n       \
    \ return r;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \ {\n        return modp(-n, p);\n    }\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    if (n == 1)\n    {\n        return n;\n    }\n    if (n % 2 ==\
    \ 0)\n    {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    else\n\
    \    {\n        return modp(n / 2, p) * modp(n / 2, p) * n % p;\n    }\n}\n/*\n\
    Return the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n    19\n\
    */\nlong numdigits(long n) \n{\n    if (n == 0)\n    {\n        return 1;\n  \
    \  }\n    else\n    {\n        return (long)log10(n) + 1;\n    }\n}\n/*\nReturn\
    \ the sum of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n\
    \    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n    15\n   \
    \ >>> sumdigits(123456789L)\n    45\n    >>> sumdigits(1234567890123456789L)\n\
    \    135\n*/\nlong sumdigits(long n) \n{\n    if (n == 0)\n    {\n        return\
    \ 0;\n    }\n    else\n    {\n        return n % 10 + sumdigits(n / 10);\n   \
    \ }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n   \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps5clhm8a.d(63): Error: C style cast illegal, use `cast(long)log10(n)`

    /tmp/tmps5clhm8a.d(92): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps5clhm8a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = modp(n >> 1, p);\n    res = (res * res) % p;\n\
    \    if (n & 1)\n        res = (res * 2) % p;\n    return res;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the Jacobi symbol (a/b) (be aware of numerics).\n\
    \    >>> jacobi(1L, 1L)\n    1\n    >>> jacobi(5L, 1L)\n    1\n    >>> jacobi(1L,\
    \ 5L)\n    1\n    >>> jacobi(5L, 7L)\n    -1\n    >>> jacobi(7L, 5L)\n    1\n\
    \    >>> jacobi(7L, 13L)\n    -1\n    >>> jacobi(13L, 7L)\n    1\n    >>> jacobi(7L,\
    \ 15L)\n    1\n    >>> jacobi(15L, 7L)\n    1\n    >>> jacobi(7L, 21L)\n    -1\n\
    \    >>> jacobi(21L, 7L)\n    1\n    >>> jacobi(7L, 23L)\n    1\n    >>> jacobi(23L,\
    \ 7L)\n    1\n    >>> jacobi(7L, 29L)\n    -1\n    >>> jacobi(29L, 7L)\n    1\n\
    \    >>> jacobi(7L, 31L)\n    1\n    >>> jacobi(31L, 7L)\n    1\n    >>> jacobi(7L,\
    \ 33L)\n    -1\n    >>> jacobi(33L, 7L)\n    1\n    >>> jacobi(7L, 35L)\n    1\n\
    \    >>> jacobi(35L, 7L)\n    1\n    >>> jacobi(7L, 37L)\n    -1\n    >>> jacobi(37L,\
    \ 7L)\n    1\n    >>> jacobi(7L, 39L)\n    1\n    >>> jacobi(39L, 7L)\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgomwyu_d.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgomwyu_d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n /= 2L;\n        if (n > 0L) \n    \
    \    {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp02bv2frb.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmp02bv2frb.__unittest_L34_C1() [0x427abf]

    ??:? void tmp02bv2frb.__modtest() [0x427b94]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long r = modp(n / 2,\
    \ p);\n        r = (r * r) % p;\n        if (n % 2 == 1) \n        {\n       \
    \     r = (r * 2) % p;\n        }\n        return r;\n    }\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) {\n        r = (r * 2L) % p;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p > 0L) \n    {\n        if (p % 2L == 1L) \n \
    \       {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p /= 2L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(100L)\n    3\n    >>> digits(1000L)\n\
    \    4\n    >>> digits(10000L)\n    5\n    >>> digits(100000L)\n    6\n    >>>\
    \ digits(1000000L)\n    7\n    >>> digits(10000000L)\n    8\n    >>> digits(100000000L)\n\
    \    9\n    >>> digits(1000000000L)\n    10\n    >>> digits(10000000000L)\n  \
    \  11\n    >>> digits(100000000000L)\n    12\n    >>> digits(1000000000000L)\n\
    \    13\n    >>> digits(10000000000000L)\n    14\n    >>> digits(100000000000000L)\n\
    \    15\n    >>> digits(1000000000000000L)\n    16\n    >>> digits(10000000000000000L)\n\
    \    17\n    >>> digits(100000000000000000L)\n    18\n    >>> digits(1000000000000000000L)\n\
    \    19\n    >>> digits(10000000000000000000L)\n    20\n    >>> digits(100000000000000000000L)\n\
    \    21\n    >>> digits(1000000000000000000000L)\n    22\n    >>> digits(10000000000000000000000L)\n\
    \    23\n    >>> digits(100000000000000000000000L)\n    24\n    >>> digits(1000000000000000000000000L)\n\
    \    25\n    >>> digits(10000000000000000000000000L)\n    26\n    >>> digits(100000000000000000000000000L)\n\
    \    27\n    >>> digits(1000000000000000000000000000L)\n    28\n    >>> digits(10000000000000000000000000000L)\n\
    \    29\n    >>> digits(100000000000000000000000000000L)\n    30\n    >>> digits(1000000000000000000000000000000L)\n\
    \    31\n    >>>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa2vg2os4.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa2vg2os4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) \n    {\n        r = (r * 2L) % p;\n    }\n    return\
    \ r;\n}\n/*\nReturn the number of bits in the binary representation of n.\n  \
    \  >>> bitlen(0L)\n    0\n    >>> bitlen(1L)\n    1\n    >>> bitlen(2L)\n    2\n\
    \    >>> bitlen(3L)\n    2\n    >>> bitlen(4L)\n    3\n    >>> bitlen(5L)\n  \
    \  3\n    >>> bitlen(6L)\n    3\n    >>> bitlen(7L)\n    3\n    >>> bitlen(8L)\n\
    \    4\n    >>> bitlen(9L)\n    4\n    >>> bitlen(10L)\n    4\n    >>> bitlen(11L)\n\
    \    4\n    >>> bitlen(12L)\n    4\n    >>> bitlen(13L)\n    4\n    >>> bitlen(14L)\n\
    \    4\n    >>> bitlen(15L)\n    4\n    >>> bitlen(16L)\n    5\n    >>> bitlen(17L)\n\
    \    5\n    >>> bitlen(18L)\n    5\n    >>> bitlen(19L)\n    5\n    >>> bitlen(20L)\n\
    \    5\n    >>> bitlen(21L)\n    5\n    >>> bitlen(22L)\n    5\n    >>> bitlen(23L)\n\
    \    5\n    >>> bitlen(24L)\n    5\n    >>> bitlen(25L)\n    5\n    >>> bitlen(26L)\n\
    \    5\n    >>> bitlen(27L)\n    5\n    >>> bitlen(28L)\n    5\n    >>> bitlen(29L)\n\
    \    5\n    >>> bitlen(30L)\n    5\n    >>> bitlen(31L)\n    5\n    >>> bitlen(32L)\n\
    \    6\n    >>> bitlen(33L)\n    6\n    >>> bitlen(34L)\n    6\n    >>> bitlen(35L)\n\
    \    6\n    >>> bitlen(36L)\n    6\n    >>> bitlen\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzvg_6ikn.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzvg_6ikn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n         \
    \   result = (result * n) % p;\n        }\n        n = n / 2L;\n        n = n\
    \ % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpp1glriz7.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e0d]

    ??:? void tmpp1glriz7.__unittest_L31_C1() [0x427ab7]

    ??:? void tmpp1glriz7.__modtest() [0x427b8c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430008]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fae5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a99d]

    ??:? runModuleUnitTests [0x42b909]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * x) % p;\n        }\n        n = n / 2L;\n\
    \        x = (x * x) % p;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> numdigits(12345)\n    5\n    >>> numdigits(0)\n   \
    \ 1\n    >>> numdigits(-12345)\n    5\n*/\nlong numdigits(long n) \n{\n    if\
    \ (n == 0L) \n    {\n        return 1L;\n    }\n    return (long)floor(log10(abs(n)))\
    \ + 1L;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(12345)\n\
    \    5\n    >>> numdigits(0)\n    1\n    >>> numdigits(-12345)\n    5\n*/\nlong\
    \ numdigits(long n) \n{\n    if (n == 0L) \n    {\n        return 1L;\n    }\n\
    \    return (long)floor(log10(abs(n))) + 1L;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(12345)\n    5\n    >>> numdigits(0)\n    1\n    >>>\
    \ numdigits(-12345)\n    5\n*/\nlong numdigits(long n) \n{\n    if (n == 0L) \n\
    \    {\n        return 1L;\n    }\n    return (long)floor(log10(abs(n))) + 1L;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> numdigits(12345)\n    5\n  \
    \  >>> numdigits(0)\n    1\n    >>> numdigits(-12345)\n    5\n*/\nlong numdigits(long\
    \ n) \n{\n    if (n == 0L) \n    {\n        return 1L;\n    }\n    return (long)floor(log10(abs(n)))\
    \ +\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqx9j9km.d(47): Error: C style cast illegal, use `cast(long)floor(log10(abs(n)))`

    /tmp/tmpvqx9j9km.d(64): Error: C style cast illegal, use `cast(long)floor(log10(abs(n)))`

    /tmp/tmpvqx9j9km.d(81): Error: C style cast illegal, use `cast(long)floor(log10(abs(n)))`

    /tmp/tmpvqx9j9km.d(98): Error: C style cast illegal, use `cast(long)floor(log10(abs(n)))`

    /tmp/tmpvqx9j9km.d(99): Error: expression expected, not `unittest`

    /tmp/tmpvqx9j9km.d(100): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqx9j9km.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            r = (r * b) % p;\n        }\n        n >>= 1L;\n     \
    \   b = (b * b) % p;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n    {\n        r = (r * 2L) % p;\n    }\n    return r;\n\
    }\n/*\nReturn the number of bits in the binary representation of n.\n    >>> num_bits(0L)\n\
    \    0\n    >>> num_bits(1L)\n    1\n    >>> num_bits(2L)\n    2\n    >>> num_bits(3L)\n\
    \    2\n    >>> num_bits(4L)\n    3\n    >>> num_bits(5L)\n    3\n    >>> num_bits(6L)\n\
    \    3\n    >>> num_bits(7L)\n    3\n    >>> num_bits(8L)\n    4\n    >>> num_bits(9L)\n\
    \    4\n    >>> num_bits(10L)\n    4\n    >>> num_bits(11L)\n    4\n    >>> num_bits(12L)\n\
    \    4\n    >>> num_bits(13L)\n    4\n    >>> num_bits(14L)\n    4\n    >>> num_bits(15L)\n\
    \    4\n    >>> num_bits(16L)\n    5\n    >>> num_bits(17L)\n    5\n    >>> num_bits(18L)\n\
    \    5\n    >>> num_bits(19L)\n    5\n    >>> num_bits(20L)\n    5\n    >>> num_bits(21L)\n\
    \    5\n    >>> num_bits(22L)\n    5\n    >>> num_bits(23L)\n    5\n    >>> num_bits(24L)\n\
    \    5\n    >>> num_bits(25L)\n    5\n    >>> num_bits(26L)\n    5\n    >>> num_bits(27L)\n\
    \    5\n    >>> num_bits(28L)\n    5\n    >>> num_bits(29L)\n    5\n    >>> num_bits(30L)\n\
    \    5\n    >>> num_bits(31L)\n    5\n    >>> num_bits(32L)\n    6\n    >>> num_bits(33L)\n\
    \    6\n    >>> num_bits(34\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_14l_q0x.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_14l_q0x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if\
    \ (n & 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) {\n        if (p % 2L == 1L) {\n        \
    \    result = (result * x) % n;\n        }\n        x = (x * x) % n;\n       \
    \ p = p / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphv9iyqx1.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmphv9iyqx1.__unittest_L30_C1() [0x427a99]

    ??:? void tmphv9iyqx1.__modtest() [0x427b94]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long x = n;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n \
    \       {\n            res = (res * x) % p;\n        }\n        x = (x * x) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the greatest common\
    \ divisor of a and b.\n    >>> gcd(2L, 3L)\n    1L\n    >>> gcd(3L, 3L)\n    3L\n\
    \    >>> gcd(3L, 6L)\n    3L\n    >>> gcd(6L, 3L)\n    3L\n    >>> gcd(3L, 9L)\n\
    \    3L\n    >>> gcd(9L, 3L)\n    3L\n    >>> gcd(3L, 12L)\n    3L\n    >>> gcd(12L,\
    \ 3L)\n    3L\n    >>> gcd(3L, 15L)\n    3L\n    >>> gcd(15L, 3L)\n    3L\n  \
    \  >>> gcd(3L, 18L)\n    3L\n    >>> gcd(18L, 3L)\n    3L\n    >>> gcd(3L, 21L)\n\
    \    3L\n    >>> gcd(21L, 3L)\n    3L\n    >>> gcd(3L, 24L)\n    3L\n    >>> gcd(24L,\
    \ 3L)\n    3L\n    >>> gcd(3L, 27L)\n    3L\n    >>> gcd(27L, 3L)\n    3L\n  \
    \  >>> gcd(3L, 30L)\n    3L\n    >>> gcd(30L, 3L)\n    3L\n    >>> gcd(3L, 33L)\n\
    \    3L\n    >>> gcd(33L, 3L)\n    3L\n    >>> gcd(3L, 36L)\n    3L\n    >>> gcd(36L,\
    \ 3L)\n    3L\n    >>> gcd(3L, 39L)\n    3L\n    >>> gcd\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp90ybx3bo.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp90ybx3bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n\
    \    5\n    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n\
    \    5\n    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n\
    \    5\n    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n\
    \    5\n    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n\
    \    5\n    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n\
    \    6\n    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n\
    \    6\n    >>> bits(37L)\n    6\n    >>> bits(\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbx72wlcn.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbx72wlcn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the number of bits in\
    \ the binary representation of n.\n    >>> bitlen(0L)\n    0\n    >>> bitlen(1L)\n\
    \    1\n    >>> bitlen(2L)\n    2\n    >>> bitlen(3L)\n    2\n    >>> bitlen(4L)\n\
    \    3\n    >>> bitlen(5L)\n    3\n    >>> bitlen(6L)\n    3\n    >>> bitlen(7L)\n\
    \    3\n    >>> bitlen(8L)\n    4\n    >>> bitlen(9L)\n    4\n    >>> bitlen(10L)\n\
    \    4\n    >>> bitlen(11L)\n    4\n    >>> bitlen(12L)\n    4\n    >>> bitlen(13L)\n\
    \    4\n    >>> bitlen(14L)\n    4\n    >>> bitlen(15L)\n    4\n    >>> bitlen(16L)\n\
    \    5\n    >>> bitlen(17L)\n    5\n    >>> bitlen(18L)\n    5\n    >>> bitlen(19L)\n\
    \    5\n    >>> bitlen(20L)\n    5\n    >>> bitlen(21L)\n    5\n    >>> bitlen(22L)\n\
    \    5\n    >>> bitlen(23L)\n    5\n    >>> bitlen(24L)\n    5\n    >>> bitlen(25L)\n\
    \    5\n    >>> bitlen(26L)\n    5\n    >>> bitlen(27L)\n    5\n    >>> bitlen(28L)\n\
    \    5\n    >>> bitlen(29L)\n    5\n    >>> bitlen(30L)\n    5\n    >>> bitlen(31L)\n\
    \    5\n    >>> bitlen(32L)\n    6\n    >>> bitlen(33L)\n    6\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_lli8hzu.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_lli8hzu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of digits in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n\
    \    1\n    >>> ndigits(10L)\n    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(12345678901234567890L)\n\
    \    20\n*/\nlong ndigits(long n) \n{\n    long result = 1L;\n    while (n >=\
    \ 10L) \n    {\n        n /= 10L;\n        result += 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>>\
    \ sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n\
    \    15\n    >>> sumdigits(12345678901234567890L)\n    90\n*/\nlong sumdigits(long\
    \ n) \n{\n    long result = 0L;\n    while (n > 0L) \n    {\n        result +=\
    \ n % 10L;\n        n /= 10L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n    1\n  \
    \  >>> ndigits(10L)\n    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(12345678901234567890L)\n\
    \    20\n*/\nlong ndigits(long n) \n{\n    long result = 1L;\n    while (n >=\
    \ 10L) \n    {\n        n /= 10L;\n        result\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_kafwk_b.d(98): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmp_kafwk_b.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp_kafwk_b.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_kafwk_b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n    1\n    >>>\
    \ ndigits(10)\n    2\n    >>> ndigits(12345)\n    5\n    >>> ndigits(10**100)\n\
    \    101\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n \
    \   else\n        return cast(long)floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n\
    \    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(12345)\n    5\n    >>> ndigits(10**100)\n\
    \    101\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n \
    \   else\n        return cast(long)floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n\
    \    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(12345)\n    5\n    >>> ndigits(10**100)\n\
    \    101\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n \
    \   else\n        return cast(long)floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3q278xb5.d(88): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3q278xb5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpubqzskgj.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e6d]

    ??:? void tmpubqzskgj.__unittest_L28_C1() [0x427b17]

    ??:? void tmpubqzskgj.__modtest() [0x427bec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else\n    {\n        long r = modp(n / 2,\
    \ p);\n        r = (r * r) % p;\n        if (n % 2 == 1)\n        {\n        \
    \    r = (r * 2) % p;\n        }\n        return r;\n    }\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            r = (r * b) % p;\n        }\n        n >>= 1L;\n     \
    \   b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the integer square root\
    \ of n, rounded down.\n    >>> isqrt(0)\n    0\n    >>> isqrt(1)\n    1\n    >>>\
    \ isqrt(2)\n    1\n    >>> isqrt(3)\n    1\n    >>> isqrt(4)\n    2\n    >>> isqrt(15)\n\
    \    3\n    >>> isqrt(16)\n    4\n    >>> isqrt(17)\n    4\n    >>> isqrt(2**50\
    \ - 1)\n    22517998136852479L\n    >>> isqrt(2**50)\n    2251799813685248L\n\
    \    >>> isqrt(2**50 + 1)\n    2251799813685248L\n*/\nlong isqrt(long n) \n{\n\
    \    long x = n;\n    long y = (x + 1L) >> 1L;\n    while (y < x) \n    {\n  \
    \      x = y;\n        y = (x + n / x) >> 1L;\n    }\n    return x;\n}\n/*\nReturn\
    \ the integer square root of n, rounded down.\n    >>> isqrt(0)\n    0\n    >>>\
    \ isqrt(1)\n    1\n    >>> isqrt(2)\n    1\n    >>> isqrt(3)\n    1\n    >>> isqrt(4)\n\
    \    2\n    >>> isqrt(15)\n    3\n    >>> isqrt(16)\n    4\n    >>> isqrt(17)\n\
    \    4\n    >>> isqrt(2**50 - 1)\n    22517998136852479L\n    >>> isqrt(2**50)\n\
    \    2251799813685248L\n    >>> isqrt(2**50 + 1\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw9tq6_np.d(68): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw9tq6_np.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n \
    \   101\n    >>> digits(10**1000)\n    1001\n*/\nlong digits(long n) \n{\n   \
    \ if (n == 0)\n        return 1;\n    else\n        return cast(long)floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the nth digit of n, counting from the right.\n\
    \    >>> nthdigit(0, 0)\n    0\n    >>> nthdigit(1, 0)\n    1\n    >>> nthdigit(10,\
    \ 0)\n    0\n    >>> nthdigit(10, 1)\n    1\n    >>> nthdigit(12345, 0)\n    5\n\
    \    >>> nthdigit(12345, 1)\n    4\n    >>> nthdigit(12345, 2)\n    3\n    >>>\
    \ nthdigit(12345, 3)\n    2\n    >>> nthdigit(12345, 4)\n    1\n    >>> nthdigit(12345,\
    \ 5)\n    0\n*/\nlong nthdigit(long n, long d) \n{\n    return (n / cast(long)pow(10,\
    \ d)) % 10;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0)\n\
    \    0\n    >>> sumdigits(1)\n    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(11)\n\
    \    2\n    >>> sumdigits(12345)\n    15\n*/\nlong sumdigits(long n) \n{\n   \
    \ long sum = 0;\n    foreach (d; 0 .. digits(n))\n        sum += n\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuxa7apq3.d(91): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpuxa7apq3.d(103): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuxa7apq3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of 1 bits in n.\n    >>> bitcount(0L)\n    0\n    >>> bitcount(1L)\n\
    \    1\n    >>> bitcount(2L)\n    1\n    >>> bitcount(3L)\n    2\n    >>> bitcount(4L)\n\
    \    1\n    >>> bitcount(5L)\n    2\n    >>> bitcount(6L)\n    2\n    >>> bitcount(7L)\n\
    \    3\n    >>> bitcount(8L)\n    1\n    >>> bitcount(9L)\n    2\n    >>> bitcount(10L)\n\
    \    2\n    >>> bitcount(11L)\n    3\n    >>> bitcount(12L)\n    2\n    >>> bitcount(13L)\n\
    \    3\n    >>> bitcount(14L)\n    3\n    >>> bitcount(15L)\n    4\n    >>> bitcount(16L)\n\
    \    1\n    >>> bitcount(17L)\n    2\n    >>> bitcount(18L)\n    2\n    >>> bitcount(19L)\n\
    \    3\n    >>> bitcount(20L)\n    2\n    >>> bitcount(21L)\n    3\n    >>> bitcount(22L)\n\
    \    3\n    >>> bitcount(23L)\n    4\n    >>> bitcount(24L)\n    2\n    >>> bitcount(25L)\n\
    \    3\n    >>> bitcount(26L)\n    3\n    >>> bitcount(27L)\n    4\n    >>> bitcount(28L)\n\
    \    3\n    >>> bitcount(29L)\n    4\n    >>> bitcount(30L)\n    4\n    >>> bitcount(31L)\n\
    \    5\n    >>> bitcount(32L)\n    1\n    >>> bitcount(33L)\n    2\n    >>> bitcount(34L)\n\
    \    2\n    >>> bitcount(\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa8ff01ki.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa8ff01ki.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) {\n        if (n & 1L) {\n            r = (r * 2L) % p;\n \
    \       }\n        n >>= 1L;\n    }\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8hqw7jsi.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmp8hqw7jsi.__unittest_L28_C1() [0x427a65]

    ??:? void tmp8hqw7jsi.__modtest() [0x427b60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) {\n        if (n & 1L) {\n            r = (r * 2L) % p;\n \
    \       }\n        n >>= 1L;\n    }\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8hqw7jsi.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmp8hqw7jsi.__unittest_L28_C1() [0x427a65]

    ??:? void tmp8hqw7jsi.__modtest() [0x427b60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n  \
    \  >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(10**100)\n\
    \    101\n    >>> ndigits(10**1000)\n    1001\n*/\nlong ndigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    return cast(long) floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n\
    \    >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(10**100)\n\
    \    101\n    >>> ndigits(10**1000)\n    1001\n*/\nlong ndigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    return cast(long) floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n\
    \    >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(10**100)\n\
    \    101\n    >>> ndigits(10**1000)\n    1001\n*/\nlong ndigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    return cast(long) floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n\
    \    >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n    >>> ndig\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuzedj2x6.d(83): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuzedj2x6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppxz7_crk.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmppxz7_crk.__unittest_L32_C1() [0x427a7d]

    ??:? void tmppxz7_crk.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * x) % p;\n        }\n        n = n >> 1L;\n       \
    \ x = (x * x) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) {\n        if (n % 2L == 1L) {\n            result = (result\
    \ * n) % p;\n        }\n        n = n / 2L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5grprklc.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmp5grprklc.__unittest_L28_C1() [0x427aab]

    ??:? void tmp5grprklc.__modtest() [0x427b80]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(100L)\n    3\n    >>> numdigits(1000L)\n    4\n    >>>\
    \ numdigits(10000L)\n    5\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    long ndigits = 1L;\n    while (n\
    \ >= 10L) \n    {\n        n = n / 10L;\n        ndigits = ndigits + 1L;\n   \
    \ }\n    return ndigits;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(100L)\n\
    \    1\n    >>> sumdigits(1000L)\n    1\n    >>> sumdigits(10000L)\n    1\n  \
    \  >>> sumdigits(123456789L)\n    45\n    >>> sumdigits(1234567890123456789L)\n\
    \    90\n*/\nlong sumdigits(long n) \n{\n    long s = 0L;\n    while (n > 0L)\
    \ \n    {\n        s = s + n % 10L;\n        n = n / 10L;\n    }\n    return s;\n\
    }\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>>\
    \ sumdig\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy38zfset.d(90): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy38zfset.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n    >>> digits(1234567890123456789)\n    19\n*/\nlong digits(long n) \n\
    {\n    long d = 1;\n    while (n >= 10) \n    {\n        n /= 10;\n        d +=\
    \ 1;\n    }\n    return d;\n}\n/*\nReturn the sum of the digits in n.\n    >>>\
    \ digit_sum(0)\n    0\n    >>> digit_sum(1)\n    1\n    >>> digit_sum(10)\n  \
    \  1\n    >>> digit_sum(12345)\n    15\n    >>> digit_sum(123456789)\n    45\n\
    \    >>> digit_sum(1234567890123456789)\n    135\n*/\nlong digit_sum(long n) \n\
    {\n    long s = 0;\n    while (n > 0) \n    {\n        s += n % 10;\n        n\
    \ /= 10;\n    }\n    return s;\n}\n/*\nReturn the sum of the digits in n.\n  \
    \  >>> digit_sum(0)\n    0\n    >>> digit_sum(1)\n    1\n    >>> digit_sum(10)\n\
    \    1\n    >>> digit_sum(12345)\n    15\n    >>> digit_sum(123456789)\n    45\n\
    \    >>> digit_sum(1234567890123456789)\n    135\n*/\nlong digit_sum(long n) \n\
    {\n    long s = 0;\n    while (n > 0) \n    {\n        s += n % 10;\n        n\
    \ /= 10;\n    }\n    return s\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxnce11zy.d(101): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpxnce11zy.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxnce11zy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164305
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long d = 1L;\n    while (n >= 10L) {\n        n = n / 10L;\n      \
    \  d = d + 1L;\n    }\n    return d;\n}\n/*\nReturn the nth digit of n (0-based).\n\
    \    >>> nthdigit(0L, 0L)\n    0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(1L,\
    \ 0L)\n    1\n    >>> nthdigit(12345L, 0L)\n    5\n    >>> nthdigit(12345L, 1L)\n\
    \    4\n    >>> nthdigit(12345L, 2L)\n    3\n    >>> nthdigit(12345L, 3L)\n  \
    \  2\n    >>> nthdigit(12345L, 4L)\n    1\n    >>> nthdigit(12345L, 5L)\n    0\n\
    \    >>> nthdigit(12345L, 6L)\n    0\n*/\nlong nthdigit(long n, long d) \n{\n\
    \    long p = pow(10L, d);\n    return (n / p) % 10L;\n}\n/*\nReturn the sum of\
    \ the digits of n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n\
    \    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n    15\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1mzfkyn6.d(80): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1mzfkyn6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) \n    {\n        r = (r * 2L) % p;\n    }\n    return\
    \ r;\n}\n/*\nReturn the nth Fibonacci number modulo p (be aware of numerics).\n\
    \    >>> fibp(0L, 101L)\n    0L\n    >>> fibp(1L, 101L)\n    1L\n    >>> fibp(2L,\
    \ 101L)\n    1L\n    >>> fibp(3L, 101L)\n    2L\n    >>> fibp(4L, 101L)\n    3L\n\
    \    >>> fibp(5L, 101L)\n    5L\n    >>> fibp(6L, 101L)\n    8L\n    >>> fibp(7L,\
    \ 101L)\n    13L\n    >>> fibp(8L, 101L)\n    21L\n    >>> fibp(9L, 101L)\n  \
    \  34L\n    >>> fibp(10L, 101L)\n    55L\n    >>> fibp(11L, 101L)\n    89L\n \
    \   >>> fibp(12L, 101L)\n    14L\n    >>> fibp(13L, 101L)\n    23L\n    >>> fibp(14L,\
    \ 101L)\n    37L\n    >>> fibp(15L, 101L)\n    60L\n    >>> fibp(16L, 101L)\n\
    \    97L\n    >>> fibp(17L, 101L)\n    31L\n    >>> fibp(18L, 101L)\n    50L\n\
    \    >>> fibp(19L, 101L)\n    81L\n    >>> fibp(20L, 101L)\n    13L\n    >>> fibp(21L,\
    \ 101L)\n    44L\n    >>> fibp(22L, 101L)\n    71L\n    >>> fibp(23L, 101L)\n\
    \    11L\n    >>> fibp(24L, 101L)\n    52L\n    >>> fibp(25L, 101L)\n    83L\n\
    \    >>> fibp(26L, 101L)\n    28L\n    >>> fibp(27L, 101L\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe_trkg9a.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_trkg9a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if\
    \ (n & 1)\n        r = (r * 2) % p;\n    return r;\n}\n/*\nReturn the number of\
    \ bits needed to represent n.\n    >>> bits(0L)\n    0\n    >>> bits(1L)\n   \
    \ 1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n    3\n\
    \    >>> bits(5L)\n    3\n    >>> bits(6L)\n    3\n    >>> bits(7L)\n    3\n \
    \   >>> bits(8L)\n    4\n    >>> bits(9L)\n    4\n    >>> bits(10L)\n    4\n \
    \   >>> bits(11L)\n    4\n    >>> bits(12L)\n    4\n    >>> bits(13L)\n    4\n\
    \    >>> bits(14L)\n    4\n    >>> bits(15L)\n    4\n    >>> bits(16L)\n    5\n\
    \    >>> bits(17L)\n    5\n    >>> bits(18L)\n    5\n    >>> bits(19L)\n    5\n\
    \    >>> bits(20L)\n    5\n    >>> bits(21L)\n    5\n    >>> bits(22L)\n    5\n\
    \    >>> bits(23L)\n    5\n    >>> bits(24L)\n    5\n    >>> bits(25L)\n    5\n\
    \    >>> bits(26L)\n    5\n    >>> bits(27L)\n    5\n    >>> bits(28L)\n    5\n\
    \    >>> bits(29L)\n    5\n    >>> bits(30L)\n    5\n    >>> bits(31L)\n    5\n\
    \    >>> bits(32L)\n    6\n    >>> bits(33L)\n    6\n    >>> bits(34L)\n    6\n\
    \    >>> bits(35L)\n    6\n    >>> bits(36L)\n    6\n    >>> bits(37L)\n    6\n\
    \    >>> bits(38L)\n    6\n   \nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8qnkwprp.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8qnkwprp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n == 1)\n        return n % p;\n    if (n % 2 == 0)\n\
    \        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n        return\
    \ (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1hgldthu.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e6d]

    ??:? void tmp1hgldthu.__unittest_L28_C1() [0x427b17]

    ??:? void tmp1hgldthu.__modtest() [0x427bec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164291
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\nReturn the nth\
    \ Lucas number.\n    >>> lucas(0L)\n    2L\n    >>> lucas(1L)\n    1L\n    >>>\
    \ lucas(2L)\n    3L\n    >>> lucas(3L)\n    4L\n    >>> lucas(4L)\n    7L\n  \
    \  >>> lucas(5L)\n    11L\n    >>> lucas(6L)\n    18L\n    >>> lucas(7L)\n   \
    \ 29L\n    >>> lucas(8L)\n    47L\n    >>> lucas(9L)\n    76L\n    >>> lucas(10L)\n\
    \    123L\n    >>> lucas(11L)\n    199L\n    >>> lucas(12L)\n    322L\n    >>>\
    \ lucas(13L)\n    521L\n    >>> lucas(14L)\n    843L\n    >>> lucas(15L)\n   \
    \ 1364L\n    >>> lucas(16L)\n    2207L\n    >>> lucas(17L)\n    3571L\n    >>>\
    \ lucas(18L)\n    5778L\n    >>> lucas(19L)\n    9349L\n    >>> lucas(20L)\n \
    \   15127L\n    >>> lucas(21L)\n    24476L\n    >>> lucas(22L)\n    39603L\n \
    \   >>> lucas(23L)\n    64079L\n    >>> lucas(24L)\n    103682L\n    >>> lucas(25L)\n\
    \    167761L\n    >>> lucas(26L)\n    271443L\n    >>> lucas(27L)\n    439204L\n\
    \    >>> lucas(28L)\n    710647L\n    >>> lucas(29L)\n   \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn5svis_6.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn5svis_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbb3y_0jg.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e6d]

    ??:? void tmpbb3y_0jg.__unittest_L28_C1() [0x427b17]

    ??:? void tmpbb3y_0jg.__modtest() [0x427bec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430068]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9fd]

    ??:? runModuleUnitTests [0x42b969]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long r = modp(n >>\
    \ 1, p);\n        r = (r * r) % p;\n        if (n & 1) \n        {\n         \
    \   r = (r * 2) % p;\n        }\n        return r;\n    }\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    foreach (i; 0 .. n) \n    {\n        result = (result * 2L) % p;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of bits in the binary representation\
    \ of n.\n    >>> bits(0L)\n    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n\
    \    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n \
    \   3\n    >>> bits(6L)\n    3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n  \
    \  4\n    >>> bits(9L)\n    4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n \
    \   4\n    >>> bits(12L)\n    4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n\
    \    4\n    >>> bits(15L)\n    4\n    >>> bits(16L)\n    5\n    >>> bits(123456789L)\n\
    \    31\n*/\nlong bits(long n) \n{\n    long result = 0L;\n    foreach (i; 0 ..\
    \ n) \n    {\n        result = result + 1L;\n    }\n    return result;\n}\n/*\n\
    Return the parity of n.\n    >>> parity(0L)\n    0\n    >>> parity(1L)\n    1\n\
    \    >>> parity(2L)\n    1\n    >>> parity(3L)\n    0\n    >>> parity(4L)\n  \
    \  1\n    >>> parity(5L)\n    0\n    >>> parity(6L)\n    0\n    >>> parity(7L)\n\
    \    1\n    >>> parity(8L)\n    1\n    >>> parity(9L)\n    0\n    >>> parity(10L)\n\
    \    0\n    >>> parity(11L)\n    1\n    >>> parity(12L)\n    0\n    >>> parity(13L)\n\
    \    1\n    >>> parity(14L)\n    1\n    >>> parity(15L)\n    0\n    >>> parity(16L)\n\
    \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjbr49scv.d(74): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjbr49scv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p > 0L) \n    {\n        if ((p & 1L) != 0L) \n\
    \        {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkwffh2wc.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmpkwffh2wc.__unittest_L32_C1() [0x427a79]

    ??:? void tmpkwffh2wc.__modtest() [0x427b74]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong numdigits(long n) \n{\n    long result = 1L;\n    while\
    \ (n >= 10L) {\n        n = n / 10L;\n        result = result + 1L;\n    }\n \
    \   return result;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(123456789L)\n\
    \    45\n    >>> sumdigits(1234567890123456789L)\n    90\n    \n*/\nlong sumdigits(long\
    \ n) \n{\n    long result = 0L;\n    while (n > 0L) {\n        result = result\
    \ + n % 10L;\n        n = n / 10L;\n    }\n    return result;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(123456789L)\n    9\n\
    \    >>> numdigits(1234567890123456789L)\n    19\n    \n*/\nlong numdigits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) {\n        n\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1blvcnd4.d(95): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmp1blvcnd4.d(107): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp1blvcnd4.d(107): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1blvcnd4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n\
    \ >= 10L) \n    {\n        n = n / 10L;\n        result = result + 1L;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n    \n*/\nlong digits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n        n = n /\
    \ 10L;\n        result = result + 1L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n    9\n    >>>\
    \ digits(1234567890123456789L)\n    19\n    \n*/\nlong digits(long n) \n{\n  \
    \  long result = 1L;\n    while (n >= 10L) \n    {\n        n = n / 10L;\n   \
    \     result = result + 1L;\n    }\n    return result;\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppqxvvmmy.d(104): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppqxvvmmy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164305
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow2 = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n    \
    \        result = (result * pow2) % p;\n        }\n        pow2 = (pow2 * pow2)\
    \ % p;\n        n /= 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) {\n        if (n & 1L) {\n            r = (r * 2L) % p;\n \
    \       }\n        n >>= 1L;\n    }\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8hqw7jsi.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmp8hqw7jsi.__unittest_L28_C1() [0x427a65]

    ??:? void tmp8hqw7jsi.__modtest() [0x427b60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164292
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the number of bits\
    \ in the binary representation of n.\n    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n\
    \    1\n    >>> bit_length(2L)\n    2\n    >>> bit_length(3L)\n    2\n    >>>\
    \ bit_length(4L)\n    3\n    >>> bit_length(5L)\n    3\n    >>> bit_length(6L)\n\
    \    3\n    >>> bit_length(7L)\n    3\n    >>> bit_length(8L)\n    4\n    >>>\
    \ bit_length(9L)\n    4\n    >>> bit_length(10L)\n    4\n    >>> bit_length(11L)\n\
    \    4\n    >>> bit_length(12L)\n    4\n    >>> bit_length(13L)\n    4\n    >>>\
    \ bit_length(14L)\n    4\n    >>> bit_length(15L)\n    4\n    >>> bit_length(16L)\n\
    \    5\n    >>> bit_length(17L)\n    5\n    >>> bit_length(18L)\n    5\n    >>>\
    \ bit_length(19L)\n    5\n    >>> bit_length(20L)\n    5\n    >>> bit_length(21L)\n\
    \    5\n    >>> bit_length(22L)\n    5\n    >>> bit_length(23L)\n    5\n    >>>\
    \ bit_length(24L)\n    5\n    >>> bit_length(25L)\n    5\n    >>> bit_length(26L)\n\
    \    5\n    >>> bit_length(27L)\n    5\n    >>> bit_length(28L)\n    5\n    >>>\
    \ bit_length(29L)\n    5\n    >>> bit_length(30L)\n    5\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplhsfsm2a.d(32): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplhsfsm2a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164292
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164291
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * x) % p;\n        }\n        n >>= 1L;\n        x =\
    \ (x * x) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164292
