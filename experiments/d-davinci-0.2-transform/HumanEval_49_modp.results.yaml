language: d
name: HumanEval_49_modp
results:
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    long b = n;\n    while (b > 0L) \n    {\n        if ((b\
    \ & 1L) != 0L) \n        {\n            result = (result * a) % p;\n        }\n\
    \        a = (a * a) % p;\n        b >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp34c6n419.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427df5]\n??:? void tmp34c6n419.__unittest_L32_C1() [0x427a7d]\n??:?
    void tmp34c6n419.__modtest() [0x427b78]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42facd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a985]\n??:? runModuleUnitTests [0x42b8f1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281cb]\n??:? _d_run_main [0x428136]\n??:? main [0x427b8b]\n??:?
    __libc_start_main [0x6fde9554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bitlen(0L)\n\
    \    0\n    >>> bitlen(1L)\n    1\n    >>> bitlen(2L)\n    2\n    >>> bitlen(3L)\n\
    \    2\n    >>> bitlen(4L)\n    3\n    >>> bitlen(5L)\n    3\n    >>> bitlen(6L)\n\
    \    3\n    >>> bitlen(7L)\n    3\n    >>> bitlen(8L)\n    4\n    >>> bitlen(9L)\n\
    \    4\n    >>> bitlen(10L)\n    4\n    >>> bitlen(11L)\n    4\n    >>> bitlen(12L)\n\
    \    4\n    >>> bitlen(13L)\n    4\n    >>> bitlen(14L)\n    4\n    >>> bitlen(15L)\n\
    \    4\n    >>> bitlen(16L)\n    5\n    >>> bitlen(17L)\n    5\n    >>> bitlen(18L)\n\
    \    5\n    >>> bitlen(19L)\n    5\n    >>> bitlen(20L)\n    5\n    >>> bitlen(21L)\n\
    \    5\n    >>> bitlen(22L)\n    5\n    >>> bitlen(23L)\n    5\n    >>> bitlen(24L)\n\
    \    5\n    >>> bitlen(25L)\n    5\n    >>> bitlen(26L)\n    5\n    >>> bitlen(27L)\n\
    \    5\n    >>> bitlen(28L)\n    5\n    >>> bitlen(29L)\n    5\n    >>> bitlen(30L)\n\
    \    5\n    >>> bitlen(31L)\n    5\n    >>> bitlen(32L)\n    6\n    >>> bitlen(33L\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8wp38wd7.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp8wp38wd7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bitlength(0L)\n\
    \    0\n    >>> bitlength(1L)\n    1\n    >>> bitlength(2L)\n    2\n    >>> bitlength(3L)\n\
    \    2\n    >>> bitlength(4L)\n    3\n    >>> bitlength(5L)\n    3\n    >>> bitlength(6L)\n\
    \    3\n    >>> bitlength(7L)\n    3\n    >>> bitlength(8L)\n    4\n    >>> bitlength(9L)\n\
    \    4\n    >>> bitlength(10L)\n    4\n    >>> bitlength(11L)\n    4\n    >>>\
    \ bitlength(12L)\n    4\n    >>> bitlength(13L)\n    4\n    >>> bitlength(14L)\n\
    \    4\n    >>> bitlength(15L)\n    4\n    >>> bitlength(16L)\n    5\n    >>>\
    \ bitlength(17L)\n    5\n    >>> bitlength(18L)\n    5\n    >>> bitlength(19L)\n\
    \    5\n    >>> bitlength(20L)\n    5\n    >>> bitlength(21L)\n    5\n    >>>\
    \ bitlength(22L)\n    5\n    >>> bitlength(23L)\n    5\n    >>> bitlength(24L)\n\
    \    5\n    >>> bitlength(25L)\n    5\n    >>> bitlength(26L)\n    5\n    >>>\
    \ bitlength(27L)\n    5\n    >>> bitlength(28L)\n    5\n    >>> bitlength(29L)\n\
    \    5\n    >>> bitlength(30L)\n    5\n    >>> bitlength(31L)\n    5\n    >>>\
    \ bitlength(32L)\n    6\n    >>> bitlength(33L)\n    6\n    >>> bitlength(34L)\n\
    \    6\n    >>>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn4ptulo7.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpn4ptulo7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) {\n        if (n % 2L == 1L) {\n            result = (result\
    \ * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n\
    \    5\n    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n\
    \    5\n    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n\
    \    5\n    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n\
    \    5\n    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n\
    \    5\n    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n\
    \    6\n    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n\
    \    6\n    >>> bits(37L)\n    6\n    >>> bits(38L)\n    6\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpylzlroqj.d(28): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpylzlroqj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else\n    {\n        return (modp(n - 1, p)\
    \ * 2) % p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n % 2 == 0)\n    {\n        long m = modp(n / 2, p);\n  \
    \      return (m * m) % p;\n    }\n    else\n    {\n        long m = modp(n -\
    \ 1, p);\n        return (2 * m) % p;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else if (n == 1)\n    {\n        return 2;\n\
    \    }\n    else if (n % 2 == 0)\n    {\n        long x = modp(n / 2, p);\n  \
    \      return (x * x) % p;\n    }\n    else\n    {\n        return (2 * modp(n\
    \ - 1, p)) % p;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return\
    \ cast(long) floor(log10(n)) + 1;\n    }\n}\n/*\nReturn the nth digit of n.\n\
    \    >>> nthdigit(0L, 0L)\n    0L\n    >>> nthdigit(0L, 1L)\n    0L\n    >>> nthdigit(1L,\
    \ 0L)\n    1L\n    >>> nthdigit(12345L, 0L)\n    5L\n    >>> nthdigit(12345L,\
    \ 1L)\n    4L\n    >>> nthdigit(12345L, 2L)\n    3L\n    >>> nthdigit(12345L,\
    \ 3L)\n    2L\n    >>> nthdigit(12345L, 4L)\n    1L\n    >>> nthdigit(12345L,\
    \ 5L)\n    0L\n*/\nlong nthdigit(long n, long d) \n{\n    return (n / pow(10L,\
    \ d)) % 10L;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n\
    \    0L\n    >>> sumdigits(1L)\n    1L\n    >>> sumdigits(10L)\n    1\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwpct3hum.d(86): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpwpct3hum.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bitlength(0L)\n\
    \    0\n    >>> bitlength(1L)\n    1\n    >>> bitlength(2L)\n    2\n    >>> bitlength(3L)\n\
    \    2\n    >>> bitlength(4L)\n    3\n    >>> bitlength(5L)\n    3\n    >>> bitlength(6L)\n\
    \    3\n    >>> bitlength(7L)\n    3\n    >>> bitlength(8L)\n    4\n    >>> bitlength(9L)\n\
    \    4\n    >>> bitlength(10L)\n    4\n    >>> bitlength(11L)\n    4\n    >>>\
    \ bitlength(12L)\n    4\n    >>> bitlength(13L)\n    4\n    >>> bitlength(14L)\n\
    \    4\n    >>> bitlength(15L)\n    4\n    >>> bitlength(16L)\n    5\n    >>>\
    \ bitlength(17L)\n    5\n    >>> bitlength(18L)\n    5\n    >>> bitlength(19L)\n\
    \    5\n    >>> bitlength(20L)\n    5\n    >>> bitlength(21L)\n    5\n    >>>\
    \ bitlength(22L)\n    5\n    >>> bitlength(23L)\n    5\n    >>> bitlength(24L)\n\
    \    5\n    >>> bitlength(25L)\n    5\n    >>> bitlength(26L)\n    5\n    >>>\
    \ bitlength(27L)\n    5\n    >>> bitlength(28L)\n    5\n    >>> bitlength(29L)\n\
    \    5\n    >>> bitlength(30L)\n    5\n    >>> bitlength(31L)\n    5\n    >>>\
    \ bitlength(32L)\n    6\n    >>> bitlength(33L\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuywc88cq.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpuywc88cq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(11L)\n    2\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return (long)floor(log10(n)) + 1;\n}\n/*\nReturn the n-th digit\
    \ of n.\n    >>> nthdigit(0L, 0L)\n    0L\n    >>> nthdigit(1L, 0L)\n    1L\n\
    \    >>> nthdigit(11L, 0L)\n    1L\n    >>> nthdigit(11L, 1L)\n    1L\n    >>>\
    \ nthdigit(123456789L, 0L)\n    9L\n    >>> nthdigit(123456789L, 1L)\n    8L\n\
    \    >>> nthdigit(123456789L, 2L)\n    7L\n    >>> nthdigit(123456789L, 3L)\n\
    \    6L\n    >>> nthdigit(123456789L, 4L)\n    5L\n    >>> nthdigit(123456789L,\
    \ 5L)\n    4L\n    >>> nthdigit(123456789L, 6L)\n    3L\n    >>> nthdigit(123456789L,\
    \ 7L)\n    2L\n    >>> nthdigit(123456789L, 8L)\n    1L\n    >>> nthdigit(1234567890123456789L,\
    \ 0L)\n    9L\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8x48ccrp.d(47): Error: C style cast illegal, use `cast(long)floor(log10(n))`\n/tmp/tmp8x48ccrp.d(49):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8x48ccrp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n != 0L) {\n        if (n & 1L) {\n            result = (result *\
    \ n) % p;\n        }\n        n = n >> 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpf0sllne0.d(33): unittest failure\n----------------\n??:?
    _d_unittestp [0x427de5]\n??:? void tmpf0sllne0.__unittest_L28_C1() [0x427a93]\n??:?
    void tmpf0sllne0.__modtest() [0x427b68]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a975]\n??:? runModuleUnitTests [0x42b8e1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281bb]\n??:? _d_run_main [0x428126]\n??:? main [0x427b7b]\n??:?
    __libc_start_main [0x8a22d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return r;\n}\n/*\nReturn\
    \ the number of digits in the binary representation of n.\n    >>> ndigits(0L)\n\
    \    0\n    >>> ndigits(1L)\n    1\n    >>> ndigits(2L)\n    2\n    >>> ndigits(3L)\n\
    \    2\n    >>> ndigits(4L)\n    3\n    >>> ndigits(5L)\n    3\n    >>> ndigits(6L)\n\
    \    3\n    >>> ndigits(7L)\n    3\n    >>> ndigits(8L)\n    4\n    >>> ndigits(9L)\n\
    \    4\n    >>> ndigits(10L)\n    4\n    >>> ndigits(11L)\n    4\n    >>> ndigits(12L)\n\
    \    4\n    >>> ndigits(13L)\n    4\n    >>> ndigits(14L)\n    4\n    >>> ndigits(15L)\n\
    \    4\n    >>> ndigits(16L)\n    5\n    >>> ndigits(17L)\n    5\n    >>> ndigits(18L)\n\
    \    5\n    >>> ndigits(19L)\n    5\n    >>> ndigits(20L)\n    5\n    >>> ndigits(21L)\n\
    \    5\n    >>> ndigits(22L)\n    5\n    >>> ndigits(23L)\n    5\n    >>> ndigits(24L)\n\
    \    5\n    >>> ndigits(25L)\n    5\n    >>> ndigits(26L)\n    5\n    >>> ndigits(27L)\n\
    \    5\n    >>> ndigits(28L)\n    5\n    >>> ndigits(29L)\n    5\n    >>> ndigits(30L)\n\
    \    5\n    >>> ndigits(31L)\n    5\n    >>> ndigits(32L)\n    6\n    >>> ndigits(33L)\n\
    \    6\n    >>> ndigits(34L)\n    6\n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpesolzlqe.d(24): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpesolzlqe.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n         \
    \   res = (res * n) % p;\n        }\n        n = n / 2L;\n        n = n % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpkmwim8yw.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e0d]\n??:? void tmpkmwim8yw.__unittest_L31_C1() [0x427ab7]\n??:?
    void tmpkmwim8yw.__modtest() [0x427b8c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430008]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fae5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a99d]\n??:? runModuleUnitTests [0x42b909]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281e3]\n??:? _d_run_main [0x42814e]\n??:? main [0x427b9f]\n??:?
    __libc_start_main [0xeac22554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n   \
    \ 5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\n    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\n    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ return floor(log(n) / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n\
    \    >>> digits(12345)\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8rpi3cpj.d(89): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp8rpi3cpj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \ {\n        return modp(-n, p);\n    }\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    if (n == 1)\n    {\n        return n;\n    }\n    if (n % 2 ==\
    \ 0)\n    {\n        long m = modp(n / 2, p);\n        return (m * m) % p;\n \
    \   }\n    else\n    {\n        return (n * modp(n - 1, p)) % p;\n    }\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp669c5jmx.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e35]\n??:? void tmp669c5jmx.__unittest_L41_C1() [0x427ae3]\n??:?
    void tmp669c5jmx.__modtest() [0x427bb8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb5b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb81]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430030]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb0d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9c5]\n??:? runModuleUnitTests [0x42b931]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428284]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42820b]\n??:? _d_run_main [0x428176]\n??:? main [0x427bcb]\n??:?
    __libc_start_main [0xcec19554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjy8poe9r.d(33): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e6d]\n??:? void tmpjy8poe9r.__unittest_L28_C1() [0x427b17]\n??:?
    void tmpjy8poe9r.__modtest() [0x427bec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9fd]\n??:? runModuleUnitTests [0x42b969]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428243]\n??:? _d_run_main [0x4281ae]\n??:? main [0x427bff]\n??:?
    __libc_start_main [0x2364a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        long result = (half * half) % p;\n\
    \        if (n % 2 == 1)\n            result = (result * n) % p;\n        return\
    \ result;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpux8n4m80.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e25]\n??:? void tmpux8n4m80.__unittest_L32_C1() [0x427acf]\n??:?
    void tmpux8n4m80.__modtest() [0x427ba4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb4b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9de]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb71]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430020]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fafd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9b5]\n??:? runModuleUnitTests [0x42b921]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428274]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281fb]\n??:? _d_run_main [0x428166]\n??:? main [0x427bb7]\n??:?
    __libc_start_main [0xc1ab4554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n        {\n\
    \            result = (result * x) % n;\n        }\n        p >>= 1L;\n      \
    \  x = (x * x) % n;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzmxg9vyh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ else\n        return cast(long)log10(n) + 1;\n}\n/*\nReturn the sum of the digits\
    \ in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n\
    \    1\n    >>> sumdigits(12345L)\n    15\n    >>> sumdigits(12345678901234567890L)\n\
    \    90\n*/\nlong sumdigits(long n) \n{\n    if (n == 0)\n        return 0;\n\
    \    else\n        return n % 10 + sumdigits(n / 10);\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ else\n        return cast(long)log10(n) + 1;\n}\n/*\nReturn the sum of the digits\
    \ in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7e_4f6fy.d(88): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp7e_4f6fy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fpl9kjm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n    9\n*/\n\
    long digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) \n    {\n    \
    \    n = n / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) \n\
    \    {\n        n = n / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\n\
    Return the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) \n\
    \    {\n        n = n / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\n\
    Return the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjmf808i9.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjmf808i9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0jcjv6u4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n        {\n      \
    \      result = (result * n) % p;\n        }\n        n = n >> 1L;\n        n\
    \ = (n * n) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnk1c3hup.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> len_num(1L)\n    1\n    >>> len_num(12345L)\n\
    \    5\n    >>> len_num(123456789012345L)\n    15\n    >>> len_num(1234567890123456789L)\n\
    \    19\n*/\nlong len_num(long n) \n{\n    return n.to!string.length;\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sum_digits(1L)\n    1\n    >>> sum_digits(12345L)\n\
    \    15\n    >>> sum_digits(123456789012345L)\n    45\n    >>> sum_digits(1234567890123456789L)\n\
    \    90\n*/\nlong sum_digits(long n) \n{\n    long sum = 0;\n    foreach (c; n.to!string)\n\
    \        sum += c.to!long - '0'.to!long;\n    return sum;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> len_num(1L)\n    1\n    >>> len_num(12345L)\n    5\n\
    \    >>> len_num(123456789012345L)\n    15\n    >>> len_num(1234567890123456789L)\n\
    \    19\n*/\nlong len_num(long n) \n{\n    return n.to!string.length;\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sum_digits(1L)\n    1\n    >>> sum_digits(12345L)\n\
    \    15\n    >>> sum_digits(123456789012345L)\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5nb6yeo4.d(76): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5nb6yeo4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long x = modp(n / 2,\
    \ p);\n        if (n % 2 == 0) \n        {\n            return x * x % p;\n  \
    \      }\n        else \n        {\n            return x * x * 2 % p;\n      \
    \  }\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n   \
    \ 1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n*/\nlong digits(long n) \n{\n  \
    \  if (n == 0) \n    {\n        return 1;\n    }\n    else \n    {\n        return\
    \ 1 + digits(n / 10);\n    }\n}\n/*\nReturn the sum of the digits in n.\n    >>>\
    \ sumdigits(0)\n    0\n    >>> sumdigits(1)\n    1\n    >>> sumdigits(10)\n  \
    \  1\n    >>> sumdigits(10**100)\n    1\n    >>> sumdigits(123456789)\n    45\n\
    */\nlong sumdigits(long n) \n{\n    if (n == 0) \n    {\n        return 0;\n \
    \   }\n    else \n    {\n        return n % 10 + sumdigits(n / 10);\n    }\n}\n\
    /*\nReturn the sum of the digits in n.\n    >>> sumdigits(0)\n    0\n    >>> sumdigits(1)\n\
    \    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(10**100)\n    1\n    >>>\
    \ sumdigits(123456789)\n    45\n*/\nlong sumdigits(long n) \n{\n    if (n == 0)\
    \ \n    {\n        return 0;\n    }\n    else \n    {\n        return n % 10 +\
    \ sumdigits(n / 10);\n    }\n}\n/*\nReturn the sum of the digits in n.\n    >>>\
    \ sumdigits(0\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph85lxbyj.d(108): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph85lxbyj.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            r = (r * b) % p;\n        }\n        n >>= 1L;\n     \
    \   b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of bits in\
    \ the binary representation of n.\n    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n\
    \    1\n    >>> bit_length(2L)\n    2\n    >>> bit_length(3L)\n    2\n    >>>\
    \ bit_length(4L)\n    3\n    >>> bit_length(5L)\n    3\n    >>> bit_length(6L)\n\
    \    3\n    >>> bit_length(7L)\n    3\n    >>> bit_length(8L)\n    4\n    >>>\
    \ bit_length(9L)\n    4\n    >>> bit_length(10L)\n    4\n    >>> bit_length(11L)\n\
    \    4\n    >>> bit_length(12L)\n    4\n    >>> bit_length(13L)\n    4\n    >>>\
    \ bit_length(14L)\n    4\n    >>> bit_length(15L)\n    4\n    >>> bit_length(16L)\n\
    \    5\n    >>> bit_length(17L)\n    5\n    >>> bit_length(18L)\n    5\n    >>>\
    \ bit_length(19L)\n    5\n    >>> bit_length(20L)\n    5\n    >>> bit_length(21L)\n\
    \    5\n    >>> bit_length(22L)\n    5\n    >>> bit_length(23L)\n    5\n    >>>\
    \ bit_length(24L)\n    5\n    >>> bit_length(25L)\n    5\n    >>> bit_length(26L)\n\
    \    5\n    >>> bit_length(27L)\n    5\n    >>> bit_length(28L)\n    5\n    >>>\
    \ bit_length(29L)\n    5\n    >>> bit_length(30L)\n    5\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1bl4l5p5.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp1bl4l5p5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    foreach (i; 0 .. n)\n    {\n        res = (res * 2L) % p;\n    }\n    return\
    \ res;\n}\n/*\nReturn the number of bits in the binary representation of n.\n\
    \    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n    1\n    >>> bit_length(2L)\n\
    \    2\n    >>> bit_length(3L)\n    2\n    >>> bit_length(4L)\n    3\n    >>>\
    \ bit_length(5L)\n    3\n    >>> bit_length(6L)\n    3\n    >>> bit_length(7L)\n\
    \    3\n    >>> bit_length(8L)\n    4\n    >>> bit_length(9L)\n    4\n    >>>\
    \ bit_length(10L)\n    4\n    >>> bit_length(11L)\n    4\n    >>> bit_length(12L)\n\
    \    4\n    >>> bit_length(13L)\n    4\n    >>> bit_length(14L)\n    4\n    >>>\
    \ bit_length(15L)\n    4\n    >>> bit_length(16L)\n    5\n    >>> bit_length(17L)\n\
    \    5\n    >>> bit_length(18L)\n    5\n    >>> bit_length(19L)\n    5\n    >>>\
    \ bit_length(20L)\n    5\n    >>> bit_length(21L)\n    5\n    >>> bit_length(22L)\n\
    \    5\n    >>> bit_length(23L)\n    5\n    >>> bit_length(24L)\n    5\n    >>>\
    \ bit_length(25L)\n    5\n    >>> bit_length(26L)\n    5\n    >>> bit_length(27L)\n\
    \    5\n    >>> bit_length(28L)\n    5\n    >>> bit_length(29L)\n    5\n    >>>\
    \ bit_length(30L)\n    5\n    >>> bit_length(31L)\n    5\n    >>> bit_length(32L)\n\
    \    6\n    >>> bit_length(33L)\n    6\n    >>> bit_length(34\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpghv17d_l.d(26): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpghv17d_l.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \ {\n        return modp(-n, p);\n    }\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    if (n == 1)\n    {\n        return n;\n    }\n    long result\
    \ = 1;\n    while (n > 0)\n    {\n        if (n & 1)\n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1;\n        n = (n * n) % p;\n\
    \    }\n    return result;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n \
    \   >>> digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n*/\nlong digits(long n) \n{\n  \
    \  if (n == 0)\n    {\n        return 1;\n    }\n    long result = 0;\n    while\
    \ (n > 0)\n    {\n        n = n / 10;\n        result++;\n    }\n    return result;\n\
    }\n/*\nReturn the number of digits in the binary representation of n.\n    >>>\
    \ binary_digits(0)\n    1\n    >>> binary_digits(1)\n    1\n    >>> binary_digits(10)\n\
    \    4\n    >>> binary_digits(12345)\n    14\n    >>> binary_digits(10**100)\n\
    \    334\n    >>> binary_digits(10**1000)\n    3333\n*/\nlong binary_digits(long\
    \ n) \n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    long result =\
    \ 0;\n    while (n > 0)\n    {\n        n = n / 2;\n        result++;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of digits in the hexadecimal representation\
    \ of n.\n    >>> hex_digits(0)\n    1\n    >>> hex_digits(1)\n    1\n    >>> hex_\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp856p391n.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp856p391n.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       r = (r * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b) %\
    \ p;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptzui2qj1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp34c6n419.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427df5]\n??:? void tmp34c6n419.__unittest_L32_C1() [0x427a7d]\n??:?
    void tmp34c6n419.__modtest() [0x427b78]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42facd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a985]\n??:? runModuleUnitTests [0x42b8f1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281cb]\n??:? _d_run_main [0x428136]\n??:? main [0x427b8b]\n??:?
    __libc_start_main [0x6fde9554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of 1 bits in n.\n    >>> bitcount(0L)\n    0\n    >>> bitcount(1L)\n    1\n\
    \    >>> bitcount(2L)\n    1\n    >>> bitcount(3L)\n    2\n    >>> bitcount(4L)\n\
    \    1\n    >>> bitcount(5L)\n    2\n    >>> bitcount(6L)\n    2\n    >>> bitcount(7L)\n\
    \    3\n    >>> bitcount(8L)\n    1\n    >>> bitcount(9L)\n    2\n    >>> bitcount(10L)\n\
    \    2\n    >>> bitcount(11L)\n    3\n    >>> bitcount(12L)\n    2\n    >>> bitcount(13L)\n\
    \    3\n    >>> bitcount(14L)\n    3\n    >>> bitcount(15L)\n    4\n    >>> bitcount(16L)\n\
    \    1\n    >>> bitcount(17L)\n    2\n    >>> bitcount(18L)\n    2\n    >>> bitcount(19L)\n\
    \    3\n    >>> bitcount(20L)\n    2\n    >>> bitcount(21L)\n    3\n    >>> bitcount(22L)\n\
    \    3\n    >>> bitcount(23L)\n    4\n    >>> bitcount(24L)\n    2\n    >>> bitcount(25L)\n\
    \    3\n    >>> bitcount(26L)\n    3\n    >>> bitcount(27L)\n    4\n    >>> bitcount(28L)\n\
    \    3\n    >>> bitcount(29L)\n    4\n    >>> bitcount(30L)\n    4\n    >>> bitcount(31L)\n\
    \    5\n    >>> bitcount(32L)\n    1\n    >>> bitcount(33L)\n   \nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp211p7zl.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpp211p7zl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the nth Fibonacci number modulo p (be aware\
    \ of numerics).\n    >>> fibp(0L, 101L)\n    0L\n    >>> fibp(1L, 101L)\n    1L\n\
    \    >>> fibp(2L, 101L)\n    1L\n    >>> fibp(3L, 101L)\n    2L\n    >>> fibp(4L,\
    \ 101L)\n    3L\n    >>> fibp(5L, 101L)\n    5L\n    >>> fibp(6L, 101L)\n    8L\n\
    \    >>> fibp(7L, 101L)\n    13L\n    >>> fibp(8L, 101L)\n    21L\n    >>> fibp(9L,\
    \ 101L)\n    34L\n    >>> fibp(10L, 101L)\n    55L\n    >>> fibp(11L, 101L)\n\
    \    89L\n    >>> fibp(12L, 101L)\n    14L\n    >>> fibp(13L, 101L)\n    23L\n\
    \    >>> fibp(14L, 101L)\n    37L\n    >>> fibp(15L, 101L)\n    60L\n    >>> fibp(16L,\
    \ 101L)\n    97L\n    >>> fibp(17L, 101L)\n    31L\n    >>> fibp(18L, 101L)\n\
    \    50L\n    >>> fibp(19L, 101L)\n    81L\n    >>> fibp(20L, 101L)\n    13L\n\
    \    >>> fibp(21L, 101L)\n    21L\n    >>> fibp(22L, 101L)\n    34L\n    >>> fibp(23L,\
    \ 101L)\n    55L\n    >>> fibp(24L, 101L)\n    89L\n    >>> fib\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdbwp45ep.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpdbwp45ep.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm3gmq07n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of elements of the group of units modulo p.\n    >>> phi(5L)\n    4L\n\
    \    >>> phi(101L)\n    100L\n    >>> phi(11L)\n    10L\n    >>> phi(1L)\n   \
    \ 1L\n    >>> phi(2L)\n    1L\n*/\nlong phi(long p) \n{\n    long result = p;\n\
    \    for (long i = 2; i < p; i++)\n        if (gcd(i, p) == 1)\n            result--;\n\
    \    return result;\n}\n/*\nReturn the order of a modulo p.\n    >>> order(2L,\
    \ 7L)\n    3L\n    >>> order(3L, 11L)\n    10L\n    >>> order(2L, 101L)\n    100L\n\
    \    >>> order(3L, 101L)\n    100L\n    >>> order(2L, 1L)\n    1L\n    >>> order(2L,\
    \ 2L)\n    1L\n*/\nlong order(long a, long p) \n{\n    long result = 1;\n    while\
    \ (modp(a, p) != 1)\n    {\n        a = (a * a) % p;\n        result++;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of elements of the group of units\
    \ modulo p^n.\n    >>> phi_pow(5L, 2L)\n    20L\n    >>> phi_pow(101L, 2L)\n \
    \   10000L\n    >>> phi_pow(11L, 2L)\n    100L\n    >>> phi_pow(1L, 2L)\n    1L\n\
    \    >>> phi\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4m0gi6m4.d(74): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp4m0gi6m4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long x = modp(n / 2,\
    \ p);\n        if (n % 2 == 0) \n        {\n            return (x * x) % p;\n\
    \        }\n        else \n        {\n            return (x * x * 2) % p;\n  \
    \      }\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n*/\nlong digits(long n) \n{\n    if (n == 0) \n    {\n        return\
    \ 1;\n    }\n    else \n    {\n        return 1 + digits(n / 10);\n    }\n}\n\
    /*\nReturn the sum of the digits in n.\n    >>> sumdigits(0)\n    0\n    >>> sumdigits(1)\n\
    \    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(10**100)\n    1\n*/\n\
    long sumdigits(long n) \n{\n    if (n == 0) \n    {\n        return 0;\n    }\n\
    \    else \n    {\n        return n % 10 + sumdigits(n / 10);\n    }\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sumdigits(0)\n    0\n    >>> sumdigits(1)\n\
    \    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(10**100)\n    1\n*/\n\
    long sumdigits(long n) \n{\n    if (n == 0) \n    {\n        return 0;\n    }\n\
    \    else \n    {\n        return n % 10 + sumdigits(n / 10);\n    }\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sumdigits(0)\n    0\n    >>> sumdigits(1)\n\
    \    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(10**100)\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk3ozxa_f.d(102): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3ozxa_f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv_4mu_c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fpl9kjm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * x) % p;\n        }\n        n = n / 2L;\n\
    \        x = (x * x) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr8pkrhwl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * x) % p;\n        }\n        n = n / 2L;\n        x =\
    \ (x * x) % p;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n    \n*/\nlong digits(long n) \n{\n    if (n == 0L) {\n        return\
    \ 1L;\n    }\n    long result = 0L;\n    while (n > 0L) {\n        n = n / 10L;\n\
    \        result = result + 1L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n    \n*/\nlong digits(long n) \n{\n    if (n == 0L) {\n        return\
    \ 1L;\n    }\n    long result = 0L;\n    while (n > 0L) {\n        n = n / 10L;\n\
    \        result = result + 1L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n    \n*/\nlong digits(long n) \n{\n    if (n == 0L) {\n        return\
    \ 1L;\n    }\n    long result = 0L;\n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvo2q7k8x.d(103): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvo2q7k8x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpixc7szse.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    foreach (i; 0 .. n)\n    {\n        res = (res * 2L) % p;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6ett62w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (pow > 0L) {\n        if ((pow & 1L) != 0L) {\n\
    \            result = (result * n) % p;\n        }\n        pow >>= 1L;\n    \
    \    n = (n * n) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn2rrp9xh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n % 2L) == 1L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n = n / 2L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ojgk9ra.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long r = modp(n / 2, p);\n        r = (r * r) % p;\n        if (n % 2\
    \ == 1)\n            r = (r * 2) % p;\n        return r;\n    }\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphp1casve.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnsny14kl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n    19\n\
    \    \n*/\nlong numdigits(long n) \n{\n    long r = 1L;\n    while (n >= 10L)\
    \ \n    {\n        n = n / 10L;\n        r = r + 1L;\n    }\n    return r;\n}\n\
    /*\nReturn the nth digit of n.\n    >>> digit(12345L, 0L)\n    5\n    >>> digit(12345L,\
    \ 1L)\n    4\n    >>> digit(12345L, 2L)\n    3\n    >>> digit(12345L, 3L)\n  \
    \  2\n    >>> digit(12345L, 4L)\n    1\n    >>> digit(12345L, 5L)\n    0\n   \
    \ \n*/\nlong digit(long n, long i) \n{\n    long r = 0L;\n    while (i > 0L) \n\
    \    {\n        r = n % 10L;\n        n = n / 10L;\n        i = i - 1L;\n    }\n\
    \    return r;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph_vljy4z.d(83): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmph_vljy4z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsopqlb39.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        n\
    \ >>= 1L;\n        base = (base * base) % p;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpde4btzga.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long a = modp(n / 2, p);\n    a = a * a % p;\n    if (n\
    \ % 2 == 1)\n        a = a * 2 % p;\n    return a;\n}\n/*\nReturn the number of\
    \ digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n\
    \    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n    1001\n\
    \    >>> digits(10**10000)\n    10001\n*/\nlong digits(long n) \n{\n    if (n\
    \ == 0)\n        return 1;\n    return cast(long)floor(log(n) / log(10)) + 1;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n\
    \    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n\
    \    1001\n    >>> digits(10**10000)\n    10001\n*/\nlong digits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    return cast(long)floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n \
    \   >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    1001\n    >>> digits(10**10000)\n    10001\n\
    */\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n    return cast(long)floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n\
    \    101\n    >>> digits(10**1000)\n    100\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuf76968y.d(90): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpuf76968y.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fpl9kjm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) \n    {\n        if (p % 2L == 1L) \n   \
    \     {\n            result = (result * x) % n;\n        }\n        x = (x * x)\
    \ % n;\n        p = p / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpck4py3ig.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bit_length(0L)\n\
    \    0\n    >>> bit_length(1L)\n    1\n    >>> bit_length(2L)\n    2\n    >>>\
    \ bit_length(3L)\n    2\n    >>> bit_length(4L)\n    3\n    >>> bit_length(5L)\n\
    \    3\n    >>> bit_length(6L)\n    3\n    >>> bit_length(7L)\n    3\n    >>>\
    \ bit_length(8L)\n    4\n    >>> bit_length(9L)\n    4\n    >>> bit_length(10L)\n\
    \    4\n    >>> bit_length(11L)\n    4\n    >>> bit_length(12L)\n    4\n    >>>\
    \ bit_length(13L)\n    4\n    >>> bit_length(14L)\n    4\n    >>> bit_length(15L)\n\
    \    4\n    >>> bit_length(16L)\n    5\n    >>> bit_length(17L)\n    5\n    >>>\
    \ bit_length(18L)\n    5\n    >>> bit_length(19L)\n    5\n    >>> bit_length(20L)\n\
    \    5\n    >>> bit_length(21L)\n    5\n    >>> bit_length(22L)\n    5\n    >>>\
    \ bit_length(23L)\n    5\n    >>> bit_length(24L)\n    5\n    >>> bit_length(25L)\n\
    \    5\n    >>> bit_length(26L)\n    5\n    >>> bit_length(27L)\n    5\n    >>>\
    \ bit_length(28L)\n    5\n    >>> bit_length(29L)\n    5\n    >>> bit_length(30L)\n\
    \    5\n    >>> bit_length(31L)\n    5\n    >>> bit_length(\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp58ddyiip.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp58ddyiip.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(100)\n    3\n\
    \    >>> digits(1000)\n    4\n    >>> digits(10000)\n    5\n    >>> digits(12345)\n\
    \    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    19\n    >>> digits(123456789012345678901234567890)\n    29\n*/\nlong digits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)\
    \ floor(log10(n)) + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(100)\n\
    \    3\n    >>> digits(1000)\n    4\n    >>> digits(10000)\n    5\n    >>> digits(12345)\n\
    \    5\n    >>> digits(123456789)\n    9\n    >>> digits(12345678901234567890)\n\
    \    19\n    >>> digits(123456789012345678901234567890)\n    29\n*/\nlong digits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)\
    \ floor(log10(n)) + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n\
    \    1\n    >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(100)\n\
    \    3\n    >>> digits(1000)\n    4\n   \nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv5z160xb.d(86): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpv5z160xb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(101L)\n\
    \    3\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return cast(long) floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the nth digit of n, where the rightmost digit is 0.\n    >>> nthdigit(123456789L,\
    \ 0)\n    9L\n    >>> nthdigit(123456789L, 1)\n    8L\n    >>> nthdigit(123456789L,\
    \ 2)\n    7L\n    >>> nthdigit(123456789L, 3)\n    6L\n    >>> nthdigit(123456789L,\
    \ 4)\n    5L\n    >>> nthdigit(123456789L, 5)\n    4L\n    >>> nthdigit(123456789L,\
    \ 6)\n    3L\n    >>> nthdigit(123456789L, 7)\n    2L\n    >>> nthdigit(123456789L,\
    \ 8)\n    1L\n    >>> nthdigit(123456789L, 9)\n    0L\n*/\nlong nthdigit(long\
    \ n, long d) \n{\n    return (n / modp(10, d)) % 10;\n}\n/*\nReturn the sum of\
    \ the digits of n.\n    >>> sumdigits(0L)\n    0L\n    >>> sumdigits\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx99prq38.d(75): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpx99prq38.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       r = (r * b) % p;\n        }\n        n >>= 1L;\n        b = (b * b) %\
    \ p;\n    }\n    return r;\n}\n/*\nReturn the number of digits in n.\n    >>>\
    \ digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n \
    \   >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n    20\n\
    */\nlong digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) {\n      \
    \  n /= 10L;\n        d += 1L;\n    }\n    return d;\n}\n/*\nReturn the nth digit\
    \ of n, counting from the right.\n    >>> digit(0L, 0L)\n    0\n    >>> digit(0L,\
    \ 1L)\n    0\n    >>> digit(1L, 0L)\n    1\n    >>> digit(12345L, 0L)\n    5\n\
    \    >>> digit(12345L, 1L)\n    4\n    >>> digit(12345L, 2L)\n    3\n    >>> digit(12345L,\
    \ 3L)\n    2\n    >>> digit(12345L, 4L)\n    1\n    >>> digit(12345L, 5L)\n  \
    \  0\n    >>> digit(12345L, 6L)\n    0\n*/\nlong digit(long n, long i) \n{\n \
    \   return (n / pow(10L, i)) % 10L;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n \
    \   2\n    >>> digits(12345L)\n    5\n    >>> digits(12345678901234567890L)\n\
    \    20\n*/\nlong digits(long n) \n{\n    long d = 1L;\n    while\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaaqjvf62.d(96): Error: found \''unittest\'' when expecting \''(\''\n/tmp/tmpaaqjvf62.d(108):
    Error: found \''void\'' when expecting \'')\''\n/tmp/tmpaaqjvf62.d(108): Error:
    found \''{\'' when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpaaqjvf62.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozbaa_v5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n        if (n > 0L) \n \
    \       {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n\
    \    15\n    >>> digits(1234567890123456789L)\n    19\n*/\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8e07mdx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 0;\n    while (n > 0) \n   \
    \ {\n        n /= 10;\n        d++;\n    }\n    return d;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 0;\n    while (n > 0) \n   \
    \ {\n        n /= 10;\n        d++;\n    }\n    return d;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 0;\n    while (n > 0) \n   \
    \ {\n        n /= 10;\n        d++;\n    }\n    return d;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n*/\nlong digits(long n) \n{\n    long d = 0;\n    while (n > 0\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpece7oc5o.d(113): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpece7oc5o.d(125): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpece7oc5o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    long b = n;\n    while (b > 0L) \n    {\n        if (b\
    \ % 2L == 1L) \n        {\n            result = (result * a) % p;\n        }\n\
    \        a = (a * a) % p;\n        b = b / 2L;\n    }\n    return result;\n}\n\
    /*\nReturn the number of elements in the finite field with p elements.\n    >>>\
    \ card(5L)\n    4L\n    >>> card(101L)\n    100L\n    >>> card(11L)\n    10L\n\
    \    >>> card(2L)\n    1L\n    >>> card(1L)\n    0L\n*/\nlong card(long p) \n\
    {\n    return p - 1L;\n}\n/*\nReturn the order of a modulo p.\n    >>> order(3L,\
    \ 5L)\n    4L\n    >>> order(2L, 101L)\n    100L\n    >>> order(3L, 11L)\n   \
    \ 10L\n    >>> order(2L, 2L)\n    1L\n    >>> order(1L, 1L)\n    0L\n*/\nlong\
    \ order(long a, long p) \n{\n    long result = 0L;\n    long i = 1L;\n    while\
    \ (modp(a, p) != 1L) \n    {\n        i = i + 1L;\n        a = (a * a) % p;\n\
    \    }\n    result = i;\n    return result;\n}\n/*\nReturn the number of elements\
    \ of order n in the finite field with p elements.\n    >>> num_elements_order(4L,\
    \ 5L)\n    1L\n    >>> num_elements_order(100L, 101L)\n    1L\n    >>> num_elements_order(10L,\
    \ 11L)\n    1L\n    >>> num_elements_order(1L, 2L)\n    1L\n    >>> num_elements_order(0L,\
    \ 1L)\n    0L\n*/\nlong num_elements_order(long n, long p) \n{\n\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdygs6nbx.d(91): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdygs6nbx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p;\n    else\n        return modp(n/2, p) * modp(n/2, p) * 2 % p;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(123456789L)\n    9\n    >>> numdigits(123456789012345L)\n    15\n\
    \    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long n) \n\
    {\n    long numdigits = 0;\n    while (n > 0) \n    {\n        n /= 10;\n    \
    \    numdigits++;\n    }\n    return numdigits;\n}\n/*\nReturn the sum of the\
    \ digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n \
    \   >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n    15\n    >>> sumdigits(123456789L)\n\
    \    45\n    >>> sumdigits(123456789012345L)\n    90\n    >>> sumdigits(1234567890123456789L)\n\
    \    180\n*/\nlong sumdigits(long n) \n{\n    long sumdigits = 0;\n    while (n\
    \ > 0) \n    {\n        sumdigits += n % 10;\n        n /= 10;\n    }\n    return\
    \ sumdigits;\n}\n/*\nReturn the number of trailing zeros in n!.\n    >>> numtrailingzeros(0L)\n\
    \    0\n    >>> numtrailingzeros(1L)\n    0\n    >>> numtrailingzeros(2L)\n  \
    \  0\n    >>> numtrailing\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphg_muppo.d(80): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmphg_muppo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the smallest prime factor of n.\n    >>> smallest_prime_factor(2L)\n  \
    \  2L\n    >>> smallest_prime_factor(3L)\n    3L\n    >>> smallest_prime_factor(4L)\n\
    \    2L\n    >>> smallest_prime_factor(5L)\n    5L\n    >>> smallest_prime_factor(6L)\n\
    \    2L\n    >>> smallest_prime_factor(7L)\n    7L\n    >>> smallest_prime_factor(8L)\n\
    \    2L\n    >>> smallest_prime_factor(9L)\n    3L\n    >>> smallest_prime_factor(10L)\n\
    \    2L\n    >>> smallest_prime_factor(11L)\n    11L\n    >>> smallest_prime_factor(12L)\n\
    \    2L\n    >>> smallest_prime_factor(13L)\n    13L\n    >>> smallest_prime_factor(14L)\n\
    \    2L\n    >>> smallest_prime_factor(15L)\n    3L\n    >>> smallest_prime_factor(16L)\n\
    \    2L\n    >>> smallest_prime_factor(17L)\n    17L\n    >>> smallest_prime_factor(18L)\n\
    \    2L\n    >>> smallest_prime_factor(19L)\n    19L\n    >>> smallest_prime_factor(20L)\n\
    \    2L\n    >>> smallest_prime_factor(21L)\n    3L\n    >>> smallest_prime_factor(22L)\n\
    \    2L\n    >>> smallest_prime_factor(23L)\n    23L\n    >>> smallest_prime_factor(24L)\n\
    \    2L\n    >>> smallest_prime_factor(25L)\n    5L\n    >>> smallest_prime_factor(26L)\n\
    \    2L\n    >>> smallest_prime_factor(27L)\n\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzvwvuts8.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpzvwvuts8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n  \
    \  >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(123456789012345L)\n    15\n*/\nlong digits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return cast(long) floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the nth digit of n, counting from the right.\n\
    \    >>> nthdigit(0L, 0L)\n    0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(1L,\
    \ 0L)\n    1\n    >>> nthdigit(1L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n\
    \    5\n    >>> nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n  \
    \  3\n    >>> nthdigit(12345L, 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n\
    \    >>> nthdigit(12345L, 5L)\n    0\n*/\nlong nthdigit(long n, long d) \n{\n\
    \    if (d == 0)\n        return n % 10;\n    else\n        return nthdigit(n\
    \ / 10, d - 1);\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n\
    \    15\n    >>> sumdigits\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzp7kfd_b.d(76): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpzp7kfd_b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n\
    \    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(12345678901234567890L)\n\
    \    20\n*/\nlong numdigits(long n) \n{\n    long result = 0L;\n    while (n >\
    \ 0L) \n    {\n        n = n / 10L;\n        result = result + 1L;\n    }\n  \
    \  return result;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n\
    \    15\n    >>> sumdigits(12345678901234567890L)\n    90\n*/\nlong sumdigits(long\
    \ n) \n{\n    long result = 0L;\n    while (n > 0L) \n    {\n        result =\
    \ result + n % 10L;\n        n = n / 10L;\n    }\n    return result;\n}\n/*\n\
    Return the sum of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n\
    \    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n    15\n   \
    \ >>> sumdigits(12345678901234567890L)\n    90\n*/\nlong sumdigits(long n) \n\
    {\n    long result = 0L;\n    while (n > 0L) \n   \nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvsohiecq.d(96): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvsohiecq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the number of elements\
    \ in the group of units modulo p.\n    >>> phi(7L)\n    6L\n    >>> phi(11L)\n\
    \    10L\n    >>> phi(13L)\n    12L\n    >>> phi(17L)\n    16L\n    >>> phi(19L)\n\
    \    18L\n    >>> phi(23L)\n    22L\n    >>> phi(29L)\n    28L\n    >>> phi(31L)\n\
    \    30L\n    >>> phi(37L)\n    36L\n    >>> phi(41L)\n    40L\n    >>> phi(43L)\n\
    \    42L\n    >>> phi(47L)\n    46L\n    >>> phi(53L)\n    52L\n    >>> phi(59L)\n\
    \    58L\n    >>> phi(61L)\n    60L\n    >>> phi(67L)\n    66L\n    >>> phi(71L)\n\
    \    70L\n    >>> phi(73L)\n    72L\n    >>> phi(79L)\n    78L\n    >>> phi(83L)\n\
    \    82L\n    >>> phi(89L)\n    88L\n    >>> phi(97L)\n    96L\n    >>> phi(101L)\n\
    \    100L\n    >>> phi(103L)\n    102L\n    >>> phi(107L)\n    106L\n    >>> phi(109L)\n\
    \    108L\n    >>> phi(113L)\n    112L\n    >>> phi(127L)\n    126L\n    >>> phi(131L)\n\
    \    130L\n    >>> phi(137L)\n    136L\n    >>> phi(139L)\n    138\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmqqjqwf2.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmqqjqwf2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1m6r95ho.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\n/*\nReturn the number of digits of n in base\
    \ b.\n    >>> digits(0L, 10L)\n    1L\n    >>> digits(1L, 10L)\n    1L\n    >>>\
    \ digits(10L, 10L)\n    2L\n    >>> digits(100L, 10L)\n    3L\n    >>> digits(1000L,\
    \ 10L)\n    4L\n    >>> digits(123456789L, 10L)\n    9L\n    >>> digits(123456789L,\
    \ 2L)\n    31L\n    >>> digits(123456789L, 8L)\n    12L\n    >>> digits(123456789L,\
    \ 16L)\n    8L\n    >>> digits(123456789L, 32L)\n    7L\n    >>> digits(123456789L,\
    \ 36L)\n    7L\n    >>> digits(123456789L, 62L)\n    6L\n    >>> digits(123456789L,\
    \ 64L)\n    6L\n    >>> digits(123456789L, 100L)\n    6L\n    >>> digits(123456789L,\
    \ 1000L)\n    5L\n    >>> digits(123456789L, 10000L)\n    5L\n    >>> digits(123456789L,\
    \ 100000L)\n    5L\n    >>> digits(123456789L, 1000000L)\n    5L\n    >>> digits(123456789L,\
    \ 10000000L)\n    5L\n    >>> digits(123456789L, 100000000L)\n    5L\n    >>>\
    \ digits(123456789L, 1000000000L)\n    5L\n    >>> digits(123456789L, 10000000000L)\n\
    \    5L\n    >>> digits(123456789L, 100000000000L)\n    5L\n    >>> digits(123456789\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4x0_sbqh.d(31): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp4x0_sbqh.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long r = modp(n / 2, p);\n        r\
    \ = (r * r) % p;\n        if (n % 2 == 1)\n            r = (r * 2) % p;\n    \
    \    return r;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjlv9z8k8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n        r = (r * 2L) % p;\n    return r;\n}\n/*\nReturn\
    \ the number of bits in the binary representation of n.\n    >>> bits(1L)\n  \
    \  1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n   \
    \ 3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n    3\n    >>> bits(7L)\n    3\n\
    \    >>> bits(8L)\n    4\n    >>> bits(9L)\n    4\n    >>> bits(10L)\n    4\n\
    \    >>> bits(11L)\n    4\n    >>> bits(12L)\n    4\n    >>> bits(13L)\n    4\n\
    \    >>> bits(14L)\n    4\n    >>> bits(15L)\n    4\n    >>> bits(16L)\n    5\n\
    \    >>> bits(17L)\n    5\n    >>> bits(18L)\n    5\n    >>> bits(19L)\n    5\n\
    \    >>> bits(20L)\n    5\n    >>> bits(21L)\n    5\n    >>> bits(22L)\n    5\n\
    \    >>> bits(23L)\n    5\n    >>> bits(24L)\n    5\n    >>> bits(25L)\n    5\n\
    \    >>> bits(26L)\n    5\n    >>> bits(27L)\n    5\n    >>> bits(28L)\n    5\n\
    \    >>> bits(29L)\n    5\n    >>> bits(30L)\n    5\n    >>> bits(31L)\n    5\n\
    \    >>> bits(32L)\n    6\n    >>> bits(33L)\n    6\n    >>> bits(34L)\n    6\n\
    \    >>> bits(35L)\n    6\n    >>> bits(36L)\n    6\n    >>> bits(37L)\n    6\n\
    \    >>> bits(38L)\n    6\n    >>> bits(39L)\n    6\n    >>> bits(40L)\n    6\n\
    \    >>> bits(41L)\n    6\n    >>> bits(\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplzian83w.d(24): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmplzian83w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    */\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L) {\n \
    \       n /= 10L;\n        result += 1L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the nth digit of n, starting from the right.\n    >>> nth_digit(1L, 0L)\n  \
    \  0\n    >>> nth_digit(1L, 1L)\n    1\n    >>> nth_digit(12345L, 0L)\n    5\n\
    \    >>> nth_digit(12345L, 1L)\n    4\n    >>> nth_digit(12345L, 2L)\n    3\n\
    \    >>> nth_digit(12345L, 3L)\n    2\n    >>> nth_digit(12345L, 4L)\n    1\n\
    \    >>> nth_digit(12345L, 5L)\n    0\n*/\nlong nth_digit(long n, long k) \n{\n\
    \    return (n / pow(10L, k)) % 10L;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n \
    \   2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    */\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L)\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8urq3zau.d(92): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8urq3zau.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        return (modp(n / 2,\
    \ p) * modp(n - n / 2, p)) % p;\n    }\n}\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp95ea8dzf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the smallest prime factor\
    \ of n.\n    >>> smallest_prime_factor(2L)\n    2L\n    >>> smallest_prime_factor(3L)\n\
    \    3L\n    >>> smallest_prime_factor(4L)\n    2L\n    >>> smallest_prime_factor(5L)\n\
    \    5L\n    >>> smallest_prime_factor(6L)\n    2L\n    >>> smallest_prime_factor(7L)\n\
    \    7L\n    >>> smallest_prime_factor(8L)\n    2L\n    >>> smallest_prime_factor(9L)\n\
    \    3L\n    >>> smallest_prime_factor(10L)\n    2L\n    >>> smallest_prime_factor(11L)\n\
    \    11L\n    >>> smallest_prime_factor(12L)\n    2L\n    >>> smallest_prime_factor(13L)\n\
    \    13L\n    >>> smallest_prime_factor(14L)\n    2L\n    >>> smallest_prime_factor(15L)\n\
    \    3L\n    >>> smallest_prime_factor(16L)\n    2L\n    >>> smallest_prime_factor(17L)\n\
    \    17L\n    >>> smallest_prime_factor(18L)\n    2L\n    >>> smallest_prime_factor(19L)\n\
    \    19L\n    >>> smallest_prime_factor(20L)\n    2L\n    >>> smallest_prime_factor(21L)\n\
    \    3L\n    >>> smallest_prime_factor(22L)\n    2L\n    >>> smallest_prime_factor(23L)\n\
    \    23L\n    >>> smallest_prime_factor(24L)\n    2L\n    >>> smallest_prime_factor(25L)\n\
    \    5L\n    >>> smallest_prime_factor(26L)\n    2L\n    >>> smallest_prime_factor(27L)\n\
    \   \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcwddn6om.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpcwddn6om.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsopqlb39.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i > 0L) \n    {\n     \
    \   if (i % 2L == 1L) \n        {\n            result = (result * power) % p;\n\
    \        }\n        power = (power * power) % p;\n        i = i / 2L;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfkqfiyl3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\n/*\nReturn the number of digits in the base\
    \ 10 representation of n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n   \
    \ 1\n    >>> digits(9L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(99L)\n\
    \    2\n    >>> digits(100L)\n    3\n    >>> digits(999L)\n    3\n    >>> digits(1000L)\n\
    \    4\n    >>> digits(9999L)\n    4\n    >>> digits(10000L)\n    5\n    >>> digits(99999L)\n\
    \    5\n    >>> digits(100000L)\n    6\n    >>> digits(999999L)\n    6\n    >>>\
    \ digits(1000000L)\n    7\n    >>> digits(9999999L)\n    7\n    >>> digits(10000000L)\n\
    \    8\n    >>> digits(99999999L)\n    8\n    >>> digits(100000000L)\n    9\n\
    \    >>> digits(999999999L)\n    9\n    >>> digits(1000000000L)\n    10\n    >>>\
    \ digits(9999999999L)\n    10\n    >>> digits(10000000000L)\n    11\n    >>> digits(99999999999L)\n\
    \    11\n    >>> digits(100000000000L)\n    12\n    >>> digits(999999999999L)\n\
    \    12\n    >>> digits(1000000000000L)\n    13\n    >>> digits(9999999999999L)\n\
    \    13\n    >>> digits(10000000000000L)\n    14\n    >>> digits(99999999999999L)\n\
    \    14\n    >>> digits(100000000000000L)\n    15\n    >>> digits(999999999999999L)\n\
    \    15\n    >>> digits(1000000000000000L)\n    16\n    >>> digits(9999999999999999L)\n\
    \    16\n    >>> digits\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7sl3bi1x.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp7sl3bi1x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\n/*\nReturn the greatest\
    \ common divisor of a and b.\n    >>> gcd(12, 8)\n    4\n    >>> gcd(8, 12)\n\
    \    4\n    >>> gcd(0, 12)\n    12\n    >>> gcd(12, 0)\n    12\n    >>> gcd(0,\
    \ 0)\n    0\n*/\nlong gcd(long a, long b) \n{\n    if (a == 0)\n        return\
    \ b;\n    else if (b == 0)\n        return a;\n    else\n        return gcd(b,\
    \ a % b);\n}\n/*\nReturn the least common multiple of a and b.\n    >>> lcm(12,\
    \ 8)\n    24\n    >>> lcm(8, 12)\n    24\n    >>> lcm(0, 12)\n    0\n    >>> lcm(12,\
    \ 0)\n    0\n    >>> lcm(0, 0)\n    0\n*/\nlong lcm(long a, long b) \n{\n    if\
    \ (a == 0 || b == 0)\n        return 0;\n    else\n        return a * b / gcd(a,\
    \ b);\n}\n/*\nReturn the multiplicative inverse of a modulo b.\n    >>> modinv(3L,\
    \ 5L)\n    2L\n    >>> modinv(1101L, 101L)\n    99L\n    >>> modinv(0L, 101L)\n\
    \    0L\n    >>> modinv(3L, 11L)\n    4L\n    >>> modinv(100L, 101L)\n    1L\n\
    */\nlong modinv(long a, long b) \n{\n    long b0 = b, t, q;\n    long x0 = 0,\
    \ x1 = 1;\n    if (b == 1\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_crso88e.d(88): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmp_crso88e.d(100):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_crso88e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n /= 2L;\n        if (n > 0L) \n    \
    \    {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphppp92fn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return n % p * modp(n - 1, p) % p;\n}\n/*\nReturn the number of digits\
    \ of n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n    1\n    >>> ndigits(10L)\n\
    \    2\n    >>> ndigits(12345L)\n    5\n*/\nlong ndigits(long n) \n{\n    if (n\
    \ == 0)\n        return 1;\n    else\n        return cast(long) floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits of n in base b.\n    >>> ndigits(0L,\
    \ 2L)\n    1\n    >>> ndigits(1L, 2L)\n    1\n    >>> ndigits(10L, 2L)\n    4\n\
    \    >>> ndigits(12345L, 2L)\n    13\n*/\nlong ndigits(long n, long b) \n{\n \
    \   if (n == 0)\n        return 1;\n    else\n        return cast(long) floor(log(n)\
    \ / log(b)) + 1;\n}\n/*\nReturn the number of digits of n in base b.\n    >>>\
    \ ndigits(0L, 2L)\n    1\n    >>> ndigits(1L, 2L)\n    1\n    >>> ndigits(10L,\
    \ 2L)\n    4\n    >>> ndigits(12345L, 2L)\n    13\n*/\nlong ndigits(long n, long\
    \ b) \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)\
    \ floor(log(n) / log(b)) + 1;\n}\n/*\nReturn the number of digits of n in base\
    \ b.\n    >>> ndigits(0L, 2L)\n    1\n    >>> ndigits(1\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3_s1hmjc.d(82): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3_s1hmjc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789012345L)\n    15\n\
    */\nlong digits(long n) \n{\n    long d = 1L;\n    while (n >= 10L) \n    {\n\
    \        n = n / 10L;\n        d = d + 1L;\n    }\n    return d;\n}\n/*\nReturn\
    \ the nth digit of n, counting from the right.\n    >>> nthdigit(0L, 0L)\n   \
    \ 0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n    5\n  \
    \  >>> nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n    3\n    >>>\
    \ nthdigit(12345L, 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n    >>> nthdigit(12345L,\
    \ 5L)\n    0\n*/\nlong nthdigit(long n, long i) \n{\n    return n / pow(10L, i)\
    \ % 10L;\n}\n/*\nReturn the nth digit of n, counting from the left.\n    >>> nthdigit(0L,\
    \ 0L)\n    0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n\
    \    1\n    >>> nthdigit(12345L, 1L)\n    2\n    >>> nthdigit(12345L, 2L)\n  \
    \  3\n\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu7c5fv_f.d(78): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpu7c5fv_f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i != 0L) \n    {\n    \
    \    if ((i & 1L) != 0L) \n        {\n            result = (result * power) %\
    \ p;\n        }\n        power = (power * power) % p;\n        i >>= 1L;\n   \
    \ }\n    return result;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(2L)\n    1\n    >>> digits(10L)\n\
    \    2\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n >= 10L)\
    \ \n    {\n        n /= 10L;\n        result += 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(2L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n        n /= 10L;\n\
    \        result += 1L;\n    }\n    return result;\n}\n/*\nReturn the number of\
    \ digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(2L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long result = 1L;\n    while (n >= 10L) \nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj8zo_aok.d(102): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj8zo_aok.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) {\n        r = (r * 2L) % p;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjufgw7sf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n == 1)\n        return n % p;\n    if (n % 2 == 0)\n\
    \        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n        return\
    \ (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvb2hd3ih.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv_4mu_c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long x = modp(n / 2, p);\n        if\
    \ (n % 2 == 0)\n            return (x * x) % p;\n        else\n            return\
    \ (x * x * 2) % p;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(11L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return (long)log10(n) + 1;\n}\n/*\nReturn the nth digit of\
    \ n, where the rightmost digit is 0.\n    >>> nthdigit(0L, 0L)\n    0\n    >>>\
    \ nthdigit(0L, 1L)\n    0\n    >>> nthdigit(12345L, 0L)\n    5\n    >>> nthdigit(12345L,\
    \ 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n    3\n    >>> nthdigit(12345L, 3L)\n\
    \    2\n    >>> nthdigit(12345L, 4L)\n    1\n    >>> nthdigit(12345L, 5L)\n  \
    \  0\n    >>> nthdigit(12345L, 6L)\n    0\n*/\nlong nthdigit(long n, long d) \n\
    {\n    if (d >= numdigits(n))\n        return 0;\n    else\n        return n /\
    \ (long)pow(10, d) % 10;\n}\n/*\nReturn the number of digits in n that are equal\
    \ to d.\n    >>> numdigitsmatch(0L, 0L)\n    1\n    >>> numdigitsmatch(0L, 1L)\n\
    \    0\n    >>> numdigitsmatch(12345L\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpikt650gc.d(50): Error: C style cast illegal, use cast(long)log10(n)\n/tmp/tmpikt650gc.d(78):
    Error: C style cast illegal, use cast(long)pow(10, d)\n/tmp/tmpikt650gc.d(80):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpikt650gc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = 1;\n    while (n > 0) {\n        if (n & 1)\n\
    \            res = (res * n) % p;\n        n >>= 1;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcxlhky7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fpl9kjm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n         \
    \   result = (result * n) % p;\n        }\n        n = n / 2L;\n        n = n\
    \ % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_iooi4s5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n % 2L) == 1L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        n\
    \ = n / 2L;\n        base = (base * base) % p;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9gemrey7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = r * r % p;\n    if (n\
    \ % 2 == 1)\n        r = r * 2 % p;\n    return r;\n}\n/*\nReturn the number of\
    \ elements in the group of order p.\n    >>> p = 101L\n    >>> order(0L, p)\n\
    \    1L\n    >>> order(1L, p)\n    1L\n    >>> order(2L, p)\n    50L\n    >>>\
    \ order(3L, p)\n    33L\n    >>> order(4L, p)\n    25L\n    >>> order(5L, p)\n\
    \    20L\n    >>> order(6L, p)\n    16L\n    >>> order(7L, p)\n    14L\n    >>>\
    \ order(8L, p)\n    12L\n    >>> order(9L, p)\n    11L\n    >>> order(10L, p)\n\
    \    10L\n    >>> order(11L, p)\n    10L\n    >>> order(12L, p)\n    9L\n    >>>\
    \ order(13L, p)\n    9L\n    >>> order(14L, p)\n    9L\n    >>> order(15L, p)\n\
    \    9L\n    >>> order(16L, p)\n    8L\n    >>> order(17L, p)\n    8L\n    >>>\
    \ order(18L, p)\n    8L\n    >>> order(19L, p)\n    8L\n    >>> order(20L, p)\n\
    \    8L\n    >>> order(21L, p)\n    8L\n    >>> order(22L, p)\n    8L\n    >>>\
    \ order(23L, p)\n    8L\n    >>> order(24L, p)\n    8L\n    >>> order(25L, p)\n\
    \    7L\n    >>> order(26L, p)\n    7L\n    >>> order(27L, p)\n    7L\n    >>>\
    \ order(28L, p)\n    7L\n    >>> order(29L, p)\n    7L\n    >>> order\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp62q2lsnm.d(27): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp62q2lsnm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long factor = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L)\
    \ \n        {\n            result = (result * factor) % p;\n        }\n      \
    \  factor = (factor * factor) % p;\n        n /= 2L;\n    }\n    return result;\n\
    }\n/*\nReturn the nth Fibonacci number modulo p (be aware of numerics).\n    >>>\
    \ fibp(0L, 101L)\n    0L\n    >>> fibp(1L, 101L)\n    1L\n    >>> fibp(2L, 101L)\n\
    \    1L\n    >>> fibp(3L, 101L)\n    2L\n    >>> fibp(4L, 101L)\n    3L\n    >>>\
    \ fibp(5L, 101L)\n    5L\n    >>> fibp(6L, 101L)\n    8L\n    >>> fibp(7L, 101L)\n\
    \    13L\n    >>> fibp(8L, 101L)\n    21L\n    >>> fibp(9L, 101L)\n    34L\n \
    \   >>> fibp(10L, 101L)\n    55L\n    >>> fibp(11L, 101L)\n    89L\n    >>> fibp(12L,\
    \ 101L)\n    14L\n    >>> fibp(13L, 101L)\n    23L\n    >>> fibp(14L, 101L)\n\
    \    37L\n    >>> fibp(15L, 101L)\n    60L\n    >>> fibp(16L, 101L)\n    97L\n\
    \    >>> fibp(17L, 101L)\n    31L\n    >>> fibp(18L, 101L)\n    50L\n    >>> fibp(19L,\
    \ 101L)\n    81L\n    >>> fibp(20L, 101L)\n    65L\n    >>> fibp(21L, 101L)\n\
    \    106L\n    >>> fibp(22L, 101L)\n    17L\n    >>> fibp(23L, 101L)\n    28L\n\
    \    >>> fibp(24L, 101L)\n    45\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz7hykl14.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpz7hykl14.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj1mj6cfj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n) +\
    \ 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n) +\
    \ 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789L)\n    9\n*/\nlong numdigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n) +\
    \ 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfnp3mqkc.d(44): Error: C style cast illegal, use cast(long)log10(n)\n/tmp/tmpfnp3mqkc.d(64):
    Error: C style cast illegal, use cast(long)log10(n)\n/tmp/tmpfnp3mqkc.d(84): Error:
    C style cast illegal, use cast(long)log10(n)\n/tmp/tmpfnp3mqkc.d(86): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfnp3mqkc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0L) \n \
    \   {\n        return modp(-n, p);\n    }\n    if (n == 0L) \n    {\n        return\
    \ 1L;\n    }\n    if (n == 1L) \n    {\n        return 2L % p;\n    }\n    if\
    \ (n % 2L == 0L) \n    {\n        return modp(n / 2L, p) * modp(n / 2L, p) % p;\n\
    \    }\n    else \n    {\n        return 2L * modp(n - 1L, p) % p;\n    }\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp38whi234.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\n/*\nReturn the inverse\
    \ of x modulo p.\n    >>> modinv(3L, 5L)\n    2L\n    >>> modinv(2L, 5L)\n   \
    \ 3L\n    >>> modinv(4L, 5L)\n    1L\n    >>> modinv(3L, 11L)\n    4L\n    >>>\
    \ modinv(10L, 17L)\n    13L\n*/\nlong modinv(long x, long p) \n{\n    return modp(x,\
    \ p - 2, p);\n}\n/*\nReturn x^n modulo p (be aware of numerics).\n    >>> modp(3L,\
    \ 5L, 7L)\n    2L\n    >>> modp(1101L, 101L, 1001L)\n    2L\n    >>> modp(0L,\
    \ 101L, 1001L)\n    1L\n    >>> modp(3L, 11L, 101L)\n    8L\n    >>> modp(100L,\
    \ 101L, 1001L)\n    1L\n*/\nlong modp(long x, long n, long p) \n{\n    if (n ==\
    \ 0)\n        return 1;\n    else if (n == 1)\n        return x % p;\n    else\
    \ if (n % 2 == 0)\n        return modp(x * x % p, n / 2, p);\n    else\n     \
    \   return x * modp(x * x % p, n / 2, p) % p;\n}\n/*\nReturn the inverse of x\
    \ modulo p.\n    >>> modinv(3L, 5L)\n    2L\n    >>> modinv(2L, 5L)\n    3L\n\
    \    >>> modinv(4L, 5L)\n    1L\n    >>> modinv(3L\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprbdvs0i1.d(69): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprbdvs0i1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return 0;\n    else\n        return\
    \ (modp(n - 1, p) + modp(n - 2, p)) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqf7ogmsg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpixc7szse.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) {\n        if (n & 1L) {\n            res = (res * n) % p;\n\
    \        }\n        n = n >> 1L;\n        n = (n * n) % p;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_eow7td.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p != 0L) {\n        if ((p & 1L) != 0L) {\n     \
    \       result = (result * x) % n;\n        }\n        x = (x * x) % n;\n    \
    \    p >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjkgeb02z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long result = modp(n\
    \ >> 1, p);\n        result = (result * result) % p;\n        if (n & 1) \n  \
    \      {\n            result = (result * 2) % p;\n        }\n        return result;\n\
    \    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(123456789L)\n\
    \    9\n*/\nlong numdigits(long n) \n{\n    long result = 0;\n    while (n > 0)\
    \ \n    {\n        n = n / 10;\n        result = result + 1;\n    }\n    return\
    \ result;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(11L)\n\
    \    2\n    >>> sumdigits(123456789L)\n    45\n*/\nlong sumdigits(long n) \n{\n\
    \    long result = 0;\n    while (n > 0) \n    {\n        result = result + n\
    \ % 10;\n        n = n / 10;\n    }\n    return result;\n}\n/*\nReturn the sum\
    \ of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n \
    \   1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(11L)\n    2\n    >>> sumdigits(123456789L)\n\
    \    45\n*/\nlong sumdigits(long n) \n{\n    long result = 0;\n    while (n >\
    \ 0) \n    {\n        result = result + n % 10;\n        n = n / 10;\n    }\n\
    \    return result;\n}\n/*\nReturn the sum of the digits in n.\n\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpydnv0z53.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpydnv0z53.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\n/*\nReturn the number of bits in the binary\
    \ representation of n.\n    >>> num_bits(0L)\n    0\n    >>> num_bits(1L)\n  \
    \  1\n    >>> num_bits(2L)\n    2\n    >>> num_bits(3L)\n    2\n    >>> num_bits(4L)\n\
    \    3\n    >>> num_bits(5L)\n    3\n    >>> num_bits(6L)\n    3\n    >>> num_bits(7L)\n\
    \    3\n    >>> num_bits(8L)\n    4\n    >>> num_bits(9L)\n    4\n    >>> num_bits(10L)\n\
    \    4\n    >>> num_bits(11L)\n    4\n    >>> num_bits(12L)\n    4\n    >>> num_bits(13L)\n\
    \    4\n    >>> num_bits(14L)\n    4\n    >>> num_bits(15L)\n    4\n    >>> num_bits(16L)\n\
    \    5\n    >>> num_bits(17L)\n    5\n    >>> num_bits(18L)\n    5\n    >>> num_bits(19L)\n\
    \    5\n    >>> num_bits(20L)\n    5\n    >>> num_bits(21L)\n    5\n    >>> num_bits(22L)\n\
    \    5\n    >>> num_bits(23L)\n    5\n    >>> num_bits(24L)\n    5\n    >>> num_bits(25L)\n\
    \    5\n    >>> num_bits(26L)\n    5\n    >>> num_bits(27L)\n    5\n    >>> num_bits(28L)\n\
    \    5\n    >>> num_bits(29L)\n    5\n    >>> num_bits(30L)\n    5\n    >>> num_bits(\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcug8piki.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpcug8piki.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnsny14kl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1m6r95ho.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fpl9kjm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\n/*\nReturn the number of digits in n.\n  \
    \  >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n   \
    \ 2\n    >>> digits(100L)\n    3\n    >>> digits(1000L)\n    4\n    >>> digits(10000L)\n\
    \    5\n    >>> digits(100000L)\n    6\n    >>> digits(1000000L)\n    7\n    >>>\
    \ digits(10000000L)\n    8\n    >>> digits(100000000L)\n    9\n    >>> digits(1000000000L)\n\
    \    10\n    >>> digits(10000000000L)\n    11\n    >>> digits(100000000000L)\n\
    \    12\n    >>> digits(1000000000000L)\n    13\n    >>> digits(10000000000000L)\n\
    \    14\n    >>> digits(100000000000000L)\n    15\n    >>> digits(1000000000000000L)\n\
    \    16\n    >>> digits(10000000000000000L)\n    17\n    >>> digits(100000000000000000L)\n\
    \    18\n    >>> digits(1000000000000000000L)\n    19\n    >>> digits(10000000000000000000L)\n\
    \    20\n    >>> digits(100000000000000000000L)\n    21\n    >>> digits(1000000000000000000000L)\n\
    \    22\n    >>> digits(10000000000000000000000L)\n    23\n    >>> digits(100000000000000000000000L)\n\
    \    24\n    >>> digits(1000000000000000000000000L)\n    25\n    >>> digits(10000000000000000000000000L)\n\
    \    26\n    >>> digits(100000000000000000000000000L)\n    27\n    >>> digits(1000000000000000000000000000L)\n\
    \    28\n    >>> digits(10000000000000000000000000000L)\n    29\n    >>> digits(100000000000000000000000000000L)\n\
    \    30\n    >>> digits(1000000000000000000000000000000L)\n    31\n    >>> digits(10000000000000000000000000000000L)\n\
    \   \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnhaacpg9.d(31): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnhaacpg9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n\
    \    5\n    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n\
    \    5\n    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n\
    \    5\n    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n\
    \    5\n    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n\
    \    5\n    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n\
    \    6\n    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb1u6q79m.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpb1u6q79m.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n\
    \    >>> digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)floor(log10(n))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n    1\n\
    \    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n   \
    \ else\n        return cast(long)floor(log10(n)) + 1;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(12345L)\n    5\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    if (n == 0)\n        return 1;\n    else\n        return cast(long)floor(log10(n))\
    \ + 1;\n}\n/*\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfcye2ykn.d(94): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfcye2ykn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if\
    \ (n & 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf60q_qq8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else\n    {\n\
    \        long half = modp(n / 2, p);\n        long result = (half * half) % p;\n\
    \        if (n % 2 == 1)\n            result = (result * 2) % p;\n        return\
    \ result;\n    }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789012345L)\n    15\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    if (n == 0)\n        return 1;\n\
    \    else\n        return (long)log10(n) + 1;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789012345L)\n\
    \    15\n    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long\
    \ n) \n{\n    if (n == 0)\n        return 1;\n    else\n        return (long)log10(n)\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n\
    \    5\n    >>> numdigits(123456789012345L)\n    15\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptlkfhtbh.d(52): Error: C style cast illegal, use cast(long)log10(n)\n/tmp/tmptlkfhtbh.d(74):
    Error: C style cast illegal, use cast(long)log10(n)\n/tmp/tmptlkfhtbh.d(92): Error:
    semicolon expected following function declaration\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmptlkfhtbh.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n\
    \    3\n    >>> numdigits(1000L)\n    4\n    >>> numdigits(10000L)\n    5\n  \
    \  >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    long count = 0;\n    while (n > 0)\
    \ \n    {\n        n /= 10;\n        count++;\n    }\n    return count;\n}\n/*\n\
    Return the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n    3\n    >>>\
    \ numdigits(1000L)\n    4\n    >>> numdigits(10000L)\n    5\n    >>> numdigits(123456789L)\n\
    \    9\n    >>> numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long\
    \ n) \n{\n    long count = 0;\n    while (n > 0) \n    {\n        n /= 10;\n \
    \       count++;\n    }\n    return count;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(100L)\n    3\n    >>> numdigits\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyb8wzu9e.d(84): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpyb8wzu9e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i > 0L) {\n        if (i\
    \ % 2L == 1L) {\n            result = (result * power) % p;\n        }\n     \
    \   power = (power * power) % p;\n        i /= 2L;\n    }\n    return result;\n\
    }\n/*\nReturn the Jacobi symbol (a/b) (be aware of numerics).\n    >>> jacobi(1L,\
    \ 1L)\n    1\n    >>> jacobi(2L, 1L)\n    1\n    >>> jacobi(3L, 1L)\n    1\n \
    \   >>> jacobi(4L, 1L)\n    1\n    >>> jacobi(5L, 1L)\n    1\n    >>> jacobi(6L,\
    \ 1L)\n    1\n    >>> jacobi(7L, 1L)\n    1\n    >>> jacobi(8L, 1L)\n    1\n \
    \   >>> jacobi(9L, 1L)\n    1\n    >>> jacobi(10L, 1L)\n    1\n    >>> jacobi(11L,\
    \ 1L)\n    1\n    >>> jacobi(12L, 1L)\n    1\n    >>> jacobi(13L, 1L)\n    1\n\
    \    >>> jacobi(14L, 1L)\n    1\n    >>> jacobi(15L, 1L)\n    1\n    >>> jacobi(16L,\
    \ 1L)\n    1\n    >>> jacobi(17L, 1L)\n    1\n    >>> jacobi(18L, 1L)\n    1\n\
    \    >>> jacobi(19L, 1L)\n    1\n    >>> jacobi(20L, 1L)\n    1\n    >>> jacobi(21L,\
    \ 1L)\n    1\n    >>> jacobi(22L, 1L)\n    1\n    >>> jacobi(23L, 1L)\n    1\n\
    \    >>> jacobi(24L, 1L)\n    1\n    >>> jacobi(25L, 1L)\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbg8h89a8.d(31): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpbg8h89a8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\n/*\nReturn the\
    \ number of digits of n in base b.\n    >>> digits(0L, 10L)\n    1L\n    >>> digits(1L,\
    \ 10L)\n    1L\n    >>> digits(10L, 10L)\n    2L\n    >>> digits(100L, 10L)\n\
    \    3L\n    >>> digits(1000L, 10L)\n    4L\n    >>> digits(123456789L, 10L)\n\
    \    9L\n    >>> digits(123456789L, 2L)\n    31L\n    >>> digits(123456789L, 16L)\n\
    \    8L\n*/\nlong digits(long n, long b) \n{\n    if (n == 0)\n        return\
    \ 1;\n    else\n        return cast(long)floor(log(n) / log(b)) + 1;\n}\n/*\n\
    Return the number of digits of n in base b.\n    >>> digits(0L, 10L)\n    1L\n\
    \    >>> digits(1L, 10L)\n    1L\n    >>> digits(10L, 10L)\n    2L\n    >>> digits(100L,\
    \ 10L)\n    3L\n    >>> digits(1000L, 10L)\n    4L\n    >>> digits(123456789L,\
    \ 10L)\n    9L\n    >>> digits(123456789L, 2L)\n    31L\n    >>> digits(123456789L,\
    \ 16L)\n    8L\n*/\nlong digits(long n, long b) \n{\n    if (n == 0)\n       \
    \ return 1;\n    else\n        return cast(long)floor(log(n) / log(b)) + 1;\n\
    }\n/*\nReturn the number of digits of n in base b.\n   \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx7g6jr9t.d(80): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpx7g6jr9t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1m6r95ho.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(12345)\n   \
    \ 5\n*/\nlong digits(long n) \n{\n    if (n == 0)\n        return 1;\n    else\n\
    \        return (long)log10(n) + 1;\n}\n/*\nReturn the sum of the digits of n.\n\
    \    >>> sum_digits(0)\n    0\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(10)\n\
    \    1\n    >>> sum_digits(12345)\n    15\n*/\nlong sum_digits(long n) \n{\n \
    \   if (n == 0)\n        return 0;\n    else\n        return n % 10 + sum_digits(n\
    \ / 10);\n}\n/*\nReturn the sum of the digits of n.\n    >>> sum_digits(0)\n \
    \   0\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(10)\n    1\n    >>> sum_digits(12345)\n\
    \    15\n*/\nlong sum_digits(long n) \n{\n    if (n == 0)\n        return 0;\n\
    \    else\n        return n % 10 + sum_digits(n / 10);\n}\n/*\nReturn the sum\
    \ of the digits of n.\n    >>> sum_digits(0)\n    0\n    >>> sum_digits(1)\n \
    \   1\n    >>> sum_digits(10)\n    1\n    >>> sum_digits(12345)\n    15\n*/\n\
    long sum_digits(long n) \n{\n    if (n == 0)\n        return 0;\n    else\n  \
    \      return n % 10 + sum_\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn278l0gu.d(42): Error: C style cast illegal, use cast(long)log10(n)\n/tmp/tmpn278l0gu.d(97):
    Error: found \''unittest\'' when expecting \'';\'' following return statement\n/tmp/tmpn278l0gu.d(109):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn278l0gu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       result = (result * a) % p;\n        }\n        a = (a * a) % p;\n    \
    \    n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25jkul_z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long m = modp(n >>\
    \ 1, p);\n        m = m * m % p;\n        if (n & 1) \n        {\n           \
    \ m = m * 2 % p;\n        }\n        return m;\n    }\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n\
    \    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(123456789012345L)\n\
    \    15\n*/\nlong numdigits(long n) \n{\n    long num = 0;\n    while (n > 0)\
    \ \n    {\n        n /= 10;\n        num++;\n    }\n    return num;\n}\n/*\nReturn\
    \ the nth digit of n.\n    >>> nthdigit(12345L, 0)\n    5\n    >>> nthdigit(12345L,\
    \ 1)\n    4\n    >>> nthdigit(12345L, 2)\n    3\n    >>> nthdigit(12345L, 3)\n\
    \    2\n    >>> nthdigit(12345L, 4)\n    1\n    >>> nthdigit(12345L, 5)\n    0\n\
    */\nlong nthdigit(long n, long d) \n{\n    long num = numdigits(n);\n    if (d\
    \ >= num) \n    {\n        return 0;\n    }\n    else \n    {\n        return\
    \ (n / pow(10L, num - d - 1L)) % 10L;\n    }\n}\n/*\nReturn the sum of the digits\
    \ of n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n\
    \    1\n    >>> sumdigits(12345L)\n    15\n    >>> sumdigits(123456789012345L)\n\
    \    45\n*/\nlong sumdigits(long n) \n{\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1_jyu3ew.d(99): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_jyu3ew.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = 1;\n    while (n > 0)\n    {\n        if (n &\
    \ 1)\n            res = (res * n) % p;\n        n = n >> 1;\n        n = (n *\
    \ n) % p;\n    }\n    return res;\n}\n/*\nReturn the number of digits in n.\n\
    \    >>> numdigits(0)\n    1\n    >>> numdigits(1)\n    1\n    >>> numdigits(10)\n\
    \    2\n    >>> numdigits(12345)\n    5\n    >>> numdigits(123456789)\n    9\n\
    */\nlong numdigits(long n) \n{\n    long res = 0;\n    while (n > 0)\n    {\n\
    \        n = n / 10;\n        res++;\n    }\n    return res;\n}\n/*\nReturn the\
    \ nth digit of n.\n    >>> digit(12345, 0)\n    5\n    >>> digit(12345, 1)\n \
    \   4\n    >>> digit(12345, 2)\n    3\n    >>> digit(12345, 3)\n    2\n    >>>\
    \ digit(12345, 4)\n    1\n    >>> digit(12345, 5)\n    0\n*/\nlong digit(long\
    \ n, long i) \n{\n    long res = 0;\n    while (i > 0)\n    {\n        n = n /\
    \ 10;\n        i--;\n    }\n    return n % 10;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0)\n    1\n    >>> numdigits(1)\n    1\n    >>> numdigits(10)\n\
    \    2\n    >>> numdigits(12345)\n    5\n    >>> numdigits(123456789)\n    9\n\
    */\nlong numdigits(long n) \n{\n    long res = 0;\n    while (n > 0)\n    {\n\
    \        n = n / 10;\n        res++;\n    }\n    return res;\n}\n/*\nReturn the\
    \ nth digit of n.\n    >>> digit(12345, 0)\n    5\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwbpo6s7f.d(102): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwbpo6s7f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\n/*\nReturn the number of bits in the binary\
    \ representation of n.\n    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n\
    \    1\n    >>> bit_length(2L)\n    2\n    >>> bit_length(3L)\n    2\n    >>>\
    \ bit_length(4L)\n    3\n    >>> bit_length(5L)\n    3\n    >>> bit_length(6L)\n\
    \    3\n    >>> bit_length(7L)\n    3\n    >>> bit_length(8L)\n    4\n    >>>\
    \ bit_length(9L)\n    4\n    >>> bit_length(10L)\n    4\n    >>> bit_length(11L)\n\
    \    4\n    >>> bit_length(12L)\n    4\n    >>> bit_length(13L)\n    4\n    >>>\
    \ bit_length(14L)\n    4\n    >>> bit_length(15L)\n    4\n    >>> bit_length(16L)\n\
    \    5\n    >>> bit_length(17L)\n    5\n    >>> bit_length(18L)\n    5\n    >>>\
    \ bit_length(19L)\n    5\n    >>> bit_length(20L)\n    5\n    >>> bit_length(21L)\n\
    \    5\n    >>> bit_length(22L)\n    5\n    >>> bit_length(23L)\n    5\n    >>>\
    \ bit_length(24L)\n    5\n    >>> bit_length(25L)\n    5\n    >>> bit_length(26L)\n\
    \    5\n    >>> bit_length(27L)\n    5\n    >>> bit_length(28L)\n    5\n    >>>\
    \ bit_length(29L)\n    5\n    >>> bit_length(30L)\n    5\n    >>> bit_length(\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpliahzdo6.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpliahzdo6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) return\
    \ 1;\n    long k = modp(n / 2, p);\n    if (n % 2 == 0) return (k * k) % p;\n\
    \    else return (k * k * 2) % p;\n}\n/*\nReturn the number of digits in the decimal\
    \ representation of n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n \
    \   >>> digits(10)\n    2\n    >>> digits(10**100)\n    101\n    >>> digits(10**1000)\n\
    \    1001\n    >>> digits(10**10000)\n    10001\n    >>> digits(10**100000)\n\
    \    100001\n    >>> digits(10**1000000)\n    1000001\n    >>> digits(10**10000000)\n\
    \    10000001\n    >>> digits(10**100000000)\n    100000001\n    >>> digits(10**1000000000)\n\
    \    1000000001\n    >>> digits(10**10000000000)\n    10000000001\n    >>> digits(10**100000000000)\n\
    \    100000000001\n    >>> digits(10**1000000000000)\n    1000000000001\n    >>>\
    \ digits(10**10000000000000)\n    10000000000001\n    >>> digits(10**100000000000000)\n\
    \    100000000000001\n    >>> digits(10**1000000000000000)\n    1000000000000001\n\
    \    >>> digits(10**10000000000000000)\n    10000000000000001\n    >>> digits(10**100000000000000000)\n\
    \    100000000000000001\n    >>> digits(10**1000000000000000000)\n    10000000000000000001\n\
    \    >>> digits(10**10000000000000000000)\n    100000000000000000001\n    >>>\
    \ digits(10**100000000000000000000)\n    1000000000000000000001\n    >>> digits(10**1000000000000000000000)\n\
    \    10000000000000000000001\n    >>> digits(10**10000000000000000000000)\n  \
    \  100000000000000000000001\n    >>> digits(10**100000000000000000000000)\n  \
    \  1000000000000000000000001\n    >>> digits(10**1000000000000000000000000)\n\
    \    10000000000000000000000001\n    >>> digits(10**10000000000000000000000000)\n\
    \    100000000000000000000000001\n    >>> digits(10**100000000000000000000000000)\n\
    \    1000000000000000000000000001\n    >>> digits(10**1000000000000000000000000000\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmm_6gs8h.d(24): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmm_6gs8h.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsopqlb39.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            r = (r\
    \ * n) % p;\n        }\n        n = n >> 1L;\n    }\n    return r;\n}\n/*\nReturn\
    \ the number of digits of n in base b.\n    >>> digits(0L, 2L)\n    1L\n    >>>\
    \ digits(1L, 2L)\n    1L\n    >>> digits(2L, 2L)\n    2L\n    >>> digits(3L, 2L)\n\
    \    2L\n    >>> digits(4L, 2L)\n    3L\n    >>> digits(5L, 2L)\n    3L\n    >>>\
    \ digits(6L, 2L)\n    3L\n    >>> digits(7L, 2L)\n    3L\n    >>> digits(8L, 2L)\n\
    \    4L\n    >>> digits(9L, 2L)\n    4L\n    >>> digits(10L, 2L)\n    4L\n   \
    \ >>> digits(11L, 2L)\n    4L\n    >>> digits(12L, 2L)\n    4L\n    >>> digits(13L,\
    \ 2L)\n    4L\n    >>> digits(14L, 2L)\n    4L\n    >>> digits(15L, 2L)\n    4L\n\
    \    >>> digits(16L, 2L)\n    5L\n    >>> digits(17L, 2L)\n    5L\n    >>> digits(18L,\
    \ 2L)\n    5L\n    >>> digits(19L, 2L)\n    5L\n    >>> digits(20L, 2L)\n    5L\n\
    \    >>> digits(21L, 2L)\n    5L\n    >>> digits(22L, 2L)\n    5L\n    >>> digits(23L,\
    \ 2L)\n    5L\n    >>> digits(24L, 2L)\n    5L\n    >>> digits(25L, 2L)\n    5L\n\
    \    >>> digits(26L, 2L)\n    5L\n    >>> digits(27L, 2L)\n    5L\n    >>> digits(28L,\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_tyi01es.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_tyi01es.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    foreach (i; 0 .. n) \n    {\n        result = (result * 2L) % p;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of bits in the binary representation\
    \ of n.\n    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n    1\n    >>>\
    \ bit_length(2L)\n    2\n    >>> bit_length(3L)\n    2\n    >>> bit_length(4L)\n\
    \    3\n    >>> bit_length(5L)\n    3\n    >>> bit_length(6L)\n    3\n    >>>\
    \ bit_length(7L)\n    3\n    >>> bit_length(8L)\n    4\n    >>> bit_length(9L)\n\
    \    4\n    >>> bit_length(10L)\n    4\n    >>> bit_length(11L)\n    4\n    >>>\
    \ bit_length(12L)\n    4\n    >>> bit_length(13L)\n    4\n    >>> bit_length(14L)\n\
    \    4\n    >>> bit_length(15L)\n    4\n    >>> bit_length(16L)\n    5\n    >>>\
    \ bit_length(17L)\n    5\n    >>> bit_length(18L)\n    5\n    >>> bit_length(19L)\n\
    \    5\n    >>> bit_length(20L)\n    5\n    >>> bit_length(21L)\n    5\n    >>>\
    \ bit_length(22L)\n    5\n    >>> bit_length(23L)\n    5\n    >>> bit_length(24L)\n\
    \    5\n    >>> bit_length(25L)\n    5\n    >>> bit_length(26L)\n    5\n    >>>\
    \ bit_length(27L)\n    5\n    >>> bit_length(28L)\n    5\n    >>> bit_length(29L)\n\
    \    5\n    >>> bit_length(30L)\n    5\n    >>> bit_length(31L)\n    5\n    >>>\
    \ bit_length(32L)\n    6\n    >>> bit_length(33L)\n    6\n    >>> bit_length(\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprqkasl92.d(26): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprqkasl92.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long x = n;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n \
    \       {\n            res = (res * x) % p;\n        }\n        x = (x * x) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(12345L)\n    5\n    >>> numdigits(10**100)\n    100\n\
    \    >>> numdigits(10**1000)\n    1000\n*/\nlong numdigits(long n) \n{\n    long\
    \ res = 1L;\n    while (n >= 10L) \n    {\n        n /= 10L;\n        res += 1L;\n\
    \    }\n    return res;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n\
    \    15\n    >>> sumdigits(10**100)\n    1\n    >>> sumdigits(10**1000)\n    1\n\
    */\nlong sumdigits(long n) \n{\n    long res = 0L;\n    while (n > 0L) \n    {\n\
    \        res += n % 10L;\n        n /= 10L;\n    }\n    return res;\n}\n/*\nReturn\
    \ the number of digits of n in base b.\n    >>> numdigits(0L, 2)\n    1\n    >>>\
    \ numdigits(1L, 2)\n    1\n    >>> numdigits(10L, 2)\n    4\n    >>> numdigits(12345L,\
    \ 2)\n    14\n    >>> numdigits(10**100, 2)\n    332\n    >>> numdigits(10**1000,\
    \ 2)\n    3332\n*/\nlong num\nunittest\n{\n    alias candidate = modp;\n\n   \
    \ assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqkq5j_po.d(98): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqkq5j_po.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n != 0L) {\n        if (n % 2L != 0L) {\n            result = (result\
    \ * 2L) % p;\n        }\n        n /= 2L;\n    }\n    return result;\n}\n/*\n\
    Return the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(1234567890123456789L)\n    19\n*/\nlong numdigits(long n) \n{\n  \
    \  long result = 0L;\n    while (n != 0L) {\n        n /= 10L;\n        result\
    \ += 1L;\n    }\n    return result;\n}\n/*\nReturn the nth digit of n.\n    >>>\
    \ nthdigit(0L, 0L)\n    0\n    >>> nthdigit(1L, 0L)\n    1\n    >>> nthdigit(10L,\
    \ 0L)\n    0\n    >>> nthdigit(10L, 1L)\n    1\n    >>> nthdigit(12345L, 0L)\n\
    \    5\n    >>> nthdigit(12345L, 1L)\n    4\n    >>> nthdigit(12345L, 2L)\n  \
    \  3\n    >>> nthdigit(12345L, 3L)\n    2\n    >>> nthdigit(12345L, 4L)\n    1\n\
    \    >>> nthdigit(12345L, 5L)\n    0\n    >>> nthdigit(1234567890123456789L, 0L)\n\
    \    9\n    >>> nthdigit(1234567890123456789L, 1L)\n    8\n    >>> nthdigit(1234567890123456789L,\
    \ 2L)\n    7\n    >>> nthdigit(1234567890123456789L, 3L)\n    6\n    >>> nthdigit(1234567890123456789L,\
    \ 4L)\n    5\n    >>> nthdigit\nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbk2bw3e8.d(50): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpbk2bw3e8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    long i = p - 2L;\n    while (i != 0L) \n    {\n    \
    \    if ((i & 1L) != 0L) \n        {\n            result = (result * power) %\
    \ p;\n        }\n        power = (power * power) % p;\n        i >>= 1L;\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkyvsmz2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n\
    \    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n\
    \    3\n    >>> numdigits(1234567890L)\n    10\n*/\nlong numdigits(long n) \n\
    {\n    long res = 0L;\n    while (n > 0L) \n    {\n        res = res + 1L;\n \
    \       n = n / 10L;\n    }\n    return res;\n}\n/*\nReturn the sum of the digits\
    \ in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n\
    \    1\n    >>> sumdigits(100L)\n    1\n    >>> sumdigits(1234567890L)\n    45\n\
    */\nlong sumdigits(long n) \n{\n    long res = 0L;\n    while (n > 0L) \n    {\n\
    \        res = res + n % 10L;\n        n = n / 10L;\n    }\n    return res;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>>\
    \ numdigits(1L)\n    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n\
    \    3\n    >>> numdigits(1234567890L)\n    10\n*/\nlong numdigits(long n) \n\
    {\n    long res = 0L;\n    while (n > 0L) \n    {\n        res = res + 1L;\n \
    \       n = n / 10L;\n    }\n    return res;\n}\n\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph1vlijk3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4kwgfdft.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\n/*\nReturn the greatest common divisor of a and b.\n\
    \    >>> gcd(14, 15)\n    1\n    >>> gcd(2*3*5*11*17, 3*7*11*13*19)\n    3*11\n\
    */\nlong gcd(long a, long b) \n{\n    if (a < 0L) \n    {\n        a = -a;\n \
    \   }\n    if (b < 0L) \n    {\n        b = -b;\n    }\n    while (a != 0L) \n\
    \    {\n        long c = a;\n        a = b % a;\n        b = c;\n    }\n    return\
    \ b;\n}\n/*\nReturn the least common multiple of a and b.\n    >>> lcm(14, 15)\n\
    \    210\n    >>> lcm(2*3*5*11*17, 3*7*11*13*19)\n    2310\n*/\nlong lcm(long\
    \ a, long b) \n{\n    return (a / gcd(a, b)) * b;\n}\n/*\nReturn the integer square\
    \ root of n.\n    >>> isqrt(0)\n    0\n    >>> isqrt(1)\n    1\n    >>> isqrt(4)\n\
    \    2\n    >>> isqrt(15)\n    3\n    >>> isqrt(16)\n    4\n    >>> isqrt(234)\n\
    \    15\n*/\nlong isqrt(long n) \n{\n    long x = n;\n    long y = (x + 1L) >>\
    \ 1L;\n    while (y < x) \n    {\n        x = y;\n        y = (x + n / x) >> 1L;\n\
    \    }\n    return x;\n}\n/*\nReturn the integer square root of n.\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpws9sbsl_.d(93): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpws9sbsl_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else\n    {\n        long r = modp(n / 2,\
    \ p);\n        r = (r * r) % p;\n        if (n % 2 == 1)\n        {\n        \
    \    r = (r * 2) % p;\n        }\n        return r;\n    }\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu3dlr3dn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) {\n        if (n & 1L) {\n            result = (result * n)\
    \ % p;\n        }\n        n = n >> 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyr0670bk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n /= 2L;\n        if (n > 0L) \n    \
    \    {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\n/*\n\
    Return the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(100L)\n    3\n    >>>\
    \ numdigits(1000L)\n    4\n    >>> numdigits(10000L)\n    5\n    >>> numdigits(100000L)\n\
    \    6\n    >>> numdigits(1000000L)\n    7\n    >>> numdigits(10000000L)\n   \
    \ 8\n    >>> numdigits(100000000L)\n    9\n    >>> numdigits(1000000000L)\n  \
    \  10\n    >>> numdigits(10000000000L)\n    11\n    >>> numdigits(100000000000L)\n\
    \    12\n    >>> numdigits(1000000000000L)\n    13\n    >>> numdigits(10000000000000L)\n\
    \    14\n    >>> numdigits(100000000000000L)\n    15\n    >>> numdigits(1000000000000000L)\n\
    \    16\n    >>> numdigits(10000000000000000L)\n    17\n    >>> numdigits(100000000000000000L)\n\
    \    18\n    >>> numdigits(1000000000000000000L)\n    19\n    >>> numdigits(10000000000000000000L)\n\
    \    20\n    >>> numdigits(100000000000000000000L)\n    21\n    >>> numdigits(1000000000000000000000L)\n\
    \    22\n    >>> numdigits(10000000000000000000000L)\n    23\n    >>> numdigits(100000000000000000000000L)\n\
    \    24\n    >>> numdigits(1000000000000000000000000L)\n    25\n    >>> numdigits(10000000000000000000000000L)\n\
    \    26\n    >>> numdigits(1000000000000000000000000\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpamfvu4tm.d(34): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpamfvu4tm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm3gmq07n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv_4mu_c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else\n    {\n        long r = modp(n >> 1, p);\n       \
    \ r = (r * r) % p;\n        if (n & 1)\n            r = (r * 2) % p;\n       \
    \ return r;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr5uopeci.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0)\n   \
    \ {\n        return modp(-n, p);\n    }\n    if (n == 0)\n    {\n        return\
    \ 1;\n    }\n    if (n == 1)\n    {\n        return n;\n    }\n    if (n % 2 ==\
    \ 0)\n    {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    else\n\
    \    {\n        return modp(n / 2, p) * modp(n / 2, p) * n % p;\n    }\n}\n/*\n\
    Return the number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(12345L)\n    5\n    >>>\
    \ numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n    19\n\
    */\nlong numdigits(long n) \n{\n    if (n == 0)\n    {\n        return 1;\n  \
    \  }\n    else\n    {\n        return (long)log10(n) + 1;\n    }\n}\n/*\nReturn\
    \ the sum of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n\
    \    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n    15\n   \
    \ >>> sumdigits(123456789L)\n    45\n    >>> sumdigits(1234567890123456789L)\n\
    \    135\n*/\nlong sumdigits(long n) \n{\n    if (n == 0)\n    {\n        return\
    \ 0;\n    }\n    else\n    {\n        return n % 10 + sumdigits(n / 10);\n   \
    \ }\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(0L)\n    1\n\
    \    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n   \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppuvlrq73.d(63): Error: C style cast illegal, use cast(long)log10(n)\n/tmp/tmppuvlrq73.d(92):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppuvlrq73.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long res = modp(n >> 1, p);\n    res = (res * res) % p;\n\
    \    if (n & 1)\n        res = (res * 2) % p;\n    return res;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9vuj7ad4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if ((n & 1L) != 0L) {\n     \
    \       res = (res * a) % p;\n        }\n        a = (a * a) % p;\n        n >>=\
    \ 1L;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the Jacobi symbol (a/b) (be aware of numerics).\n\
    \    >>> jacobi(1L, 1L)\n    1\n    >>> jacobi(5L, 1L)\n    1\n    >>> jacobi(1L,\
    \ 5L)\n    1\n    >>> jacobi(5L, 7L)\n    -1\n    >>> jacobi(7L, 5L)\n    1\n\
    \    >>> jacobi(7L, 13L)\n    -1\n    >>> jacobi(13L, 7L)\n    1\n    >>> jacobi(7L,\
    \ 15L)\n    1\n    >>> jacobi(15L, 7L)\n    1\n    >>> jacobi(7L, 21L)\n    -1\n\
    \    >>> jacobi(21L, 7L)\n    1\n    >>> jacobi(7L, 23L)\n    1\n    >>> jacobi(23L,\
    \ 7L)\n    1\n    >>> jacobi(7L, 29L)\n    -1\n    >>> jacobi(29L, 7L)\n    1\n\
    \    >>> jacobi(7L, 31L)\n    1\n    >>> jacobi(31L, 7L)\n    1\n    >>> jacobi(7L,\
    \ 33L)\n    -1\n    >>> jacobi(33L, 7L)\n    1\n    >>> jacobi(7L, 35L)\n    1\n\
    \    >>> jacobi(35L, 7L)\n    1\n    >>> jacobi(7L, 37L)\n    -1\n    >>> jacobi(37L,\
    \ 7L)\n    1\n    >>> jacobi(7L, 39L)\n    1\n    >>> jacobi(39L, 7L)\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_k9xh45o.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_k9xh45o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n /= 2L;\n        if (n > 0L) \n    \
    \    {\n            r = (r * r) % p;\n        }\n    }\n    return r;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphppp92fn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcrrxtgiw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long r = modp(n / 2,\
    \ p);\n        r = (r * r) % p;\n        if (n % 2 == 1) \n        {\n       \
    \     r = (r * 2) % p;\n        }\n        return r;\n    }\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphom7jsoy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) {\n        r = (r * 2L) % p;\n    }\n    return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjufgw7sf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p > 0L) \n    {\n        if (p % 2L == 1L) \n \
    \       {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p /= 2L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(100L)\n    3\n    >>> digits(1000L)\n\
    \    4\n    >>> digits(10000L)\n    5\n    >>> digits(100000L)\n    6\n    >>>\
    \ digits(1000000L)\n    7\n    >>> digits(10000000L)\n    8\n    >>> digits(100000000L)\n\
    \    9\n    >>> digits(1000000000L)\n    10\n    >>> digits(10000000000L)\n  \
    \  11\n    >>> digits(100000000000L)\n    12\n    >>> digits(1000000000000L)\n\
    \    13\n    >>> digits(10000000000000L)\n    14\n    >>> digits(100000000000000L)\n\
    \    15\n    >>> digits(1000000000000000L)\n    16\n    >>> digits(10000000000000000L)\n\
    \    17\n    >>> digits(100000000000000000L)\n    18\n    >>> digits(1000000000000000000L)\n\
    \    19\n    >>> digits(10000000000000000000L)\n    20\n    >>> digits(100000000000000000000L)\n\
    \    21\n    >>> digits(1000000000000000000000L)\n    22\n    >>> digits(10000000000000000000000L)\n\
    \    23\n    >>> digits(100000000000000000000000L)\n    24\n    >>> digits(1000000000000000000000000L)\n\
    \    25\n    >>> digits(10000000000000000000000000L)\n    26\n    >>> digits(100000000000000000000000000L)\n\
    \    27\n    >>> digits(1000000000000000000000000000L)\n    28\n    >>> digits(10000000000000000000000000000L)\n\
    \    29\n    >>> digits(100000000000000000000000000000L)\n    30\n    >>> digits(1000000000000000000000000000000L)\n\
    \    31\n    >>>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgr57s_qz.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpgr57s_qz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) \n    {\n        r = (r * 2L) % p;\n    }\n    return\
    \ r;\n}\n/*\nReturn the number of bits in the binary representation of n.\n  \
    \  >>> bitlen(0L)\n    0\n    >>> bitlen(1L)\n    1\n    >>> bitlen(2L)\n    2\n\
    \    >>> bitlen(3L)\n    2\n    >>> bitlen(4L)\n    3\n    >>> bitlen(5L)\n  \
    \  3\n    >>> bitlen(6L)\n    3\n    >>> bitlen(7L)\n    3\n    >>> bitlen(8L)\n\
    \    4\n    >>> bitlen(9L)\n    4\n    >>> bitlen(10L)\n    4\n    >>> bitlen(11L)\n\
    \    4\n    >>> bitlen(12L)\n    4\n    >>> bitlen(13L)\n    4\n    >>> bitlen(14L)\n\
    \    4\n    >>> bitlen(15L)\n    4\n    >>> bitlen(16L)\n    5\n    >>> bitlen(17L)\n\
    \    5\n    >>> bitlen(18L)\n    5\n    >>> bitlen(19L)\n    5\n    >>> bitlen(20L)\n\
    \    5\n    >>> bitlen(21L)\n    5\n    >>> bitlen(22L)\n    5\n    >>> bitlen(23L)\n\
    \    5\n    >>> bitlen(24L)\n    5\n    >>> bitlen(25L)\n    5\n    >>> bitlen(26L)\n\
    \    5\n    >>> bitlen(27L)\n    5\n    >>> bitlen(28L)\n    5\n    >>> bitlen(29L)\n\
    \    5\n    >>> bitlen(30L)\n    5\n    >>> bitlen(31L)\n    5\n    >>> bitlen(32L)\n\
    \    6\n    >>> bitlen(33L)\n    6\n    >>> bitlen(34L)\n    6\n    >>> bitlen(35L)\n\
    \    6\n    >>> bitlen(36L)\n    6\n    >>> bitlen\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgu6txojk.d(26): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpgu6txojk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv_4mu_c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n         \
    \   result = (result * n) % p;\n        }\n        n = n / 2L;\n        n = n\
    \ % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_iooi4s5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * x) % p;\n        }\n        n = n / 2L;\n\
    \        x = (x * x) % p;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> numdigits(12345)\n    5\n    >>> numdigits(0)\n   \
    \ 1\n    >>> numdigits(-12345)\n    5\n*/\nlong numdigits(long n) \n{\n    if\
    \ (n == 0L) \n    {\n        return 1L;\n    }\n    return (long)floor(log10(abs(n)))\
    \ + 1L;\n}\n/*\nReturn the number of digits in n.\n    >>> numdigits(12345)\n\
    \    5\n    >>> numdigits(0)\n    1\n    >>> numdigits(-12345)\n    5\n*/\nlong\
    \ numdigits(long n) \n{\n    if (n == 0L) \n    {\n        return 1L;\n    }\n\
    \    return (long)floor(log10(abs(n))) + 1L;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(12345)\n    5\n    >>> numdigits(0)\n    1\n    >>>\
    \ numdigits(-12345)\n    5\n*/\nlong numdigits(long n) \n{\n    if (n == 0L) \n\
    \    {\n        return 1L;\n    }\n    return (long)floor(log10(abs(n))) + 1L;\n\
    }\n/*\nReturn the number of digits in n.\n    >>> numdigits(12345)\n    5\n  \
    \  >>> numdigits(0)\n    1\n    >>> numdigits(-12345)\n    5\n*/\nlong numdigits(long\
    \ n) \n{\n    if (n == 0L) \n    {\n        return 1L;\n    }\n    return (long)floor(log10(abs(n)))\
    \ +\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2idcpj3b.d(47): Error: C style cast illegal, use cast(long)floor(log10(abs(n)))\n/tmp/tmp2idcpj3b.d(64):
    Error: C style cast illegal, use cast(long)floor(log10(abs(n)))\n/tmp/tmp2idcpj3b.d(81):
    Error: C style cast illegal, use cast(long)floor(log10(abs(n)))\n/tmp/tmp2idcpj3b.d(98):
    Error: C style cast illegal, use cast(long)floor(log10(abs(n)))\n/tmp/tmp2idcpj3b.d(99):
    Error: expression expected, not \''unittest\''\n/tmp/tmp2idcpj3b.d(100): Error:
    found \''{\'' when expecting \'';\'' following return statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp2idcpj3b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            r = (r * b) % p;\n        }\n        n >>= 1L;\n     \
    \   b = (b * b) % p;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp38t5doyy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n)\n    {\n        r = (r * 2L) % p;\n    }\n    return r;\n\
    }\n/*\nReturn the number of bits in the binary representation of n.\n    >>> num_bits(0L)\n\
    \    0\n    >>> num_bits(1L)\n    1\n    >>> num_bits(2L)\n    2\n    >>> num_bits(3L)\n\
    \    2\n    >>> num_bits(4L)\n    3\n    >>> num_bits(5L)\n    3\n    >>> num_bits(6L)\n\
    \    3\n    >>> num_bits(7L)\n    3\n    >>> num_bits(8L)\n    4\n    >>> num_bits(9L)\n\
    \    4\n    >>> num_bits(10L)\n    4\n    >>> num_bits(11L)\n    4\n    >>> num_bits(12L)\n\
    \    4\n    >>> num_bits(13L)\n    4\n    >>> num_bits(14L)\n    4\n    >>> num_bits(15L)\n\
    \    4\n    >>> num_bits(16L)\n    5\n    >>> num_bits(17L)\n    5\n    >>> num_bits(18L)\n\
    \    5\n    >>> num_bits(19L)\n    5\n    >>> num_bits(20L)\n    5\n    >>> num_bits(21L)\n\
    \    5\n    >>> num_bits(22L)\n    5\n    >>> num_bits(23L)\n    5\n    >>> num_bits(24L)\n\
    \    5\n    >>> num_bits(25L)\n    5\n    >>> num_bits(26L)\n    5\n    >>> num_bits(27L)\n\
    \    5\n    >>> num_bits(28L)\n    5\n    >>> num_bits(29L)\n    5\n    >>> num_bits(30L)\n\
    \    5\n    >>> num_bits(31L)\n    5\n    >>> num_bits(32L)\n    6\n    >>> num_bits(33L)\n\
    \    6\n    >>> num_bits(34\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmqyp9ig3.d(26): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmqyp9ig3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozbaa_v5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if\
    \ (n & 1)\n        r = (r * 2) % p;\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf60q_qq8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = n;\n    while (p > 0L) {\n        if (p % 2L == 1L) {\n        \
    \    result = (result * x) % n;\n        }\n        x = (x * x) % n;\n       \
    \ p = p / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp979u252g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long x = n;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n \
    \       {\n            res = (res * x) % p;\n        }\n        x = (x * x) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the greatest common\
    \ divisor of a and b.\n    >>> gcd(2L, 3L)\n    1L\n    >>> gcd(3L, 3L)\n    3L\n\
    \    >>> gcd(3L, 6L)\n    3L\n    >>> gcd(6L, 3L)\n    3L\n    >>> gcd(3L, 9L)\n\
    \    3L\n    >>> gcd(9L, 3L)\n    3L\n    >>> gcd(3L, 12L)\n    3L\n    >>> gcd(12L,\
    \ 3L)\n    3L\n    >>> gcd(3L, 15L)\n    3L\n    >>> gcd(15L, 3L)\n    3L\n  \
    \  >>> gcd(3L, 18L)\n    3L\n    >>> gcd(18L, 3L)\n    3L\n    >>> gcd(3L, 21L)\n\
    \    3L\n    >>> gcd(21L, 3L)\n    3L\n    >>> gcd(3L, 24L)\n    3L\n    >>> gcd(24L,\
    \ 3L)\n    3L\n    >>> gcd(3L, 27L)\n    3L\n    >>> gcd(27L, 3L)\n    3L\n  \
    \  >>> gcd(3L, 30L)\n    3L\n    >>> gcd(30L, 3L)\n    3L\n    >>> gcd(3L, 33L)\n\
    \    3L\n    >>> gcd(33L, 3L)\n    3L\n    >>> gcd(3L, 36L)\n    3L\n    >>> gcd(36L,\
    \ 3L)\n    3L\n    >>> gcd(3L, 39L)\n    3L\n    >>> gcd\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpottupti9.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpottupti9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fpl9kjm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of bits in the binary representation of n.\n    >>> bits(0L)\n\
    \    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n \
    \   2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n    3\n    >>> bits(6L)\n  \
    \  3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n    4\n    >>> bits(9L)\n   \
    \ 4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n    4\n    >>> bits(12L)\n \
    \   4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n    4\n    >>> bits(15L)\n\
    \    4\n    >>> bits(16L)\n    5\n    >>> bits(17L)\n    5\n    >>> bits(18L)\n\
    \    5\n    >>> bits(19L)\n    5\n    >>> bits(20L)\n    5\n    >>> bits(21L)\n\
    \    5\n    >>> bits(22L)\n    5\n    >>> bits(23L)\n    5\n    >>> bits(24L)\n\
    \    5\n    >>> bits(25L)\n    5\n    >>> bits(26L)\n    5\n    >>> bits(27L)\n\
    \    5\n    >>> bits(28L)\n    5\n    >>> bits(29L)\n    5\n    >>> bits(30L)\n\
    \    5\n    >>> bits(31L)\n    5\n    >>> bits(32L)\n    6\n    >>> bits(33L)\n\
    \    6\n    >>> bits(34L)\n    6\n    >>> bits(35L)\n    6\n    >>> bits(36L)\n\
    \    6\n    >>> bits(37L)\n    6\n    >>> bits(\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1nrg0fn3.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp1nrg0fn3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long b = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * b) % p;\n        }\n        n >>= 1L;\n        b =\
    \ (b * b) % p;\n    }\n    return result;\n}\n/*\nReturn the number of bits in\
    \ the binary representation of n.\n    >>> bitlen(0L)\n    0\n    >>> bitlen(1L)\n\
    \    1\n    >>> bitlen(2L)\n    2\n    >>> bitlen(3L)\n    2\n    >>> bitlen(4L)\n\
    \    3\n    >>> bitlen(5L)\n    3\n    >>> bitlen(6L)\n    3\n    >>> bitlen(7L)\n\
    \    3\n    >>> bitlen(8L)\n    4\n    >>> bitlen(9L)\n    4\n    >>> bitlen(10L)\n\
    \    4\n    >>> bitlen(11L)\n    4\n    >>> bitlen(12L)\n    4\n    >>> bitlen(13L)\n\
    \    4\n    >>> bitlen(14L)\n    4\n    >>> bitlen(15L)\n    4\n    >>> bitlen(16L)\n\
    \    5\n    >>> bitlen(17L)\n    5\n    >>> bitlen(18L)\n    5\n    >>> bitlen(19L)\n\
    \    5\n    >>> bitlen(20L)\n    5\n    >>> bitlen(21L)\n    5\n    >>> bitlen(22L)\n\
    \    5\n    >>> bitlen(23L)\n    5\n    >>> bitlen(24L)\n    5\n    >>> bitlen(25L)\n\
    \    5\n    >>> bitlen(26L)\n    5\n    >>> bitlen(27L)\n    5\n    >>> bitlen(28L)\n\
    \    5\n    >>> bitlen(29L)\n    5\n    >>> bitlen(30L)\n    5\n    >>> bitlen(31L)\n\
    \    5\n    >>> bitlen(32L)\n    6\n    >>> bitlen(33L)\n    6\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbpxhcfbw.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpbpxhcfbw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\n/*\n\
    Return the number of digits in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n\
    \    1\n    >>> ndigits(10L)\n    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(12345678901234567890L)\n\
    \    20\n*/\nlong ndigits(long n) \n{\n    long result = 1L;\n    while (n >=\
    \ 10L) \n    {\n        n /= 10L;\n        result += 1L;\n    }\n    return result;\n\
    }\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>>\
    \ sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n\
    \    15\n    >>> sumdigits(12345678901234567890L)\n    90\n*/\nlong sumdigits(long\
    \ n) \n{\n    long result = 0L;\n    while (n > 0L) \n    {\n        result +=\
    \ n % 10L;\n        n /= 10L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> ndigits(0L)\n    1\n    >>> ndigits(1L)\n    1\n  \
    \  >>> ndigits(10L)\n    2\n    >>> ndigits(12345L)\n    5\n    >>> ndigits(12345678901234567890L)\n\
    \    20\n*/\nlong ndigits(long n) \n{\n    long result = 1L;\n    while (n >=\
    \ 10L) \n    {\n        n /= 10L;\n        result\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp52gj8gpr.d(98): Error: found \''unittest\'' when expecting \'';\''
    following statement\n/tmp/tmp52gj8gpr.d(110): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmp52gj8gpr.d(110): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp52gj8gpr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n    1\n    >>>\
    \ ndigits(10)\n    2\n    >>> ndigits(12345)\n    5\n    >>> ndigits(10**100)\n\
    \    101\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n \
    \   else\n        return cast(long)floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n\
    \    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(12345)\n    5\n    >>> ndigits(10**100)\n\
    \    101\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n \
    \   else\n        return cast(long)floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n\
    \    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(12345)\n    5\n    >>> ndigits(10**100)\n\
    \    101\n*/\nlong ndigits(long n) \n{\n    if (n == 0)\n        return 1;\n \
    \   else\n        return cast(long)floor(log(n) / log(10)) + 1;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> ndigits(0)\n    1\n    >>> ndigits(1)\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi3fpos9_.d(88): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpi3fpos9_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    else\n \
    \       return modp(n / 2, p) * modp(n / 2, p) * n % p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1m6r95ho.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \  {\n        return 1;\n    }\n    else\n    {\n        long r = modp(n / 2,\
    \ p);\n        r = (r * r) % p;\n        if (n % 2 == 1)\n        {\n        \
    \    r = (r * 2) % p;\n        }\n        return r;\n    }\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu3dlr3dn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n != 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            r = (r * b) % p;\n        }\n        n >>= 1L;\n     \
    \   b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the integer square root\
    \ of n, rounded down.\n    >>> isqrt(0)\n    0\n    >>> isqrt(1)\n    1\n    >>>\
    \ isqrt(2)\n    1\n    >>> isqrt(3)\n    1\n    >>> isqrt(4)\n    2\n    >>> isqrt(15)\n\
    \    3\n    >>> isqrt(16)\n    4\n    >>> isqrt(17)\n    4\n    >>> isqrt(2**50\
    \ - 1)\n    22517998136852479L\n    >>> isqrt(2**50)\n    2251799813685248L\n\
    \    >>> isqrt(2**50 + 1)\n    2251799813685248L\n*/\nlong isqrt(long n) \n{\n\
    \    long x = n;\n    long y = (x + 1L) >> 1L;\n    while (y < x) \n    {\n  \
    \      x = y;\n        y = (x + n / x) >> 1L;\n    }\n    return x;\n}\n/*\nReturn\
    \ the integer square root of n, rounded down.\n    >>> isqrt(0)\n    0\n    >>>\
    \ isqrt(1)\n    1\n    >>> isqrt(2)\n    1\n    >>> isqrt(3)\n    1\n    >>> isqrt(4)\n\
    \    2\n    >>> isqrt(15)\n    3\n    >>> isqrt(16)\n    4\n    >>> isqrt(17)\n\
    \    4\n    >>> isqrt(2**50 - 1)\n    22517998136852479L\n    >>> isqrt(2**50)\n\
    \    2251799813685248L\n    >>> isqrt(2**50 + 1\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp23jik6b4.d(68): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp23jik6b4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0)\n    1\n   \
    \ >>> digits(1)\n    1\n    >>> digits(10)\n    2\n    >>> digits(10**100)\n \
    \   101\n    >>> digits(10**1000)\n    1001\n*/\nlong digits(long n) \n{\n   \
    \ if (n == 0)\n        return 1;\n    else\n        return cast(long)floor(log(n)\
    \ / log(10)) + 1;\n}\n/*\nReturn the nth digit of n, counting from the right.\n\
    \    >>> nthdigit(0, 0)\n    0\n    >>> nthdigit(1, 0)\n    1\n    >>> nthdigit(10,\
    \ 0)\n    0\n    >>> nthdigit(10, 1)\n    1\n    >>> nthdigit(12345, 0)\n    5\n\
    \    >>> nthdigit(12345, 1)\n    4\n    >>> nthdigit(12345, 2)\n    3\n    >>>\
    \ nthdigit(12345, 3)\n    2\n    >>> nthdigit(12345, 4)\n    1\n    >>> nthdigit(12345,\
    \ 5)\n    0\n*/\nlong nthdigit(long n, long d) \n{\n    return (n / cast(long)pow(10,\
    \ d)) % 10;\n}\n/*\nReturn the sum of the digits of n.\n    >>> sumdigits(0)\n\
    \    0\n    >>> sumdigits(1)\n    1\n    >>> sumdigits(10)\n    1\n    >>> sumdigits(11)\n\
    \    2\n    >>> sumdigits(12345)\n    15\n*/\nlong sumdigits(long n) \n{\n   \
    \ long sum = 0;\n    foreach (d; 0 .. digits(n))\n        sum += n\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpquyy_9eu.d(91): Error: found \''unittest\'' when expecting \'';\''
    following statement\n/tmp/tmpquyy_9eu.d(103): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpquyy_9eu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) \n    {\n        if (n % 2L == 1L) \n        {\n          \
    \  r = (r * 2L) % p;\n        }\n        n = n / 2L;\n    }\n    return r;\n}\n\
    /*\nReturn the number of 1 bits in n.\n    >>> bitcount(0L)\n    0\n    >>> bitcount(1L)\n\
    \    1\n    >>> bitcount(2L)\n    1\n    >>> bitcount(3L)\n    2\n    >>> bitcount(4L)\n\
    \    1\n    >>> bitcount(5L)\n    2\n    >>> bitcount(6L)\n    2\n    >>> bitcount(7L)\n\
    \    3\n    >>> bitcount(8L)\n    1\n    >>> bitcount(9L)\n    2\n    >>> bitcount(10L)\n\
    \    2\n    >>> bitcount(11L)\n    3\n    >>> bitcount(12L)\n    2\n    >>> bitcount(13L)\n\
    \    3\n    >>> bitcount(14L)\n    3\n    >>> bitcount(15L)\n    4\n    >>> bitcount(16L)\n\
    \    1\n    >>> bitcount(17L)\n    2\n    >>> bitcount(18L)\n    2\n    >>> bitcount(19L)\n\
    \    3\n    >>> bitcount(20L)\n    2\n    >>> bitcount(21L)\n    3\n    >>> bitcount(22L)\n\
    \    3\n    >>> bitcount(23L)\n    4\n    >>> bitcount(24L)\n    2\n    >>> bitcount(25L)\n\
    \    3\n    >>> bitcount(26L)\n    3\n    >>> bitcount(27L)\n    4\n    >>> bitcount(28L)\n\
    \    3\n    >>> bitcount(29L)\n    4\n    >>> bitcount(30L)\n    4\n    >>> bitcount(31L)\n\
    \    5\n    >>> bitcount(32L)\n    1\n    >>> bitcount(33L)\n    2\n    >>> bitcount(34L)\n\
    \    2\n    >>> bitcount(\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc3ynla9b.d(30): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpc3ynla9b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) {\n        if (n & 1L) {\n            r = (r * 2L) % p;\n \
    \       }\n        n >>= 1L;\n    }\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw25b8e6_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) {\n        if (n & 1L) {\n            r = (r * 2L) % p;\n \
    \       }\n        n >>= 1L;\n    }\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw25b8e6_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n  \
    \  >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(10**100)\n\
    \    101\n    >>> ndigits(10**1000)\n    1001\n*/\nlong ndigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    return cast(long) floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n\
    \    >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(10**100)\n\
    \    101\n    >>> ndigits(10**1000)\n    1001\n*/\nlong ndigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    return cast(long) floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n\
    \    >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n    >>> ndigits(10**100)\n\
    \    101\n    >>> ndigits(10**1000)\n    1001\n*/\nlong ndigits(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    return cast(long) floor(log(n) / log(10))\
    \ + 1;\n}\n/*\nReturn the number of digits in n.\n    >>> ndigits(0)\n    1\n\
    \    >>> ndigits(1)\n    1\n    >>> ndigits(10)\n    2\n    >>> ndig\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppsggbt7v.d(83): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmppsggbt7v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long power = n;\n    while (p > 0L) \n    {\n        if (p & 1L) \n     \
    \   {\n            result = (result * power) % n;\n        }\n        power =\
    \ (power * power) % n;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp34c6n419.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427df5]\n??:? void tmp34c6n419.__unittest_L32_C1() [0x427a7d]\n??:?
    void tmp34c6n419.__modtest() [0x427b78]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42facd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a985]\n??:? runModuleUnitTests [0x42b8f1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281cb]\n??:? _d_run_main [0x428136]\n??:? main [0x427b8b]\n??:?
    __libc_start_main [0x6fde9554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv_4mu_c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * x) % p;\n        }\n        n = n >> 1L;\n       \
    \ x = (x * x) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ouarp2f.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) {\n        if (n % 2L == 1L) {\n            result = (result\
    \ * n) % p;\n        }\n        n = n / 2L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmfuzk1ju.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n   \
    \     {\n            r = (r * b) % p;\n        }\n        n = n / 2L;\n      \
    \  b = (b * b) % p;\n    }\n    return r;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(100L)\n    3\n    >>> numdigits(1000L)\n    4\n    >>>\
    \ numdigits(10000L)\n    5\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n*/\nlong numdigits(long n) \n{\n    long ndigits = 1L;\n    while (n\
    \ >= 10L) \n    {\n        n = n / 10L;\n        ndigits = ndigits + 1L;\n   \
    \ }\n    return ndigits;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(100L)\n\
    \    1\n    >>> sumdigits(1000L)\n    1\n    >>> sumdigits(10000L)\n    1\n  \
    \  >>> sumdigits(123456789L)\n    45\n    >>> sumdigits(1234567890123456789L)\n\
    \    90\n*/\nlong sumdigits(long n) \n{\n    long s = 0L;\n    while (n > 0L)\
    \ \n    {\n        s = s + n % 10L;\n        n = n / 10L;\n    }\n    return s;\n\
    }\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n    0\n    >>>\
    \ sumdig\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmxytr4oa.d(90): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmxytr4oa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozbaa_v5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n / 2, p);\n    r = (r * r) % p;\n    if (n\
    \ % 2 == 1)\n        r = (r * 2) % p;\n    return r;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0)\n    1\n    >>> digits(1)\n    1\n    >>>\
    \ digits(10)\n    2\n    >>> digits(12345)\n    5\n    >>> digits(123456789)\n\
    \    9\n    >>> digits(1234567890123456789)\n    19\n*/\nlong digits(long n) \n\
    {\n    long d = 1;\n    while (n >= 10) \n    {\n        n /= 10;\n        d +=\
    \ 1;\n    }\n    return d;\n}\n/*\nReturn the sum of the digits in n.\n    >>>\
    \ digit_sum(0)\n    0\n    >>> digit_sum(1)\n    1\n    >>> digit_sum(10)\n  \
    \  1\n    >>> digit_sum(12345)\n    15\n    >>> digit_sum(123456789)\n    45\n\
    \    >>> digit_sum(1234567890123456789)\n    135\n*/\nlong digit_sum(long n) \n\
    {\n    long s = 0;\n    while (n > 0) \n    {\n        s += n % 10;\n        n\
    \ /= 10;\n    }\n    return s;\n}\n/*\nReturn the sum of the digits in n.\n  \
    \  >>> digit_sum(0)\n    0\n    >>> digit_sum(1)\n    1\n    >>> digit_sum(10)\n\
    \    1\n    >>> digit_sum(12345)\n    15\n    >>> digit_sum(123456789)\n    45\n\
    \    >>> digit_sum(1234567890123456789)\n    135\n*/\nlong digit_sum(long n) \n\
    {\n    long s = 0;\n    while (n > 0) \n    {\n        s += n % 10;\n        n\
    \ /= 10;\n    }\n    return s\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsxfhgrx0.d(101): Error: found \''unittest\'' when expecting
    \'';\'' following return statement\n/tmp/tmpsxfhgrx0.d(113): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpsxfhgrx0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            res\
    \ = (res * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) % p;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsopqlb39.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(12345L)\n\
    \    5\n    >>> digits(1234567890123456789L)\n    19\n*/\nlong digits(long n)\
    \ \n{\n    long d = 1L;\n    while (n >= 10L) {\n        n = n / 10L;\n      \
    \  d = d + 1L;\n    }\n    return d;\n}\n/*\nReturn the nth digit of n (0-based).\n\
    \    >>> nthdigit(0L, 0L)\n    0\n    >>> nthdigit(0L, 1L)\n    0\n    >>> nthdigit(1L,\
    \ 0L)\n    1\n    >>> nthdigit(12345L, 0L)\n    5\n    >>> nthdigit(12345L, 1L)\n\
    \    4\n    >>> nthdigit(12345L, 2L)\n    3\n    >>> nthdigit(12345L, 3L)\n  \
    \  2\n    >>> nthdigit(12345L, 4L)\n    1\n    >>> nthdigit(12345L, 5L)\n    0\n\
    \    >>> nthdigit(12345L, 6L)\n    0\n*/\nlong nthdigit(long n, long d) \n{\n\
    \    long p = pow(10L, d);\n    return (n / p) % 10L;\n}\n/*\nReturn the sum of\
    \ the digits of n.\n    >>> sumdigits(0L)\n    0\n    >>> sumdigits(1L)\n    1\n\
    \    >>> sumdigits(10L)\n    1\n    >>> sumdigits(12345L)\n    15\n   \nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmtgzul9m.d(80): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmtgzul9m.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   foreach (i; 0 .. n) \n    {\n        r = (r * 2L) % p;\n    }\n    return\
    \ r;\n}\n/*\nReturn the nth Fibonacci number modulo p (be aware of numerics).\n\
    \    >>> fibp(0L, 101L)\n    0L\n    >>> fibp(1L, 101L)\n    1L\n    >>> fibp(2L,\
    \ 101L)\n    1L\n    >>> fibp(3L, 101L)\n    2L\n    >>> fibp(4L, 101L)\n    3L\n\
    \    >>> fibp(5L, 101L)\n    5L\n    >>> fibp(6L, 101L)\n    8L\n    >>> fibp(7L,\
    \ 101L)\n    13L\n    >>> fibp(8L, 101L)\n    21L\n    >>> fibp(9L, 101L)\n  \
    \  34L\n    >>> fibp(10L, 101L)\n    55L\n    >>> fibp(11L, 101L)\n    89L\n \
    \   >>> fibp(12L, 101L)\n    14L\n    >>> fibp(13L, 101L)\n    23L\n    >>> fibp(14L,\
    \ 101L)\n    37L\n    >>> fibp(15L, 101L)\n    60L\n    >>> fibp(16L, 101L)\n\
    \    97L\n    >>> fibp(17L, 101L)\n    31L\n    >>> fibp(18L, 101L)\n    50L\n\
    \    >>> fibp(19L, 101L)\n    81L\n    >>> fibp(20L, 101L)\n    13L\n    >>> fibp(21L,\
    \ 101L)\n    44L\n    >>> fibp(22L, 101L)\n    71L\n    >>> fibp(23L, 101L)\n\
    \    11L\n    >>> fibp(24L, 101L)\n    52L\n    >>> fibp(25L, 101L)\n    83L\n\
    \    >>> fibp(26L, 101L)\n    28L\n    >>> fibp(27L, 101L\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpchxv3xwi.d(26): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpchxv3xwi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    long r = modp(n >> 1, p);\n    r = (r * r) % p;\n    if\
    \ (n & 1)\n        r = (r * 2) % p;\n    return r;\n}\n/*\nReturn the number of\
    \ bits needed to represent n.\n    >>> bits(0L)\n    0\n    >>> bits(1L)\n   \
    \ 1\n    >>> bits(2L)\n    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n    3\n\
    \    >>> bits(5L)\n    3\n    >>> bits(6L)\n    3\n    >>> bits(7L)\n    3\n \
    \   >>> bits(8L)\n    4\n    >>> bits(9L)\n    4\n    >>> bits(10L)\n    4\n \
    \   >>> bits(11L)\n    4\n    >>> bits(12L)\n    4\n    >>> bits(13L)\n    4\n\
    \    >>> bits(14L)\n    4\n    >>> bits(15L)\n    4\n    >>> bits(16L)\n    5\n\
    \    >>> bits(17L)\n    5\n    >>> bits(18L)\n    5\n    >>> bits(19L)\n    5\n\
    \    >>> bits(20L)\n    5\n    >>> bits(21L)\n    5\n    >>> bits(22L)\n    5\n\
    \    >>> bits(23L)\n    5\n    >>> bits(24L)\n    5\n    >>> bits(25L)\n    5\n\
    \    >>> bits(26L)\n    5\n    >>> bits(27L)\n    5\n    >>> bits(28L)\n    5\n\
    \    >>> bits(29L)\n    5\n    >>> bits(30L)\n    5\n    >>> bits(31L)\n    5\n\
    \    >>> bits(32L)\n    6\n    >>> bits(33L)\n    6\n    >>> bits(34L)\n    6\n\
    \    >>> bits(35L)\n    6\n    >>> bits(36L)\n    6\n    >>> bits(37L)\n    6\n\
    \    >>> bits(38L)\n    6\n   \nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphi5cvzsf.d(27): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmphi5cvzsf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    if (n == 1)\n        return n % p;\n    if (n % 2 == 0)\n\
    \        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n        return\
    \ (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvb2hd3ih.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            result = (result * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        n >>= 1L;\n    }\n    return result;\n}\n/*\nReturn the nth\
    \ Lucas number.\n    >>> lucas(0L)\n    2L\n    >>> lucas(1L)\n    1L\n    >>>\
    \ lucas(2L)\n    3L\n    >>> lucas(3L)\n    4L\n    >>> lucas(4L)\n    7L\n  \
    \  >>> lucas(5L)\n    11L\n    >>> lucas(6L)\n    18L\n    >>> lucas(7L)\n   \
    \ 29L\n    >>> lucas(8L)\n    47L\n    >>> lucas(9L)\n    76L\n    >>> lucas(10L)\n\
    \    123L\n    >>> lucas(11L)\n    199L\n    >>> lucas(12L)\n    322L\n    >>>\
    \ lucas(13L)\n    521L\n    >>> lucas(14L)\n    843L\n    >>> lucas(15L)\n   \
    \ 1364L\n    >>> lucas(16L)\n    2207L\n    >>> lucas(17L)\n    3571L\n    >>>\
    \ lucas(18L)\n    5778L\n    >>> lucas(19L)\n    9349L\n    >>> lucas(20L)\n \
    \   15127L\n    >>> lucas(21L)\n    24476L\n    >>> lucas(22L)\n    39603L\n \
    \   >>> lucas(23L)\n    64079L\n    >>> lucas(24L)\n    103682L\n    >>> lucas(25L)\n\
    \    167761L\n    >>> lucas(26L)\n    271443L\n    >>> lucas(27L)\n    439204L\n\
    \    >>> lucas(28L)\n    710647L\n    >>> lucas(29L)\n   \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo5gatrx3.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpo5gatrx3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n == 1)\n        return n % p;\n    else if (n\
    \ % 2 == 0)\n        return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\n\
    \        return (modp(n / 2, p) * modp(n / 2, p) * n) % p;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjy8poe9r.d(33): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e6d]\n??:? void tmpjy8poe9r.__unittest_L28_C1() [0x427b17]\n??:?
    void tmpjy8poe9r.__modtest() [0x427bec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9fd]\n??:? runModuleUnitTests [0x42b969]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428243]\n??:? _d_run_main [0x4281ae]\n??:? main [0x427bff]\n??:?
    __libc_start_main [0x2364a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozbaa_v5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 1;\n    else if (n % 2 == 0)\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    else\n        return modp(n / 2, p) * modp(n / 2, p) * 2 %\
    \ p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv_4mu_c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800149
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) \n \
    \   {\n        return 1;\n    }\n    else \n    {\n        long r = modp(n >>\
    \ 1, p);\n        r = (r * r) % p;\n        if (n & 1) \n        {\n         \
    \   r = (r * 2) % p;\n        }\n        return r;\n    }\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbcj1u4gy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    foreach (i; 0 .. n) \n    {\n        result = (result * 2L) % p;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of bits in the binary representation\
    \ of n.\n    >>> bits(0L)\n    0\n    >>> bits(1L)\n    1\n    >>> bits(2L)\n\
    \    2\n    >>> bits(3L)\n    2\n    >>> bits(4L)\n    3\n    >>> bits(5L)\n \
    \   3\n    >>> bits(6L)\n    3\n    >>> bits(7L)\n    3\n    >>> bits(8L)\n  \
    \  4\n    >>> bits(9L)\n    4\n    >>> bits(10L)\n    4\n    >>> bits(11L)\n \
    \   4\n    >>> bits(12L)\n    4\n    >>> bits(13L)\n    4\n    >>> bits(14L)\n\
    \    4\n    >>> bits(15L)\n    4\n    >>> bits(16L)\n    5\n    >>> bits(123456789L)\n\
    \    31\n*/\nlong bits(long n) \n{\n    long result = 0L;\n    foreach (i; 0 ..\
    \ n) \n    {\n        result = result + 1L;\n    }\n    return result;\n}\n/*\n\
    Return the parity of n.\n    >>> parity(0L)\n    0\n    >>> parity(1L)\n    1\n\
    \    >>> parity(2L)\n    1\n    >>> parity(3L)\n    0\n    >>> parity(4L)\n  \
    \  1\n    >>> parity(5L)\n    0\n    >>> parity(6L)\n    0\n    >>> parity(7L)\n\
    \    1\n    >>> parity(8L)\n    1\n    >>> parity(9L)\n    0\n    >>> parity(10L)\n\
    \    0\n    >>> parity(11L)\n    1\n    >>> parity(12L)\n    0\n    >>> parity(13L)\n\
    \    1\n    >>> parity(14L)\n    1\n    >>> parity(15L)\n    0\n    >>> parity(16L)\n\
    \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfsgbe6p0.d(74): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfsgbe6p0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow = n;\n    while (p > 0L) \n    {\n        if ((p & 1L) != 0L) \n\
    \        {\n            result = (result * pow) % p;\n        }\n        pow =\
    \ (pow * pow) % p;\n        p >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe58va07m.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number of digits\
    \ in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n    1\n    >>> numdigits(10L)\n\
    \    2\n    >>> numdigits(123456789L)\n    9\n    >>> numdigits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong numdigits(long n) \n{\n    long result = 1L;\n    while\
    \ (n >= 10L) {\n        n = n / 10L;\n        result = result + 1L;\n    }\n \
    \   return result;\n}\n/*\nReturn the sum of the digits in n.\n    >>> sumdigits(0L)\n\
    \    0\n    >>> sumdigits(1L)\n    1\n    >>> sumdigits(10L)\n    1\n    >>> sumdigits(123456789L)\n\
    \    45\n    >>> sumdigits(1234567890123456789L)\n    90\n    \n*/\nlong sumdigits(long\
    \ n) \n{\n    long result = 0L;\n    while (n > 0L) {\n        result = result\
    \ + n % 10L;\n        n = n / 10L;\n    }\n    return result;\n}\n/*\nReturn the\
    \ number of digits in n.\n    >>> numdigits(0L)\n    1\n    >>> numdigits(1L)\n\
    \    1\n    >>> numdigits(10L)\n    2\n    >>> numdigits(123456789L)\n    9\n\
    \    >>> numdigits(1234567890123456789L)\n    19\n    \n*/\nlong numdigits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) {\n        n\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkmf36ivg.d(95): Error: found \''unittest\'' when expecting \'';\''
    following statement\n/tmp/tmpkmf36ivg.d(107): Error: found \''EOF\'' when expecting
    \''}\'' following compound statement\n/tmp/tmpkmf36ivg.d(107): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkmf36ivg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if (n % 2L == 1L) \n  \
    \      {\n            result = (result * a) % p;\n        }\n        a = (a *\
    \ a) % p;\n        n = n / 2L;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n    1\n    >>>\
    \ digits(10L)\n    2\n    >>> digits(123456789L)\n    9\n    >>> digits(1234567890123456789L)\n\
    \    19\n    \n*/\nlong digits(long n) \n{\n    long result = 1L;\n    while (n\
    \ >= 10L) \n    {\n        n = n / 10L;\n        result = result + 1L;\n    }\n\
    \    return result;\n}\n/*\nReturn the number of digits in n.\n    >>> digits(0L)\n\
    \    1\n    >>> digits(1L)\n    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n\
    \    9\n    >>> digits(1234567890123456789L)\n    19\n    \n*/\nlong digits(long\
    \ n) \n{\n    long result = 1L;\n    while (n >= 10L) \n    {\n        n = n /\
    \ 10L;\n        result = result + 1L;\n    }\n    return result;\n}\n/*\nReturn\
    \ the number of digits in n.\n    >>> digits(0L)\n    1\n    >>> digits(1L)\n\
    \    1\n    >>> digits(10L)\n    2\n    >>> digits(123456789L)\n    9\n    >>>\
    \ digits(1234567890123456789L)\n    19\n    \n*/\nlong digits(long n) \n{\n  \
    \  long result = 1L;\n    while (n >= 10L) \n    {\n        n = n / 10L;\n   \
    \     result = result + 1L;\n    }\n    return result;\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5v5jbeh0.d(104): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5v5jbeh0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (n > 0L) \n    {\n        if (n & 1L) \n        {\n            result\
    \ = (result * n) % p;\n        }\n        n = n >> 1L;\n        n = (n * n) %\
    \ p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpixc7szse.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long pow2 = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n    \
    \        result = (result * pow2) % p;\n        }\n        pow2 = (pow2 * pow2)\
    \ % p;\n        n /= 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgn4y858l.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   while (n > 0L) {\n        if (n & 1L) {\n            r = (r * 2L) % p;\n \
    \       }\n        n >>= 1L;\n    }\n    return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw25b8e6_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n       \
    \     result = (result * a) % p;\n        }\n        a = (a * a) % p;\n      \
    \  n = n / 2L;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph10i3_ou.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long base = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L)\
    \ \n        {\n            result = (result * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        n >>= 1L;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    long a = 2L;\n    while (n > 0L) \n    {\n        if ((n & 1L) != 0L) \n\
    \        {\n            res = (res * a) % p;\n        }\n        a = (a * a) %\
    \ p;\n        n >>= 1L;\n    }\n    return res;\n}\n/*\nReturn the number of bits\
    \ in the binary representation of n.\n    >>> bit_length(0L)\n    0\n    >>> bit_length(1L)\n\
    \    1\n    >>> bit_length(2L)\n    2\n    >>> bit_length(3L)\n    2\n    >>>\
    \ bit_length(4L)\n    3\n    >>> bit_length(5L)\n    3\n    >>> bit_length(6L)\n\
    \    3\n    >>> bit_length(7L)\n    3\n    >>> bit_length(8L)\n    4\n    >>>\
    \ bit_length(9L)\n    4\n    >>> bit_length(10L)\n    4\n    >>> bit_length(11L)\n\
    \    4\n    >>> bit_length(12L)\n    4\n    >>> bit_length(13L)\n    4\n    >>>\
    \ bit_length(14L)\n    4\n    >>> bit_length(15L)\n    4\n    >>> bit_length(16L)\n\
    \    5\n    >>> bit_length(17L)\n    5\n    >>> bit_length(18L)\n    5\n    >>>\
    \ bit_length(19L)\n    5\n    >>> bit_length(20L)\n    5\n    >>> bit_length(21L)\n\
    \    5\n    >>> bit_length(22L)\n    5\n    >>> bit_length(23L)\n    5\n    >>>\
    \ bit_length(24L)\n    5\n    >>> bit_length(25L)\n    5\n    >>> bit_length(26L)\n\
    \    5\n    >>> bit_length(27L)\n    5\n    >>> bit_length(28L)\n    5\n    >>>\
    \ bit_length(29L)\n    5\n    >>> bit_length(30L)\n    5\n\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1iurrn_g.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp1iurrn_g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   long b = 2L;\n    while (n > 0L) {\n        if (n % 2L == 1L) {\n        \
    \    r = (r * b) % p;\n        }\n        n = n / 2L;\n        b = (b * b) % p;\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozbaa_v5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    long x = 2L;\n    while (n != 0L) {\n        if ((n & 1L) != 0L) {\n    \
    \        result = (result * x) % p;\n        }\n        n >>= 1L;\n        x =\
    \ (x * x) % p;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3b5sfypm.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659800150
