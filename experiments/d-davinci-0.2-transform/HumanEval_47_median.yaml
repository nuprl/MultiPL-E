name: HumanEval_47_median
language: d
prompt: "import std.math;\n/*\nReturn median of elements in the list l.\n    >>> median([3L,\
  \ 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n  \
  \  15.0\n    \n*/\nfloat median(long[] l) \n"
tests: "unittest\n{\n    alias candidate = median;\n\n    assert(candidate([3L, 1L,\
  \ 2L, 4L, 5L]) == 3L);\n    assert(candidate([-10L, 4L, 6L, 1000L, 10L, 20L]) ==\
  \ 8.0);\n    assert(candidate([5L]) == 5L);\n    assert(candidate([6L, 5L]) == 5.5);\n\
  \    assert(candidate([8L, 1L, 3L, 9L, 9L, 2L, 7L]) == 7L);\n}\nvoid main(){}"
completions: ["{\n    long[] sorted = l.dup;\n    sorted.sort;\n    if (sorted.length\
    \ % 2 == 1)\n        return sorted[sorted.length / 2];\n    else\n        return\
    \ (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2.0;\n}", "{\n\
    \    long[] temp = l.dup;\n    temp.sort;\n    int len = temp.length;\n    if\
    \ (len % 2 == 0)\n    {\n        return (temp[len / 2] + temp[len / 2 - 1]) /\
    \ 2.0;\n    }\n    else\n    {\n        return temp[len / 2];\n    }\n}", "{\n\
    \    long[] sorted = l.dup;\n    sorted.sort;\n    if (sorted.length % 2 == 1)\n\
    \        return sorted[sorted.length / 2];\n    else\n        return (sorted[sorted.length\
    \ / 2 - 1] + sorted[sorted.length / 2]) / 2.0;\n}", "{\n    long[] sorted = l.dup;\n\
    \    sorted.sort;\n    if (sorted.length % 2 == 1) \n    {\n        return sorted[sorted.length\
    \ / 2];\n    } \n    else \n    {\n        return (sorted[sorted.length / 2 -\
    \ 1] + sorted[sorted.length / 2]) / 2.0;\n    }\n}", "{\n    long[] temp = l.dup;\n\
    \    temp.sort;\n    int len = temp.length;\n    if (len % 2 == 0) \n    {\n \
    \       return (temp[len / 2 - 1] + temp[len / 2]) / 2.0;\n    } \n    else \n\
    \    {\n        return temp[len / 2];\n    }\n}", "{\n    int n = l.length;\n\
    \    if (n == 0) \n    {\n        return 0.0;\n    }\n    else if (n == 1) \n\
    \    {\n        return l[0];\n    }\n    else if (n == 2) \n    {\n        return\
    \ (l[0] + l[1]) / 2.0;\n    }\n    else \n    {\n        long[] l2 = l[0..n];\n\
    \        sort(l2);\n        if (n % 2 == 0) \n        {\n            return (l2[n\
    \ / 2 - 1] + l2[n / 2]) / 2.0;\n        }\n        else \n        {\n        \
    \    return l2[n / 2];\n        }\n    }\n}", "{\n    long[] sorted = l.sort();\n\
    \    int mid = sorted.length / 2;\n    if (sorted.length % 2 == 0)\n    {\n  \
    \      return (sorted[mid] + sorted[mid - 1]) / 2.0;\n    }\n    else\n    {\n\
    \        return sorted[mid];\n    }\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n\
    \    int len = sorted.length;\n    if (len % 2 == 0) \n    {\n        return (sorted[len\
    \ / 2 - 1] + sorted[len / 2]) / 2.0;\n    }\n    else \n    {\n        return\
    \ sorted[len / 2];\n    }\n}", "{\n    l.sort();\n    int n = l.length;\n    if\
    \ (n % 2 == 1)\n        return l[n / 2];\n    else\n        return (l[n / 2 -\
    \ 1] + l[n / 2]) / 2.0;\n}", "{\n    long[] sorted = l.dup.sort;\n    int mid\
    \ = sorted.length / 2;\n    if (sorted.length % 2 == 0)\n        return (sorted[mid\
    \ - 1] + sorted[mid]) / 2.0;\n    else\n        return sorted[mid];\n}", "{\n\
    \    int n = l.length;\n    if (n == 0) \n    {\n        return 0.0;\n    }\n\
    \    if (n == 1) \n    {\n        return l[0];\n    }\n    sort(l);\n    if (n\
    \ % 2 == 0) \n    {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0;\n    }\n\
    \    else \n    {\n        return l[n / 2];\n    }\n}", "{\n    long[] sorted\
    \ = l.dup;\n    sorted.sort;\n    if (sorted.length % 2 == 1) \n    {\n      \
    \  return sorted[sorted.length / 2];\n    }\n    else \n    {\n        return\
    \ (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2.0;\n    }\n}",
  "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    int n = sorted.length;\n \
    \   if (n % 2 == 1)\n        return sorted[n / 2];\n    else\n        return (sorted[n\
    \ / 2 - 1] + sorted[n / 2]) / 2.0;\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n\
    \    if (sorted.length % 2 == 1)\n    {\n        return sorted[sorted.length /\
    \ 2];\n    }\n    else\n    {\n        return (sorted[sorted.length / 2 - 1] +\
    \ sorted[sorted.length / 2]) / 2.0;\n    }\n}", "{\n    long[] sorted = l.dup;\n\
    \    sorted.sort;\n    if (sorted.length % 2 == 1)\n        return sorted[sorted.length\
    \ / 2];\n    else\n        return (sorted[sorted.length / 2 - 1] + sorted[sorted.length\
    \ / 2]) / 2.0;\n}", "{\n    long[] sorted = sort(l);\n    int len = l.length;\n\
    \    if (len % 2 == 1)\n    {\n        return sorted[len / 2];\n    }\n    else\n\
    \    {\n        return (sorted[len / 2 - 1] + sorted[len / 2]) / 2.0;\n    }\n\
    }", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n    if (sorted.length %\
    \ 2 == 1)\n        return sorted[sorted.length / 2];\n    else\n        return\
    \ (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2.0;\n}", "{\n\
    \    long[] temp = l.dup;\n    temp.sort;\n    int n = temp.length;\n    if (n\
    \ % 2 == 0)\n    {\n        return (temp[n/2] + temp[n/2-1])/2.0;\n    }\n   \
    \ else\n    {\n        return temp[n/2];\n    }\n}", "{\n    long[] l2 = l.dup;\n\
    \    l2.sort;\n    int len = l2.length;\n    if (len % 2 == 0) \n    {\n     \
    \   return (l2[len / 2 - 1] + l2[len / 2]) / 2.0;\n    } \n    else \n    {\n\
    \        return l2[len / 2];\n    }\n}", "{\n    long[] sorted = l.dup;\n    sorted.sort;\n\
    \    int n = sorted.length;\n    if (n % 2 == 1)\n        return sorted[n / 2];\n\
    \    else\n        return (sorted[n / 2 - 1] + sorted[n / 2]) / 2.0;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
