language: d
name: HumanEval_128_prod_signs
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6g9rswhn.d(28): Error: undefined identifier `sign`, did you
    mean template `sgn(F)(F x)`?\n/tmp/tmp6g9rswhn.d(22): Error: cannot implicitly
    convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6g9rswhn.d(30):
    Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6g9rswhn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplflji0rp.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplflji0rp.d(33): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplflji0rp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgoqln0r9.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpgoqln0r9.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgoqln0r9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgoqln0r9.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpgoqln0r9.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgoqln0r9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr)\n    {\n        if (i == 0)\n            continue;\n        if (i >\
    \ 0)\n            prod *= 1L;\n        else\n            prod *= -1L;\n      \
    \  sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfjqnmgkc.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpfjqnmgkc.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfjqnmgkc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr) \n    {\n        if (i < 0)\n            prod *= -1L;\n        else\
    \ if (i == 0)\n            prod = 0L;\n        sum += abs(i);\n    }\n    return\
    \ sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n      \
    \  auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp53yilsqp.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp53yilsqp.d(33): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp53yilsqp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp27wm9rl3.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp27wm9rl3.d(33): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27wm9rl3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0L;\n    long prod = 1L;\n    foreach\
    \ (i; arr)\n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n \
    \   return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkizlgps6.d(28): Error: undefined identifier `sign`, did you
    mean template `sgn(F)(F x)`?\n/tmp/tmpkizlgps6.d(22): Error: cannot implicitly
    convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpkizlgps6.d(30):
    Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkizlgps6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1;\n        else if\
    \ (i < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n   \
    \     sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6n87891d.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6n87891d.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6n87891d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr) \n    {\n        if (i > 0)\n            prod *= 1L;\n        else\
    \ if (i < 0)\n            prod *= -1L;\n        else\n            prod *= 0L;\n\
    \        sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwhcbpmxx.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpwhcbpmxx.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhcbpmxx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1;\n    long sum = 0;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        else if\
    \ (i == 0)\n            prod = 0;\n        sum += abs(i);\n    }\n    return sum\
    \ * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto\
    \ result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get\
    \ == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplflji0rp.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmplflji0rp.d(33): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplflji0rp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr) \n    {\n        sum += abs(i);\n        prod *= sign(i);\n    }\n\
    \    return sum * prod;\n}\nunittest\n{\n    alias candidate = prod_signs;\n\n\
    {\n        auto result = candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull\
    \ && result.get == -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n{\n        auto result\
    \ = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -10L);\n}\n\n{\n        auto result = candidate([]);\n       \
    \ assert(result.isNull);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 2L, -1L, -1L, 9L]);\n        assert(!result.isNull && result.get == 20L);\n\
    }\n\n{\n        auto result = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == -4L);\n}\n\n{\n      \
    \  auto result = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6g9rswhn.d(28): Error: undefined identifier `sign`, did you
    mean template `sgn(F)(F x)`?\n/tmp/tmp6g9rswhn.d(22): Error: cannot implicitly
    convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp6g9rswhn.d(30):
    Error: cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6g9rswhn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1L;\n        else if\
    \ (i < 0)\n            prod *= -1L;\n        else\n            prod *= 0L;\n \
    \       sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg0rh5d24.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpg0rh5d24.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg0rh5d24.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach (i;\
    \ arr) \n    {\n        if (i > 0) \n        {\n            prod *= 1L;\n    \
    \        sum += i;\n        }\n        else if (i < 0) \n        {\n         \
    \   prod *= -1L;\n            sum += abs(i);\n        }\n        else \n     \
    \   {\n            prod *= 0L;\n        }\n    }\n    return sum * prod;\n}\n\
    unittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result = candidate([1L,\
    \ 2L, 2L, -4L]);\n        assert(!result.isNull && result.get == -9L);\n}\n\n\
    {\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L,\
    \ 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n}\n\n\
    {\n        auto result = candidate([]);\n        assert(result.isNull);\n}\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1omj_51y.d(21): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmp1omj_51y.d(41): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1omj_51y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1L;\n        else if\
    \ (i < 0)\n            prod *= -1L;\n        else\n            prod *= 0L;\n \
    \       sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg0rh5d24.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpg0rh5d24.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg0rh5d24.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        if (i < 0)\n            prod *= -1;\n        sum +=\
    \ abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate\
    \ = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n  \
    \      assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkmbxvw9h.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpkmbxvw9h.d(31): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkmbxvw9h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long sum = 0;\n    long prod = 1;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            sum += i;\n        else if\
    \ (i < 0)\n        {\n            sum += abs(i);\n            prod *= -1;\n  \
    \      }\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias candidate =\
    \ prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n    \
    \    assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm_yysoq5.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpm_yysoq5.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm_yysoq5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) \n    {\n        return null;\n    }\n    long prod = 1L;\n    long sum\
    \ = 0L;\n    foreach (elem; arr) \n    {\n        if (elem < 0) \n        {\n\
    \            prod *= -1L;\n        }\n        else if (elem > 0) \n        {\n\
    \            prod *= 1L;\n        }\n        else \n        {\n            prod\
    \ *= 0L;\n        }\n        sum += abs(elem);\n    }\n    return sum * prod;\n\
    }\nunittest\n{\n    alias candidate = prod_signs;\n\n{\n        auto result =\
    \ candidate([1L, 2L, 2L, -4L]);\n        assert(!result.isNull && result.get ==\
    \ -9L);\n}\n\n{\n        auto result = candidate([0L, 1L]);\n        assert(!result.isNull\
    \ && result.get == 0L);\n}\n\n{\n        auto result = candidate([1L, 1L, 1L,\
    \ 2L, 3L, -1L, 1L]);\n        assert(!result.isNull && result.get == -10L);\n\
    }\n\n{\n        auto result = candidate([]);\n        assert(result.isNull);\n\
    }\n\n{\n        auto result = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n   \
    \     assert(!result.isNull && result.get == 20L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, -1L, 1L]);\n        assert(!result.isNull && result.get\
    \ == 4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 1L]);\n     \
    \   assert(!result.isNull && result.get == -4L);\n}\n\n{\n        auto result\
    \ = candidate([-1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
    \ == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpag9hgybl.d(23): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpag9hgybl.d(43): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpag9hgybl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0)\n        return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach\
    \ (i; arr)\n    {\n        if (i > 0)\n            prod *= 1L;\n        else if\
    \ (i < 0)\n            prod *= -1L;\n        else\n            prod *= 0L;\n \
    \       sum += abs(i);\n    }\n    return sum * prod;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg0rh5d24.d(22): Error: cannot implicitly convert expression
    `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpg0rh5d24.d(35): Error:
    cannot implicitly convert expression `sum * prod` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg0rh5d24.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ arr of integers and you need to return\n    sum of magnitudes of integers multiplied\
    \ by product of all signs\n    of each number in the array, represented by 1,\
    \ -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1L,\
    \ 2L, 2L, -4L])\n    9L\n    >>> prod_signs([0L, 1L])\n    0L\n    >>> prod_signs([])\n\
    \    None\n    \n*/\nNullable!(long) prod_signs(long[] arr) \n{\n    if (arr.length\
    \ == 0) return null;\n    long prod = 1L;\n    long sum = 0L;\n    foreach (i;\
    \ arr) \n    {\n        if (i == 0) continue;\n        prod *= sign(i);\n    \
    \    sum += abs(i);\n    }\n    return prod * sum;\n}\nunittest\n{\n    alias\
    \ candidate = prod_signs;\n\n{\n        auto result = candidate([1L, 2L, 2L, -4L]);\n\
    \        assert(!result.isNull && result.get == -9L);\n}\n\n{\n        auto result\
    \ = candidate([0L, 1L]);\n        assert(!result.isNull && result.get == 0L);\n\
    }\n\n{\n        auto result = candidate([1L, 1L, 1L, 2L, 3L, -1L, 1L]);\n    \
    \    assert(!result.isNull && result.get == -10L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 2L, -1L, -1L, 9L]);\n        assert(!result.isNull\
    \ && result.get == 20L);\n}\n\n{\n        auto result = candidate([-1L, 1L, -1L,\
    \ 1L]);\n        assert(!result.isNull && result.get == 4L);\n}\n\n{\n       \
    \ auto result = candidate([-1L, 1L, 1L, 1L]);\n        assert(!result.isNull &&\
    \ result.get == -4L);\n}\n\n{\n        auto result = candidate([-1L, 1L, 1L, 0L]);\n\
    \        assert(!result.isNull && result.get == 0L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn44pqafz.d(27): Error: undefined identifier `sign`, did you
    mean template `sgn(F)(F x)`?\n/tmp/tmpn44pqafz.d(21): Error: cannot implicitly
    convert expression `null` of type `typeof(null)` to `Nullable!long`\n/tmp/tmpn44pqafz.d(30):
    Error: cannot implicitly convert expression `prod * sum` of type `long` to `Nullable!long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn44pqafz.d", "-I/tmp"]\n'''
  stdout: b''
