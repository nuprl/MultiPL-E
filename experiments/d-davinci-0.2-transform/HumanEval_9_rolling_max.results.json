{
  "language": "d",
  "name": "HumanEval_9_rolling_max",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers)\n    {\n        if (n > max)\n            max = n;\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpq59q3pag.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428536]\n??:? long[] tmpq59q3pag.rolling_max(long[]) [0x427e62]\n??:? void tmpq59q3pag.__unittest_L22_C1() [0x427f1a]\n??:? void tmpq59q3pag.__modtest() [0x428208]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c563]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430681]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b30]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43060d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3cd]\n??:? runModuleUnitTests [0x42c339]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$])\n    {\n        result[i+1] = max(result[i], number);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7vold8a8.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7vold8a8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $])\n    {\n        if (n > max)\n        {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $])\n    {\n        if (n < min)\n        {\n            min = n;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $])\n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpddj40z1u.d(64): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpddj40z1u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph9zjxt89.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9zjxt89.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $])\n    {\n        if (n > max)\n        {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $])\n    {\n        if (n < min)\n        {\n            min = n;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $])\n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe9ku3jbv.d(64): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe9ku3jbv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[];\n    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result ~= max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp48woki8_.d(12): Error: new can only create structs, dynamic arrays or class objects, not `long[]`'s\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp48woki8_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd17y716h.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd17y716h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i] = max(result[i - 1], number);\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i] = min(result[i - 1], number);\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i] = result[i - 1] + number;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.4L, 2.5L, 2.4285714285714284L]\n*/\ndouble[] rolling_avg(long[]\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz72iio13.d(59): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz72iio13.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, number; numbers) \n    {\n        min = min(min, number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum += number;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.4L, 2.5L, 2.4285714285714284L]\n    \n*/\ndouble[] rolling_average(long[] numbers) \n{\n    double[] result =\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpk2afe058.d(67): Error: expression expected, not `unittest`\n/tmp/tmpk2afe058.d(68): Error: semicolon expected, not `{`\n/tmp/tmpk2afe058.d(76): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk2afe058.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L, 2L, 2L, 2L, 2L]\n    \n*/\nlong[] rolling_average(long[] numbers\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcpflkiub.d(65): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcpflkiub.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6y22nyxg.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6y22nyxg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwzym511.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwzym511.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    \n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n    {\n        if(number > max)\n        {\n            max = number;\n        }\n        result[i+1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpcaj3yl07.d(14): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpcaj3yl07.rolling_max(long[]) [0x427e62]\n??:? void tmpcaj3yl07.__unittest_L26_C1() [0x427f5e]\n??:? void tmpcaj3yl07.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    for (long i = 1; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    for (long i = 1; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    for (long i = 1; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcphlfyxz.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcphlfyxz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers)\n    {\n        max = max(max, n);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc_6ff5iq.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc_6ff5iq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpt98ul1lz.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpt98ul1lz.rolling_max(long[]) [0x427e62]\n??:? void tmpt98ul1lz.__unittest_L25_C1() [0x427f5e]\n??:? void tmpt98ul1lz.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i+1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i+1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzs2vx6at.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzs2vx6at.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpsfifftoh.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpsfifftoh.rolling_max(long[]) [0x427e62]\n??:? void tmpsfifftoh.__unittest_L25_C1() [0x427f5e]\n??:? void tmpsfifftoh.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwzym511.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwzym511.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph9zjxt89.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9zjxt89.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number < min) \n        {\n            min = number;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwp5efwf3.d(66): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwp5efwf3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1cwt67od.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1cwt67od.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp47f3rw7_.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47f3rw7_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjd86_swv.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjd86_swv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\n    {\n        if (number > max)\n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp2jjdgusu.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmp2jjdgusu.rolling_max(long[]) [0x427e62]\n??:? void tmp2jjdgusu.__unittest_L25_C1() [0x427f5e]\n??:? void tmp2jjdgusu.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpsfifftoh.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpsfifftoh.rolling_max(long[]) [0x427e62]\n??:? void tmpsfifftoh.__unittest_L25_C1() [0x427f5e]\n??:? void tmpsfifftoh.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number < min) \n        {\n            min = number;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling mean of elements found until given moment\n    in the sequence.\n    >>> rolling_mean([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt8ypai_g.d(66): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt8ypai_g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    for (size_t i = 1; i < numbers.length; i++) \n    {\n        max_so_far = max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp3rhrkez.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp3rhrkez.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph9zjxt89.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9zjxt89.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpsfifftoh.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpsfifftoh.rolling_max(long[]) [0x427e62]\n??:? void tmpsfifftoh.__unittest_L25_C1() [0x427f5e]\n??:? void tmpsfifftoh.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    Given a list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    Given a list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    Given a list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp84z63jvx.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp84z63jvx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwzym511.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwzym511.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1cwt67od.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1cwt67od.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = 0;\n    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, number; numbers) \n    {\n        min = min(min, number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    foreach(i, number; numbers) \n    {\n        sum += number;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long product = 1;\n    fore\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmycpv64r.d(69): Error: found `unittest` when expecting `;` following statement\n/tmp/tmpmycpv64r.d(78): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmycpv64r.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa9ihh5t3.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa9ihh5t3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp33po8ma9.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33po8ma9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, number; numbers)\n    {\n        min = min(min, number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, number; numbers)\n    {\n        sum += number;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long product = numbers[0];\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpocryis1_.d(68): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpocryis1_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n        max_so_far = max(max_so_far, number);\n        result[i + 1] = max_so_far;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkvrestno.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvrestno.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu2piqzqh.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu2piqzqh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max_so_far = max(max_so_far, n);\n        result[i + 1] = max_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    result[0] = min_so_far;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min_so_far = min(min_so_far, n);\n        result[i + 1] = min_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum_so_far = numbers[0];\n    result[0] = sum_so_far;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum_so_far += n;\n        result[i + 1] = sum_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcip9yscc.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcip9yscc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_prod([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy6k45v9x.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy6k45v9x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpwllrvi43.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmpwllrvi43.rolling_max(long[]) [0x427e62]\n??:? void tmpwllrvi43.__unittest_L24_C1() [0x427f4a]\n??:? void tmpwllrvi43.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling mean of elements found until given moment\n    in the sequence.\n    >>> rolling_mean([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9ykroolq.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ykroolq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, e; numbers)\n    {\n        max = max(max, e);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpptnguwnu.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpptnguwnu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpaji_71m7.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaji_71m7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number < min) \n        {\n            min = number;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwp5efwf3.d(66): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwp5efwf3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number < min) \n        {\n            min = number;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwp5efwf3.d(66): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwp5efwf3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, v; numbers[1 .. $]) \n    {\n        max = max(max, v);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0bs27_gv.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0bs27_gv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $])\n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $])\n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $])\n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy_er0dyw.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy_er0dyw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp47f3rw7_.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47f3rw7_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpt98ul1lz.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpt98ul1lz.rolling_max(long[]) [0x427e62]\n??:? void tmpt98ul1lz.__unittest_L25_C1() [0x427f5e]\n??:? void tmpt98ul1lz.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, number; numbers) \n    {\n        min = min(min, number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum += number;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long product = numbers\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg1vyejlm.d(68): Error: semicolon expected, not `unittest`\n/tmp/tmpg1vyejlm.d(68): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg1vyejlm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $])\n    {\n        if (n > max)\n        {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpjbldm6s5.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpjbldm6s5.rolling_max(long[]) [0x427e62]\n??:? void tmpjbldm6s5.__unittest_L25_C1() [0x427f5e]\n??:? void tmpjbldm6s5.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n        max_so_far = max(max_so_far, number);\n        result[i + 1] = max_so_far;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkvrestno.d(17): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvrestno.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph9zjxt89.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9zjxt89.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $])\n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2ykvwsld.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ykvwsld.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6y22nyxg.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6y22nyxg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers)\n    {\n        if (n > max)\n            max = n;\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, n; numbers)\n    {\n        if (n < min)\n            min = n;\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, n; numbers)\n    {\n        sum += n;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsl6e6fij.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmpsl6e6fij.d(67): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsl6e6fij.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1cwt67od.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1cwt67od.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[](numbers.length);\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc75_ofvy.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc75_ofvy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, v; numbers[1 .. $])\n    {\n        max = max(max, v);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, v; numbers[1 .. $])\n    {\n        min = min(min, v);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, v; numbers[1 .. $])\n    {\n        sum += v;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfoz0b6vy.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfoz0b6vy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, number; numbers) \n    {\n        min = min(min, number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum += number;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L, 3L, 3L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz4o4l995.d(67): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz4o4l995.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, e; numbers[1 .. $]) \n    {\n        max = max(max, e);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi6qib0px.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi6qib0px.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[];\n    long max = 0;\n    foreach(n; numbers) \n    {\n        max = max(max, n);\n        result ~= max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[];\n    long min = numbers[0];\n    foreach(n; numbers) \n    {\n        min = min(min, n);\n        result ~= min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[];\n    long sum = 0;\n    foreach(n; numbers) \n    {\n        sum += n;\n        result ~= sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long[];\n    long product = 1;\n    foreach(n; numbers) \n    {\n        product *= n;\n        result ~= product;\n    }\n    return result\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmalaio4g.d(71): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmpmalaio4g.d(80): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmalaio4g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max_so_far = max(max_so_far, number);\n        result[i] = max_so_far;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvdmmvhw3.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvdmmvhw3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1cwt67od.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1cwt67od.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1cwt67od.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1cwt67od.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpstibitno.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpstibitno.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd17y716h.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd17y716h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdqaucojy.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdqaucojy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n   \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps72mul0s.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps72mul0s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = long.min;\n    foreach (i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = long.max;\n    foreach (i, number; numbers) \n    {\n        min = min(min, number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    foreach (i, number; numbers) \n    {\n        sum += number;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long product = 1;\n    foreach\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpewv5idyc.d(66): Error: found `unittest` when expecting `(`\n/tmp/tmpewv5idyc.d(67): Error: basic type expected, not `{`\n/tmp/tmpewv5idyc.d(67): Error: no identifier for declarator `_error_`\n/tmp/tmpewv5idyc.d(67): Error: found `{` when expecting `;`\n/tmp/tmpewv5idyc.d(68): Error: expression expected, not `alias`\n/tmp/tmpewv5idyc.d(68): Error: found `candidate` when expecting `)`\n/tmp/tmpewv5idyc.d(68): Error: found `=` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpewv5idyc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpt98ul1lz.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpt98ul1lz.rolling_max(long[]) [0x427e62]\n??:? void tmpt98ul1lz.__unittest_L25_C1() [0x427f5e]\n??:? void tmpt98ul1lz.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, number; numbers) \n    {\n        if (number < min) \n        {\n            min = number;\n        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum += number;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L, 3L, 3L]\n*/\nlong[] rolling_avg(long[]\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp81mk7aic.d(68): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp81mk7aic.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6y22nyxg.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6y22nyxg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max = max(max, n);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6_rmfnyz.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6_rmfnyz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\n    {\n        if (number > max)\n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp2jjdgusu.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmp2jjdgusu.rolling_max(long[]) [0x427e62]\n??:? void tmp2jjdgusu.__unittest_L25_C1() [0x427f5e]\n??:? void tmp2jjdgusu.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[];\n    long max = 0;\n    foreach(n; numbers) \n    {\n        max = max(max, n);\n        result ~= max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    auto result = new long[];\n    long min = numbers[0];\n    foreach(n; numbers) \n    {\n        min = min(min, n);\n        result ~= min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    auto result = new long[];\n    long sum = 0;\n    foreach(n; numbers) \n    {\n        sum += n;\n        result ~= sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.4L, 2.5L, 2.4285714285714284L]\n*/\ndouble[] rolling_avg(long[] numbers) \n{\n    auto result = new double[];\n    long sum = 0;\n    long count = 0;\n    foreach(n; numbers) \n    {\n       \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprit5yawd.d(69): Error: found `unittest` instead of statement\n/tmp/tmprit5yawd.d(78): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprit5yawd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    auto result = new long[](numbers.length);\n    long max = numbers[0];\n    foreach (i, number; numbers) {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgqhr43rq.d(15): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgqhr43rq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd17y716h.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd17y716h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, e; numbers) \n    {\n        if (e > max) \n        {\n            max = e;\n        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, e; numbers) \n    {\n        if (e < min) \n        {\n            min = e;\n        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, e; numbers) \n    {\n        sum += e;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpycerw_mw.d(71): Error: semicolon expected following function declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpycerw_mw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph9zjxt89.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9zjxt89.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph9zjxt89.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9zjxt89.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n < min) \n        {\n            min = n;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmsab9zcv.d(66): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmsab9zcv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], number);\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = min(result[i], number);\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = result[i] + number;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0fxhnzyz.d(61): Error: semicolon expected, not `unittest`\n/tmp/tmp0fxhnzyz.d(61): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0fxhnzyz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, v; numbers[1 .. $]) \n    {\n        if (v > max) \n        {\n            max = v;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, v; numbers[1 .. $]) \n    {\n        if (v < min) \n        {\n            min = v;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, v; numbers[1 .. $]) \n    {\n        sum += v;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprnqh3fnd.d(66): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprnqh3fnd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1cwt67od.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1cwt67od.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpt98ul1lz.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpt98ul1lz.rolling_max(long[]) [0x427e62]\n??:? void tmpt98ul1lz.__unittest_L25_C1() [0x427f5e]\n??:? void tmpt98ul1lz.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L, 2L, 3L, 3L, 3L]\n*/\nlong[] rolling_avg(long[] numbers) \n{\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4pmiumts.d(63): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4pmiumts.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L, 2L, 3L, 3L, 3L]\n*/\nlong[] rolling_avg(long[] numbers) \n{\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4pmiumts.d(63): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4pmiumts.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu2piqzqh.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu2piqzqh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpt98ul1lz.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpt98ul1lz.rolling_max(long[]) [0x427e62]\n??:? void tmpt98ul1lz.__unittest_L25_C1() [0x427f5e]\n??:? void tmpt98ul1lz.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwzym511.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwzym511.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\n    {\n        if (number > max)\n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp2jjdgusu.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmp2jjdgusu.rolling_max(long[]) [0x427e62]\n??:? void tmp2jjdgusu.__unittest_L25_C1() [0x427f5e]\n??:? void tmp2jjdgusu.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmpt98ul1lz.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42857e]\n??:? long[] tmpt98ul1lz.rolling_max(long[]) [0x427e62]\n??:? void tmpt98ul1lz.__unittest_L25_C1() [0x427f5e]\n??:? void tmpt98ul1lz.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max = max(max, n);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6_rmfnyz.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6_rmfnyz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$])\n    {\n        result[i+1] = max(result[i], number);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7vold8a8.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7vold8a8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjd86_swv.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjd86_swv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1cwt67od.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1cwt67od.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = long.min;\n    foreach (i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp30n0xyy.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp30n0xyy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n        {\n            max = number;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number < min) \n        {\n            min = number;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling count of elements found until given moment\n    in the sequence.\n    >>> rolling_count([1L, 2L, 3L, 2L, 3L, 4L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7340m5dd.d(64): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7340m5dd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwzym511.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwzym511.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max = max(max, n);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, n; numbers) \n    {\n        min = min(min, n);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, n; numbers) \n    {\n        sum += n;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long product = numbers\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwb0oosqm.d(68): Error: semicolon expected, not `unittest`\n/tmp/tmpwb0oosqm.d(68): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwb0oosqm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long current_max = numbers[0];\n    result[0] = current_max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        current_max = max(current_max, n);\n        result[i + 1] = current_max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long current_min = numbers[0];\n    result[0] = current_min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        current_min = min(current_min, n);\n        result[i + 1] = current_min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long current_sum = numbers[0];\n    result[0] = current_sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        current_sum += n;\n        result[i + 1] = current_sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkz_qtgjo.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkz_qtgjo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], number);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1gsya8g8.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1gsya8g8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa9ihh5t3.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa9ihh5t3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_average(long[] numbers) \n{\n   \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_vyvxtqo.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_vyvxtqo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n < min) \n        {\n            min = n;\n        }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbw_4wsj5.d(64): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbw_4wsj5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i+1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i+1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzs2vx6at.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzs2vx6at.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdqaucojy.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdqaucojy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpaji_71m7.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaji_71m7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] > max)\n            max = numbers[i];\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.RangeError@/tmp/tmp2p_nbzi5.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmp2p_nbzi5.rolling_max(long[]) [0x427e62]\n??:? void tmp2p_nbzi5.__unittest_L22_C1() [0x427f4a]\n??:? void tmp2p_nbzi5.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph9zjxt89.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9zjxt89.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n   \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps72mul0s.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps72mul0s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3r5sad5o.d(65): Error: found `unittest` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3r5sad5o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max = max(max, n);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6_rmfnyz.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6_rmfnyz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7mh51m0e.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7mh51m0e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, v; numbers) \n    {\n        max = max(max, v);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i, v; numbers) \n    {\n        min = min(min, v);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, v; numbers) \n    {\n        sum += v;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.4L, 2.5L, 2.4285714285714284L]\n*/\ndouble[] rolling_avg(long[] numbers) \n{\n    double[] result = new\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc4jjhn_8.d(64): Error: basic type expected, not `unittest`\n/tmp/tmpc4jjhn_8.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmpc4jjhn_8.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc4jjhn_8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max_so_far = max(max_so_far, number);\n        result[i] = max_so_far;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvdmmvhw3.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvdmmvhw3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfn1zvyu9.d(60): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfn1zvyu9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    Given a list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    Given a list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    Given a list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpevndkdtn.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpevndkdtn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkwzym511.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwzym511.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max_so_far = max(max_so_far, number);\n        result[i] = max_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    foreach(i, number; numbers) \n    {\n        min_so_far = min(min_so_far, number);\n        result[i] = min_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum_so_far = numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum_so_far += number;\n        result[i] = sum_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkcqbaygf.d(57): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkcqbaygf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcdevm9f2.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdevm9f2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjd86_swv.d(16): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjd86_swv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    for (int i = 1; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling average of elements found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpstibitno.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpstibitno.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, e; numbers[1 .. $]) \n    {\n        result[i + 1] = max(result[i], e);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp31x2srpg.d(16): Error: undefined identifier `max`, did you mean function `fmax`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp31x2srpg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n Given a list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyysa8i9q.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyysa8i9q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n        result[i+1] = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n        result[i+1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate a list of rolling product of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnw9ohvae.d(58): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnw9ohvae.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmtwxvmc9.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmtwxvmc9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4ah68rdd.d(17): Error: function expected before `()`, not `max` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ah68rdd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    }
  ]
}