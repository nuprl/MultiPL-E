name: HumanEval_9_rolling_max
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n From a given list of integers,\
  \ generate a list of rolling maximum element found until given moment\n    in the\
  \ sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
  \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L])\
  \ == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, n; numbers)\n    {\n        if (n > max)\n            max = n;\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$])\n    {\n        result[i+1] = max(result[i], number);\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $])\n    {\n        if (n > max)\n        {\n            max = n;\n     \
    \   }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, n; numbers[1 .. $])\n    {\n        if\
    \ (n < min)\n        {\n            min = n;\n        }\n        result[i + 1]\
    \ = min;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L,\
    \ 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = numbers[0];\n    result[0]\
    \ = sum;\n    foreach (i, n; numbers[1 .. $])\n    {\n        sum += n;\n    \
    \    result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling product of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $])\
    \ \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n \
    \   return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n     \
    \   result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum\
    \ += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling product of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $])\n    {\n        if (n > max)\n        {\n\
    \            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $])\n   \
    \ {\n        if (n < min)\n        {\n            min = n;\n        }\n      \
    \  result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n \
    \   result[0] = sum;\n    foreach (i, n; numbers[1 .. $])\n    {\n        sum\
    \ += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling product of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[];\n    long max\
    \ = numbers[0];\n    foreach(i, number; numbers) \n    {\n        if (number >\
    \ max) \n        {\n            max = number;\n        }\n        result ~= max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,", "{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, number; numbers[1..$]) \n    {\n        result[i] = max(result[i - 1], number);\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        result[i] = min(result[i - 1], number);\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] =\
    \ numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i]\
    \ = result[i - 1] + number;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1.5L, 2L, 2L, 2.4L, 2.5L, 2.4285714285714284L]\n*/\ndouble[] rolling_avg(long[]",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n  \
    \      result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        min = min(min, number);\n  \
    \      result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        sum += number;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling average of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L,\
    \ 2.4L, 2.5L, 2.4285714285714284L]\n    \n*/\ndouble[] rolling_average(long[]\
    \ numbers) \n{\n    double[] result =", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling average of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L, 2L, 2L,\
    \ 2L, 2L]\n    \n*/\nlong[] rolling_average(long[] numbers", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number;\
    \ numbers)\n    {\n        max = max(max, number);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    \n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach(i, number; numbers[1..$])\n\
    \    {\n        if(number > max)\n        {\n            max = number;\n     \
    \   }\n        result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    for (long i = 1; i < numbers.length; i++) \n    {\n\
    \        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    for (long i = 1; i < numbers.length;\
    \ i++) \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  for (long i = 1; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling product of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 6L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers)\n    {\n        max =\
    \ max(max, n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ if (number > max) \n        {\n            max = number;\n        }\n      \
    \  result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i+1] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  min = min(min, number);\n        result[i+1] = min;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        sum += number;\n        result[i+1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n > max) \n        {\n\
    \            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n      \
    \  max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n  \
    \  {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ if (number > max) \n        {\n            max = number;\n        }\n      \
    \  result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  if (number < min) \n        {\n            min = number;\n        }\n     \
    \   result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n     \
    \   result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min\
    \ = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n\
    /*\n    From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n  \
    \  {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling product of\
    \ elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number;\
    \ numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\n\
    \    {\n        if (number > max)\n        {\n            max = number;\n    \
    \    }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n \
    \   From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        if (number >\
    \ max) \n        {\n            max = number;\n        }\n        result[i + 1]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        if (number < min) \n  \
    \      {\n            min = number;\n        }\n        result[i + 1] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n    \
    \    result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling mean of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_mean([1L, 2L, 3L, 2L, 3L, 4", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0]\
    \ = max_so_far;\n    for (size_t i = 1; i < numbers.length; i++) \n    {\n   \
    \     max_so_far = max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n     \
    \   result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum\
    \ += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling product of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max,\
    \ n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    Given\
    \ a list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 2L, 2L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min\
    \ = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n\
    /*\n    Given a list of integers, generate a list of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n  \
    \  {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n\
    }\n/*\n    Given a list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n     \
    \   result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = 0;\n    foreach(i, number; numbers) \n\
    \    {\n        max = max(max, number);\n        result[i] = max;\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ min = min(min, number);\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    foreach(i, number; numbers) \n    {\n        sum += number;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = 1;\n    fore", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling average of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 1.5L, 2L, 2L, 2", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    foreach(i, number; numbers)\n    {\n        min = min(min,\
    \ number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    foreach(i, number; numbers)\n    {\n        sum += number;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = numbers[0];", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0]\
    \ = max_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n        max_so_far\
    \ = max(max_so_far, number);\n        result[i + 1] = max_so_far;\n    }\n   \
    \ return result;\n}", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n \
    \   }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i\
    \ + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling average of elements found until given moment\n  \
    \  in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 1.5L, 2L, 2L,", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i,\
    \ n; numbers[1 .. $]) \n    {\n        max_so_far = max(max_so_far, n);\n    \
    \    result[i + 1] = max_so_far;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    result[0] = min_so_far;\n    foreach (i, n; numbers[1 .. $]) \n    {\n  \
    \      min_so_far = min(min_so_far, n);\n        result[i + 1] = min_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum_so_far = numbers[0];\n    result[0]\
    \ = sum_so_far;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum_so_far\
    \ += n;\n        result[i + 1] = sum_so_far;\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling product of", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n \
    \   }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i\
    \ + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  in the sequence.\n    >>> rolling_prod([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 2L, 6L, 12L, 36L", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     if (numbers[i] > max)\n        {\n            max = numbers[i];\n      \
    \  }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n    \
    \    result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling mean of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_mean([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n  \
    \  [1L, 1.5L, 2L, 2L,", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, e; numbers)\n    {\n        max =\
    \ max(max, e);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }\n/*\n Given a list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n Given a list of integers, generate a list of rolling\
    \ sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n Given a list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  if (number > max) \n        {\n            max = number;\n        }\n     \
    \   result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  if (number < min) \n        {\n            min = number;\n        }\n     \
    \   result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        if (number < min) \n        {\n            min = number;\n   \
    \     }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, v; numbers[1\
    \ .. $]) \n    {\n        max = max(max, v);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $])\n    {\n        max = max(max, n);\n        result[i + 1] = max;\n  \
    \  }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, n; numbers[1 .. $])\n    {\n        min = min(min, n);\n      \
    \  result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, n; numbers[1 .. $])\n    {\n        sum\
    \ += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling product of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min\
    \ = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n\
    /*\n    From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n  \
    \  {\n        sum += n;\n        result[i + 1] = sum;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling product of\
    \ elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n\
    \        {\n            max = number;\n        }\n        result[i + 1] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    foreach(i, number; numbers) \n    {\n        min = min(min,\
    \ number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum += number;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = numbers", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $])\n \
    \   {\n        if (n > max)\n        {\n            max = n;\n        }\n    \
    \    result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    result[0]\
    \ = max_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n        max_so_far\
    \ = max(max_so_far, number);\n        result[i + 1] = max_so_far;\n    }\n   \
    \ return result;\n}", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n     \
    \   result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum\
    \ += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling product of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $])\n    {\n        max = max(max, n);\n        result[i + 1] = max;\n  \
    \  }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, n; numbers)\n    {\n        if (n > max)\n            max = n;\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   foreach(i, n; numbers)\n    {\n        if (n < min)\n            min = n;\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    foreach(i, n; numbers)\n    {\n        sum += n;\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long product", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n     \
    \   result[i] = max;\n    }\n    return result;\n}", "{\n    auto result = new\
    \ long[](numbers.length);\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, v; numbers[1 .. $])\n    {\n        max = max(max, v);\n    \
    \    result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, v; numbers[1 .. $])\n    {\n        min\
    \ = min(min, v);\n        result[i + 1] = min;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, v; numbers[1\
    \ .. $])\n    {\n        sum += v;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number;\
    \ numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    foreach(i, number; numbers)\
    \ \n    {\n        min = min(min, number);\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, number;\
    \ numbers) \n    {\n        sum += number;\n        result[i] = sum;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling average of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L,\
    \ 3L, 3L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, e; numbers[1\
    \ .. $]) \n    {\n        max = max(max, e);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[];\n    long max\
    \ = 0;\n    foreach(n; numbers) \n    {\n        max = max(max, n);\n        result\
    \ ~= max;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[];\n    long min = numbers[0];\n    foreach(n; numbers) \n\
    \    {\n        min = min(min, n);\n        result ~= min;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[];\n    long sum = 0;\n    foreach(n;\
    \ numbers) \n    {\n        sum += n;\n        result ~= sum;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,\
    \ 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[];\n    long product = 1;\n    foreach(n; numbers) \n    {\n        product\
    \ *= n;\n        result ~= product;\n    }\n    return result", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    foreach(i,\
    \ number; numbers) \n    {\n        max_so_far = max(max_so_far, number);\n  \
    \      result[i] = max_so_far;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n \
    \   From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n     \
    \   result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n  \
    \  for (int i = 1; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   result[0] = min;\n    for (int i = 1; i < numbers.length; i++) \n    {\n \
    \       min = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    for (int i = 1; i < numbers.length; i++)\
    \ \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ average of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$])\n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling product of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n   ", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = long.min;\n    foreach (i, number; numbers) \n    {\n        max = max(max,\
    \ number);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = long.max;\n\
    \    foreach (i, number; numbers) \n    {\n        min = min(min, number);\n \
    \       result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long sum = 0;\n    foreach\
    \ (i, number; numbers) \n    {\n        sum += number;\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long product = 1;\n    foreach", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  if (number > max) \n        {\n            max = number;\n        }\n     \
    \   result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number;\
    \ numbers) \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n    From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        if (number < min) \n       \
    \ {\n            min = number;\n        }\n        result[i] = min;\n    }\n \
    \   return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, number; numbers)\
    \ \n    {\n        sum += number;\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ average of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L, 3L,\
    \ 3L]\n*/\nlong[] rolling_avg(long[]", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, n; numbers) \n    {\n        max = max(max, n);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\n\
    \    {\n        if (number > max)\n        {\n            max = number;\n    \
    \    }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    auto\
    \ result = new long[];\n    long max = 0;\n    foreach(n; numbers) \n    {\n \
    \       max = max(max, n);\n        result ~= max;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    auto result = new long[];\n    long min = numbers[0];\n  \
    \  foreach(n; numbers) \n    {\n        min = min(min, n);\n        result ~=\
    \ min;\n    }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    auto result = new\
    \ long[];\n    long sum = 0;\n    foreach(n; numbers) \n    {\n        sum +=\
    \ n;\n        result ~= sum;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling average of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.4L, 2.5L, 2.4285714285714284L]\n*/\ndouble[]\
    \ rolling_avg(long[] numbers) \n{\n    auto result = new double[];\n    long sum\
    \ = 0;\n    long count = 0;\n    foreach(n; numbers) \n    {\n       ", "{\n \
    \   auto result = new long[](numbers.length);\n    long max = numbers[0];\n  \
    \  foreach (i, number; numbers) {\n        max = max(max, number);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, e; numbers) \n    {\n        if (e\
    \ > max) \n        {\n            max = e;\n        }\n        result[i] = max;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    foreach(i, e; numbers)\
    \ \n    {\n        if (e < min) \n        {\n            min = e;\n        }\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    foreach(i, e; numbers) \n    {\n        sum += e;\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) ", "{\n \
    \   long[] result = new long[numbers.length];\n    long max = numbers[0];\n  \
    \  result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max\
    \ = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        min\
    \ = min(min, n);\n        result[i + 1] = min;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n  \
    \  {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if\
    \ (n > max) \n        {\n            max = n;\n        }\n        result[i + 1]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, n; numbers[1 .. $]) \n    {\n        if (n < min) \n        {\n\
    \            min = n;\n        }\n        result[i + 1] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1L, 2L, 3L, 2L, 3L, 4", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        result[i + 1] = max(result[i], number);\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] =\
    \ numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i\
    \ + 1] = min(result[i], number);\n    }\n    return result;\n}\n/*\n    From a\
    \ given list of integers, generate a list of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] =\
    \ numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i\
    \ + 1] = result[i] + number;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling product of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, v; numbers[1\
    \ .. $]) \n    {\n        if (v > max) \n        {\n            max = v;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, v; numbers[1 .. $]) \n  \
    \  {\n        if (v < min) \n        {\n            min = v;\n        }\n    \
    \    result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, v; numbers[1 .. $]) \n    {\n        sum\
    \ += v;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling product of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n \
    \   long[] result = new long[numbers.length];\n    long min = numbers[0];\n  \
    \  for (int i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 2L, 2L, 3L, 3L, 3L]\n*/\nlong[] rolling_avg(long[] numbers) \n{",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        min = min(min,\
    \ numbers[i]);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum\
    \ += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling average of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L, 2L, 3L, 3L, 3L]\n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        min = min(min, n);\n        result[i + 1] = min;\n \
    \   }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, n; numbers[1 .. $]) \n    {\n        sum += n;\n        result[i\
    \ + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list of integers,\
    \ generate a list of rolling average of elements found until given moment\n  \
    \  in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 1.5L, 2L, 2L,", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$])\n    {\n        if (number > max)\n  \
    \      {\n            max = number;\n        }\n        result[i + 1] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   foreach(i, n; numbers) \n    {\n        max = max(max, n);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$])\n    {\n\
    \        result[i+1] = max(result[i], number);\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n  \
    \      result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = long.min;\n    foreach (i, number;\
    \ numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n \
    \   From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        if (number < min) \n        {\n            min = number;\n   \
    \     }\n        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From\
    \ a given list of integers, generate a list of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ count of elements found until given moment\n    in the sequence.\n    >>> rolling_count([1L,\
    \ 2L, 3L, 2L, 3L, 4L", "{\n    long[] result = new long[numbers.length];\n   \
    \ long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n\
    \        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n\
    \    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max =\
    \ max(max, n);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    foreach(i, n; numbers) \n    {\n        min = min(min, n);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    foreach(i, n; numbers) \n    {\n        sum += n;\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n   \
    \ long[] result = new long[numbers.length];\n    long product = numbers", "{\n\
    \    long[] result = new long[numbers.length];\n    long current_max = numbers[0];\n\
    \    result[0] = current_max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n \
    \       current_max = max(current_max, n);\n        result[i + 1] = current_max;\n\
    \    }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long current_min = numbers[0];\n    result[0] = current_min;\n    foreach\
    \ (i, n; numbers[1 .. $]) \n    {\n        current_min = min(current_min, n);\n\
    \        result[i + 1] = current_min;\n    }\n    return result;\n}\n/*\n    From\
    \ a given list of integers, generate a list of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long current_sum\
    \ = numbers[0];\n    result[0] = current_sum;\n    foreach (i, n; numbers[1 ..\
    \ $]) \n    {\n        current_sum += n;\n        result[i + 1] = current_sum;\n\
    \    }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        result[i + 1] = max(result[i], number);\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }\n/*\n    From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling average of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 1.5L, 2L, 2L, 2", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling average\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_average([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_average(long[]\
    \ numbers) \n{\n   ", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n > max) \n        {\n\
    \            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n  \
    \  {\n        if (n < min) \n        {\n            min = n;\n        }\n    \
    \    result[i + 1] = min;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum\
    \ += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From\
    \ a given list of integers, generate a list of rolling average of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i+1] = max;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i+1] = min;\n    }\n \
    \   return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n    \
    \    result[i+1] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\n\
    \    {\n        max = max(max, number);\n        result[i + 1] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n Given a list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  min = min(min, number);\n        result[i + 1] = min;\n    }\n    return result;\n\
    }\n/*\n Given a list of integers, generate a list of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n Given a list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        if (numbers[i] > max)\n          \
    \  max = numbers[i];\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, n; numbers[1 .. $]) \n  \
    \  {\n        min = min(min, n);\n        result[i + 1] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = numbers[0];\n    result[0] = sum;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        sum += n;\n        result[i + 1] = sum;\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ product of elements found until given moment\n    in the sequence.\n    >>>\
    \ rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling product of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n   ", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n  \
    \      max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i\
    \ < numbers.length; i++) \n    {\n        sum += numbers[i];\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i,\
    \ n; numbers) \n    {\n        max = max(max, n);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, v; numbers)\
    \ \n    {\n        max = max(max, v);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    foreach(i, v; numbers) \n    {\n        min = min(min, v);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    foreach(i, v; numbers) \n    {\n        sum += v;\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n    From a given list of integers, generate\
    \ a list of rolling average of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.4L,\
    \ 2.5L, 2.4285714285714284L]\n*/\ndouble[] rolling_avg(long[] numbers) \n{\n \
    \   double[] result = new", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    foreach(i, number; numbers) \n    {\n\
    \        max_so_far = max(max_so_far, number);\n        result[i] = max_so_far;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        min = min(min, number);\n\
    \        result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  sum += number;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    for (int i = 1; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n \
    \   Given a list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 2L, 2L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    for (int i = 1; i < numbers.length; i++)\
    \ \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n   \
    \ }\n    return result;\n}\n/*\n    Given a list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  for (int i = 1; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n    Given a list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max_so_far = numbers[0];\n    foreach(i, number; numbers) \n    {\n \
    \       max_so_far = max(max_so_far, number);\n        result[i] = max_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_so_far = numbers[0];\n    foreach(i, number;\
    \ numbers) \n    {\n        min_so_far = min(min_so_far, number);\n        result[i]\
    \ = min_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L,\
    \ 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n \
    \   long[] result = new long[numbers.length];\n    long sum_so_far = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        sum_so_far += number;\n    \
    \    result[i] = sum_so_far;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling product of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    for (int i = 1; i < numbers.length; i++) \n    {\n\
    \        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n    From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    for (int i = 1; i < numbers.length; i++)\
    \ \n    {\n        min = min(min, numbers[i]);\n        result[i] = min;\n   \
    \ }\n    return result;\n}\n/*\n    From a given list of integers, generate a\
    \ list of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  for (int i = 1; i < numbers.length; i++) \n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given\
    \ list of integers, generate a list of rolling average of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 2L", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, e; numbers[1 .. $]) \n    {\n  \
    \      result[i + 1] = max(result[i], e);\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }\n/*\n Given a list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n Given a list of integers, generate a list of rolling\
    \ sum of elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    result[0] = sum;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        sum += number;\n        result[i + 1] = sum;\n    }\n    return\
    \ result;\n}\n/*\n Given a list of integers, generate a list of rolling product\
    \ of elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i+1] = max;\n    }\n    return result;\n}\n/*\n   \
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i+1] = min;\n    }\n \
    \   return result;\n}\n/*\n    From a given list of integers, generate a list\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i+1] = sum;\n    }\n    return result;\n}\n/*\n    From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n\
    \    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
