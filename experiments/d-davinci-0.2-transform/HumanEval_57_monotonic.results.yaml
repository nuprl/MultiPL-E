language: d
name: HumanEval_57_monotonic
results:
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\
    \ \n    {\n        if (l[i] < l[i - 1]) \n        {\n            increasing =\
    \ false;\n        }\n        if (l[i] > l[i - 1]) \n        {\n            decreasing\
    \ = false;\n        }\n    }\n    return increasing || decreasing;\n}\n/*\nReturn\
    \ True if the list is sorted.\n    >>> is_sorted([1L, 2L, 4L, 20L])\n    true\n\
    \    >>> is_sorted([1L, 20L, 4L, 10L])\n    false\n    >>> is_sorted([4L, 1L,\
    \ 0L, -10L])\n    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\
    \ \n    {\n        if (l[i] < l[i - 1]) \n        {\n            increasing =\
    \ false;\n        }\n        if (l[i] > l[i - 1]) \n        {\n            decreasing\
    \ = false;\n        }\n    }\n    return increasing || decreasing;\n}\n/*\nReturn\
    \ True if list is sorted.\n    >>> is_sorted([1L, 2L, 4L, 20L])\n    true\n  \
    \  >>> is_sorted([1L, 20L, 4L, 10L])\n    false\n    >>> is_sorted([4L, 1L, 0L,\
    \ -10L])\n    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n   \
    \ assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    bool increasing = l[0] < l[1];\n    for (int i = 1; i\
    \ < l.length - 1; i++)\n    {\n        if (increasing)\n        {\n          \
    \  if (l[i] > l[i + 1]) return false;\n        }\n        else\n        {\n  \
    \          if (l[i] < l[i + 1]) return false;\n        }\n    }\n    return true;\n\
    }\n/*\nReturn True if list elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1.0, 2.0, 4.0, 20.0])\n    true\n    >>> monotonic([1.0, 20.0,\
    \ 4.0, 10.0])\n    false\n    >>> monotonic([4.0, 1.0, 0.0, -10.0])\n    true\n\
    */\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1)\n    {\n        return true;\n    }\n    bool increasing = l[1] > l[0];\n\
    \    for (int i = 2; i < l.length; i++)\n    {\n        if (increasing)\n    \
    \    {\n            if (l[i] < l[i - 1])\n            {\n                return\
    \ false;\n            }\n        }\n        else\n        {\n            if (l[i]\
    \ > l[i - 1])\n            {\n                return false;\n            }\n \
    \       }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n        return true;\n    bool increasing = l[0] < l[1];\n    foreach\
    \ (i, e; l)\n    {\n        if (i > 0)\n        {\n            if (increasing\
    \ && e < l[i - 1])\n                return false;\n            if (!increasing\
    \ && e > l[i - 1])\n                return false;\n        }\n    }\n    return\
    \ true;\n}\n/*\nReturn True if list elements are monotonically increasing.\n \
    \   >>> monotonic_increasing([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n\
    \    false\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    bool increasing = l[1] > l[0];\n\
    \    foreach (i, v; l[1..$]) \n    {\n        if (increasing) \n        {\n  \
    \          if (v < l[i - 1]) \n            {\n                return false;\n\
    \            }\n        } \n        else \n        {\n            if (v > l[i\
    \ - 1]) \n            {\n                return false;\n            }\n      \
    \  }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpg3bauzug.d(24): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x42844e]\n??:? bool tmpg3bauzug.monotonic(long[]) [0x427de8]\n??:?
    void tmpg3bauzug.__unittest_L39_C1() [0x427e99]\n??:? void tmpg3bauzug.__modtest()
    [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428860]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287e7]\n??:? _d_run_main [0x428752]\n??:? main [0x42812f]\n??:?
    __libc_start_main [0x114c6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n        return true;\n    bool increasing = l[0] < l[1];\n    for (int\
    \ i = 1; i < l.length - 1; i++)\n    {\n        if (increasing && l[i] > l[i +\
    \ 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n\
    \            return false;\n    }\n    return true;\n}\n/*\nReturn True is list\
    \ elements are monotonically increasing or decreasing.\n    >>> monotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n        return true;\n    bool increasing = l[0] < l[1];\n    foreach\
    \ (i, e; l)\n    {\n        if (i == 0)\n            continue;\n        if (increasing\
    \ && e < l[i - 1])\n            return false;\n        if (!increasing && e >\
    \ l[i - 1])\n            return false;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n        return true;\n    bool increasing = l[0] < l[1];\n    foreach\
    \ (i, e; l)\n    {\n        if (i > 0)\n        {\n            if (increasing\
    \ && e < l[i - 1])\n                return false;\n            if (!increasing\
    \ && e > l[i - 1])\n                return false;\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\n\
    \    {\n        if (l[i] < l[i - 1])\n        {\n            increasing = false;\n\
    \        }\n        if (l[i] > l[i - 1])\n        {\n            decreasing =\
    \ false;\n        }\n    }\n    return increasing || decreasing;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    bool increasing = l[1] > l[0];\n\
    \    foreach (i, e; l[1..$]) \n    {\n        if (increasing && e < l[i - 1])\
    \ \n        {\n            return false;\n        }\n        if (!increasing &&\
    \ e > l[i - 1]) \n        {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpz1wfctop.d(22): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428456]\n??:? bool tmpz1wfctop.monotonic(long[]) [0x427de8]\n??:?
    void tmpz1wfctop.__unittest_L33_C1() [0x427ea1]\n??:? void tmpz1wfctop.__modtest()
    [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428868]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287ef]\n??:? _d_run_main [0x42875a]\n??:? main [0x428137]\n??:?
    __libc_start_main [0x1776b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (size_t i = 1; i < l.length; i++)\n\
    \    {\n        if (l[i] < l[i - 1])\n        {\n            increasing = false;\n\
    \        }\n        if (l[i] > l[i - 1])\n        {\n            decreasing =\
    \ false;\n        }\n    }\n    return increasing || decreasing;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\n\
    \    {\n        if (l[i] < l[i - 1])\n        {\n            increasing = false;\n\
    \        }\n        if (l[i] > l[i - 1])\n        {\n            decreasing =\
    \ false;\n        }\n    }\n    return increasing || decreasing;\n}\n/*\nReturn\
    \ True if list elements are monotonically increasing.\n    >>> monotonic_increasing([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L, 20L, 4L, 10L])\n\
    \    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n    false\n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n    {\n        return true;\n    }\n    long[] diffs = l[1..$].map!((a)\
    \ => a - l[$ - 1]);\n    return diffs.all!((a) => a == 0) || diffs.all!((a) =>\
    \ a > 0) || diffs.all!((a) => a < 0);\n}\n/*\nReturn True if list elements are\
    \ monotonically increasing.\n    >>> monotonic_increasing([1L, 2L, 4L, 20L])\n\
    \    true\n    >>> monotonic_increasing([1L, 20L, 4L, 10L])\n    false\n    >>>\
    \ monotonic_increasing([4L, 1L, 0L, -10L])\n    false\n*/\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt2bkl6h6.d(19): Error: no property `map` for type `long[]`\n/tmp/tmpt2bkl6h6.d(20):
    Error: no property `all` for type `long[]`\n/tmp/tmpt2bkl6h6.d(20): Error: no
    property `all` for type `long[]`\n/tmp/tmpt2bkl6h6.d(20): Error: no property `all`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt2bkl6h6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0) \n    {\n        return true;\n    }\n    long sign = l[1] - l[0];\n \
    \   if (sign == 0) \n    {\n        return false;\n    }\n    for (long i = 2;\
    \ i < l.length; i++) \n    {\n        if (sign * (l[i] - l[i - 1]) < 0) \n   \
    \     {\n            return false;\n        }\n    }\n    return true;\n}\n/*\n\
    Return True if list elements are monotonically increasing.\n    >>> monotonic_increasing([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L, 20L, 4L, 10L])\n\
    \    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n    false\n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp715lj339.d(53): unittest failure\n----------------\n??:?
    _d_unittestp [0x428345]\n??:? void tmp715lj339.__unittest_L42_C1() [0x4280ae]\n??:?
    void tmp715lj339.__modtest() [0x4280c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428808]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42878f]\n??:? _d_run_main [0x4286fa]\n??:? main [0x4280db]\n??:?
    __libc_start_main [0x12ff554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    bool increasing = l[1] > l[0];\n\
    \    foreach (i, e; l[1..$]) \n    {\n        if (increasing) \n        {\n  \
    \          if (e < l[i - 1]) \n            {\n                return false;\n\
    \            }\n        } \n        else \n        {\n            if (e > l[i\
    \ - 1]) \n            {\n                return false;\n            }\n      \
    \  }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpilwr6vux.d(24): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x42844e]\n??:? bool tmpilwr6vux.monotonic(long[]) [0x427de8]\n??:?
    void tmpilwr6vux.__unittest_L39_C1() [0x427e99]\n??:? void tmpilwr6vux.__modtest()
    [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428860]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4287e7]\n??:? _d_run_main [0x428752]\n??:? main [0x42812f]\n??:?
    __libc_start_main [0x3bf63554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    bool decreasing = true;\n    for (int i = 1; i < l.length; i++)\
    \ \n    {\n        if (l[i] < l[i - 1]) \n        {\n            increasing =\
    \ false;\n        }\n        if (l[i] > l[i - 1]) \n        {\n            decreasing\
    \ = false;\n        }\n    }\n    return increasing || decreasing;\n}\n/*\nReturn\
    \ True if list elements are monotonically increasing.\n    >>> monotonic_increasing([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L, 20L, 4L, 10L])\n\
    \    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n    false\n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1)\n        return true;\n    bool increasing = l[0] < l[1];\n    foreach\
    \ (i, e; l)\n    {\n        if (i > 0)\n        {\n            if (increasing\
    \ && e < l[i - 1])\n                return false;\n            if (!increasing\
    \ && e > l[i - 1])\n                return false;\n        }\n    }\n    return\
    \ true;\n}\n/*\nReturn True if list elements are monotonically increasing.\n \
    \   >>> monotonic_increasing([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic_increasing([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic_increasing([4L, 1L, 0L, -10L])\n\
    \    false\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2)\n    {\n        return true;\n    }\n    bool increasing = l[1] > l[0];\n\
    \    foreach (i, e; l)\n    {\n        if (i > 0)\n        {\n            if (increasing\
    \ && e < l[i - 1])\n            {\n                return false;\n           \
    \ }\n            if (!increasing && e > l[i - 1])\n            {\n           \
    \     return false;\n            }\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn True is list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n    {\n        return true;\n    }\n    bool increasing = l[1] > l[0];\n\
    \    for (int i = 1; i < l.length; i++) \n    {\n        if (increasing) \n  \
    \      {\n            if (l[i] < l[i - 1]) \n            {\n                return\
    \ false;\n            }\n        } \n        else \n        {\n            if\
    \ (l[i] > l[i - 1]) \n            {\n                return false;\n         \
    \   }\n        }\n    }\n    return true;\n}\n/*\nReturn True if list elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
    \    true\n    >>> monotonic([1, 20, 4, 10])\n    false\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
